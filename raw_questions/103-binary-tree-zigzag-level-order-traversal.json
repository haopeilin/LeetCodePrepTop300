{
    "questionId": "103",
    "questionFrontendId": "103",
    "title": "Binary Tree Zigzag Level Order Traversal",
    "titleSlug": "binary-tree-zigzag-level-order-traversal",
    "content": "<p>Given the <code>root</code> of a binary tree, return <em>the zigzag level order traversal of its nodes&#39; values</em>. (i.e., from left to right, then right to left for the next level and alternate between).</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"images/103/tree1.jpg\" style=\"width: 277px; height: 302px;\" />\n<pre>\n<strong>Input:</strong> root = [3,9,20,null,null,15,7]\n<strong>Output:</strong> [[3],[20,9],[15,7]]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [1]\n<strong>Output:</strong> [[1]]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = []\n<strong>Output:</strong> []\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 2000]</code>.</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n",
    "difficulty": "Medium",
    "stats": "{\"totalAccepted\": \"1.7M\", \"totalSubmission\": \"2.7M\", \"totalAcceptedRaw\": 1711535, \"totalSubmissionRaw\": 2711563, \"acRate\": \"63.1%\"}",
    "hints": [],
    "similarQuestions": "[{\"title\": \"Binary Tree Level Order Traversal\", \"titleSlug\": \"binary-tree-level-order-traversal\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Zigzag Grid Traversal With Skip\", \"titleSlug\": \"zigzag-grid-traversal-with-skip\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
    "topicTags": [
        {
            "name": "Tree",
            "slug": "tree"
        },
        {
            "name": "Breadth-First Search",
            "slug": "breadth-first-search"
        },
        {
            "name": "Binary Tree",
            "slug": "binary-tree"
        }
    ],
    "companyTags": null,
    "codeSnippets": [
        {
            "lang": "Java",
            "langSlug": "java",
            "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\n        \n    }\n}"
        }
    ],
    "solution": {
        "content": "<h2><a href=\"#solution\"><svg><path></path></svg></a>Solution</h2>\n<hr/>\n<h3><a href=\"#approach-1-bfs-breadth-first-search\"><svg><path></path></svg></a>Approach 1: BFS (Breadth-First Search)</h3>\n<p><strong>Intuition</strong></p>\n<p>Following the description of the problem, the most intuitive solution would be the <em>BFS</em> (Breadth-First Search) approach through which we traverse the tree level-by-level.</p>\n<p>The default ordering of BFS within a single level is from left to right. As a result, we should adjust the BFS algorithm a bit to generate the desired zigzag ordering.</p>\n<blockquote>\n<p>One of the keys here is to store the values that are of the same level with the <code>deque</code> (double-ended queue) data structure, where we could add new values on either end of a queue.</p>\n</blockquote>\n<p>So if we want to have the ordering of <strong>FIFO</strong> (first-in-first-out), we simply append the new elements to the <em>tail</em> of the queue, <em>i.e.</em> the latecomers stand last in the queue. If we want to have the ordering of <strong>FILO</strong> (first-in-last-out), we insert the new elements to the <em>head</em> of the queue, <em>i.e.</em> the latecomers jump the queue.</p>\n<p></p>\n<p><strong>Algorithm</strong></p>\n<p>There are several ways to implement the BFS algorithm.</p>\n<ul>\n<li>One way would be to run a two-level nested loop, with the <em>outer loop</em> iterating each level on the tree, and with the <em>inner loop</em> iterating each node within a single level.\n<br/>\n</li>\n<li>We could also implement BFS with a single loop though. The trick is that we append the nodes to be visited into a queue and we separate nodes of different levels with a sort of <strong>delimiter</strong> (<em>e.g.</em> an empty node). The delimiter marks the end of a level, as well as the beginning of a new level.</li>\n</ul>\n<p>Here we adopt the <em>second</em> approach above. One can start with the normal BFS algorithm, upon which we add a touch of <em>zigzag</em> order with the help of <code>deque</code>. For each level, we start from an empty deque container to hold all the values of the same level. Depending on the ordering of each level, <em>i.e.</em> either from left to right or from right to left, we decide at which end of the deque to add the new element:</p>\n<p></p>\n<ul>\n<li>\n<p>For the ordering of from-left-to-right (FIFO), we <em>append</em> the new element to the <strong><em>tail</em></strong> of the queue, so that the element that comes late would get out late as well. As we can see from the above graph, given an input sequence of <code>[1, 2, 3, 4, 5]</code>, with FIFO ordering, we would have an output sequence of <code>[1, 2, 3, 4, 5]</code>.</p>\n</li>\n<li>\n<p>For the ordering of from-right-to-left (FILO), we <em>insert</em> the new element to the <strong><em>head</em></strong> of the queue, so that the element that comes late would get out first. With the same input sequence of <code>[1, 2, 3, 4, 5]</code>, with FILO ordering, we would obtain an output sequence of <code>[5, 4, 3, 2, 1]</code>.</p>\n</li>\n</ul>\n<pre><code>// Definition for a binary tree node.\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) {\n        val = x;\n        left = null;\n        right = null;\n    }\n}\n\nclass Solution {\n    public List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) {\n        if (root == null) return new ArrayList&lt;&gt;();\n\n        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();\n        Deque&lt;TreeNode&gt; nodeQueue = new ArrayDeque&lt;&gt;();\n        nodeQueue.offerLast(root);\n        nodeQueue.offerLast(null); // Delimiter for a single level\n\n        Deque&lt;Integer&gt; levelList = new ArrayDeque&lt;&gt;();\n        boolean isOrderLeft = true;\n\n        while (!nodeQueue.isEmpty()) {\n            TreeNode temp = nodeQueue.pollFirst();\n            if (temp != null) {\n                if (isOrderLeft)\n                    levelList.offerLast(temp.val);\n                else\n                    levelList.offerFirst(temp.val);\n\n                if (temp.left != null) nodeQueue.offerLast(temp.left);\n                if (temp.right != null) nodeQueue.offerLast(temp.right);\n            } else {\n                // Add current level to result and prepare for the next level\n                result.add(new ArrayList&lt;&gt;(levelList));\n                levelList.clear();\n                if (!nodeQueue.isEmpty()) nodeQueue.offerLast(null);\n                isOrderLeft = !isOrderLeft;\n            }\n        }\n        return result;\n    }\n}</code></pre>\n<p>Note: as an alternative approach, one can also implement the normal BFS algorithm first, which would generate the ordering of from-left-to-right for each of the levels. Then, at the end of the algorithm, we can simply <strong><em>reverse</em></strong> the ordering of certain levels, following the zigzag steps.</p>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: O(N), where N is the number of nodes in the tree.</p>\n<ul>\n<li>\n<p>We visit each node once and only once.</p>\n</li>\n<li>\n<p>In addition, the insertion operation on either end of the deque takes a constant time, rather than using the array/list data structure where the inserting at the head could take the O(K) time where K is the length of the list.</p>\n</li>\n</ul>\n</li>\n<li>\n<p>Space Complexity: O(N) where N is the number of nodes in the tree.</p>\n<ul>\n<li>\n<p>The main memory consumption of the algorithm is the <code>node_queue</code> that we use for the loop, apart from the array that we use to keep the final output.</p>\n</li>\n<li>\n<p>As one can see, at any given moment, the <code>node_queue</code> would hold the nodes that are <em>at most</em> across two levels. Therefore, at most, the size of the queue would be no more than 2⋅L, assuming L is the maximum number of nodes that might reside on the same level. Since we have a binary tree, the level that contains the most nodes could occur to consist of all the leave nodes in a full binary tree, which is roughly L=2N​. As a result, we have the space complexity of 2⋅2N​=N in the worst case.</p>\n</li>\n</ul>\n</li>\n</ul>\n<hr/>\n<h3><a href=\"#approach-2-dfs-depth-first-search\"><svg><path></path></svg></a>Approach 2: DFS (Depth-First Search)</h3>\n<p><strong>Intuition</strong></p>\n<p>Though not intuitive, we could also obtain the <em>BFS</em> traversal ordering via the <em>DFS</em> (Depth-First Search) traversal in the tree.</p>\n<blockquote>\n<p>The trick is that during the DFS traversal, we maintain the results in a <em>global</em> array that is indexed by the level, <em>i.e.</em> the element <code>array[level]</code> would contain all the nodes that are at the same level. The global array would then be referred to and updated at each step of DFS.</p>\n</blockquote>\n<p></p>\n<p>Similar with the above modified BFS algorithm, we employ the <code>deque</code> data structure to hold the nodes that are of the same level, and we alternate the insertion direction (<em>i.e.</em> either to the head or to the tail) to generate the desired output ordering.</p>\n<p><strong>Algorithm</strong></p>\n<p>Here we implement the DFS algorithm via <em>recursion</em>. We define a recursive function called <code>DFS(node, level)</code> which only takes care of the current <code>node</code> which is located at the specified <code>level</code>. Within the function, here are three steps that we would perform:</p>\n<ul>\n<li>\n<p>If this is the first time that we visit any node at the <code>level</code>, <em>i.e.</em> the deque for the level does not exist, then we simply create the deque with the current node value as the initial element.</p>\n</li>\n<li>\n<p>If the deque for this level exists, then depending on the ordering, we insert the current node value either to the head or to the tail of the queue.</p>\n</li>\n<li>\n<p>At the end, we <em>recursively</em> call the function for each of its child nodes.</p>\n</li>\n</ul>\n<pre><code>/* Definition for a binary tree node. */\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) {\n        val = x;\n        left = null;\n        right = null;\n    }\n}\n\nclass Solution {\n    public List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) {\n        if (root == null) {\n            return new ArrayList&lt;&gt;();\n        }\n\n        List&lt;Deque&lt;Integer&gt;&gt; results = new ArrayList&lt;&gt;();\n\n        dfs(root, 0, results);\n\n        List&lt;List&lt;Integer&gt;&gt; finalResults = new ArrayList&lt;&gt;();\n        for (Deque&lt;Integer&gt; r : results) {\n            finalResults.add(new ArrayList&lt;&gt;(r));\n        }\n        return finalResults;\n    }\n\n    private void dfs(TreeNode node, int level, List&lt;Deque&lt;Integer&gt;&gt; results) {\n        if (level &gt;= results.size()) {\n            Deque&lt;Integer&gt; deque = new ArrayDeque&lt;&gt;();\n            deque.offerLast(node.val);\n            results.add(deque);\n        } else {\n            if (level % 2 == 0)\n                results.get(level).offerLast(node.val);\n            else\n                results.get(level).offerFirst(node.val);\n        }\n\n        if (node.left != null) dfs(node.left, level + 1, results);\n        if (node.right != null) dfs(node.right, level + 1, results);\n    }\n}</code></pre>\n<p>It might go without saying that, one can also implement the DFS traversal via <strong><em>iteration</em></strong> rather than recursion, which could be one of the followup questions by an interviewer.</p>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: O(N), where N is the number of nodes in the tree.</p>\n<ul>\n<li>Same as the previous BFS approach, we visit each node once and only once.</li>\n</ul>\n</li>\n<li>\n<p>Space Complexity: O(N).</p>\n<ul>\n<li>\n<p>Unlike the BFS approach, in the DFS approach, we do not need to maintain the <code>node_queue</code> data structure for the traversal.</p>\n</li>\n<li>\n<p>However, the function recursion will incur additional memory consumption on the <em>function call stack</em>. As we can see, the size of the call stack for any invocation of <code>DFS(node, level)</code> will be exactly the number of <code>level</code> that the current node resides on. Therefore, the space complexity of our DFS algorithm is O(H), where H is the height of the tree. In the worst-case scenario, when the tree is very skewed, the tree height could be N. Thus the space complexity is also O(N).</p>\n</li>\n<li>\n<p>Note that if the tree were guaranteed to be balanced, then the maximum height of the tree would be logN which would result in a better space complexity than the BFS approach.</p>\n</li>\n</ul>\n</li>\n</ul>",
        "isOfficial": true,
        "scrapedAt": "2026-02-18T07:16:37.027Z"
    }
}