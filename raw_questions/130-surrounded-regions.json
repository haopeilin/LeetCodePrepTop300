{
    "questionId": "130",
    "questionFrontendId": "130",
    "title": "Surrounded Regions",
    "titleSlug": "surrounded-regions",
    "content": "<p>You are given an <code>m x n</code> matrix <code>board</code> containing <strong>letters</strong> <code>&#39;X&#39;</code> and <code>&#39;O&#39;</code>, <strong>capture regions</strong> that are <strong>surrounded</strong>:</p>\n\n<ul>\n\t<li><strong>Connect</strong>: A cell is connected to adjacent cells horizontally or vertically.</li>\n\t<li><strong>Region</strong>: To form a region <strong>connect every</strong> <code>&#39;O&#39;</code> cell.</li>\n\t<li><strong>Surround</strong>: A region is surrounded if none of the <code>&#39;O&#39;</code> cells in that region are on the edge of the board. Such regions are <strong>completely enclosed </strong>by <code>&#39;X&#39;</code> cells.</li>\n</ul>\n\n<p>To capture a <strong>surrounded region</strong>, replace all <code>&#39;O&#39;</code>s with <code>&#39;X&#39;</code>s <strong>in-place</strong> within the original board. You do not need to return anything.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">board = [[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;O&quot;,&quot;O&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;X&quot;,&quot;O&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;O&quot;,&quot;X&quot;,&quot;X&quot;]]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">[[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;O&quot;,&quot;X&quot;,&quot;X&quot;]]</span></p>\n\n<p><strong>Explanation:</strong></p>\n<img alt=\"\" src=\"images/130/xogrid.jpg\" style=\"width: 367px; height: 158px;\" />\n<p>In the above diagram, the bottom region is not captured because it is on the edge of the board and cannot be surrounded.</p>\n</div>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">board = [[&quot;X&quot;]]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">[[&quot;X&quot;]]</span></p>\n</div>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == board.length</code></li>\n\t<li><code>n == board[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 200</code></li>\n\t<li><code>board[i][j]</code> is <code>&#39;X&#39;</code> or <code>&#39;O&#39;</code>.</li>\n</ul>\n",
    "difficulty": "Medium",
    "stats": "{\"totalAccepted\": \"1.1M\", \"totalSubmission\": \"2.6M\", \"totalAcceptedRaw\": 1141438, \"totalSubmissionRaw\": 2553327, \"acRate\": \"44.7%\"}",
    "hints": [],
    "similarQuestions": "[{\"title\": \"Number of Islands\", \"titleSlug\": \"number-of-islands\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Walls and Gates\", \"titleSlug\": \"walls-and-gates\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
    "topicTags": [
        {
            "name": "Array",
            "slug": "array"
        },
        {
            "name": "Depth-First Search",
            "slug": "depth-first-search"
        },
        {
            "name": "Breadth-First Search",
            "slug": "breadth-first-search"
        },
        {
            "name": "Union-Find",
            "slug": "union-find"
        },
        {
            "name": "Matrix",
            "slug": "matrix"
        }
    ],
    "companyTags": null,
    "codeSnippets": [
        {
            "lang": "Java",
            "langSlug": "java",
            "code": "class Solution {\n    public void solve(char[][] board) {\n        \n    }\n}"
        }
    ],
    "solution": {
        "content": "<h2><a href=\"#solution\"><svg><path></path></svg></a>Solution</h2>\n<hr/>\n<h3><a href=\"#overview\"><svg><path></path></svg></a>Overview</h3>\n<p>This problem is <em>almost</em> identical as the <a href=\"https://en.wikipedia.org/wiki/Rules_of_Go#Capture\">capture rule</a> of the Go game, where one captures the opponent's stones by surrounding them. The difference is that in the Go game the borders of the board are considered to the walls that surround the stones, while in this problem a group of cells (<em>i.e.</em> region) is considered to be <em><strong>escaped</strong></em> from the surrounding if it reaches any border.</p>\n<p></p>\n<p>This problem is yet another problem concerning the <em><strong>traversal of 2D grid</strong></em>, <em>e.g.</em> <a href=\"https://leetcode.com/articles/robot-room-cleaner/\">Robot room cleaner</a>.</p>\n<blockquote>\n<p>As similar to the traversal problems in a tree structure, there are generally two approaches in terms of solution: <em><strong>DFS</strong></em> (Depth-First Search) and <em><strong>BFS</strong></em> (Breadth-First Search).</p>\n</blockquote>\n<p>One can apply either of the above strategies to traverse the 2D grid, while taking some specific actions to resolve the problems.</p>\n<p>Given a traversal strategy (<em>DFS</em> or <em>BFS</em>), there could be a thousand implementations for a thousand people, if we indulge ourselves to exaggerate a bit. However, there are some common neat <em><strong>techniques</strong></em> that we could apply along with both of the strategies, in order to obtain a more optimized solution.<br/>\n<br/><br/>\n<br/></p>\n<hr/>\n<h3><a href=\"#approach-1-dfs-depth-first-search\"><svg><path></path></svg></a>Approach 1: DFS (Depth-First Search)</h3>\n<p><strong>Intuition</strong></p>\n<blockquote>\n<p>The goal of this problem is to mark those <em><strong>captured</strong></em> cells.</p>\n</blockquote>\n<p>If we are asked to summarize the algorithm in one sentence, it would be that we enumerate all those candidate cells (<em>i.e.</em> the ones filled with <code>O</code>), and check <em>one by one</em> if they are <em>captured</em> or not, <em>i.e.</em> we start with a candidate cell (<code>O</code>), and then apply either DFS or BFS strategy to explore its surrounding cells.</p>\n<p><strong>Algorithm</strong></p>\n<p>Let us start with the DFS algorithm, which usually results in a more concise code than the BFS algorithm. The algorithm consists of three steps:</p>\n<ul>\n<li>\n<p>Step 1). We select all the cells that are located on the borders of the board.</p>\n</li>\n<li>\n<p>Step 2). Start from each of the above selected cell, we then perform the <em>DFS</em> traversal.</p>\n<ul>\n<li>\n<p>If a cell on the border happens to be <code>O</code>, then we know that this cell is <em>alive</em>, together with the other <code>O</code> cells that are <em>connected</em> to this border cell, based on the description of the problem. Two cells are <em>connected</em>, if there exists a path consisting of only <code>O</code> letter that bridges between the two cells.</p>\n</li>\n<li>\n<p>Based on the above conclusion, the goal of our DFS traversal would be to <em>mark</em> out all those <em><strong>connected</strong></em> <code>O</code> cells that is originated from the border, with any distinguished letter such as <code>E</code>.</p>\n</li>\n</ul>\n</li>\n<li>\n<p>Step 3). Once we iterate through all border cells, we would then obtain three types of cells:</p>\n<ul>\n<li>\n<p>The one with the <code>X</code> letter: the cell that we could consider as the wall.</p>\n</li>\n<li>\n<p>The one with the <code>O</code> letter: the cells that are spared in our <em>DFS</em> traversal, <em>i.e.</em> these cells has no connection to the border, therefore they are <em><strong>captured</strong></em>. We then should replace these cell with <code>X</code> letter.</p>\n</li>\n<li>\n<p>The one with the <code>E</code> letter: these are the cells that are marked during our DFS traversal, <em>i.e.</em> these are the cells that has at least one connection to the borders, therefore they are not <em>captured</em>. As a result, we would revert the cell to its original letter <code>O</code>.</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>We demonstrate how the DFS works with an example in the following animation.</p>\n<p></p>\n<pre><code>class Solution {\n    private int ROWS, COLS;\n\n    public void solve(char[][] board) {\n        if (board == null || board.length == 0 || board[0].length == 0) return;\n        ROWS = board.length;\n        COLS = board[0].length;\n\n        for (int i = 0; i &lt; ROWS; i++) {\n            for (int j = 0; j &lt; COLS; j++) {\n                if (i == 0 || j == 0 || i == ROWS - 1 || j == COLS - 1) {\n                    dfs(board, i, j);\n                }\n            }\n        }\n\n        for (int i = 0; i &lt; ROWS; i++) {\n            for (int j = 0; j &lt; COLS; j++) {\n                if (board[i][j] == 'O') {\n                    board[i][j] = 'X';\n                } else if (board[i][j] == 'E') {\n                    board[i][j] = 'O';\n                }\n            }\n        }\n    }\n\n    private void dfs(char[][] board, int i, int j) {\n        if (board[i][j] != 'O') return;\n        board[i][j] = 'E';\n        if (j &lt; COLS - 1) dfs(board, i, j + 1);\n        if (i &lt; ROWS - 1) dfs(board, i + 1, j);\n        if (j &gt; 0) dfs(board, i, j - 1);\n        if (i &gt; 0) dfs(board, i - 1, j);\n    }\n}</code></pre>\n<p><strong>Optimizations</strong></p>\n<p>In the above implementation, there are a few techniques that we applied <em><strong>under the hood</strong></em>, in order to further optimize our solution. Here we list them one by one.</p>\n<blockquote>\n<p>Rather than iterating all candidate cells (the ones filled with <code>O</code>), we check only the ones on the <strong><em>borders</em></strong>.</p>\n</blockquote>\n<p>In the above implementation, our starting points of <em>DFS</em> are those cells that meet two conditions: 1). on the border. 2). filled with <code>O</code>.</p>\n<p><em>As an alternative solution, one might decide to iterate all <code>O</code> cells, which is less optimal compared to our starting points.</em></p>\n<p>As one can see, during DFS traversal, the alternative solution would traverse the cells that eventually might be captured, which is not necessary in our approach.</p>\n<blockquote>\n<p>Rather than using a sort of <code>visited[cell_index]</code> map to keep track of the visited cells, we simply mark visited cell <em><strong>in place</strong></em>.</p>\n</blockquote>\n<p><em>This technique helps us gain both in the space and time complexity.</em></p>\n<p>As an alternative approach, one could use a additional data structure to keep track of the visited cells, which goes without saying would require additional memory. And also it requires additional calculation for the comparison. Though one might argue that we could use the hash table data structure for the <code>visited[]</code> map, which has the O(1) asymptotic time complexity, but it is still more expensive than the simple comparison on the value of cell.</p>\n<blockquote>\n<p>Rather than doing the boundary check within the <code>DFS()</code> function, we do it <em><strong>before</strong></em> the invocation of the function.</p>\n</blockquote>\n<p>As a comparison, here is the implementation where we do the boundary check within the <code>DFS()</code> function.</p>\n<pre><code>private void dfs(char[][] board, int row, int col) {\n    if (row &lt; 0 || row &gt;= ROWS || col &lt; 0 || col &gt;= COLS) {\n        return;\n    }\n    if (board[row][col] != 'O') {\n        return;\n    }\n    board[row][col] = 'E';\n    dfs(board, row, col + 1);\n    dfs(board, row + 1, col);\n    dfs(board, row, col - 1);\n    dfs(board, row - 1, col);\n}</code></pre><svg><path></path></svg>\n<p><em>This measure reduces the number of recursion, therefore it reduces the overheads with the function calls.</em></p>\n<p>As trivial as this modification might seem to be, it actually reduces the runtime of the Java implementation significantly, improving its overall performance compared with a version that performs boundary checks on every recursive call.</p>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: O(N) where N is the number of cells in the board. In the worst case where it contains only the <code>O</code> cells on the board, we would traverse each cell twice: once during the DFS traversal and the other time during the cell reversion in the last step.</p>\n</li>\n<li>\n<p>Space Complexity: O(N) where N is the number of cells in the board. There are mainly two places that we consume some additional memory.</p>\n<ul>\n<li>\n<p>We keep a list of border cells as starting points for our traversal. We could consider the number of border cells is proportional to the total number (N) of cells.</p>\n</li>\n<li>\n<p>During the recursive calls of <code>DFS()</code> function, we would consume some space in the function call stack, <em>i.e.</em> the call stack will pile up along with the depth of recursive calls. And the maximum depth of recursive calls would be N as in the worst scenario mentioned in the time complexity.</p>\n</li>\n<li>\n<p>As a result, the overall space complexity of the algorithm is O(N).</p>\n<br/>\n</li>\n</ul>\n</li>\n</ul>\n<br/>\n<hr/>\n<h3><a href=\"#approach-2-bfs-breadth-first-search\"><svg><path></path></svg></a>Approach 2: BFS (Breadth-First Search)</h3>\n<p><strong>Intuition</strong></p>\n<blockquote>\n<p>In contrary to the DFS strategy, in BFS (Breadth-First Search) we prioritize the visit of a cell's neighbors before moving further (deeper) into the neighbor's neighbor.</p>\n</blockquote>\n<p>Though the order of visit might differ between DFS and BFS, eventually both strategies would visit the same set of cells, for most of the 2D grid traversal problems. This is also the case for this problem.</p>\n<p><strong>Algorithm</strong></p>\n<p>We could reuse the bulk of the DFS approach, while simply replacing the <code>DFS()</code> function with a <code>BFS()</code> function.<br/>\nHere we just elaborate the implementation of the <code>BFS()</code> function.</p>\n<ul>\n<li>\n<p>Essentially we can implement the BFS with the help of queue data structure, which could be of <code>ArrayDeque</code> or <code>LinkedList</code> in Java.</p>\n</li>\n<li>\n<p>Through the queue, we maintain the order of visit for the cells. Due to the <strong>FIFO</strong> (First-In First-Out) property of the queue, the one at the head of the queue would have the highest priority to be visited.</p>\n</li>\n<li>\n<p>The main logic of the algorithm is a loop that iterates through the above-mentioned queue. At each iteration of the loop, we <em>pop out</em> the <strong>head</strong> element from the queue.</p>\n<ul>\n<li>\n<p>If the popped element is of the candidate cell (<em>i.e.</em> <code>O</code>), we mark it as escaped, otherwise we skip this iteration.</p>\n</li>\n<li>\n<p>For a candidate cell, we then simply append its neighbor cells into the queue, which would get their turns to be visited in the next iterations.</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>As comparison, we demonstrate how BFS works with the same example in DFS, in the following animation.</p>\n<p></p>\n<pre><code>class Solution {\n    private int ROWS;\n    private int COLS;\n\n    private void bfs(char[][] board, int row, int col) {\n        java.util.Queue&lt;int[]&gt; queue = new java.util.ArrayDeque&lt;&gt;();\n        queue.offer(new int[]{row, col});\n\n        while (!queue.isEmpty()) {\n            int[] front = queue.poll();\n            int r = front[0], c = front[1];\n            if (board[r][c] != 'O') continue;\n\n            board[r][c] = 'E';\n            if (c &lt; COLS - 1) queue.offer(new int[]{r, c + 1});\n            if (r &lt; ROWS - 1) queue.offer(new int[]{r + 1, c});\n            if (c &gt; 0) queue.offer(new int[]{r, c - 1});\n            if (r &gt; 0) queue.offer(new int[]{r - 1, c});\n        }\n    }\n\n    public void solve(char[][] board) {\n        int numRows = board.length;\n        if (numRows == 0) return;\n        int numCols = board[0].length;\n\n        this.ROWS = numRows;\n        this.COLS = numCols;\n\n        java.util.List&lt;int[]&gt; border = new java.util.ArrayList&lt;&gt;();\n        for (int r = 0; r &lt; ROWS; r++) {\n            border.add(new int[]{r, 0});\n            border.add(new int[]{r, COLS - 1});\n        }\n        for (int c = 0; c &lt; COLS; c++) {\n            border.add(new int[]{0, c});\n            border.add(new int[]{ROWS - 1, c});\n        }\n\n        for (int[] cell : border) {\n            bfs(board, cell[0], cell[1]);\n        }\n\n        for (int r = 0; r &lt; ROWS; r++) {\n            for (int c = 0; c &lt; COLS; c++) {\n                if (board[r][c] == 'O') board[r][c] = 'X';\n                else if (board[r][c] == 'E') board[r][c] = 'O';\n            }\n        }\n    }\n}</code></pre>\n<p><strong>From BFS to DFS</strong></p>\n<p>In the above implementation of BFS, the fun part is that we could easily convert the BFS strategy to DFS by changing one single line of code. And the obtained DFS implementation is done in iteration, instead of recursion.</p>\n<blockquote>\n<p>The key is that instead of using the <em><strong>queue</strong></em> data structure which follows the principle of FIFO (First-In First-Out), if we use the <em><strong>stack</strong></em> data structure which follows the principle of LIFO (Last-In First-Out), we then switch the strategy from BFS to DFS.</p>\n</blockquote>\n<p>Specifically, at the moment we pop an element from the queue, instead of popping out the <em>head</em> element, we pop the <em>tail</em> element, which then changes the behavior of the container from queue to stack. Here is how it looks like.</p>\n<pre><code>protected void dfsIterative(char[][] board, int r, int c) {\n    java.util.Deque&lt;int[]&gt; stack = new java.util.ArrayDeque&lt;&gt;();\n    stack.offerLast(new int[]{r, c});\n\n    while (!stack.isEmpty()) {\n        int[] cell = stack.pollLast();\n        int row = cell[0], col = cell[1];\n        if (board[row][col] != 'O') continue;\n\n        board[row][col] = 'E';\n        if (col &lt; this.COLS - 1) stack.offerLast(new int[]{row, col + 1});\n        if (row &lt; this.ROWS - 1) stack.offerLast(new int[]{row + 1, col});\n        if (col &gt; 0) stack.offerLast(new int[]{row, col - 1});\n        if (row &gt; 0) stack.offerLast(new int[]{row - 1, col});\n    }\n}</code></pre>\n<p>Note that, though the above implementations indeed follow the DFS strategy, they are NOT equivalent to the previous <em><strong>recursive</strong></em> version of DFS, <em>i.e.</em> they do not produce the exactly same sequence of visit.</p>\n<p>In the recursive DFS, we would visit the <em>right-hand side</em> neighbor <code>(row, col+1)</code> first, while in the iterative DFS, we would visit the <em>up</em> neighbor <code>(row-1, col)</code> first.</p>\n<p>In order to obtain the same order of visit as the recursive DFS, one should <em>reverse</em> the processing order of neighbors in the above iterative DFS.</p>\n<p><strong>Complexity</strong></p>\n<ul>\n<li>\n<p>Time Complexity: O(N) where N is the number of cells in the board. In the worst case where it contains only the <code>O</code> cells on the board, we would traverse each cell twice: once during the BFS traversal and the other time during the cell reversion in the last step.</p>\n</li>\n<li>\n<p>Space Complexity: O(N) where N is the number of cells in the board. There are mainly two places that we consume some additional memory.</p>\n<ul>\n<li>\n<p>We keep a list of border cells as starting points for our traversal. We could consider the number of border cells is proportional to the total number (N) of cells.</p>\n</li>\n<li>\n<p>Within each invocation of <code>BFS()</code> function, we use a queue data structure to hold the cells to be visited. We then need to estimate the upper bound on the size of the queue. <em>Intuitively we could imagine the unfold of BFS as the structure of an onion.</em><br/>\nEach layer of the onion represents the cells that has the same distance to the starting point.<br/>\nAny given moment the queue would contain no more than two layers of <em>onion</em>, which in the worst case might cover <em>almost</em> all cells in the board.</p>\n</li>\n<li>\n<p>As a result, the overall space complexity of the algorithm is O(N).</p>\n<br/>\n</li>\n</ul>\n</li>\n</ul>\n<br/>",
        "isOfficial": true,
        "scrapedAt": "2026-02-18T08:12:52.044Z"
    }
}