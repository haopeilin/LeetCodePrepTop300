{
    "questionId": "275",
    "questionFrontendId": "275",
    "title": "H-Index II",
    "titleSlug": "h-index-ii",
    "content": "<p>Given an array of integers <code>citations</code> where <code>citations[i]</code> is the number of citations a researcher received for their <code>i<sup>th</sup></code> paper and <code>citations</code> is sorted in <strong>non-descending order</strong>, return <em>the researcher&#39;s h-index</em>.</p>\n\n<p>According to the <a href=\"https://en.wikipedia.org/wiki/H-index\" target=\"_blank\">definition of h-index on Wikipedia</a>: The h-index is defined as the maximum value of <code>h</code> such that the given researcher has published at least <code>h</code> papers that have each been cited at least <code>h</code> times.</p>\n\n<p>You must write an algorithm that runs in logarithmic time.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> citations = [0,1,3,5,6]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> [0,1,3,5,6] means the researcher has 5 papers in total and each of them had received 0, 1, 3, 5, 6 citations respectively.\nSince the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, their h-index is 3.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> citations = [1,2,100]\n<strong>Output:</strong> 2\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == citations.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= citations[i] &lt;= 1000</code></li>\n\t<li><code>citations</code> is sorted in <strong>ascending order</strong>.</li>\n</ul>\n",
    "difficulty": "Medium",
    "stats": "{\"totalAccepted\": \"261.3K\", \"totalSubmission\": \"664K\", \"totalAcceptedRaw\": 261276, \"totalSubmissionRaw\": 664038, \"acRate\": \"39.3%\"}",
    "hints": [
        "Expected runtime complexity is in <i>O</i>(log <i>n</i>) and the input is sorted."
    ],
    "similarQuestions": "[{\"title\": \"H-Index\", \"titleSlug\": \"h-index\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
    "topicTags": [
        {
            "name": "Array",
            "slug": "array"
        },
        {
            "name": "Binary Search",
            "slug": "binary-search"
        }
    ],
    "companyTags": null,
    "codeSnippets": [
        {
            "lang": "Java",
            "langSlug": "java",
            "code": "class Solution {\n    public int hIndex(int[] citations) {\n        \n    }\n}"
        }
    ],
    "solution": {
        "content": "<h2><a href=\"#solution\"><svg><path></path></svg></a>Solution</h2>\n<hr/>\n<h3><a href=\"#approach-1-linear-search-ok-time\"><svg><path></path></svg></a>Approach 1: Linear search, O(k) time</h3>\n<p><strong>Intuition</strong></p>\n<p>Since the list of citation numbers is sorted in ascending order, we can solve the problem in a single pass.</p>\n<p>Consider a paper with citation number <code>c</code> at index <code>i</code>, <em>i.e</em> <code>c = citations[i]</code>. The number of papers with a citation number larger than <code>c</code> is <code>n - i - 1</code>. Hence, including the current paper, there are <code>n - i</code> papers that are cited at least <code>c</code> times.</p>\n<p>Per the definition of H-Index, we need to find the first paper at index <code>i</code> where citation number <code>c = citation[i]</code> is greater than or equal to <code>n - i</code>, <em>i.e.</em> <code>c &gt;= n - i</code>. Since all papers after paper <code>i</code> are cited at least <code>c</code> times, there are <code>n - i</code> papers (including paper <code>i</code>) that are cited at least <code>c</code> times. In other words, the H-Index is <code>n - i</code>.</p>\n<p></p>\n<p><strong>Implementation</strong></p>\n<pre><code>class Solution {\n \u00a0 \u00a0public int hIndex(int[] citations) {\n \u00a0 \u00a0 \u00a0 \u00a0int n = citations.length;\n \u00a0 \u00a0 \u00a0 \u00a0int idx = 0;\n \u00a0 \u00a0 \u00a0 \u00a0for (int c : citations) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0if (c &gt;= n - idx)\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0return n - idx;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0else\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0idx++;\n \u00a0 \u00a0 \u00a0  }\n \u00a0 \u00a0 \u00a0 \u00a0return 0;\n \u00a0  }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity: O(N) where N is the length of the input list, since in the worst case, we would have to iterate the entire list.</p>\n</li>\n<li>\n<p>Space complexity: O(1), because no additional data structures were used.<br/>\n<br/><br/>\n<br/></p>\n</li>\n</ul>\n<hr/>\n<h3><a href=\"#approach-2-binary-search-olog-n-time\"><svg><path></path></svg></a>Approach 2: Binary Search, O(log N) time</h3>\n<p><strong>Intuition</strong></p>\n<p>As mentioned earlier, the problem can be re-phrased like so:</p>\n<blockquote>\n<p>Given a sorted list <code>citations</code> of size <code>n</code>,<br/>\nfind the <em>first</em> number <code>citations[i]</code><br/>\nthat meets the constraint: <code>citations[i] &gt;= n - i</code>.</p>\n</blockquote>\n<p>Since this is a sorted list, we can leverage binary search by reducing the search space by half at each iteration. This leads to a better optimized O(logN) time complexity (compared to O(N) for linear search).</p>\n<p></p>\n<p><strong>Algorithm</strong></p>\n<ol>\n<li>\n<p>Find a pivot (middle of list), <em>i.e.</em> <code>citations[mid]</code>, which divides the original list into two sublists: <code>citations[0: mid - 1]</code> and <code>citations[mid + 1: n]</code>.</p>\n</li>\n<li>\n<p>Compare <code>n - mid</code> to <code>citations[mid]</code>, to determine the next step as one of the following 3 options:</p>\n<ul>\n<li>\n<p><code>citations[mid] == n - mid</code>: We found our target!<br/>\nThere's (n - mid) papers with an equal or higher citation count than citations[mid]. If (citations[mid] == n - mid), it's the optimal result since if we move to the right, the next paper is going to have max(0, n - mid - 1) papers with equal or higher citations and citations[mid + 1] &gt; (n - mid - 1), which won't work as the h-index. If we move to the left, we'll have a smaller (or equal) h-index - a sub-optimal result. So, if found, this can be returned right away.</p>\n</li>\n<li>\n<p><code>citations[mid] &lt; n - mid</code>:<br/>\nSince the target needs to be greater than or equal to <code>n - mid</code>, we need to look at the sublist on the right, <em>i.e.</em> <code>citations[mid + 1: n]</code>.</p>\n</li>\n<li>\n<p><code>citations[mid] &gt; n - mid</code>:<br/>\nIn this case, look at the sublist on the left, <em>i.e.</em> <code>citations[0: mid - 1]</code>.</p>\n</li>\n</ul>\n</li>\n</ol>\n<p>One difference from the textbook binary search algorithm is that here we return <code>n - mid</code> (the count of indices beginning at <code>mid</code> through the end of the array), instead of a value at some position in the array.</p>\n<p><strong>Implementation</strong></p>\n<pre><code>class Solution {\n \u00a0 \u00a0public int hIndex(int[] citations) {\n \u00a0 \u00a0 \u00a0 \u00a0int n = citations.length;\n \u00a0 \u00a0 \u00a0 \u00a0int left = 0, right = n - 1;\n\u200b\n \u00a0 \u00a0 \u00a0 \u00a0// We need to find the rightmost 'index' such that: (citations[index] &lt;= n - index)\n \u00a0 \u00a0 \u00a0 \u00a0while (left &lt;= right) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0int mid = left + (right - left) / 2;\n\u200b\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0//There are (n - mid) papers with an equal or higher citation count than citations[mid]\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0// If (citations[mid] == n - mid) it's the optimal result and can be returned right away\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0if (citations[mid] == n - mid)\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0return citations[mid];\n\u200b\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0// If citations[mid] are less than (n - mid), narrow down on the right half to look for a paper\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0// at a future index that meets the h-index criteria. Otherwise, narrow down on the left half\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0if (citations[mid] &lt; n - mid)\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0left = mid + 1;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0else\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0right = mid - 1;\n \u00a0 \u00a0 \u00a0  }\n\u200b\n \u00a0 \u00a0 \u00a0 \u00a0// We didn't find an exact match, so there are exactly (n - left) papers that have citations\n \u00a0 \u00a0 \u00a0 \u00a0// greater than or equal to citations[left] and that is our answer\n \u00a0 \u00a0 \u00a0 \u00a0return n - left;\n \u00a0  }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity: O(logN) since we apply binary search, which reduces the search space by half at each iteration.</p>\n</li>\n<li>\n<p>Space complexity : O(1), because no additional data structures were used.</p>\n</li>\n</ul>",
        "isOfficial": true,
        "scrapedAt": "2026-02-18T09:08:07.138Z"
    }
}