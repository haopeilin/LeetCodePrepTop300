{
    "questionId": "126",
    "questionFrontendId": "126",
    "title": "Word Ladder II",
    "titleSlug": "word-ladder-ii",
    "content": "<p>A <strong>transformation sequence</strong> from word <code>beginWord</code> to word <code>endWord</code> using a dictionary <code>wordList</code> is a sequence of words <code>beginWord -&gt; s<sub>1</sub> -&gt; s<sub>2</sub> -&gt; ... -&gt; s<sub>k</sub></code> such that:</p>\n\n<ul>\n\t<li>Every adjacent pair of words differs by a single letter.</li>\n\t<li>Every <code>s<sub>i</sub></code> for <code>1 &lt;= i &lt;= k</code> is in <code>wordList</code>. Note that <code>beginWord</code> does not need to be in <code>wordList</code>.</li>\n\t<li><code>s<sub>k</sub> == endWord</code></li>\n</ul>\n\n<p>Given two words, <code>beginWord</code> and <code>endWord</code>, and a dictionary <code>wordList</code>, return <em>all the <strong>shortest transformation sequences</strong> from</em> <code>beginWord</code> <em>to</em> <code>endWord</code><em>, or an empty list if no such sequence exists. Each sequence should be returned as a list of the words </em><code>[beginWord, s<sub>1</sub>, s<sub>2</sub>, ..., s<sub>k</sub>]</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]\n<strong>Output:</strong> [[&quot;hit&quot;,&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;cog&quot;],[&quot;hit&quot;,&quot;hot&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]]\n<strong>Explanation:</strong>&nbsp;There are 2 shortest transformation sequences:\n&quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;\n&quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;lot&quot; -&gt; &quot;log&quot; -&gt; &quot;cog&quot;\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]\n<strong>Output:</strong> []\n<strong>Explanation:</strong> The endWord &quot;cog&quot; is not in wordList, therefore there is no valid transformation sequence.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= beginWord.length &lt;= 5</code></li>\n\t<li><code>endWord.length == beginWord.length</code></li>\n\t<li><code>1 &lt;= wordList.length &lt;= 500</code></li>\n\t<li><code>wordList[i].length == beginWord.length</code></li>\n\t<li><code>beginWord</code>, <code>endWord</code>, and <code>wordList[i]</code> consist of lowercase English letters.</li>\n\t<li><code>beginWord != endWord</code></li>\n\t<li>All the words in <code>wordList</code> are <strong>unique</strong>.</li>\n\t<li>The <strong>sum</strong> of all shortest transformation sequences does not exceed <code>10<sup>5</sup></code>.</li>\n</ul>\n",
    "difficulty": "Hard",
    "stats": "{\"totalAccepted\": \"450.7K\", \"totalSubmission\": \"1.6M\", \"totalAcceptedRaw\": 450657, \"totalSubmissionRaw\": 1638428, \"acRate\": \"27.5%\"}",
    "hints": [],
    "similarQuestions": "[{\"title\": \"Word Ladder\", \"titleSlug\": \"word-ladder\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Groups of Strings\", \"titleSlug\": \"groups-of-strings\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
    "topicTags": [
        {
            "name": "Hash Table",
            "slug": "hash-table"
        },
        {
            "name": "String",
            "slug": "string"
        },
        {
            "name": "Backtracking",
            "slug": "backtracking"
        },
        {
            "name": "Breadth-First Search",
            "slug": "breadth-first-search"
        }
    ],
    "companyTags": null,
    "codeSnippets": [
        {
            "lang": "Java",
            "langSlug": "java",
            "code": "class Solution {\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\n        \n    }\n}"
        }
    ],
    "solution": {
        "content": "<h2><a href=\"#solution\"><svg><path></path></svg></a>Solution</h2>\n<hr/>\n<h3><a href=\"#overview\"><svg><path></path></svg></a>Overview</h3>\n<p>This problem is an extension of the problem <a href=\"https://leetcode.com/problems/word-ladder/\">Word Ladder</a>, where we only need to find the minimum number of words in the transformation from <code>beginWord</code> to <code>endWord</code>. Here, we need to find all the transformations that exist between <code>beginWord</code> and <code>endWord</code> that are the minimum length. We can use BFS to find the minimum number of words in the transformation, however, finding all such transformations is tricky because the number of transformations may be enormous.<br/>\n<br/></p>\n<hr/>\n<h3><a href=\"#approach-1-breadth-first-search-bfs--backtracking\"><svg><path></path></svg></a>Approach 1: Breadth-First Search (BFS) + Backtracking</h3>\n<h4>Intuition</h4>\n<p>The problem can be correlated with the graph data structure. We can represent the words as the vertices and an edge can be used to connect two words which differ by a single letter.</p>\n<p>Before diving further let's see how we can find all the direct connections of a particular word. To find the adjacent words for a particular word, one approach is to traverse all of the other words and add an edge for those that differ by a single letter. This approach requires O(N\u22c5K) time where N is the number of words given and K is the maximum length of a word. The observation behind the optimal approach is that the words only consist of lowercase English letters. Hence we can change each character of the word to all other English lowercase characters and check whether or not that word exists in the <code>wordList</code>(this particular check operation takes O(1) in Java while creating new strings will take O(K) due to the immutable nature of Strings).This way the number of operations will be (25\u22c5K\u2217K+1), hence the time complexity will be O(K2).</p>\n<p>Thus we can find all the words that are directly connected.  Now, the task is to find all of the shortest paths from <code>beginWord</code> to <code>endWord</code>.</p>\n<p>The naive way to do this is to use backtracking. We will start from <code>beginWord</code>, then traverse all the adjacent words until we reach the <code>endWord</code>. When we reach the <code>endWord</code>, we can compare the path length and find all the paths that have the minimum path length. This method however is extremely inefficient because the number of paths between two vertices can be enormous.</p>\n<p>Let's try to optimize our approach. Somehow, we need to reduce the number of traversed paths. Let's say the number of shortest paths that exist between <code>beginWord</code> and <code>endWord</code> is <code>x</code> and the number of paths that we must traverse to find these shortest paths is <code>y</code>. The closer the value <code>y</code> gets to the value <code>x</code>,  the more efficient our approach will be.</p>\n<p>The diagram below shows the graph that represents the connectivity among words. As shown in the diagram we want to go from <code>red</code> to <code>tax</code>.  While backtracking on this graph, we will also cover the edges upwards that is from the <code>tad</code> to <code>ted</code> similarly from <code>tex</code> we will traverse to <code>ted</code> as well as <code>rex</code>. The key observation here is that going back in the upward direction will never lead us to the shortest path. We should always traverse the edges in the direction of <code>beginWord</code> to <code>endWord</code>.<br/>\n<br/>\nTo ensure that we never traverse up the ladder, let's use directed edges to connect the words. The edges in the graph below are all directed towards <code>endWord</code>. Also, notice that graphs produced by BFS do not contain cycles.  Thus, the graph will be a Directed Acyclic Graph (DAG).<br/>\n<br/>\nNow for the easy part, think of the previous graph as a bunch of layers and observe that once we reach a particular layer we don't want the future words to have the connection back to this layer. We will build our DAG using BFS.  We will then add all the directed edges from the words present in the current layer and once all words in this layer have been traversed, we will remove them from the <code>wordList</code>. This way we will avoid adding any edges that point towards <code>beginWord</code>.</p>\n<p>After constructing the graph, we can use our same backtracking approach to find the shortest paths between <code>beginWord</code> and <code>endWord</code>. Also, note that in the graph all paths between <code>beginWord</code> and <code>endWord</code>, obtained through BFS, will be the shortest possible. This is because all the edges in the graph will be directed in the direction of <code>beginWord</code> to <code>endWord</code>. Furthermore, there will not be any edge between the words that are on the same level.  Therefore, iterating over any edge will bring us one step closer to the <code>endWord</code>, thus there is no need to compare the length of the path each time we reach the <code>endWord</code>.</p>\n<h4>Algorithm</h4>\n<ol>\n<li>\n<p>Store the words present in <code>wordList</code> in an unordered set so that the words can be efficiently removed during the breadth-first search.</p>\n</li>\n<li>\n<p>Perform the BFS, and add the edges to the adjacency list <code>adjList</code>. Also once a level is finished remove the <code>visited</code> words from the <code>wordList</code>.</p>\n</li>\n<li>\n<p>Start from <code>beginWord</code> and while keep tracking of the current path as <code>currPath</code> traverse all the possible paths, whenever the path leads to the <code>endWord</code> store the path in <code>shortestPaths</code>.</p>\n</li>\n</ol>\n<h4>Implementation</h4>\n<blockquote>\n<p><strong>NOTE:</strong></p>\n<p>In the following implementation, for convenience, instead for go from <code>beginWord</code> to <code>endWord</code>, we go from <code>endWord</code> to <code>beginWord</code>.</p>\n</blockquote>\n<pre><code>class Solution {\n    Map&lt;String, List&lt;String&gt;&gt; adjList = new HashMap&lt;&gt;();\n    List&lt;String&gt; currPath = new ArrayList&lt;&gt;();\n    List&lt;List&lt;String&gt;&gt; shortestPaths = new ArrayList&lt;&gt;();\n\n    List&lt;String&gt; findNeighbors(String word, Set&lt;String&gt; wordList) {\n        List&lt;String&gt; neighbors = new ArrayList&lt;&gt;();\n        char[] chars = word.toCharArray();\n\n        for (int i = 0; i &lt; chars.length; i++) {\n            char oldChar = chars[i];\n            for (char c = 'a'; c &lt;= 'z'; c++) {\n                if (c == oldChar) continue;\n                chars[i] = c;\n                String newWord = new String(chars);\n                if (wordList.contains(newWord)) {\n                    neighbors.add(newWord);\n                }\n            }\n            chars[i] = oldChar;\n        }\n        return neighbors;\n    }\n\n    void backtrack(String source, String destination) {\n        if (source.equals(destination)) {\n            List&lt;String&gt; path = new ArrayList&lt;&gt;();\n            for (int i = currPath.size() - 1; i &gt;= 0; i--) {\n                path.add(currPath.get(i));\n            }\n            shortestPaths.add(path);\n            return;\n        }\n        if (!adjList.containsKey(source)) return;\n        for (String next : adjList.get(source)) {\n            currPath.add(next);\n            backtrack(next, destination);\n            currPath.remove(currPath.size() - 1);\n        }\n    }\n\n    void bfs(String beginWord, String endWord, Set&lt;String&gt; wordList) {\n        Queue&lt;String&gt; queue = new LinkedList&lt;&gt;();\n        queue.offer(beginWord);\n\n        wordList.remove(beginWord);\n\n        Map&lt;String, Boolean&gt; isEnqueued = new HashMap&lt;&gt;();\n        isEnqueued.put(beginWord, true);\n\n        while (!queue.isEmpty()) {\n            List&lt;String&gt; visited = new ArrayList&lt;&gt;();\n            int size = queue.size();\n\n            for (int i = 0; i &lt; size; i++) {\n                String currWord = queue.poll();\n                List&lt;String&gt; neighbors = findNeighbors(currWord, wordList);\n                for (String word : neighbors) {\n                    visited.add(word);\n                    adjList.computeIfAbsent(word, k -&gt; new ArrayList&lt;&gt;()).add(currWord);\n\n                    if (!isEnqueued.containsKey(word)) {\n                        queue.offer(word);\n                        isEnqueued.put(word, true);\n                    }\n                }\n            }\n\n            for (String word : visited) {\n                wordList.remove(word);\n            }\n        }\n    }\n\n    public List&lt;List&lt;String&gt;&gt; findLadders(String beginWord, String endWord, List&lt;String&gt; wordList) {\n        Set&lt;String&gt; copiedWordList = new HashSet&lt;&gt;(wordList);\n        bfs(beginWord, endWord, copiedWordList);\n\n        currPath.clear();\n        currPath.add(endWord);\n        backtrack(endWord, beginWord);\n\n        return shortestPaths;\n    }\n}</code></pre>\n<hr/>\n<h3><a href=\"#approach-2-bidirectional-breadth-first-search-bfs--backtracking-time-limit-exceeded\"><svg><path></path></svg></a>Approach 2: Bidirectional Breadth-First Search (BFS) + Backtracking (<strong>Time Limit Exceeded</strong>)</h3>\n<h4>Implementation</h4>\n<blockquote>\n<p><strong>NOTE:</strong></p>\n<p>Due to the larger constant factor, this approach is likely to yield <em>Time Limit Exceeded</em> in the current platform.</p>\n</blockquote>\n<pre><code>class Solution {\n    Map&lt;String, List&lt;String&gt;&gt; adjList = new HashMap&lt;&gt;();\n    List&lt;String&gt; currPath = new ArrayList&lt;&gt;();\n    List&lt;List&lt;String&gt;&gt; shortestPaths = new ArrayList&lt;&gt;();\n\n    List&lt;String&gt; findNeighbors(String word, Set&lt;String&gt; wordList) {\n        List&lt;String&gt; neighbors = new ArrayList&lt;&gt;();\n        char[] chars = word.toCharArray();\n\n        for (int i = 0; i &lt; chars.length; i++) {\n            char oldChar = chars[i];\n            for (char c = 'a'; c &lt;= 'z'; c++) {\n                if (c == oldChar) continue;\n                chars[i] = c;\n                String newWord = new String(chars);\n                if (wordList.contains(newWord)) {\n                    neighbors.add(newWord);\n                }\n            }\n            chars[i] = oldChar;\n        }\n        return neighbors;\n    }\n\n    void backtrack(String source, String destination) {\n        if (source.equals(destination)) {\n            shortestPaths.add(new ArrayList&lt;&gt;(currPath));\n            return;\n        }\n        if (!adjList.containsKey(source)) return;\n        for (String next : adjList.get(source)) {\n            currPath.add(next);\n            backtrack(next, destination);\n            currPath.remove(currPath.size() - 1);\n        }\n    }\n\n    void addEdge(String word1, String word2, int direction) {\n        if (direction == 1) {\n            adjList.computeIfAbsent(word1, k -&gt; new ArrayList&lt;&gt;()).add(word2);\n        } else {\n            adjList.computeIfAbsent(word2, k -&gt; new ArrayList&lt;&gt;()).add(word1);\n        }\n    }\n\n    boolean bfs(String beginWord, String endWord, Set&lt;String&gt; wordList) {\n        if (!wordList.contains(endWord)) return false;\n\n        wordList.remove(beginWord);\n\n        Set&lt;String&gt; forwardQueue = new HashSet&lt;&gt;();\n        Set&lt;String&gt; backwardQueue = new HashSet&lt;&gt;();\n        forwardQueue.add(beginWord);\n        backwardQueue.add(endWord);\n\n        boolean found = false;\n        int direction = 1;\n\n        while (!forwardQueue.isEmpty()) {\n            Set&lt;String&gt; visited = new HashSet&lt;&gt;();\n\n            if (forwardQueue.size() &gt; backwardQueue.size()) {\n                Set&lt;String&gt; temp = forwardQueue;\n                forwardQueue = backwardQueue;\n                backwardQueue = temp;\n                direction ^= 1;\n            }\n\n            for (String currWord : forwardQueue) {\n                List&lt;String&gt; neighbors = findNeighbors(currWord, wordList);\n                for (String word : neighbors) {\n                    if (backwardQueue.contains(word)) {\n                        found = true;\n                        addEdge(currWord, word, direction);\n                    } else if (!found && wordList.contains(word) && !forwardQueue.contains(word)) {\n                        visited.add(word);\n                        addEdge(currWord, word, direction);\n                    }\n                }\n            }\n\n            for (String word : forwardQueue) {\n                wordList.remove(word);\n            }\n            if (found) break;\n            forwardQueue = visited;\n        }\n        return found;\n    }\n\n    public List&lt;List&lt;String&gt;&gt; findLadders(String beginWord, String endWord, List&lt;String&gt; wordList) {\n        Set&lt;String&gt; copiedWordList = new HashSet&lt;&gt;(wordList);\n        boolean sequenceFound = bfs(beginWord, endWord, copiedWordList);\n\n        if (!sequenceFound) return shortestPaths;\n\n        currPath.clear();\n        currPath.add(beginWord);\n        backtrack(beginWord, endWord);\n\n        return shortestPaths;\n    }\n}</code></pre>\n<hr/>",
        "isOfficial": true,
        "scrapedAt": "2026-02-18T08:28:38.562Z"
    }
}