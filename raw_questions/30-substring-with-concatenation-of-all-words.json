{
  "questionId": "30",
  "questionFrontendId": "30",
  "title": "Substring with Concatenation of All Words",
  "titleSlug": "substring-with-concatenation-of-all-words",
  "content": "<p>You are given a string <code>s</code> and an array of strings <code>words</code>. All the strings of <code>words</code> are of <strong>the same length</strong>.</p>\n\n<p>A <strong>concatenated string</strong> is a string that exactly contains all the strings of any permutation of <code>words</code> concatenated.</p>\n\n<ul>\n\t<li>For example, if <code>words = [&quot;ab&quot;,&quot;cd&quot;,&quot;ef&quot;]</code>, then <code>&quot;abcdef&quot;</code>, <code>&quot;abefcd&quot;</code>, <code>&quot;cdabef&quot;</code>, <code>&quot;cdefab&quot;</code>, <code>&quot;efabcd&quot;</code>, and <code>&quot;efcdab&quot;</code> are all concatenated strings. <code>&quot;acdbef&quot;</code> is not a concatenated string because it is not the concatenation of any permutation of <code>words</code>.</li>\n</ul>\n\n<p>Return an array of <em>the starting indices</em> of all the concatenated substrings in <code>s</code>. You can return the answer in <strong>any order</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">s = &quot;barfoothefoobarman&quot;, words = [&quot;foo&quot;,&quot;bar&quot;]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">[0,9]</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p>The substring starting at 0 is <code>&quot;barfoo&quot;</code>. It is the concatenation of <code>[&quot;bar&quot;,&quot;foo&quot;]</code> which is a permutation of <code>words</code>.<br />\nThe substring starting at 9 is <code>&quot;foobar&quot;</code>. It is the concatenation of <code>[&quot;foo&quot;,&quot;bar&quot;]</code> which is a permutation of <code>words</code>.</p>\n</div>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">s = &quot;wordgoodgoodgoodbestword&quot;, words = [&quot;word&quot;,&quot;good&quot;,&quot;best&quot;,&quot;word&quot;]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">[]</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p>There is no concatenated substring.</p>\n</div>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">s = &quot;barfoofoobarthefoobarman&quot;, words = [&quot;bar&quot;,&quot;foo&quot;,&quot;the&quot;]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">[6,9,12]</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p>The substring starting at 6 is <code>&quot;foobarthe&quot;</code>. It is the concatenation of <code>[&quot;foo&quot;,&quot;bar&quot;,&quot;the&quot;]</code>.<br />\nThe substring starting at 9 is <code>&quot;barthefoo&quot;</code>. It is the concatenation of <code>[&quot;bar&quot;,&quot;the&quot;,&quot;foo&quot;]</code>.<br />\nThe substring starting at 12 is <code>&quot;thefoobar&quot;</code>. It is the concatenation of <code>[&quot;the&quot;,&quot;foo&quot;,&quot;bar&quot;]</code>.</p>\n</div>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= words.length &lt;= 5000</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 30</code></li>\n\t<li><code>s</code> and <code>words[i]</code> consist of lowercase English letters.</li>\n</ul>\n",
  "difficulty": "Hard",
  "stats": "{\"totalAccepted\": \"678.7K\", \"totalSubmission\": \"2M\", \"totalAcceptedRaw\": 678666, \"totalSubmissionRaw\": 2000091, \"acRate\": \"33.9%\"}",
  "hints": [],
  "similarQuestions": "[{\"title\": \"Minimum Window Substring\", \"titleSlug\": \"minimum-window-substring\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
  "topicTags": [
    {
      "name": "Hash Table",
      "slug": "hash-table"
    },
    {
      "name": "String",
      "slug": "string"
    },
    {
      "name": "Sliding Window",
      "slug": "sliding-window"
    }
  ],
  "companyTags": null,
  "codeSnippets": [
    {
      "lang": "C++",
      "langSlug": "cpp",
      "code": "class Solution {\npublic:\n    vector<int> findSubstring(string s, vector<string>& words) {\n        \n    }\n};"
    },
    {
      "lang": "Java",
      "langSlug": "java",
      "code": "class Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        \n    }\n}"
    },
    {
      "lang": "Python3",
      "langSlug": "python3",
      "code": "class Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        "
    },
    {
      "lang": "Python",
      "langSlug": "python",
      "code": "class Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        "
    },
    {
      "lang": "JavaScript",
      "langSlug": "javascript",
      "code": "/**\n * @param {string} s\n * @param {string[]} words\n * @return {number[]}\n */\nvar findSubstring = function(s, words) {\n    \n};"
    },
    {
      "lang": "TypeScript",
      "langSlug": "typescript",
      "code": "function findSubstring(s: string, words: string[]): number[] {\n    \n};"
    },
    {
      "lang": "C#",
      "langSlug": "csharp",
      "code": "public class Solution {\n    public IList<int> FindSubstring(string s, string[] words) {\n        \n    }\n}"
    },
    {
      "lang": "C",
      "langSlug": "c",
      "code": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* findSubstring(char* s, char** words, int wordsSize, int* returnSize) {\n    \n}"
    },
    {
      "lang": "Go",
      "langSlug": "golang",
      "code": "func findSubstring(s string, words []string) []int {\n    \n}"
    },
    {
      "lang": "Kotlin",
      "langSlug": "kotlin",
      "code": "class Solution {\n    fun findSubstring(s: String, words: Array<String>): List<Int> {\n        \n    }\n}"
    },
    {
      "lang": "Swift",
      "langSlug": "swift",
      "code": "class Solution {\n    func findSubstring(_ s: String, _ words: [String]) -> [Int] {\n        \n    }\n}"
    },
    {
      "lang": "Rust",
      "langSlug": "rust",
      "code": "impl Solution {\n    pub fn find_substring(s: String, words: Vec<String>) -> Vec<i32> {\n        \n    }\n}"
    },
    {
      "lang": "Ruby",
      "langSlug": "ruby",
      "code": "# @param {String} s\n# @param {String[]} words\n# @return {Integer[]}\ndef find_substring(s, words)\n    \nend"
    },
    {
      "lang": "PHP",
      "langSlug": "php",
      "code": "class Solution {\n\n    /**\n     * @param String $s\n     * @param String[] $words\n     * @return Integer[]\n     */\n    function findSubstring($s, $words) {\n        \n    }\n}"
    },
    {
      "lang": "Dart",
      "langSlug": "dart",
      "code": "class Solution {\n  List<int> findSubstring(String s, List<String> words) {\n    \n  }\n}"
    },
    {
      "lang": "Scala",
      "langSlug": "scala",
      "code": "object Solution {\n    def findSubstring(s: String, words: Array[String]): List[Int] = {\n        \n    }\n}"
    },
    {
      "lang": "Elixir",
      "langSlug": "elixir",
      "code": "defmodule Solution do\n  @spec find_substring(s :: String.t, words :: [String.t]) :: [integer]\n  def find_substring(s, words) do\n    \n  end\nend"
    },
    {
      "lang": "Erlang",
      "langSlug": "erlang",
      "code": "-spec find_substring(S :: unicode:unicode_binary(), Words :: [unicode:unicode_binary()]) -> [integer()].\nfind_substring(S, Words) ->\n  ."
    },
    {
      "lang": "Racket",
      "langSlug": "racket",
      "code": "(define/contract (find-substring s words)\n  (-> string? (listof string?) (listof exact-integer?))\n  )"
    }
  ],
  "solution": {
    "content": "<div class=\"flex flex-col w-full\" style=\"position: relative;\"><div class=\"mYe_l WRmCx\">\n\n\n    \n\n\n<h2 id=\"solution-article\" level=\"2\" class=\"group/heading relative\"><a href=\"#solution-article\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" aria-hidden=\"true\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"link\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" role=\"img\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 640 512\" spacing=\"square\"><path fill=\"currentColor\" d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\"></path></svg></div></a>Solution Article</h2>\n<hr>\n<h3 id=\"approach-1-check-all-indices-using-a-hash-table\" level=\"3\" class=\"group/heading relative\"><a href=\"#approach-1-check-all-indices-using-a-hash-table\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" aria-hidden=\"true\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"link\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" role=\"img\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 640 512\" spacing=\"square\"><path fill=\"currentColor\" d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\"></path></svg></div></a>Approach 1: Check All Indices Using a Hash Table</h3>\n<p><strong>Intuition</strong></p>\n<blockquote>\n<p>Definition: a <strong>valid substring</strong> is a string that is a concatenation of all of the words in our word bank. So if we are given the words \"foo\" and \"bar\", then \"foobar\" and \"barfoo\" would be valid substrings.</p>\n</blockquote>\n<p>An important detail in the problem description to notice is that <strong>all elements in <code>words</code> have the same length</strong>. This gives us valuable information about all valid substrings - we know what length they will be. Each valid substring is the concatenation of <code>words.length</code> words which all have the same length, so each valid substring has a length of <code>words.length * words[0].length</code>.</p>\n<p><img alt=\"\" width=\"960\" src=\"../Figures/30/30_1.png\"><br></p>\n<p>This makes it easy for us to take a given index and check if a valid substring starting at this index exists. Let's say that the elements of <code>words</code> have a length of <code>3</code>. Then, for a given starting index, we can just look at the string in groups of <code>3</code> characters and check if those characters form a word in <code>words</code>. Because <code>words</code> can have duplicate words, we should use a hash table to maintain a count for each word. As a bonus, a hash table also lets us search for word matches very quickly.</p>\n<p>We can write a helper function that takes an index and returns if a valid substring starting at this index exists. Then, we can build our answer by running this function for all candidate indices. The logic for this function can be something along the lines of:</p>\n<ul>\n<li>Iterate from the starting index to the starting index plus the size of a valid substring.</li>\n<li>Iterate <code>words[0].length</code> characters at a time. At each iteration, we will look at a substring with the same length as the elements in <code>words</code>.</li>\n<li>If the substring doesn't exist in <code>words</code>, or it does exist but we already found the necessary amount of it, then return false.</li>\n<li>We can use a hash table to keep an updated count of the words between the starting index and the current index.</li>\n</ul>\n<p></p>\n<p><strong>Algorithm</strong></p>\n<ol>\n<li data-length=\"1\">\n<p>Initialize some variables:</p>\n<ul>\n<li><code>n</code> as the length of <code>s</code>.</li>\n<li><code>k</code> as the length of <code>words</code></li>\n<li><code>wordLength</code> as the length of each word in <code>words</code>.</li>\n<li><code>substringSize</code> as <code>wordLength * k</code>, which represents the size of each valid substring.</li>\n<li><code>wordCount</code> as a hash table that tracks how many times a word occurs in <code>words</code>.</li>\n</ul>\n</li>\n<li data-length=\"1\">\n<p>Create a function <code>check</code> that takes a starting index <code>i</code> and returns if a valid substring starts at index <code>i</code>:</p>\n<ul>\n<li>Create a copy of <code>wordCount</code> to make use of for this particular index. Let's call it <code>remaining</code>. Also, initialize an integer <code>wordsUsed</code> which tracks how many matches we have found so far.</li>\n<li>Iterate starting from <code>i</code>. Iterate until <code>i + substringSize</code> - we know that each valid substring will have this size, so we don't need to go further. At each iteration, we will be checking for a word - and we know each word has a length of <code>wordLength</code>, so increment by <code>wordLength</code> each time.</li>\n<li>If the variable we are iterating with is <code>j</code>, then at each iteration, check for a word <code>sub = s.substring(j, j + wordLength)</code>.</li>\n<li>If <code>sub</code> is in <code>remaining</code> and has a value greater than <code>0</code>, then decrease its count by <code>1</code> and increase <code>wordsUsed</code> by <code>1</code>. Otherwise, <code>break</code> out of the loop.</li>\n<li>At the end of it all, if <code>wordsUsed == k</code>, that means we used up all the words in <code>words</code> and have found a valid substring. Return <code>true</code> if so, <code>false</code> otherwise.</li>\n</ul>\n</li>\n<li data-length=\"1\">\n<p>Now that we have this function <code>check</code>, we can just check all possible starting indices. Because a valid substring has a length of <code>substringSize</code>, we only need to iterate up to <code>n - substringSize</code>. Build an array with all indices that pass <code>check</code> and return it.</p>\n</li>\n</ol>\n<p><strong>Implementation</strong></p>\n<pre><code>class Solution {\npublic:\n    unordered_map&lt;string, int&gt; wordCount;\n    int wordLength;\n    int substringSize;\n    int k;\n    bool check(int i, string s) {\n        // Copy the original dictionary to use for this index\n        unordered_map&lt;string, int&gt; remaining = wordCount;\n        int wordsUsed = 0;\n        // Each iteration will check for a match in words\n        for (int j = i; j &lt; i + substringSize; j += wordLength) {\n            string sub = s.substr(j, wordLength);\n            if (remaining[sub] != 0) {\n                remaining[sub]--;\n                wordsUsed++;\n            } else {\n                break;\n            }\n        }\n        return wordsUsed == k;\n    }\n    vector&lt;int&gt; findSubstring(string s, vector&lt;string&gt;& words) {\n        int n = s.size();\n        k = words.size();\n        wordLength = words[0].size();\n        substringSize = wordLength * k;\n        for (string word : words) {\n            if (wordCount.find(word) == wordCount.end()) {\n                wordCount[word] = 1;\n            } else {\n                wordCount[word] += 1;\n            }\n        }\n        vector&lt;int&gt; answer;\n        for (int i = 0; i &lt; n - substringSize + 1; i++) {\n            if (check(i, s)) {\n                answer.push_back(i);\n            }\n        }\n        return answer;\n    }\n};</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<p>Given <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></span> as the length of <code>s</code>, <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.4306em;\"></span><span class=\"mord mathnormal\">a</span></span></span></span></span> as the length of <code>words</code>, and <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6944em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span></span> as the length of each word:</p>\n<ul>\n<li>\n<p>Time complexity: <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.4445em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.7778em; vertical-align: -0.0833em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1.0641em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.8141em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p>First, let's analyze the time complexity of <code>check</code>. We start by creating a copy of our hash table, which in the worst case will take <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mclose\">)</span></span></span></span></span> time, when <code>words</code> only has unique elements. Then, we iterate <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.4306em;\"></span><span class=\"mord mathnormal\">a</span></span></span></span></span> times (from <code>i</code> to <code>i + substringSize</code>, <code>wordLength</code> at a time): <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord text\"><span class=\"mord\">substringSize&nbsp;/&nbsp;wordLength&nbsp;=&nbsp;words.length&nbsp;=&nbsp;</span></span><span class=\"mord mathnormal\">a</span></span></span></span></span>. At each iteration, we create a substring, which takes <code>wordLength</code> = <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6944em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span></span> time. Then we do a hash table check.</p>\n<p>That means each call to <code>check</code> uses <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.4445em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">b</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">))</span></span></span></span></span> time, simplified to <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mclose\">)</span></span></span></span></span>. How many times do we call <code>check</code>? Only <code>n - substringSize</code> times. Recall that <code>substringSize</code> is equal to the length of <code>words</code> times the length of <code>words[0]</code>, which we have defined as <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.4306em;\"></span><span class=\"mord mathnormal\">a</span></span></span></span></span> and <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6944em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span></span> respectively here. That means we call <code>check</code> <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6667em; vertical-align: -0.0833em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.4445em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.6944em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span></span> times.</p>\n<p>This gives us a time complexity of <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">((</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.4445em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.4445em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mclose\">)</span></span></span></span></span>, which can be expanded to <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.4445em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.7778em; vertical-align: -0.0833em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1.0641em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.8141em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n</li>\n<li>\n<p>Space complexity: <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p>Most of the time, the majority of extra memory we use is the hash table to store word counts. In the worst-case scenario where <code>words</code> only has unique elements, we will store up to <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.4306em;\"></span><span class=\"mord mathnormal\">a</span></span></span></span></span> keys.</p>\n<p>We also store substrings in <code>sub</code> which requires <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">b</span><span class=\"mclose\">)</span></span></span></span></span> space. So the total space complexity of this approach is <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mclose\">)</span></span></span></span></span>. However, because for this particular problem the upper bound for <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6944em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span></span> is very small (30), we can consider the space complexity to be <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n</li>\n</ul>\n<br>\n<hr>\n<h3 id=\"approach-2-sliding-window\" level=\"3\" class=\"group/heading relative\"><a href=\"#approach-2-sliding-window\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" aria-hidden=\"true\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"link\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" role=\"img\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 640 512\" spacing=\"square\"><path fill=\"currentColor\" d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\"></path></svg></div></a>Approach 2: Sliding Window</h3>\n<p><strong>Intuition</strong></p>\n<p>In the previous approach, we made use of the fact that all elements of <code>words</code> share the same length, which allows us to efficiently check for valid substrings. Unfortunately, we repeated a lot of computation - each character of <code>s</code> is iterated over many times. Imagine if we had an input like this:</p>\n<p><code>s = \"barfoobarfoo\"</code> and <code>words = [\"bar\", \"foo\"]</code></p>\n<p><img alt=\"\" width=\"960\" src=\"../Figures/30/30_5.png\"><br></p>\n<p>Valid substrings start at index <code>0</code>, <code>3</code>, and <code>6</code>. Notice that the substrings starting at indices <code>0</code> and <code>3</code> share the same <code>\"foo\"</code>. That means we are iterating over and handling this <code>\"foo\"</code> twice, which shouldn't be necessary. We do it again with the substrings starting at indices <code>3</code> and <code>6</code> - they use the same <code>\"bar\"</code>. In this specific example it may not seem too bad, but imagine if we had an input like:</p>\n<p><code>s = \"aaaa...aaa\", s.length = 10,000</code> and <code>words = [\"a\", \"a\", ..., \"a\", \"a\"], words.length = 5000</code></p>\n<p>We would be iterating over the same characters <strong>millions</strong> of times. How can we avoid repeated computation? Let's make use of a sliding window. We can re-use most of the logic from the previous approach, but this time instead of only checking for one valid substring at a time with each call to <code>check</code>, we will try to find <strong>all</strong> valid substrings in one pass by sliding our window across <code>s</code>.</p>\n<p>So how will the left and right bounds of the window move, and how can we tell if we our window is a valid substring? Let's say we start at index <code>0</code> and do the same process as the previous approach - iterate <code>wordLength</code> at a time, so that at each iteration we are focusing on one potential word. Our iteration variable, say <code>right</code>, can be our right bound. We can initialize our left bound at <code>0</code>, say <code>left = 0</code>.</p>\n<p>Now, <code>right</code> will move at each iteration, by <code>wordLength</code> each time. At each iteration, we have a word <code>sub = s.substring(right, right + wordLength)</code>. If <code>sub</code> is not in <code>words</code>, we know that we cannot possibly form a valid substring, so we should reset the entire window and try again, starting with the next iteration. If <code>sub</code> is in <code>words</code>, then we need to keep track of it. Like in the previous approach, we can use a hash table to keep count of all the words in our current window.</p>\n<p><img alt=\"\" width=\"960\" src=\"../Figures/30/30_14.png\"><br></p>\n<p><img alt=\"\" width=\"960\" src=\"../Figures/30/30_15.png\"><br></p>\n<p>When our window has reached the maximum size (<code>substringSize</code>), we can check if it is a valid substring. Like in the previous approach, we can use an integer <code>wordsUsed</code> to check if <code>wordsUsed == words.length</code> to see if we made use of all the elements in <code>words</code>, and thus have a valid substring. If we do, then we can add <code>left</code> to our answer.</p>\n<p>Whether we have a valid substring or not, if our window has reached maximum size, we need to move the left bound. This means we need to find the word we are removing from the window, and perform the necessary logic to keep our hash table up to date.</p>\n<p>Another thing to note: we may encounter excess words. For example, with <code>s = \"foofoobar\"</code>, and <code>words = [\"foo\", \"bar\"]</code>, the two <code>\"foo\"</code> should not be matched together to have <code>wordsUsed = 2</code>. Whenever we find that <code>sub</code> is in <code>words</code>, we should check how many times we have seen <code>sub</code> so far in the current window (using our hash table), and if it is greater than the number of times it appears in <code>words</code> (which we can find with a second hash table, <code>wordCount</code> in the first approach), then we know we have an excess word and should not increment <code>wordsUsed</code>.</p>\n<p>In fact, so long as we have an excess word, we can never have a valid substring. Therefore, another criterion for moving our left bound should be to remove words from the left until we find the excess word and remove it (which we can accomplish by comparing the hash table values).</p>\n<p><img alt=\"\" width=\"960\" src=\"../Figures/30/30_16.png\"><br></p>\n<p><img alt=\"\" width=\"960\" src=\"../Figures/30/30_17.png\"><br></p>\n<p>Now that we've described the logic needed for the sliding window, how will we apply the window? In the first approach, we tried every candidate index (all indices up until <code>n - substringSize</code>). In this problem, you may notice that starting the process from two indices that are <code>wordLength</code> apart is pointless. For example, if we have <code>words = [\"foo\", \"bar\"]</code>, then starting from index <code>3</code> is pointless since by starting at index <code>0</code>, we will move over index <code>3</code>. However, we will still need to try starting from indices <code>1</code> and <code>2</code>, in case the input looks something like <code>s = \"xfoobar\"</code> or <code>s = \"xyfoobar\"</code>. As such, we will only need to perform the sliding window <code>wordLength</code> amount of times.</p>\n<p></p>\n<p><strong>Algorithm</strong></p>\n<ol>\n<li data-length=\"1\">\n<p>Initialize some variables:</p>\n<ul>\n<li><code>n</code> as the length of <code>s</code>.</li>\n<li><code>k</code> as the length of <code>words</code></li>\n<li><code>wordLength</code> as the length of each word in <code>words</code>.</li>\n<li><code>substringSize</code> as <code>wordLength * k</code>, which represents the size of each valid substring.</li>\n<li><code>wordCount</code> as a hash table that tracks how many times a word occurs in <code>words</code>.</li>\n<li><code>answer</code> as an array that will hold the starting index of every valid substring</li>\n</ul>\n</li>\n<li data-length=\"1\">\n<p>Create a function <code>slidingWindow</code> that takes an index <code>left</code> and starts a sliding window from <code>left</code>:</p>\n<ul>\n<li>Initialize a hash table <code>wordsFound</code> that will keep track of how many times a word appears in our window. Also, an integer <code>wordsUsed = 0</code> to keep track of how many words are in our window, and a boolean <code>excessWord = false</code> that indicates if our window is currently holding an excess word, such as a third <code>\"foo\"</code> if <code>words = [\"foo\", \"foo\"]</code>.</li>\n<li>Iterate using the right bound of our window, <code>right</code>. Start iteration at <code>left</code>, until <code>n</code>, <code>wordLength</code> at a time. At each iteration:\n<ul>\n<li>We are dealing with a word <code>sub = s.substring(right, right + wordLength)</code>. If <code>sub</code> is not in <code>wordCount</code>, then we must reset the window. Clear our hash table <code>wordsFound</code>, and reset our variables <code>wordsUsed = 0</code> and <code>excessWord = false</code>. Move <code>left</code> to the next index we will handle, which will be <code>right + wordLength</code>.</li>\n<li>Otherwise, if <code>sub</code> is in <code>wordCount</code>, we can continue with our window. First, check if our window is beyond max size or has an excess word. So long as either of these conditions are true, move <code>left</code> over while appropriately updating our hash table, integer and boolean variables.</li>\n<li>Now, we can handle <code>sub</code>. Increment its value in <code>wordsFound</code>, and then compare its value in <code>wordsFound</code> to its value in <code>wordCount</code>. If the value is less than or equal, then we can make use of this word in a valid substring - increment <code>wordsUsed</code>. Otherwise, it is an excess word, and we should set <code>excessWord = true</code>.</li>\n<li>At the end of it all, if we have <code>wordsUsed == k</code> without any excess words, then we have a valid substring. Add <code>left</code> to <code>answer</code>.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li data-length=\"1\">\n<p>Call <code>slidingWindow</code> with each index from <code>0</code> to <code>wordLength</code>. Return <code>answer</code> once finished.</p>\n</li>\n</ol>\n<p><strong>Implementation</strong></p>\n<pre><code>class Solution {\nprivate:\n    unordered_map&lt;string, int&gt; wordCount;\n    int n;\n    int wordLength;\n    int substringSize;\n    int k;\n    void slidingWindow(int left, string &s, vector&lt;int&gt; &answer) {\n        unordered_map&lt;string, int&gt; wordsFound;\n        int wordsUsed = 0;\n        bool excessWord = false;\n        for (int right = left; right &lt;= n - wordLength; right += wordLength) {\n            string sub = s.substr(right, wordLength);\n            if (!wordCount.count(sub)) {\n                // Mismatched word - reset the window\n                wordsFound.clear();\n                wordsUsed = 0;\n                excessWord = false;\n                left = right + wordLength;\n            } else {\n                // If we reached max window size or have an excess word\n                while (right - left == substringSize || excessWord) {\n                    string leftmostWord = s.substr(left, wordLength);\n                    left += wordLength;\n                    wordsFound[leftmostWord]--;\n                    if (wordsFound[leftmostWord] &gt;= wordCount[leftmostWord]) {\n                        // This word was an excess word\n                        excessWord = false;\n                    } else {\n                        // Otherwise we actually needed it\n                        wordsUsed--;\n                    }\n                }\n                // Keep track of how many times this word occurs in the window\n                wordsFound[sub]++;\n                if (wordsFound[sub] &lt;= wordCount[sub]) {\n                    wordsUsed++;\n                } else {\n                    // Found too many instances already\n                    excessWord = true;\n                }\n                if (wordsUsed == k && !excessWord) {\n                    // Found a valid substring\n                    answer.push_back(left);\n                }\n            }\n        }\n    }\n​\npublic:\n    vector&lt;int&gt; findSubstring(string s, vector&lt;string&gt; &words) {\n        n = s.length();\n        k = words.size();\n        wordLength = words[0].length();\n        substringSize = wordLength * k;\n        for (string &word : words) {\n            wordCount[word]++;\n        }\n        vector&lt;int&gt; answer;\n        for (int i = 0; i &lt; wordLength; i++) {\n            slidingWindow(i, s, answer);\n        }\n        return answer;\n    }\n};</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<p>Given <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></span> as the length of <code>s</code>, <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.4306em;\"></span><span class=\"mord mathnormal\">a</span></span></span></span></span> as the length of <code>words</code>, and <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6944em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span></span> as the length of each word:</p>\n<ul>\n<li>\n<p>Time complexity: <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.4445em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p>First, let's analyze the time complexity of <code>slidingWindow()</code>. The for loop in this function iterates from the starting index <code>left</code> up to <code>n</code>, at increments of <code>wordLength</code>. This results in <code>n / b</code> total iterations. At each iteration, we create a substring of length <code>wordLength</code>, which costs <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">b</span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n<p>Although there is a nested while loop, the left pointer can only move over each word once, so this inner loop will only ever perform a total of <code>n / wordLength</code> iterations summed across all iterations of the outer for loop. Inside that while loop, we also take a substring which costs <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">b</span><span class=\"mclose\">)</span></span></span></span></span>, which means each iteration will cost at most <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mclose\">)</span></span></span></span></span> on average.</p>\n<p>This means that each call to <code>slidingWindow</code> costs <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1.7936em; vertical-align: -0.686em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 1.1076em;\"><span style=\"top: -2.314em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">b</span></span></span><span style=\"top: -3.23em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width: 0.04em;\"></span></span><span style=\"top: -3.677em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.686em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.6444em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mclose\">)</span></span></span></span></span>, or <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span>. How many times do we call <code>slidingWindow</code>? <code>wordLength</code>, or <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6944em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span></span> times. This means that all calls to <code>slidingWindow</code> costs <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n<p>On top of the calls to <code>slidingWindow</code>, at the start of the algorithm we create a dictionary <code>wordCount</code> by iterating through <code>words</code>, which costs <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mclose\">)</span></span></span></span></span>. This gives us our final time complexity of <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.4445em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n<p>Notice that the length of <code>words</code> <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.4306em;\"></span><span class=\"mord mathnormal\">a</span></span></span></span></span> is not multiplied by anything, which makes this approach <strong>much</strong> more efficient than the first approach due to the bounds of the problem, as <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.5782em; vertical-align: -0.0391em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.5782em; vertical-align: -0.0391em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">≫</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.6944em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span></span>.</p>\n</li>\n<li>\n<p>Space complexity: <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p>Most of the times, the majority of extra memory we use is due to the hash tables used to store word counts. In the worst-case scenario where <code>words</code> only has unique elements, we will store up to <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.4306em;\"></span><span class=\"mord mathnormal\">a</span></span></span></span></span> keys in the tables.</p>\n<p>We also store substrings in <code>sub</code> which requires <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">b</span><span class=\"mclose\">)</span></span></span></span></span> space. So the total space complexity of this approach is <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mclose\">)</span></span></span></span></span>. However, because for this particular problem the upper bound for <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6944em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span></span> is very small (30), we can consider the space complexity to be <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n</li>\n</ul>\n<br>\n<hr></div><span style=\"font-size: 0px; line-height: 0;\">&nbsp;</span></div>",
    "isOfficial": true,
    "scrapedAt": "2026-02-18T08:19:55.168Z"
  }
}