{
  "questionId": "77",
  "questionFrontendId": "77",
  "title": "Combinations",
  "titleSlug": "combinations",
  "content": "<p>Given two integers <code>n</code> and <code>k</code>, return <em>all possible combinations of</em> <code>k</code> <em>numbers chosen from the range</em> <code>[1, n]</code>.</p>\n\n<p>You may return the answer in <strong>any order</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 4, k = 2\n<strong>Output:</strong> [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]\n<strong>Explanation:</strong> There are 4 choose 2 = 6 total combinations.\nNote that combinations are unordered, i.e., [1,2] and [2,1] are considered to be the same combination.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1, k = 1\n<strong>Output:</strong> [[1]]\n<strong>Explanation:</strong> There is 1 choose 1 = 1 total combination.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 20</code></li>\n\t<li><code>1 &lt;= k &lt;= n</code></li>\n</ul>\n",
  "difficulty": "Medium",
  "stats": "{\"totalAccepted\": \"1.3M\", \"totalSubmission\": \"1.7M\", \"totalAcceptedRaw\": 1284895, \"totalSubmissionRaw\": 1732994, \"acRate\": \"74.1%\"}",
  "hints": [],
  "similarQuestions": "[{\"title\": \"Combination Sum\", \"titleSlug\": \"combination-sum\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Permutations\", \"titleSlug\": \"permutations\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
  "topicTags": [
    {
      "name": "Backtracking",
      "slug": "backtracking"
    }
  ],
  "companyTags": null,
  "codeSnippets": [
    {
      "lang": "C++",
      "langSlug": "cpp",
      "code": "class Solution {\npublic:\n    vector<vector<int>> combine(int n, int k) {\n        \n    }\n};"
    },
    {
      "lang": "Java",
      "langSlug": "java",
      "code": "class Solution {\n    public List<List<Integer>> combine(int n, int k) {\n        \n    }\n}"
    },
    {
      "lang": "Python3",
      "langSlug": "python3",
      "code": "class Solution:\n    def combine(self, n: int, k: int) -> List[List[int]]:\n        "
    },
    {
      "lang": "Python",
      "langSlug": "python",
      "code": "class Solution(object):\n    def combine(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: List[List[int]]\n        \"\"\"\n        "
    },
    {
      "lang": "JavaScript",
      "langSlug": "javascript",
      "code": "/**\n * @param {number} n\n * @param {number} k\n * @return {number[][]}\n */\nvar combine = function(n, k) {\n    \n};"
    },
    {
      "lang": "TypeScript",
      "langSlug": "typescript",
      "code": "function combine(n: number, k: number): number[][] {\n    \n};"
    },
    {
      "lang": "C#",
      "langSlug": "csharp",
      "code": "public class Solution {\n    public IList<IList<int>> Combine(int n, int k) {\n        \n    }\n}"
    },
    {
      "lang": "C",
      "langSlug": "c",
      "code": "/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\nint** combine(int n, int k, int* returnSize, int** returnColumnSizes) {\n    \n}"
    },
    {
      "lang": "Go",
      "langSlug": "golang",
      "code": "func combine(n int, k int) [][]int {\n    \n}"
    },
    {
      "lang": "Kotlin",
      "langSlug": "kotlin",
      "code": "class Solution {\n    fun combine(n: Int, k: Int): List<List<Int>> {\n        \n    }\n}"
    },
    {
      "lang": "Swift",
      "langSlug": "swift",
      "code": "class Solution {\n    func combine(_ n: Int, _ k: Int) -> [[Int]] {\n        \n    }\n}"
    },
    {
      "lang": "Rust",
      "langSlug": "rust",
      "code": "impl Solution {\n    pub fn combine(n: i32, k: i32) -> Vec<Vec<i32>> {\n        \n    }\n}"
    },
    {
      "lang": "Ruby",
      "langSlug": "ruby",
      "code": "# @param {Integer} n\n# @param {Integer} k\n# @return {Integer[][]}\ndef combine(n, k)\n    \nend"
    },
    {
      "lang": "PHP",
      "langSlug": "php",
      "code": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @param Integer $k\n     * @return Integer[][]\n     */\n    function combine($n, $k) {\n        \n    }\n}"
    },
    {
      "lang": "Dart",
      "langSlug": "dart",
      "code": "class Solution {\n  List<List<int>> combine(int n, int k) {\n    \n  }\n}"
    },
    {
      "lang": "Scala",
      "langSlug": "scala",
      "code": "object Solution {\n    def combine(n: Int, k: Int): List[List[Int]] = {\n        \n    }\n}"
    },
    {
      "lang": "Elixir",
      "langSlug": "elixir",
      "code": "defmodule Solution do\n  @spec combine(n :: integer, k :: integer) :: [[integer]]\n  def combine(n, k) do\n    \n  end\nend"
    },
    {
      "lang": "Erlang",
      "langSlug": "erlang",
      "code": "-spec combine(N :: integer(), K :: integer()) -> [[integer()]].\ncombine(N, K) ->\n  ."
    },
    {
      "lang": "Racket",
      "langSlug": "racket",
      "code": "(define/contract (combine n k)\n  (-> exact-integer? exact-integer? (listof (listof exact-integer?)))\n  )"
    }
  ],
  "solution": {
    "content": "<div class=\"flex flex-col w-full\" style=\"position: relative;\"><div class=\"mYe_l WRmCx\"><h2 id=\"solution\" level=\"2\" class=\"group/heading relative\"><a href=\"#solution\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" aria-hidden=\"true\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"link\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" role=\"img\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 640 512\" spacing=\"square\"><path fill=\"currentColor\" d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\"></path></svg></div></a>Solution</h2>\n<hr>\n<h3 id=\"approach-backtracking\" level=\"3\" class=\"group/heading relative\"><a href=\"#approach-backtracking\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" aria-hidden=\"true\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"link\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" role=\"img\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 640 512\" spacing=\"square\"><path fill=\"currentColor\" d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\"></path></svg></div></a>Approach: Backtracking</h3>\n<p><strong>Intuition</strong></p>\n<p>We are given that <code>n &lt;= 20</code>. Typically, problems that ask you to find <strong>all</strong> of something with low bounds can be solved with backtracking.</p>\n<p>In backtracking, we generate all solutions one element at a time. This problem is asking us to generate all possible combinations, so we will generate combinations one element at a time.</p>\n<p>The range of elements we are working with is <code>[1, n]</code>. To generate a combination one element at a time, we will use an array <code>curr</code> that represents the current combination we are building.</p>\n<p>To start, we add the first element <code>1</code>, so we have <code>curr = [1]</code>. We are <strong>locking</strong> in this <code>1</code> and we will now find all combinations that start with <code>1</code>.</p>\n<p>To find all combinations that start with <code>1</code>, we start by adding the first element after <code>1</code>, which is <code>2</code>. We now have <code>curr = [1, 2]</code>. We are <strong>locking</strong> in this <code>2</code> and we will now find all combinations that start with <code>1, 2</code>.</p>\n<p>This continues until we reach the target length <code>k</code>. Let's say that we have finished finding all combinations that start with <code>[1, 2]</code>. Now what? We <strong>backtrack</strong> by removing the <code>2</code>, and we have <code>curr = [1]</code> again. Now, we add the second element that comes after <code>1</code>, which is <code>3</code>. We have <code>curr = [1, 3]</code>, and now we need to find all combinations that start with <code>[1, 3]</code>.</p>\n<p>Once we find all the combinations that start with <code>[1]</code>, we backtrack by removing the <code>1</code> from <code>curr</code> and adding the next element. We have <code>curr = [2]</code>, and now we need to find all combinations that start with <code>2</code>.</p>\n<p>This process is very recursive in nature. Each time we add an element, we solve a new version of the problem (find all combinations that start with <code>curr</code>). The initial version of the problem is to find all combinations that start with <code>[]</code>, which represents all possible combinations.</p>\n<p><strong>Trees</strong></p>\n<p>The best way to think about the backtracking process is by modeling it as a tree. You can imagine the solution space as a tree, with each node representing a version of <code>curr</code>. Label each node with a number that represents the last number in <code>curr</code>. Moving to a child is like adding the child's label to <code>curr</code>.</p>\n<p>To prevent duplicate combinations like <code>[1, 2]</code> and <code>[2, 1]</code>, a node only has children with labels greater than its own.</p>\n<p>Given <code>n = 4</code> and <code>k = 2</code>, here is the backtracking tree:</p>\n<p><img alt=\"\" width=\"960\" src=\"../Figures/77/1.png\"> <br></p>\n<p>The root node represents an empty <code>[]</code>. From the root, every node's <code>curr</code> represents the path taken from the root. The nodes at depth <code>k</code> represent the answer combinations (highlighted in green).</p>\n<p>Solving this problem is equivalent to \"traversing\" this tree. The easiest way to perform the traversal is by using recursion and passing <code>curr</code> as an argument.</p>\n<p>Think of each call to the recursive function as being a node in the tree. In each call, we need to iterate over the numbers greater than the label of the current node. We can pass an argument <code>firstNum</code> representing the first number we should start iterating from.</p>\n<p>For each <code>num</code> in <code>[firstNum, n]</code>, we add it to <code>curr</code> and then make a recursive call passing <code>curr</code> and <code>num + 1</code> as <code>firstNum</code>. This ensures that we only consider numbers greater than the ones we have already added. Modifying <code>curr</code> and making a recursive call is equivalent to \"traversing\" to a child node in the tree.</p>\n<p>When we return from a function call, it's equivalent to moving back up the tree (exactly like in a DFS). When we moved from a parent to a child, we added an element to <code>curr</code>. When we move from a child back to its parent, we need to remove the element we added from <code>curr</code>. This is the \"backtracking\" step.</p>\n<p>The following is an implementation of this backtrack function, which is essentially performing a DFS on the solution space tree.</p>\n<pre><code>void backtrack(vector&lt;int&gt;& curr, int firstNum, vector&lt;vector&lt;int&gt;&gt;& ans) {\n    if (curr.size() == k) {\n        ans.push_back(curr);\n        return;\n    }\n​\n    for (int num = firstNum; num &lt;= n; num++) {\n        curr.push_back(num);\n        backtrack(curr, num + 1, ans);\n        curr.pop_back();\n    }\n​\n    return;\n}</code></pre>\n<p><strong>An optimization step</strong></p>\n<p>You may notice in the solution tree image above, we have a path that does not lead to any solutions (the <code>4</code> node).</p>\n<p>This path doesn't lead to any solutions because there aren't enough elements after <code>4</code> to reach a path length of <code>k</code>. We should avoid paths like these as they are a waste of time. It would be better if our tree looked like this:</p>\n<p><img alt=\"\" width=\"960\" src=\"../Figures/77/2.png\"> <br></p>\n<p>At each node, we have <code>curr.length</code> elements so far. We need to reach <code>k</code> elements. Therefore, we can calculate <code>need = k - curr.length</code> as the number of elements we still need to add.</p>\n<p>The range of numbers we are considering in the subtree is <code>[firstNum, n]</code>. The size of this range is <code>remain = n - firstNum + 1</code>.</p>\n<p>Finally, we can calculate <code>available = remain - need</code>. This value represents the count of numbers available to us as children. We should only consider children in the range <code>[firstNum, firstNum + available]</code> instead of the range <code>[firstNum, n]</code> like in the above code.</p>\n<p>If we moved to a child outside of this range, like <code>firstNum + available + 1</code>, then we will run out of numbers to use before reaching a length of <code>k</code>.</p>\n<p><strong>Algorithm</strong></p>\n<ol>\n<li data-length=\"1\">Initialize an answer array <code>ans</code> and an array to build combinations with <code>curr</code>.</li>\n<li data-length=\"1\">Create a <code>backtrack</code> function that takes <code>curr</code> as an argument as well as an integer <code>firstNum</code>:\n<ul>\n<li>if <code>curr.length == k</code>, add a copy of <code>curr</code> to <code>ans</code> and return.</li>\n<li>Calculate <code>available</code>, the amount of numbers we can consider at the current node.</li>\n<li>Iterate <code>num</code> from <code>firstNum</code> up to and including <code>firstNum + available</code>.</li>\n<li>For each <code>num</code>, add it to <code>curr</code>, call <code>backtrack(curr, num + 1)</code>, and then remove <code>num</code> from <code>curr</code>.</li>\n</ul>\n</li>\n<li data-length=\"1\">Call <code>backtrack</code> with an initially empty <code>curr</code> and <code>firstNum = 1</code>.</li>\n<li data-length=\"1\">Return <code>ans</code>.</li>\n</ol>\n<p><strong>Implementation</strong></p>\n<pre><code>class Solution {\npublic:\n    int k;\n    int n;\n​\n    vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) {\n        this-&gt;k = k;\n        this-&gt;n = n;\n        vector&lt;vector&lt;int&gt;&gt; ans;\n        vector&lt;int&gt; curr;\n        backtrack(curr, 1, ans);\n        return ans;\n    }\n​\n    void backtrack(vector&lt;int&gt;& curr, int firstNum, vector&lt;vector&lt;int&gt;&gt;& ans) {\n        if (curr.size() == k) {\n            ans.push_back(curr);\n            return;\n        }\n​\n        int need = k - curr.size();\n        int remain = n - firstNum + 1;\n        int available = remain - need;\n​\n        for (int num = firstNum; num &lt;= firstNum + available; num++) {\n            curr.push_back(num);\n            backtrack(curr, num + 1, ans);\n            curr.pop_back();\n        }\n    }\n};</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<blockquote>\n<p>Note: most backtracking problems, including this one, have extremely difficult time complexities to derive. Don't be discouraged if you can't derive it on your own - most of the time, the analysis requires an esoteric understanding of math. If you are asked this question in an interview, do your best to state an upper bound on the complexity by analyzing the number of nodes in the tree and the work done at each node.</p>\n</blockquote>\n<ul>\n<li>\n<p>Time complexity: <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 2.3074em; vertical-align: -0.936em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 1.3714em;\"><span style=\"top: -2.314em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"mord\"><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right: 0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)!</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.03148em;\">k</span><span class=\"mclose\">)!</span></span></span><span style=\"top: -3.23em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width: 0.04em;\"></span></span><span style=\"top: -3.677em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"mclose\">!</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.936em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p>Finding combinations is a <a href=\"https://en.wikipedia.org/wiki/Combination\" target=\"_blank\">well-studied problem in combinatorics</a>. The number of combinations of length <code>k</code> from a set of <code>n</code> elements is equal to the <a href=\"https://en.wikipedia.org/wiki/Binomial_coefficient\" target=\"_blank\">binomial coefficient</a>, also known as \"n choose k\".</p>\n<p><span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 2.4em; vertical-align: -0.95em;\"></span><span class=\"mord\"><span class=\"mopen delimcenter\" style=\"top: 0em;\"><span class=\"delimsizing size3\">(</span></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 1.1076em;\"><span style=\"top: -2.314em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right: 0.03148em;\">k</span></span></span><span style=\"top: -3.677em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.686em;\"><span></span></span></span></span></span><span class=\"mclose delimcenter\" style=\"top: 0em;\"><span class=\"delimsizing size3\">)</span></span></span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 2.3074em; vertical-align: -0.936em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 1.3714em;\"><span style=\"top: -2.314em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right: 0.03148em;\">k</span><span class=\"mclose\">!</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.03148em;\">k</span><span class=\"mclose\">)!</span></span></span><span style=\"top: -3.23em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width: 0.04em;\"></span></span><span style=\"top: -3.677em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"mclose\">!</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.936em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span></span></p>\n<p>How many nodes are in the tree?</p>\n<p>After applying the optimization, we only consider paths that lead to answers. This means that the number of leaf nodes is equal to the number of answers.</p>\n<p>Each path to a leaf has <code>k</code> nodes. However, there is a huge amount of overlap. It would be extremely difficult to calculate the exact number of nodes, but we know that it can't be greater than <code>k</code> times the number of leaves (which would occur if there was no overlap, i.e. every node had a maximum of 1 child, which is only possible for <code>n = k</code>). Therefore, an upper bound on the number of nodes is:</p>\n<p><span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 2.3074em; vertical-align: -0.936em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 1.3714em;\"><span style=\"top: -2.314em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right: 0.03148em;\">k</span><span class=\"mclose\">!</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.03148em;\">k</span><span class=\"mclose\">)!</span></span></span><span style=\"top: -3.23em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width: 0.04em;\"></span></span><span style=\"top: -3.677em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right: 0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">!</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.936em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 2.3074em; vertical-align: -0.936em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 1.3714em;\"><span style=\"top: -2.314em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"mord\"><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right: 0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)!</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.03148em;\">k</span><span class=\"mclose\">)!</span></span></span><span style=\"top: -3.23em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width: 0.04em;\"></span></span><span style=\"top: -3.677em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"mclose\">!</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.936em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span></span></p>\n<p>The fact that this is an upper bound is great news for us. Why? Because at each of the leaves, we need to perform <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right: 0.03148em;\">k</span><span class=\"mclose\">)</span></span></span></span></span> work to create a copy of <code>curr</code> to add to the answer. The work we perform to copy all the combinations is equal to the upper bound on the number of nodes. Therefore, the work done for the traversal will inevitably be dominated, and the fact that we can't calculate the exact number of nodes in the tree is irrelevant.</p>\n</li>\n<li>\n<p>Space complexity: <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right: 0.03148em;\">k</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p>We don't count the answer as part of the space complexity. The extra space we use here is for <code>curr</code> and the recursion call stack. The depth of the call stack is equal to the length of <code>curr</code>, which is limited to <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.03148em;\">k</span></span></span></span></span>.</p>\n</li>\n</ul>\n<br>\n<hr></div><span style=\"font-size: 0px; line-height: 0;\">&nbsp;</span></div>",
    "isOfficial": true,
    "scrapedAt": "2026-02-18T07:23:15.313Z"
  }
}