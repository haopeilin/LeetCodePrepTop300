{
    "questionId": "144",
    "questionFrontendId": "144",
    "title": "Binary Tree Preorder Traversal",
    "titleSlug": "binary-tree-preorder-traversal",
    "content": "<p>Given the <code>root</code> of a binary tree, return <em>the preorder traversal of its nodes&#39; values</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">root = [1,null,2,3]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">[1,2,3]</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p><img alt=\"\" src=\"images/144/screenshot-2024-08-29-202743.png\" style=\"width: 200px; height: 264px;\" /></p>\n</div>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">root = [1,2,3,4,5,null,8,null,null,6,7,9]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">[1,2,4,5,6,7,3,8,9]</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p><img alt=\"\" src=\"images/144/tree_2.png\" style=\"width: 350px; height: 286px;\" /></p>\n</div>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">root = []</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">[]</span></p>\n</div>\n\n<p><strong class=\"example\">Example 4:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">root = [1]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">[1]</span></p>\n</div>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 100]</code>.</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Recursive solution is trivial, could you do it iteratively?</p>\n",
    "difficulty": "Easy",
    "stats": "{\"totalAccepted\": \"2.3M\", \"totalSubmission\": \"3.1M\", \"totalAcceptedRaw\": 2347530, \"totalSubmissionRaw\": 3125311, \"acRate\": \"75.1%\"}",
    "hints": [],
    "similarQuestions": "[{\"title\": \"Binary Tree Inorder Traversal\", \"titleSlug\": \"binary-tree-inorder-traversal\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Verify Preorder Sequence in Binary Search Tree\", \"titleSlug\": \"verify-preorder-sequence-in-binary-search-tree\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"N-ary Tree Preorder Traversal\", \"titleSlug\": \"n-ary-tree-preorder-traversal\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Kth Largest Sum in a Binary Tree\", \"titleSlug\": \"kth-largest-sum-in-a-binary-tree\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
    "topicTags": [
        {
            "name": "Stack",
            "slug": "stack"
        },
        {
            "name": "Tree",
            "slug": "tree"
        },
        {
            "name": "Depth-First Search",
            "slug": "depth-first-search"
        },
        {
            "name": "Binary Tree",
            "slug": "binary-tree"
        }
    ],
    "companyTags": null,
    "codeSnippets": [
        {
            "lang": "Java",
            "langSlug": "java",
            "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public List<Integer> preorderTraversal(TreeNode root) {\n        \n    }\n}"
        }
    ],
    "solution": {
        "content": "<h2><a href=\"#solution\"><svg><path></path></svg></a>Solution</h2>\n<hr/>\n<h4>How to traverse the tree</h4>\n<p>There are two general strategies to traverse a tree:</p>\n<ul>\n<li>\n<p><em>Breadth First Search</em> (<code>BFS</code>)</p>\n<p>We scan through the tree level by level, following the order of height, from top to bottom. The nodes on higher levels would be visited before the ones with lower levels.</p>\n</li>\n<li>\n<p><em>Depth First Search</em> (<code>DFS</code>)</p>\n<p>In this strategy, we adopt the <code>depth</code> as the priority, so that one would start from a root and reach all the way down to a certain leaf, and then back to the root to reach another branch.</p>\n<p>The DFS strategy can further be distinguished as <code>preorder</code>, <code>inorder</code>, and <code>postorder</code> depending on the relative order among the root node, left node, and right node.</p>\n</li>\n</ul>\n<p>In the following figure, the nodes are enumerated in the order you visit them, please follow <code>1-2-3-4-5</code> to compare different strategies.</p>\n<p></p>\n<p>Here the problem is to implement preorder traversal using iterations.<br/>\n<br/><br/>\n<br/></p>\n<hr/>\n<h4>Approach 1: Iterations</h4>\n<p><strong>Algorithm</strong></p>\n<p>First of all, here is the definition of the <code>TreeNode</code> which we would use in the following implementation.</p>\n<pre><code>/* Definition for a binary tree node. */\npublic class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n​\n    TreeNode(int x) {\n        val = x;\n    }\n}</code></pre>\n<p>Let's start from the root and then at each iteration pop the current node out of the stack and push its child nodes. In the implemented strategy we push nodes into the output list following the order <code>Top-&gt;Bottom</code> and <code>Left-&gt;Right</code>, which naturally reproduces preorder traversal.</p>\n<pre><code>class Solution {\npublic:\n    vector&lt;int&gt; preorderTraversal(TreeNode* root) {\n        if (root == nullptr) {\n            return vector&lt;int&gt;();\n        }\n​\n        vector&lt;TreeNode*&gt; stack = {root};\n        vector&lt;int&gt; output;\n​\n        while (!stack.empty()) {\n            root = stack.back();\n            stack.pop_back();\n            if (root != nullptr) {\n                output.push_back(root-&gt;val);\n                if (root-&gt;right != nullptr) {\n                    stack.push_back(root-&gt;right);\n                }\n                if (root-&gt;left != nullptr) {\n                    stack.push_back(root-&gt;left);\n                }\n            }\n        }\n​\n        return output;\n    }\n};</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity: we visit each node exactly once, thus the time complexity is O(N), where N is the number of nodes, <em>i.e.</em> the size of the tree.</p>\n</li>\n<li>\n<p>Space complexity: depending on the tree structure, we could keep up to the entire tree, therefore, the space complexity is O(N).</p>\n<br/>\n</li>\n</ul>\n<br/>\n<hr/>\n<h4>Approach 2: Morris traversal</h4>\n<p>This approach is based on <a href=\"https://www.sciencedirect.com/science/article/pii/0020019079900681\">Morris's article</a> which is intended to optimize the space complexity. The algorithm does not use additional space for the computation, and the memory is only used to keep the output. If one prints the output directly along the computation, the space complexity would be O(1).</p>\n<p><strong>Algorithm</strong></p>\n<p>Here the idea is to go down from the node to its predecessor, and each predecessor will be visited twice. For this go one step left if possible and then always right till the end. When we visit a leaf (node's predecessor) first time, it has a zero right child, so we update output and establish the pseudo link <code>predecessor.right = root</code> to mark the fact the predecessor is visited. When we visit the same predecessor the second time, it already points to the current node, thus we remove the pseudo link and move right to the next node.</p>\n<p>If the first step left is impossible, update the output and move right to the next node.</p>\n<p></p>\n<pre><code>class Solution {\npublic:\n    vector&lt;int&gt; preorderTraversal(TreeNode* root) {\n        vector&lt;int&gt; output;\n        TreeNode* node = root;\n        while (node != nullptr) {\n            if (node-&gt;left == nullptr) {\n                output.push_back(node-&gt;val);\n                node = node-&gt;right;\n            } else {\n                TreeNode* predecessor = node-&gt;left;\n                while (predecessor-&gt;right != nullptr &amp;&amp;\n                       predecessor-&gt;right != node) {\n                    predecessor = predecessor-&gt;right;\n                }\n                if (predecessor-&gt;right == nullptr) {\n                    output.push_back(node-&gt;val);\n                    predecessor-&gt;right = node;\n                    node = node-&gt;left;\n                } else {\n                    predecessor-&gt;right = nullptr;\n                    node = node-&gt;right;\n                }\n            }\n        }\n        return output;\n    }\n};</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity: we visit each predecessor exactly twice descending down from the node, thus the time complexity is O(N), where N is the number of nodes, <em>i.e.</em> the size of the tree.</p>\n</li>\n<li>\n<p>Space complexity: we use no additional memory for the computation itself, but the output list contains N elements, and thus space complexity is O(N).</p>\n</li>\n</ul>",
        "isOfficial": true,
        "scrapedAt": "2026-02-18T08:06:22.855Z"
    }
}