{
    "questionId": "143",
    "questionFrontendId": "143",
    "title": "Reorder List",
    "titleSlug": "reorder-list",
    "content": "<p>You are given the head of a singly linked-list. The list can be represented as:</p>\n\n<pre>\nL<sub>0</sub> &rarr; L<sub>1</sub> &rarr; &hellip; &rarr; L<sub>n - 1</sub> &rarr; L<sub>n</sub>\n</pre>\n\n<p><em>Reorder the list to be on the following form:</em></p>\n\n<pre>\nL<sub>0</sub> &rarr; L<sub>n</sub> &rarr; L<sub>1</sub> &rarr; L<sub>n - 1</sub> &rarr; L<sub>2</sub> &rarr; L<sub>n - 2</sub> &rarr; &hellip;\n</pre>\n\n<p>You may not modify the values in the list&#39;s nodes. Only nodes themselves may be changed.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"images/143/reorder1linked-list.jpg\" style=\"width: 422px; height: 222px;\" />\n<pre>\n<strong>Input:</strong> head = [1,2,3,4]\n<strong>Output:</strong> [1,4,2,3]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"images/143/reorder2-linked-list.jpg\" style=\"width: 542px; height: 222px;\" />\n<pre>\n<strong>Input:</strong> head = [1,2,3,4,5]\n<strong>Output:</strong> [1,5,2,4,3]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the list is in the range <code>[1, 5 * 10<sup>4</sup>]</code>.</li>\n\t<li><code>1 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n",
    "difficulty": "Medium",
    "stats": "{\"totalAccepted\": \"1.4M\", \"totalSubmission\": \"2.2M\", \"totalAcceptedRaw\": 1448215, \"totalSubmissionRaw\": 2244724, \"acRate\": \"64.5%\"}",
    "hints": [],
    "similarQuestions": "[{\"title\": \"Delete the Middle Node of a Linked List\", \"titleSlug\": \"delete-the-middle-node-of-a-linked-list\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Take K of Each Character From Left and Right\", \"titleSlug\": \"take-k-of-each-character-from-left-and-right\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
    "topicTags": [
        {
            "name": "Linked List",
            "slug": "linked-list"
        },
        {
            "name": "Two Pointers",
            "slug": "two-pointers"
        },
        {
            "name": "Stack",
            "slug": "stack"
        },
        {
            "name": "Recursion",
            "slug": "recursion"
        }
    ],
    "companyTags": null,
    "codeSnippets": [
        {
            "lang": "Java",
            "langSlug": "java",
            "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public void reorderList(ListNode head) {\n        \n    }\n}"
        }
    ],
    "solution": {
        "content": "<h2><a href=\"#solution\"><svg><path></path></svg></a>Solution</h2>\n<hr/>\n<h3><a href=\"#solution-bricks\"><svg><path></path></svg></a>Solution Bricks</h3>\n<p>This problem is a combination of these three easy problems:</p>\n<ul>\n<li>\n<p><a href=\"https://leetcode.com/problems/middle-of-the-linked-list\">Middle of the Linked List</a>.</p>\n</li>\n<li>\n<p><a href=\"https://leetcode.com/problems/reverse-linked-list\">Reverse Linked List</a>.</p>\n</li>\n<li>\n<p><a href=\"https://leetcode.com/problems/merge-two-sorted-lists\">Merge Two Sorted Lists</a>.</p>\n</li>\n</ul>\n<br/>\n<br/>\n<hr/>\n<h3><a href=\"#approach-1-reverse-the-second-part-of-the-list-and-merge-two-sorted-lists\"><svg><path></path></svg></a>Approach 1: Reverse the Second Part of the List and Merge Two Sorted Lists</h3>\n<p><strong>Overview</strong></p>\n<ul>\n<li>\n<p>Find a middle node of the linked list.<br/>\nIf there are two middle nodes, return the second middle node.<br/>\nExample: for the list <code>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6</code>, the middle element is <code>4</code>.</p>\n</li>\n<li>\n<p>Once a middle node has been found, reverse the second part of the list.<br/>\nExample: convert <code>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6</code> into <code>1-&gt;2-&gt;3-&gt;4</code> and <code>6-&gt;5-&gt;4</code>.</p>\n</li>\n<li>\n<p>Now merge the two sorted lists.<br/>\nExample: merge <code>1-&gt;2-&gt;3-&gt;4</code> and <code>6-&gt;5-&gt;4</code> into <code>1-&gt;6-&gt;2-&gt;5-&gt;3-&gt;4</code>.</p>\n</li>\n</ul>\n<p></p>\n<p>Now let's check each algorithm part in more detail.</p>\n<p><strong>Find a Middle Node</strong></p>\n<p>Let's use two pointers, <code>slow</code> and <code>fast</code>. While the slow pointer moves one step forward <code>slow = slow.next</code>, the fast pointer moves two steps forward <code>fast = fast.next.next</code>, <em>i.e.</em> <code>fast</code> traverses twice as fast as <code>slow</code>. When the fast pointer reaches the end of the list, the slow pointer should be in the middle.</p>\n<p></p>\n<pre><code>// find the middle of linked list [Problem 876]\n// in 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6 find 4 \nListNode slow = head;\nListNode fast = head;\nwhile (fast != null &amp;&amp; fast.next != null) {\n    slow = slow.next;\n    fast = fast.next.next;\n}</code></pre>\n<p><strong>Reverse the Second Part of the List</strong></p>\n<p>Let's traverse the list starting from the middle node <code>slow</code> and its virtual predecessor <code>null</code>. For each current node, save its neighbors: the previous node <code>prev</code> and the next node <code>tmp = curr.next</code>.</p>\n<p>While you're moving along the list, change the node's next pointer to point to the previous node: <code>curr.next = prev</code>, and shift the current node to the right for the next iteration: <code>prev = curr</code>, <code>curr = tmp</code>.</p>\n<p></p>\n<pre><code>// reverse the second part of the list [Problem 206]\n// convert 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6 into 1-&gt;2-&gt;3-&gt;4 and 6-&gt;5-&gt;4\n// reverse the second half in-place\nListNode prev = null;\nListNode curr = slow;\nListNode tmp;\nwhile (curr != null) {\n    tmp = curr.next;\n    curr.next = prev;\n    prev = curr;\n    curr = tmp;\n}</code></pre>\n<p>There is a more elegant way to do it in Java:</p>\n<pre><code>// reverse the second part of the list [Problem 206]\n// convert 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6 into 1-&gt;2-&gt;3-&gt;4 and 6-&gt;5-&gt;4\n// reverse the second half in-place\nListNode prev = null;\nListNode curr = slow;\nwhile (curr != null) {\n    ListNode next = curr.next;\n    curr.next = prev;\n    prev = curr;\n    curr = next;\n}</code></pre>\n<p><strong>Merge Two Sorted Lists</strong></p>\n<p>This algorithm is similar to the one for list reversal.</p>\n<p>Let's pick the first node of each list - first and second, and save their successors. While you're traversing the list, set the first node's next pointer to point to the second node, and the second node's next pointer to point to the successor of the first node. For this iteration, the job is done, and for the next iteration, move to the previously saved nodes' successors.</p>\n<p></p>\n<pre><code>// merge two sorted linked lists [Problem 21]\n// merge 1-&gt;2-&gt;3-&gt;4 and 6-&gt;5-&gt;4 into 1-&gt;6-&gt;2-&gt;5-&gt;3-&gt;4\nListNode first = head;\nListNode second = prev;\nwhile (second.next != null) {\n    tmp = first.next;\n    first.next = second;\n    first = tmp;\n\n    tmp = second.next;\n    second.next = first;\n    second = tmp;\n}</code></pre>\n<p>Once again, there is a way to make things simple in Java</p>\n<pre><code>// merge two sorted linked lists [Problem 21]\n// merge 1-&gt;2-&gt;3-&gt;4 and 6-&gt;5-&gt;4 into 1-&gt;6-&gt;2-&gt;5-&gt;3-&gt;4\nListNode first = head;\nListNode second = prev;\nwhile (second.next != null) {\n    ListNode nextFirst = first.next;\n    first.next = second;\n    first = nextFirst;\n\n    ListNode nextSecond = second.next;\n    second.next = first;\n    second = nextSecond;\n}</code></pre>\n<p><strong>Implementation</strong></p>\n<p>Now it's time to put all the pieces together.</p>\n<pre><code>class Solution {\n    public void reorderList(ListNode head) {\n        if (head == null) return;\n\n        // find the middle of linked list [Problem 876]\n        // in 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6 find 4\n        ListNode slow = head;\n        ListNode fast = head;\n        while (fast != null &amp;&amp; fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n\n        // reverse the second part of the list [Problem 206]\n        // convert 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6 into 1-&gt;2-&gt;3-&gt;4 and 6-&gt;5-&gt;4\n        // reverse the second half in-place\n        ListNode prev = null;\n        ListNode curr = slow;\n        while (curr != null) {\n            ListNode tmp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = tmp;\n        }\n\n        // merge two sorted linked lists [Problem 21]\n        // merge 1-&gt;2-&gt;3-&gt;4 and 6-&gt;5-&gt;4 into 1-&gt;6-&gt;2-&gt;5-&gt;3-&gt;4\n        ListNode first = head;\n        ListNode second = prev;\n        while (second.next != null) {\n            ListNode tmp = first.next;\n            first.next = second;\n            first = tmp;\n\n            tmp = second.next;\n            second.next = first;\n            second = tmp;\n        }\n    }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity: O(N). There are three steps here. To identify the middle node takes O(N) time. To reverse the second part of the list, one needs N/2 operations. The final step, to merge two lists, requires N/2 operations as well. In total, that results in O(N) time complexity.</p>\n</li>\n<li>\n<p>Space complexity: O(1), since we do not allocate any additional data structures.</p>\n</li>\n</ul>\n<br/>\n<br/>",
        "isOfficial": true,
        "scrapedAt": "2026-02-18T07:19:58.662Z"
    }
}