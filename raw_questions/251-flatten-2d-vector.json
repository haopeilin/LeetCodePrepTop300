{
    "questionId": "251",
    "questionFrontendId": "251",
    "title": "Flatten 2D Vector",
    "titleSlug": "flatten-2d-vector",
    "content": "<p>Design an iterator to flatten a 2D vector. It should support the <code>next</code> and <code>hasNext</code> operations.</p>\n\n<p>Implement the <code>Vector2D</code> class:</p>\n\n<ul>\n\t<li><code>Vector2D(int[][] vec)</code> initializes the object with the 2D vector <code>vec</code>.</li>\n\t<li><code>next()</code> returns the next element from the 2D vector and moves the pointer one step forward. You may assume that all the calls to <code>next</code> are valid.</li>\n\t<li><code>hasNext()</code> returns <code>true</code> if there are still some elements in the vector, and <code>false</code> otherwise.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;Vector2D&quot;, &quot;next&quot;, &quot;next&quot;, &quot;next&quot;, &quot;hasNext&quot;, &quot;hasNext&quot;, &quot;next&quot;, &quot;hasNext&quot;]\n[[[[1, 2], [3], [4]]], [], [], [], [], [], [], []]\n<strong>Output</strong>\n[null, 1, 2, 3, true, true, 4, false]\n\n<strong>Explanation</strong>\nVector2D vector2D = new Vector2D([[1, 2], [3], [4]]);\nvector2D.next();    // return 1\nvector2D.next();    // return 2\nvector2D.next();    // return 3\nvector2D.hasNext(); // return True\nvector2D.hasNext(); // return True\nvector2D.next();    // return 4\nvector2D.hasNext(); // return False\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= vec.length &lt;= 200</code></li>\n\t<li><code>0 &lt;= vec[i].length &lt;= 500</code></li>\n\t<li><code>-500 &lt;= vec[i][j] &lt;= 500</code></li>\n\t<li>At most <code>10<sup>5</sup></code> calls will be made to <code>next</code> and <code>hasNext</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> As an added challenge, try to code it using only <a href=\"http://www.cplusplus.com/reference/iterator/iterator/\" target=\"_blank\">iterators in C++</a> or <a href=\"http://docs.oracle.com/javase/7/docs/api/java/util/Iterator.html\" target=\"_blank\">iterators in Java</a>.</p>\n",
    "difficulty": "Medium",
    "stats": "{\"totalAccepted\": \"145K\", \"totalSubmission\": \"287.4K\", \"totalAcceptedRaw\": 144991, \"totalSubmissionRaw\": 287445, \"acRate\": \"50.4%\"}",
    "hints": [
        "How many variables do you need to keep track?",
        "Two variables is all you need. Try with <code>x</code> and <code>y</code>.",
        "Beware of empty rows. It could be the first few rows.",
        "To write correct code, think about the <a href=\"https://en.wikipedia.org/wiki/Invariant_(computer_science)\" target=\"_blank\">invariant</a> to maintain. What is it?",
        "The invariant is <code>x</code> and <code>y</code> must always point to a valid point in the 2d vector. Should you maintain your invariant <i>ahead of time</i> or <i>right when you need it</i>?",
        "Not sure? Think about how you would implement <code>hasNext()</code>. Which is more complex?",
        "Common logic in two different places should be refactored into a common method."
    ],
    "similarQuestions": "[{\"title\": \"Binary Search Tree Iterator\", \"titleSlug\": \"binary-search-tree-iterator\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Zigzag Iterator\", \"titleSlug\": \"zigzag-iterator\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Peeking Iterator\", \"titleSlug\": \"peeking-iterator\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Flatten Nested List Iterator\", \"titleSlug\": \"flatten-nested-list-iterator\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
    "topicTags": [
        {
            "name": "Array",
            "slug": "array"
        },
        {
            "name": "Two Pointers",
            "slug": "two-pointers"
        },
        {
            "name": "Design",
            "slug": "design"
        },
        {
            "name": "Iterator",
            "slug": "iterator"
        }
    ],
    "companyTags": null,
    "codeSnippets": [
        {
            "lang": "C++",
            "langSlug": "cpp",
            "code": "class Vector2D {\npublic:\n    Vector2D(vector<vector<int>>& vec) {\n        \n    }\n    \n    int next() {\n        \n    }\n    \n    bool hasNext() {\n        \n    }\n};\n\n/**\n * Your Vector2D object will be instantiated and called as such:\n * Vector2D* obj = new Vector2D(vec);\n * int param_1 = obj->next();\n * bool param_2 = obj->hasNext();\n */"
        },
        {
            "lang": "Java",
            "langSlug": "java",
            "code": "class Vector2D {\n\n    public Vector2D(int[][] vec) {\n        \n    }\n    \n    public int next() {\n        \n    }\n    \n    public boolean hasNext() {\n        \n    }\n}\n\n/**\n * Your Vector2D object will be instantiated and called as such:\n * Vector2D obj = new Vector2D(vec);\n * int param_1 = obj.next();\n * boolean param_2 = obj.hasNext();\n */"
        },
        {
            "lang": "Python3",
            "langSlug": "python3",
            "code": "class Vector2D:\n\n    def __init__(self, vec: List[List[int]]):\n        \n\n    def next(self) -> int:\n        \n\n    def hasNext(self) -> bool:\n        \n\n\n# Your Vector2D object will be instantiated and called as such:\n# obj = Vector2D(vec)\n# param_1 = obj.next()\n# param_2 = obj.hasNext()"
        },
        {
            "lang": "Python",
            "langSlug": "python",
            "code": "class Vector2D(object):\n\n    def __init__(self, vec):\n        \"\"\"\n        :type vec: List[List[int]]\n        \"\"\"\n        \n\n    def next(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        \n\n    def hasNext(self):\n        \"\"\"\n        :rtype: bool\n        \"\"\"\n        \n\n\n# Your Vector2D object will be instantiated and called as such:\n# obj = Vector2D(vec)\n# param_1 = obj.next()\n# param_2 = obj.hasNext()"
        },
        {
            "lang": "JavaScript",
            "langSlug": "javascript",
            "code": "/**\n * @param {number[][]} vec\n */\nvar Vector2D = function(vec) {\n    \n};\n\n/**\n * @return {number}\n */\nVector2D.prototype.next = function() {\n    \n};\n\n/**\n * @return {boolean}\n */\nVector2D.prototype.hasNext = function() {\n    \n};\n\n/** \n * Your Vector2D object will be instantiated and called as such:\n * var obj = new Vector2D(vec)\n * var param_1 = obj.next()\n * var param_2 = obj.hasNext()\n */"
        },
        {
            "lang": "TypeScript",
            "langSlug": "typescript",
            "code": "class Vector2D {\n    constructor(vec: number[][]) {\n        \n    }\n\n    next(): number {\n        \n    }\n\n    hasNext(): boolean {\n        \n    }\n}\n\n/**\n * Your Vector2D object will be instantiated and called as such:\n * var obj = new Vector2D(vec)\n * var param_1 = obj.next()\n * var param_2 = obj.hasNext()\n */"
        },
        {
            "lang": "C#",
            "langSlug": "csharp",
            "code": "public class Vector2D {\n\n    public Vector2D(int[][] vec) {\n        \n    }\n    \n    public int Next() {\n        \n    }\n    \n    public bool HasNext() {\n        \n    }\n}\n\n/**\n * Your Vector2D object will be instantiated and called as such:\n * Vector2D obj = new Vector2D(vec);\n * int param_1 = obj.Next();\n * bool param_2 = obj.HasNext();\n */"
        },
        {
            "lang": "C",
            "langSlug": "c",
            "code": "\n\n\ntypedef struct {\n    \n} Vector2D;\n\n\nVector2D* vector2DCreate(int** vec, int vecSize, int* vecColSize) {\n    \n}\n\nint vector2DNext(Vector2D* obj) {\n    \n}\n\nbool vector2DHasNext(Vector2D* obj) {\n    \n}\n\nvoid vector2DFree(Vector2D* obj) {\n    \n}\n\n/**\n * Your Vector2D struct will be instantiated and called as such:\n * Vector2D* obj = vector2DCreate(vec, vecSize, vecColSize);\n * int param_1 = vector2DNext(obj);\n \n * bool param_2 = vector2DHasNext(obj);\n \n * vector2DFree(obj);\n*/"
        },
        {
            "lang": "Go",
            "langSlug": "golang",
            "code": "type Vector2D struct {\n    \n}\n\n\nfunc Constructor(vec [][]int) Vector2D {\n    \n}\n\n\nfunc (this *Vector2D) Next() int {\n    \n}\n\n\nfunc (this *Vector2D) HasNext() bool {\n    \n}\n\n\n/**\n * Your Vector2D object will be instantiated and called as such:\n * obj := Constructor(vec);\n * param_1 := obj.Next();\n * param_2 := obj.HasNext();\n */"
        },
        {
            "lang": "Kotlin",
            "langSlug": "kotlin",
            "code": "class Vector2D(vec: Array<IntArray>) {\n\n    fun next(): Int {\n        \n    }\n\n    fun hasNext(): Boolean {\n        \n    }\n\n}\n\n/**\n * Your Vector2D object will be instantiated and called as such:\n * var obj = Vector2D(vec)\n * var param_1 = obj.next()\n * var param_2 = obj.hasNext()\n */"
        },
        {
            "lang": "Swift",
            "langSlug": "swift",
            "code": "\nclass Vector2D {\n\n    init(_ vec: [[Int]]) {\n        \n    }\n    \n    func next() -> Int {\n        \n    }\n    \n    func hasNext() -> Bool {\n        \n    }\n}\n\n/**\n * Your Vector2D object will be instantiated and called as such:\n * let obj = Vector2D(vec)\n * let ret_1: Int = obj.next()\n * let ret_2: Bool = obj.hasNext()\n */"
        },
        {
            "lang": "Rust",
            "langSlug": "rust",
            "code": "struct Vector2D {\n\n}\n\n\n/** \n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl Vector2D {\n\n    fn new(vec: Vec<Vec<i32>>) -> Self {\n        \n    }\n    \n    fn next(&self) -> i32 {\n        \n    }\n    \n    fn has_next(&self) -> bool {\n        \n    }\n}\n\n/**\n * Your Vector2D object will be instantiated and called as such:\n * let obj = Vector2D::new(vec);\n * let ret_1: i32 = obj.next();\n * let ret_2: bool = obj.has_next();\n */"
        },
        {
            "lang": "Ruby",
            "langSlug": "ruby",
            "code": "class Vector2D\n\n=begin\n    :type vec: Integer[][]\n=end\n    def initialize(vec)\n        \n    end\n\n\n=begin\n    :rtype: Integer\n=end\n    def next()\n        \n    end\n\n\n=begin\n    :rtype: Boolean\n=end\n    def has_next()\n        \n    end\n\n\nend\n\n# Your Vector2D object will be instantiated and called as such:\n# obj = Vector2D.new(vec)\n# param_1 = obj.next()\n# param_2 = obj.has_next()"
        },
        {
            "lang": "PHP",
            "langSlug": "php",
            "code": "class Vector2D {\n    /**\n     * @param Integer[][] $vec\n     */\n    function __construct($vec) {\n        \n    }\n  \n    /**\n     * @return Integer\n     */\n    function next() {\n        \n    }\n  \n    /**\n     * @return Boolean\n     */\n    function hasNext() {\n        \n    }\n}\n\n/**\n * Your Vector2D object will be instantiated and called as such:\n * $obj = Vector2D($vec);\n * $ret_1 = $obj->next();\n * $ret_2 = $obj->hasNext();\n */"
        },
        {
            "lang": "Dart",
            "langSlug": "dart",
            "code": "class Vector2D {\n\n  Vector2D(List<List<int>> vec) {\n    \n  }\n  \n  int next() {\n    \n  }\n  \n  bool hasNext() {\n    \n  }\n}\n\n/**\n * Your Vector2D object will be instantiated and called as such:\n * Vector2D obj = Vector2D(vec);\n * int param1 = obj.next();\n * bool param2 = obj.hasNext();\n */"
        },
        {
            "lang": "Scala",
            "langSlug": "scala",
            "code": "class Vector2D(_vec: Array[Array[Int]]) {\n\n    def next(): Int = {\n        \n    }\n\n    def hasNext(): Boolean = {\n        \n    }\n\n}\n\n/**\n * Your Vector2D object will be instantiated and called as such:\n * val obj = new Vector2D(vec)\n * val param_1 = obj.next()\n * val param_2 = obj.hasNext()\n */"
        },
        {
            "lang": "Elixir",
            "langSlug": "elixir",
            "code": "defmodule Vector2D do\n  @spec init_(vec :: [[integer]]) :: any\n  def init_(vec) do\n    \n  end\n\n  @spec next() :: integer\n  def next() do\n    \n  end\n\n  @spec has_next() :: boolean\n  def has_next() do\n    \n  end\nend\n\n# Your functions will be called as such:\n# Vector2D.init_(vec)\n# param_1 = Vector2D.next()\n# param_2 = Vector2D.has_next()\n\n# Vector2D.init_ will be called before every test case, in which you can do some necessary initializations."
        },
        {
            "lang": "Erlang",
            "langSlug": "erlang",
            "code": "-spec vector2_d_init_(Vec :: [[integer()]]) -> any().\nvector2_d_init_(Vec) ->\n  .\n\n-spec vector2_d_next() -> integer().\nvector2_d_next() ->\n  .\n\n-spec vector2_d_has_next() -> boolean().\nvector2_d_has_next() ->\n  .\n\n\n%% Your functions will be called as such:\n%% vector2_d_init_(Vec),\n%% Param_1 = vector2_d_next(),\n%% Param_2 = vector2_d_has_next(),\n\n%% vector2_d_init_ will be called before every test case, in which you can do some necessary initializations."
        },
        {
            "lang": "Racket",
            "langSlug": "racket",
            "code": "(define vector2-d%\n  (class object%\n    (super-new)\n    \n    ; vec : (listof (listof exact-integer?))\n    (init-field\n      vec)\n    \n    ; next : -> exact-integer?\n    (define/public (next)\n      )\n    ; has-next : -> boolean?\n    (define/public (has-next)\n      )))\n\n;; Your vector2-d% object will be instantiated and called as such:\n;; (define obj (new vector2-d% [vec vec]))\n;; (define param_1 (send obj next))\n;; (define param_2 (send obj has-next))"
        }
    ],
    "solution": {
        "content": "<h2><a href=\"#solution\"><svg><path></path></svg></a>Solution</h2>\n<hr/>\n<h3><a href=\"#overview\"><svg><path></path></svg></a>Overview</h3>\n<p>This question should be fairly straightforward if you're familiar with what an Iterator is. If you aren't at all familiar with Iterators though, then we suggest having a go at <a href=\"https://leetcode.com/problems/peeking-iterator/\">Peeking Iterator</a>. Additionally, the <a href=\"https://leetcode.com/problems/peeking-iterator/solution/\">Solution Article for Peeking Iterator</a> has a special introduction section that introduces you to what Iterators are.</p>\n<p>Note that this question refers to something called a <code>Vector</code>. A <code>Vector</code> is simply another name for <code>Array</code>. To be consistent with the question, we've chosen to use the term <code>Vector</code>, rather than <code>Array</code> for this article (Sorry in advance for any confusion this causes, C++ programmers).</p>\n<br/>\n<hr/>\n<h3><a href=\"#approach-1-flatten-list-in-constructor\"><svg><path></path></svg></a>Approach 1: Flatten List in Constructor</h3>\n<p><strong>Intuition</strong></p>\n<p><em><strong>This approach is a bad approach!</strong> We've included it though, to show what it looks like, and to discuss why it's bad. This will help you to design <strong>good</strong> Iterators.</em></p>\n<p>In the constructor, we can iterate over the 2D input vector, putting each integer into a <code>List</code>. Then, the problem simplifies to being a simple <code>List</code> Iterator. Note that the reason we use a <code>List</code> rather than an array (vector) is because we don't know in advance how many integers there might be in total.</p>\n<p>Our unpack algorithm would be as follows.</p>\n<pre><code>nums = a new List\nfor each innerVector in the input 2D Vector:\n    for each number in innerVector:\n        append number to the end of nums</code></pre><svg><path></path></svg>\n<p>We'll then need to save this <code>List</code> as a field of our Iterator class, seeing as the <code>next(...)</code> and <code>hasNext(...)</code> methods will need to access it repeatedly. By then also having a position field, we can keep track of where the Iterator is up to.</p>\n<p><strong>Algorithm</strong></p>\n<p>The code shown here makes the <code>position</code> field point at the <em>next element that needs to be returned by <code>next</code></em>. Therefore, the <code>hasNext()</code> method simply needs to check that <code>position</code> is a valid index of <code>nums</code>. A similar variant would be to make <code>position</code> point at the <em>previous</em> value that was returned. This would simplify the <code>next()</code> method, but complicate the <code>hasNext()</code> method.</p>\n<pre><code>import java.util.NoSuchElementException;\n​\nclass Vector2D {\n​\n    // Constructor will put all the nums into this list.\n    private List&lt;Integer&gt; nums = new ArrayList&lt;&gt;();\n    // Keep track of where the Iterator is up to.\n    private int position = 0;\n​\n    public Vector2D(int[][] v) {\n        // We need to iterate over the 2D vector, getting all the integers\n        // out of it and putting them into nums (a field).\n        for (int[] innerVector : v) {\n            for (int num : innerVector) {\n                nums.add(num);\n            }\n        }\n    }\n​\n    public int next() {\n        // In Java, we throw a NoSuchElementException when next() is called\n        // on an exhausted Iterator.\n        if (!hasNext()) throw new NoSuchElementException();\n        // Store the number we need to return, as we still need to move position forward.\n        int result = nums.get(position);\n        // Move the position pointer forward by 1, so that it's ready for\n        // the next call to next, and gives a correct hasNext result.\n        position++;\n        return result;\n    }\n​\n    public boolean hasNext() {\n        // There's nums left as long as position is a valid index of the list.\n        return position &lt; nums.size();\n    }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<p>Let N be the number of integers within the 2D Vector, and V be the number of inner vectors.</p>\n<ul>\n<li>\n<p>Time complexity.</p>\n<ul>\n<li>\n<p><strong>Constructor:</strong> O(N+V).</p>\n<p>In total, we'll append N integers to the <code>nums</code> list. Each of these appends is an O(1) operation. This gives us O(N).</p>\n<p>Something to be cautious of is that inner vectors don't <em>have</em> to contain integers. Think of a test cases such as <code>[[], [2], [], [], []]</code>. For this test case, N=1, because there's only one integer within it. <em>However</em>, the algorithm has to loop through all of the empty vectors. The cost of checking all the vectors is O(V).</p>\n<p>Therefore, we get a final time complexity of O(N+V).</p>\n</li>\n<li>\n<p><strong>next():</strong> O(1).</p>\n<p>All operations in this method, including getting the integer at a specific index of a list, are O(1).</p>\n</li>\n<li>\n<p><strong>hasNext():</strong> O(1).</p>\n<p>All operations in this method are O(1).</p>\n</li>\n</ul>\n</li>\n<li>\n<p>Space complexity : O(N).</p>\n<p>We're making a new list that contains all of the integers from the 2D Vector. Notice that this is different from the time complexity; in the example of <code>[[], [2], [], [], []]</code>, we only store the <code>2</code>. All information about how many inner vectors there were is discarded.</p>\n</li>\n</ul>\n<p><strong>Why is this implementation bad?</strong></p>\n<p>This code works, it runs fast here on Leetcode, it seems pretty straightforward to implement.</p>\n<p>However, one of the main purposes of an Iterator is to <em>minimize</em> the use of auxiliary space. We should try to utilize the existing data structure as much as possible, only adding as much extra space as needed to keep track of the next value. In some situations, the data structure we want to iterate over is too large to even fit in memory anyway (think of file systems).</p>\n<p>In the case of our above implementation, we might as well have just had a single function <code>List&lt;Integer&gt; getFlattenedVector(int[][] v)</code>, which would return a <code>List</code> of integers, that could then be iterated over using the <code>List</code> types own standard Iterator.</p>\n<p>As a general rule, you should be very cautious of implementing Iterators with a high time complexity in the constructor, with a very low time complexity in the <code>next()</code> and <code>hasNext()</code> methods. If the code using the Iterator only wanted to access the first couple of elements in the iterated collection, then a lot of time (and probably space) has been wasted!</p>\n<p>As a side note, modifying the input collection in any way is <em>bad</em> design too. Iterators are only allowed to look at, not change, the collection they've been asked to iterate over.</p>\n<br/>\n<hr/>\n<h3><a href=\"#approach-2-two-pointers\"><svg><path></path></svg></a>Approach 2: Two Pointers</h3>\n<p><strong>Intuition</strong></p>\n<p>Like we said above, Approach 1 is bad because it creates a new data structure instead of simply iterating over the given one. Instead, we should find a way to step through the integers one-by-one, keeping track of where we currently are in the 2D vector. The location of each number is represented with 2 indexes; the index of the inner vector, and the index of the integer within its inner vector. Here's an example 2D vector, with the indexes marked on it.</p>\n<p></p>\n<p>Suppose we are at the following position:</p>\n<p></p>\n<p>How do we find the next position? Well the current integer has another integer after it, within the same inner vector. Therefore, we can just increment <code>inner</code> index by <code>1</code>. This gives the next position as shown below.</p>\n<p></p>\n<p>Now <code>inner</code> is at the end of the current inner vector. In order to get to the next integer we'll need to increment <code>outer</code> by <code>1</code>, and set <code>inner</code> to <code>0</code> (as <code>0</code> is first index of the new vector).</p>\n<p></p>\n<p>This time, it's a bit trickier, because we need to skip over empty vectors. To do that we repeatedly increment <code>outer</code> until we find an inner vector that is not empty (programmatically, this would be an <code>outer</code> where <code>inner = 0</code> is valid). Once we find one, we stop and set <code>inner</code> to <code>0</code> (the first integer of the inner vector).</p>\n<p></p>\n<p>Note that when <code>outer</code> becomes equal to the length of the 2D vector, this means there are no more inner vectors and so there are no more numbers left.</p>\n<p><strong>Algorithm</strong></p>\n<p>In Approach 1, we used O(N) auxiliary space and O(N+V) time in the constructor. In this approach though, we perform the necessary work incrementally during calls to <code>hasNext()</code> and <code>next()</code>. This means that if the caller stops using the iterator before it's exhausted, we won't have done any unnecessary work.</p>\n<p>We'll define an <code>advanceToNext()</code> helper method that checks if the current <code>inner</code> and <code>outer</code> values point to an integer, and if they don't, then it moves them forward until they point to an integer (in the way described above). If <code>outer == vector.length</code> becomes true, then the method terminates (because there's no integers left).</p>\n<p>In order to ensure no unnecessary work is done, the <em>constructor</em> doesn't check whether or not <code>vector[0][0]</code> points to an integer. This is because there might be an arbitrary number of empty inner vectors at the start of the input vector; potentially costing up to O(V) operations to skip past.</p>\n<p>Both <code>hasNext()</code> and <code>next()</code> start by calling <code>advanceToNext()</code> to ensure that <code>inner</code> and <code>outer</code> point to an integer, <strong>or</strong> that <code>outer</code> is at its \"stop\" value of <code>outer = vector.length</code>.</p>\n<p><code>next()</code> returns the integer at <code>vector[inner][outer]</code>, and then increments <code>inner</code> by <code>1</code>, so that the next call to <code>advanceToNext()</code> will start searching from after the integer we've just returned.</p>\n<p>It is important to note that calling the <code>hasNext()</code> method will only cause the pointers to move if they don't point to an integer. Once they point to an integer, repeated calls to <code>hasNext()</code> will not move them further. Only <code>next()</code> is able to move them <em>off</em> a valid integer. This design ensures that the client code calling <code>hasNext()</code> multiple times will not have unusual side effects.</p>\n<pre><code>import java.util.NoSuchElementException;\n​\nclass Vector2D {\n​\n    private int[][] vector;\n    private int inner = 0;\n    private int outer = 0;\n​\n    public Vector2D(int[][] v) {\n        // We need to store a *reference* to the input vector.\n        vector = v;\n    }\n​\n    // If the current outer and inner point to an integer, this method does nothing.\n    // Otherwise, inner and outer are advanced until they point to an integer.\n    // If there are no more integers, then outer will be equal to vector.length\n    // when this method terminates.\n    private void advanceToNext() {\n        // While outer is still within the vector, but inner is over the\n        // end of the inner list pointed to by outer, we want to move\n        // forward to the start of the next inner vector.\n        while (outer &lt; vector.length &amp;&amp; inner == vector[outer].length) {\n            inner = 0;\n            outer++;\n        }\n    }\n​\n    public int next() {\n        // As per Java specs, throw an exception if there's no next.\n        // This will also ensure the pointers point to an integer otherwise.\n        if (!hasNext()) throw new NoSuchElementException();\n        // Return current element and move inner so that is after the current\n        // element.\n        return vector[outer][inner++];\n    }\n​\n    public boolean hasNext() {\n        // Ensure the position pointers are moved such they point to an integer,\n        // or put outer = vector.length.\n        advanceToNext();\n        // If outer = vector.length then there are no integers left, otherwise\n        // we've stopped at an integer and so there's an integer left.\n        return outer &lt; vector.length;\n    }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<p>Let N be the number of integers within the 2D Vector, and V be the number of inner vectors.</p>\n<ul>\n<li>\n<p>Time complexity.</p>\n<ul>\n<li>\n<p><strong>Constructor:</strong> O(1).</p>\n<p>We're only storing a reference to the input vector—an O(1) operation.</p>\n</li>\n<li>\n<p><strong>advanceToNext():</strong> O(NV​).</p>\n<p>If the iterator is completely exhausted, then all calls to <code>advanceToNext()</code> will have performed O(N+V) total operations. (Like in Approach 1, the V comes from the fact that we go through all V inner vectors, and the N comes from the fact we perform one increment for each integer).</p>\n<p>However, because we perform N <code>advanceToNext()</code> operations in order to exhaust the iterator, the amortized cost of this operation is just NO(N+V)​=O(NN​+NV​)=O(NV​).</p>\n</li>\n<li>\n<p><strong>next() / hasNext():</strong> O(NV​) or O(1).</p>\n<p>The cost of both these methods depends on how they are called. If we just got a value from <code>next()</code>, then the next call to either method will involve calling <code>advanceToNext()</code>. In this case the time complexity is O(NV​).</p>\n<p>However if we call <code>hasNext()</code>, then all successive calls to <code>hasNext()</code>, or the next call to <code>next()</code>, will be O(1). This is because <code>advanceToNext()</code> will only perform an O(1) check and immediately return.</p>\n</li>\n</ul>\n</li>\n<li>\n<p>Space complexity : O(1).</p>\n<p>We only use a fixed set of O(1) fields (remember <code>vector</code> is a reference, not a copy!). So the space complexity is O(1).</p>\n</li>\n</ul>\n<br/>",
        "isOfficial": true,
        "scrapedAt": "2026-02-18T10:04:10.901Z"
    }
}