{
    "questionId": "284",
    "questionFrontendId": "284",
    "title": "Peeking Iterator",
    "titleSlug": "peeking-iterator",
    "content": "<p>Design an iterator that supports the <code>peek</code> operation on an existing iterator in addition to the <code>hasNext</code> and the <code>next</code> operations.</p>\n\n<p>Implement the <code>PeekingIterator</code> class:</p>\n\n<ul>\n\t<li><code>PeekingIterator(Iterator&lt;int&gt; nums)</code> Initializes the object with the given integer iterator <code>iterator</code>.</li>\n\t<li><code>int next()</code> Returns the next element in the array and moves the pointer to the next element.</li>\n\t<li><code>boolean hasNext()</code> Returns <code>true</code> if there are still elements in the array.</li>\n\t<li><code>int peek()</code> Returns the next element in the array <strong>without</strong> moving the pointer.</li>\n</ul>\n\n<p><strong>Note:</strong> Each language may have a different implementation of the constructor and <code>Iterator</code>, but they all support the <code>int next()</code> and <code>boolean hasNext()</code> functions.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;PeekingIterator&quot;, &quot;next&quot;, &quot;peek&quot;, &quot;next&quot;, &quot;next&quot;, &quot;hasNext&quot;]\n[[[1, 2, 3]], [], [], [], [], []]\n<strong>Output</strong>\n[null, 1, 2, 2, 3, false]\n\n<strong>Explanation</strong>\nPeekingIterator peekingIterator = new PeekingIterator([1, 2, 3]); // [<u><strong>1</strong></u>,2,3]\npeekingIterator.next();    // return 1, the pointer moves to the next element [1,<u><strong>2</strong></u>,3].\npeekingIterator.peek();    // return 2, the pointer does not move [1,<u><strong>2</strong></u>,3].\npeekingIterator.next();    // return 2, the pointer moves to the next element [1,2,<u><strong>3</strong></u>]\npeekingIterator.next();    // return 3, the pointer moves to the next element [1,2,3]\npeekingIterator.hasNext(); // return False\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li>All the calls to <code>next</code> and <code>peek</code> are valid.</li>\n\t<li>At most <code>1000</code> calls will be made to <code>next</code>, <code>hasNext</code>, and <code>peek</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> How would you extend your design to be generic and work with all types, not just integer?",
    "difficulty": "Medium",
    "stats": "{\"totalAccepted\": \"252.7K\", \"totalSubmission\": \"413K\", \"totalAcceptedRaw\": 252716, \"totalSubmissionRaw\": 412957, \"acRate\": \"61.2%\"}",
    "hints": [
        "Think of \"looking ahead\". You want to cache the next element.",
        "Is one variable sufficient? Why or why not?",
        "Test your design with call order of <code>peek()</code> before <code>next()</code> vs <code>next()</code> before <code>peek()</code>.",
        "For a clean implementation, check out <a href=\"https://github.com/google/guava/blob/703ef758b8621cfbab16814f01ddcc5324bdea33/guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/Iterators.java#L1125\" target=\"_blank\">Google's guava library source code</a>."
    ],
    "similarQuestions": "[{\"title\": \"Binary Search Tree Iterator\", \"titleSlug\": \"binary-search-tree-iterator\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Flatten 2D Vector\", \"titleSlug\": \"flatten-2d-vector\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Zigzag Iterator\", \"titleSlug\": \"zigzag-iterator\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
    "topicTags": [
        {
            "name": "Array",
            "slug": "array"
        },
        {
            "name": "Design",
            "slug": "design"
        },
        {
            "name": "Iterator",
            "slug": "iterator"
        }
    ],
    "companyTags": null,
    "codeSnippets": [
        {
            "lang": "Java",
            "langSlug": "java",
            "code": "// Java Iterator interface reference:\n// https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html\n\nclass PeekingIterator implements Iterator<Integer> {\n\tpublic PeekingIterator(Iterator<Integer> iterator) {\n\t    // initialize any member here.\n\t    \n\t}\n\t\n    // Returns the next element in the iteration without advancing the iterator.\n\tpublic Integer peek() {\n        \n\t}\n\t\n\t// hasNext() and next() should behave the same as in the Iterator interface.\n\t// Override them if needed.\n\t@Override\n\tpublic Integer next() {\n\t    \n\t}\n\t\n\t@Override\n\tpublic boolean hasNext() {\n\t    \n\t}\n}"
        }
    ],
    "solution": {
        "content": "<h2><a href=\"#solution\"><svg><path></path></svg></a>Solution</h2>\n<hr/>\n<h3><a href=\"#overview---what-is-an-iterator\"><svg><path></path></svg></a>Overview - What is an Iterator?</h3>\n<p><em>Feel free to skip this section if you're already familiar with this material. We have included it, as this is a beginners question on iterators.</em></p>\n<p>If you've heard of <code>Iterator</code>s, you might assume they're simply a way of iterating over indexed or finite data structures. You've probably used them in loops, e.g. <code>for item in items:</code> in Python or <code>for (int num : nums)</code> in Java.</p>\n<p>This may make it seem strange that we would need a <code>.peek()</code> on an <code>Iterator</code>. After all, couldn't we just convert our data structure into an array and use indexing to peek?</p>\n<p>But actually <code>Iterator</code>s have some interesting properties that make them widely useful for not only indexed collections (e.g. Array) and other finite data structures (e.g. <code>LinkedList</code> or <code>HashMap</code> keys), but also for (possibly-infinite) generated data. We'll look at an example of that soon.</p>\n<p>The first property of an <code>Iterator</code> that we'll looked at is that it only needs to know how to get the next item. It doesn't need to store the entire data in memory if we don't need the entire data structure. For massive data structures, this is invaluable!</p>\n<p>For example consider a linked list <code>Iterator</code>. We'll use Python as it's nice and compact. The same ideas apply to Java and C++:</p>\n<pre><code>class LinkedListIterator:\n    def __init__(self, head):\n        self._node = head\n\n    def hasNext(self):\n        return self._node is not None\n\n    def next(self):\n        result = self._node.value\n        self._node = self._node.next\n        return result</code></pre><svg><path></path></svg>\n<p>Notice how we store the head at the start, but as items are consumed, we discard the current one and replace it with the item in the node after?</p>\n<p>This means that if we're simply iterating a Linked List, and don't ever need to go back to the head, then we only need to keep one value around at a time.</p>\n<p>Another really interesting property of <code>Iterator</code>s is that they can represent sequences without even using a data structure!</p>\n<p>For example consider a range <code>Iterator</code>:</p>\n<pre><code>class RangeIterator:\n    def __init__(self, min, max):\n        self._max = max\n        self._current = min\n\n    def hasNext(self):\n        return self._current &lt; self._max\n\n    def next(self):\n        self._current += 1\n        return self._current - 1</code></pre><svg><path></path></svg>\n<p>If we simply converted this to an Array, we'd need to allocate a large chunk of memory if <code>min</code> and <code>max</code> are far apart. For the most part, this would probably be wasted space.</p>\n<p>However, by using an <code>Iterator</code>, we can use features like <code>for i in range(40, 20000000)</code> while still retaining the O(1) space of classic <code>for (int i = min; i &lt; max; i++)</code> style loops seen in other languages.</p>\n<p>Our final property is one that we couldn't even do by copying values into an Array\u2014handling an infinite sequence. For example consider an <code>Iterator</code> of squares:</p>\n<pre><code>class SquaresIterator:\n    def __init__(self):\n        self._n = 0\n\n    def hasNext(self):\n        # It continues forever,\n        # so definitely has a next!\n        return True\n\n    def next(self):\n        result = self._n\n        self._current += 1\n        return result ** 2</code></pre><svg><path></path></svg>\n<p>Notice that because <code>.hasNext()</code> always returns <code>True</code>, this <code>Iterator</code> will never run out of items. And this is to be expected, there's always another square after the previous, so our <code>Iterator</code> can give as many as we ask from it.</p>\n<p>Now that we've looked at why <code>Iterator</code>s are awesome, let's consider what they are at a base level.</p>\n<p>An <code>Iterator</code> only provides two methods:</p>\n<ul>\n<li>\n<p><code>.next()</code><br/>\nThis returns the next item in the sequence. You can't assume that this item actually \"exists\" yet, it might be created when you call <code>.next()</code>, or it might already exist in a data structure that you have an <code>Iterator</code> over.</p>\n<p>Once <code>.next()</code> is called, it will update the state of the <code>Iterator</code>. This means once you've got a value from <code>.next()</code> you won't be able to get the same value again. Therefore, if you don't store or process the value you got from the <code>Iterator</code> then it's possibly gone forever!</p>\n</li>\n<li>\n<p><code>.hasNext()</code><br/>\nThis returns whether or not another item is available. For example, an array <code>Iterator</code> should return <code>False</code> if we're at the end of the array. But for an <code>Iterator</code> that can produce items indefinitely, such as our square generator above, it might never return <code>False</code>.</p>\n</li>\n</ul>\n<p>A further property of <code>Iterator</code>s is that they provide a clean interface for the code using them. Without <code>Iterator</code>s, Linked List's, for example, tend to be particularly messy, as the code for traversing them gets muddled within the application code. With an <code>Iterator</code>, the external code doesn't even know how the underlying data structure works. For all it knows, the data could be coming from a Linked List, an Array, a Tree, a State Machine, a clever number generator, a file reader, a robot sensor, etc.</p>\n<p>Not having to deal with nodes, state, indexes, etc leads to clean code. We call this the <em>Iterator Pattern</em>, and it is one of the most important design patterns for a software engineer to know.</p>\n<p>As shown above, with only two methods, we get a lot of benefit (e.g. infinite sequences) and increased performance (e.g. not expanding sequences like range into arrays). We also get a nice way of separating the underlying data structure from the code that uses it.</p>\n<br/>\n<hr/>\n<h3><a href=\"#approach-1-saving-peeked-value\"><svg><path></path></svg></a>Approach 1: Saving Peeked Value</h3>\n<p><strong>Intuition</strong></p>\n<p>Each time we call <code>.next(...)</code>, a value is returned from the <code>Iterator</code>. If we call <code>.next(...)</code> again, a new value will be returned. This means that if we want to use a particular value multiple times, we had better save it.</p>\n<p>Our <code>.peek(...)</code> method needs to call <code>.next(...)</code> on the <code>Iterator</code>. But because <code>.next(...)</code> will return a different value next time, we need to store the value we peeked so when <code>.next(...)</code> is called we return the correct value.</p>\n<p><strong>Algorithm</strong></p>\n<pre><code>\u200b\nimport java.util.NoSuchElementException;\n\u200b\nclass PeekingIterator implements Iterator&lt;Integer&gt; {\n\u200b\n \u00a0 \u00a0private Iterator&lt;Integer&gt; iter;\n \u00a0 \u00a0private Integer peekedValue = null;\n\u200b\n \u00a0 \u00a0public PeekingIterator(Iterator&lt;Integer&gt; iterator) {\n \u00a0 \u00a0 \u00a0 \u00a0iter = iterator;\n \u00a0  }\n\u200b\n \u00a0 \u00a0public Integer peek() {\n \u00a0 \u00a0 \u00a0 \u00a0/* If there's not already a peeked value, get one out and store\n \u00a0 \u00a0 \u00a0 \u00a0 * it in the peekedValue variable. We aren't told what to do if\n \u00a0 \u00a0 \u00a0 \u00a0 * the iterator is actually empty -- here I have thrown an exception\n \u00a0 \u00a0 \u00a0 \u00a0 * but in an interview you should definitely ask! This is the kind of\n \u00a0 \u00a0 \u00a0 \u00a0 * thing they expect you to ask about. */\n \u00a0 \u00a0 \u00a0 \u00a0if (peekedValue == null) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0if (!iter.hasNext()) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0throw new NoSuchElementException();\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  }\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0peekedValue = iter.next();\n \u00a0 \u00a0 \u00a0  }\n \u00a0 \u00a0 \u00a0 \u00a0return peekedValue;\n \u00a0  }\n\u200b\n \u00a0 \u00a0@Override\n \u00a0 \u00a0public Integer next() {\n \u00a0 \u00a0 \u00a0 \u00a0/* Firstly, we need to check if we have a value already\n \u00a0 \u00a0 \u00a0 \u00a0 * stored in the peekedValue variable. If we do, we need to\n \u00a0 \u00a0 \u00a0 \u00a0 * return it and also set peekedValue to null so that the value\n \u00a0 \u00a0 \u00a0 \u00a0 * isn't returned again. */\n \u00a0 \u00a0 \u00a0 \u00a0if (peekedValue != null) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0Integer toReturn = peekedValue;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0peekedValue = null;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0return toReturn;\n \u00a0 \u00a0 \u00a0  }\n \u00a0 \u00a0 \u00a0 \u00a0/* As per the Java Iterator specs, we should throw a NoSuchElementException\n \u00a0 \u00a0 \u00a0 \u00a0 * if the next element doesn't exist. */\n \u00a0 \u00a0 \u00a0 \u00a0if (!iter.hasNext()) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0throw new NoSuchElementException();\n \u00a0 \u00a0 \u00a0  }\n \u00a0 \u00a0 \u00a0 \u00a0/* Otherwise, we need to return a new value. */\n \u00a0 \u00a0 \u00a0 \u00a0return iter.next();\n \u00a0  }\n\u200b\n \u00a0 \u00a0@Override\n \u00a0 \u00a0public boolean hasNext() {\n \u00a0 \u00a0 \u00a0 \u00a0/* If there's a value waiting in peekedValue, or if there are values\n \u00a0 \u00a0 \u00a0 \u00a0 * remaining in the iterator, we should return true. */\n \u00a0 \u00a0 \u00a0 \u00a0return peekedValue != null || iter.hasNext();\n \u00a0  }\n}\n\u200b</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity : All methods: O(1).</p>\n<p>The operation performed to update our peeked value are all O(1).</p>\n<p>The actual operations from <code>.next()</code> are impossible for us to analyse, as they depend on the given <code>Iterator</code>. By design, they are none of our concern. Our addition to the time is only O(1) though.</p>\n</li>\n<li>\n<p>Space Complexity : All methods: O(1).</p>\n<p>Like with time complexity, the <code>Iterator</code> itself is probably using memory in its own implementation. But again, this is not our concern. Our implementation only uses a few variables, so is O(1).</p>\n</li>\n</ul>\n<br/>\n<hr/>\n<h3><a href=\"#approach-2-saving-the-next-value\"><svg><path></path></svg></a>Approach 2: Saving the Next Value</h3>\n<p><strong>Intuition</strong></p>\n<p>Instead of only storing the next value after we've peeked at it, we can store it immediately in the constructor and then again in the <code>next(...)</code> method. This greatly simplifies the code, because we no longer need conditionals to check whether or not we are currently storing a peeked at value.</p>\n<p><strong>Algorithm</strong></p>\n<p>Note that in the Java code, we need to be careful not to cause an exception to be thrown from the <em>constructor</em>, in the case that the <code>Iterator</code> was empty at the start. We can do this by checking it has a next, and if it doesn't, then we set the next variable to <code>null</code>.</p>\n<pre><code>\u200b\nimport java.util.NoSuchElementException;\n\u200b\nclass PeekingIterator implements Iterator&lt;Integer&gt; {\n\u200b\n \u00a0 \u00a0private Iterator&lt;Integer&gt; iter;\n \u00a0 \u00a0private Integer next = null;\n\u200b\n \u00a0 \u00a0public PeekingIterator(Iterator&lt;Integer&gt; iterator) {\n \u00a0 \u00a0 \u00a0 \u00a0// Avoid an exception being thrown in the constructor.\n \u00a0 \u00a0 \u00a0 \u00a0if (iterator.hasNext()) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0next = iterator.next();\n \u00a0 \u00a0 \u00a0  }\n \u00a0 \u00a0 \u00a0 \u00a0iter = iterator;\n \u00a0  }\n\u200b\n \u00a0 \u00a0public Integer peek() {\n \u00a0 \u00a0 \u00a0 \u00a0return next;\n \u00a0  }\n\u200b\n \u00a0 \u00a0@Override\n \u00a0 \u00a0public Integer next() {\n \u00a0 \u00a0 \u00a0 \u00a0/* As per the Java Iterator specs, we should throw a NoSuchElementException\n \u00a0 \u00a0 \u00a0 \u00a0 * if the next element doesn't exist. */\n \u00a0 \u00a0 \u00a0 \u00a0if (next == null) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0throw new NoSuchElementException();\n \u00a0 \u00a0 \u00a0  }\n \u00a0 \u00a0 \u00a0 \u00a0Integer toReturn = next;\n \u00a0 \u00a0 \u00a0 \u00a0next = null;\n \u00a0 \u00a0 \u00a0 \u00a0if (iter.hasNext()) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0next = iter.next();\n \u00a0 \u00a0 \u00a0  }\n \u00a0 \u00a0 \u00a0 \u00a0return toReturn;\n \u00a0  }\n\u200b\n \u00a0 \u00a0@Override\n \u00a0 \u00a0public boolean hasNext() {\n \u00a0 \u00a0 \u00a0 \u00a0return next != null;\n \u00a0  }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity : All methods: O(1).</p>\n<p>Same as Approach 1.</p>\n</li>\n<li>\n<p>Space Complexity : All methods: O(1).</p>\n<p>Same as Approach 1.</p>\n</li>\n</ul>\n<br/>\n<hr/>\n<h3><a href=\"#the-follow-up\"><svg><path></path></svg></a>The Follow Up</h3>\n<p>For the most part, our code would work fine if we replaced integers with another data type (e.g. strings).</p>\n<p>There is one case where this does not work, and that's if the underlying <code>Iterator</code> might return <code>null</code>/ <code>None</code> from <code>.next(...)</code> as an actual value. If our code is using <code>null</code> to represent an exhausted <code>Iterator</code>, or to represent that we don't currently have a peeked value stored away (as in Approach 1), then the conditionals in <code>PeekingIterator</code> will not behave as expected on these values coming out of the underlying <code>Iterator</code>.</p>\n<p>We can solve it by using separate <code>boolean</code> variables to state whether or not there's currently a peeked value or the <code>Iterator</code> is exhausted, instead of trying to infer this information based on <code>null</code> status of value variables.</p>\n<p>In Java, you can also use <em>generics</em> on your <code>Iterator</code>.</p>\n<br/>",
        "isOfficial": true,
        "scrapedAt": "2026-02-18T09:10:39.036Z"
    }
}