{
    "questionId": "142",
    "questionFrontendId": "142",
    "title": "Linked List Cycle II",
    "titleSlug": "linked-list-cycle-ii",
    "content": "<p>Given the <code>head</code> of a linked list, return <em>the node where the cycle begins. If there is no cycle, return </em><code>null</code>.</p>\n\n<p>There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the <code>next</code> pointer. Internally, <code>pos</code> is used to denote the index of the node that tail&#39;s <code>next</code> pointer is connected to (<strong>0-indexed</strong>). It is <code>-1</code> if there is no cycle. <strong>Note that</strong> <code>pos</code> <strong>is not passed as a parameter</strong>.</p>\n\n<p><strong>Do not modify</strong> the linked list.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"images/142/circularlinkedlist.png\" style=\"height: 145px; width: 450px;\" />\n<pre>\n<strong>Input:</strong> head = [3,2,0,-4], pos = 1\n<strong>Output:</strong> tail connects to node index 1\n<strong>Explanation:</strong> There is a cycle in the linked list, where tail connects to the second node.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"images/142/circularlinkedlist_test2.png\" style=\"height: 105px; width: 201px;\" />\n<pre>\n<strong>Input:</strong> head = [1,2], pos = 0\n<strong>Output:</strong> tail connects to node index 0\n<strong>Explanation:</strong> There is a cycle in the linked list, where tail connects to the first node.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n<img alt=\"\" src=\"images/142/circularlinkedlist_test3.png\" style=\"height: 65px; width: 65px;\" />\n<pre>\n<strong>Input:</strong> head = [1], pos = -1\n<strong>Output:</strong> no cycle\n<strong>Explanation:</strong> There is no cycle in the linked list.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of the nodes in the list is in the range <code>[0, 10<sup>4</sup>]</code>.</li>\n\t<li><code>-10<sup>5</sup> &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n\t<li><code>pos</code> is <code>-1</code> or a <strong>valid index</strong> in the linked-list.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Can you solve it using <code>O(1)</code> (i.e. constant) memory?</p>\n",
    "difficulty": "Medium",
    "stats": "{\"totalAccepted\": \"1.9M\", \"totalSubmission\": \"3.4M\", \"totalAcceptedRaw\": 1932426, \"totalSubmissionRaw\": 3379809, \"acRate\": \"57.2%\"}",
    "hints": [],
    "similarQuestions": "[{\"title\": \"Linked List Cycle\", \"titleSlug\": \"linked-list-cycle\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Find the Duplicate Number\", \"titleSlug\": \"find-the-duplicate-number\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
    "topicTags": [
        {
            "name": "Hash Table",
            "slug": "hash-table"
        },
        {
            "name": "Linked List",
            "slug": "linked-list"
        },
        {
            "name": "Two Pointers",
            "slug": "two-pointers"
        }
    ],
    "companyTags": null,
    "codeSnippets": [
        {
            "lang": "Java",
            "langSlug": "java",
            "code": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        \n    }\n}"
        }
    ],
    "solution": {
        "content": "<h2><a href=\"#solution\"><svg><path></path></svg></a>Solution</h2>\n<hr/>\n<h3><a href=\"#approach-1-hash-set\"><svg><path></path></svg></a>Approach 1: Hash Set</h3>\n<blockquote>\n<p><strong>Note.</strong> For this approach, we assume that you already know what a hash table is and are figuring out how to apply it to a wide range of problems, such as this one. If you are not yet at this stage, we recommend checking out our relevant <a href=\"https://leetcode.com/explore/learn/card/hash-table/\">Explore Card content on hash table</a> before coming back to this article.</p>\n</blockquote>\n<h4>Intuition</h4>\n<p>The fundamental concept behind this approach is that a cycle in a linked list means visiting a node we've already seen before. By keeping track of each node we visit and checking whether we've seen it before, we can identify whether a cycle exists.</p>\n<p>A hash set is a data structure that allows us to efficiently check if an element is already present (visited) and also to insert new elements (mark as visited).</p>\n<p>So, our strategy here is to traverse the linked list one node at a time and, for each node, check if it is in our hash set nodes_seen. If we come across a node that is already in our set, then we have encountered a cycle. If not, we add this new node to the set nodes_seen and proceed to the next one.</p>\n<p>If we manage to reach the end of the list (a null node), then we can conclude that no cycle exists. This is because we would have been stuck in a loop and wouldn't reach the end if there was a cycle.</p>\n<h4>Algorithm</h4>\n<ol>\n<li>Initialize the node to the head of the linked list and an empty hash set, nodes_seen.</li>\n<li>Start from the head of the linked list, and move the node one step at a time.</li>\n<li>For each node that we visit, check if it's already in the nodes_seen.\n<ul>\n<li>If it is, it means we've found a cycle. Return the current node as the entry point of the cycle.</li>\n<li>If it's not in nodes_seen, then add the current node to nodes_seen, and move on to the next node.</li>\n</ul>\n</li>\n<li>If node becomes <code>null</code> (the end of the list), then return <code>null</code>. There's no cycle in the list because we would have been stuck in a loop and wouldn't reach the end if there was a cycle.</li>\n</ol>\n<h4>Implementation</h4>\n<pre><code>import java.util.HashSet;\nimport java.util.Set;\n\nclass Solution {\n    public ListNode detectCycle(ListNode head) {\n        // Initialize an empty hash set\n        Set&lt;ListNode&gt; nodesSeen = new HashSet&lt;&gt;();\n\n        // Start from the head of the linked list\n        ListNode node = head;\n        while (node != null) {\n            // If the current node is in nodesSeen, we have a cycle\n            if (nodesSeen.contains(node)) {\n                return node;\n            } else {\n                // Add this node to nodesSeen and move to the next node\n                nodesSeen.add(node);\n                node = node.next;\n            }\n        }\n\n        // If we reach a null node, there is no cycle\n        return null;\n    }\n}</code></pre>\n<h4>Complexity Analysis</h4>\n<p>Let n be the total number of nodes in the linked list.</p>\n<ul>\n<li>Time complexity: O(n).</li>\n</ul>\n<p>We have to visit all nodes once.</p>\n<ul>\n<li>Space complexity: O(n).</li>\n</ul>\n<p>We have to store all nodes in the hash set.</p>\n<hr/>\n<h3><a href=\"#approach-2-floyds-tortoise-and-hare-algorithm\"><svg><path></path></svg></a>Approach 2: Floyd's Tortoise and Hare Algorithm</h3>\n<h4>Intuition</h4>\n<blockquote>\n<p>This algorithm is very difficult to derive on your own and you would not be expected to do so in an interview without any help.</p>\n</blockquote>\n<p>​</p>\n<p>Floyd's Tortoise and Hare Algorithm is a clever technique that is used to detect cycles in sequences or linked lists. You can imagine it as a race between a fast \"hare\" and a slow \"tortoise.\" We will explain it in a beginner-friendly way:</p>\n<p>Imagine you're in a park, where there is a circular path inside the park and a straight path leading to the circular path. If you start walking on the straight path into the circular path, you'll eventually start walking in a cycle around the circular path.</p>\n<p>Now imagine two people: a fast runner (the \"hare\") and a slow walker (the \"tortoise\"). They both start at the beginning of the path (the start of the linked list). The hare starts running twice as fast as the tortoise.</p>\n<p>If the path does not contain a cycle (no circular path), the hare will reach the end of the straight path first. Let's focus on the case where the cycle exists.</p>\n<p>At some point, if there is a cycle (a circular path) in the park, the hare will enter this cycle earlier due to its speed. Eventually, the tortoise will also enter the cycle. Since the hare is moving faster, it will lap the tortoise at some point inside the cycle.</p>\n<p>​</p>\n<ul>\n<li>Let's define a as the length of the path from the start of the list to the entrance of the cycle.</li>\n<li>Let's define b as the length of the path from the cycle's entrance to the meeting point of the hare and the tortoise inside the cycle.</li>\n<li>Let's define c as the total length of the cycle.</li>\n</ul>\n<p>The hare could lap the cycle multiple times before it meets the tortoise, especially if the cycle's size is relatively small compared to the distance from the start to the cycle's entrance, or if the cycle's size is big, and the hare enters it significantly before the tortoise does.</p>\n<p>When the tortoise and the hare meet inside the cycle, the tortoise has walked a+b distance.</p>\n<p>On the other hand, the hare, which moves twice as fast, has covered this distance and maybe a few more laps around the cycle. So, the total distance the hare ran is a+b plus k⋅c, where k is the number of times it lapped the cycle. Because the hare moves twice as fast, this total distance is also equal to 2(a+b).</p>\n<p>If we set these two equal: a+b+k⋅c=2(a+b), we obtain k⋅c=a+b.</p>\n<p>This tells us that the number of times the hare laps the cycle times the length of the cycle equals the distance from the head of the list to the meeting point.</p>\n<p>The question now is where is the entrance to the cycle?</p>\n<p>Here is where the second part of the algorithm comes in: after finding a meeting point inside the cycle, you'll leave the tortoise there and move the hare back to the starting point of the park (or the head of the linked list). Then, have both the hare and the tortoise move at the same pace (one step at a time). When they meet again, that meeting point is the entrance to the cycle.</p>\n<p>You may ask, \"Why is this the entrance to the cycle?\" Well, let's consider the distances each has traveled.</p>\n<p>The first time that the hare and the tortoise meet within the cycle, we have established that:</p>\n<ul>\n<li>The tortoise has travelled a+b distance.</li>\n<li>The hare has traveled a+b+k⋅c distance, where k represents how many times the hare has lapped the cycle.</li>\n<li>Because the hare moves at twice the speed, a+b+k⋅c=2(a+b), rearrange for k⋅c=a+b.</li>\n</ul>\n<p>If we move the hare back to the start of the straight path and make it move at the same speed as the tortoise, here's what happens:</p>\n<ul>\n<li>The hare has a distance to travel to reach the entrance of the cycle. We can rearrange the above equation to say that the hare will reach the entrance of the cycle in a=k⋅c−b steps.</li>\n<li>Currently, the tortoise is b away from the entrance of the cycle. In k⋅c−b steps, where will the tortoise be? Relative to the entrance of the cycle, the tortoise will be at (k⋅c−b)+b=k⋅c. Because k is an integer, c is defined as the length of the cycle, and this distance is relative to the entrance of the cycle, the tortoise will be at the entrance!</li>\n</ul>\n<p>Because the tortoise and hare are now moving at the same speed, after k⋅c−b steps, they will meet again at the entrance of the cycle. This must be the first time they meet again because the hare has just entered the cycle again for the first time. Therefore, to find the entrance of the cycle, we don't actually need the values of a,b,c,k. We can just return the node at which they meet again.</p>\n<h4>Algorithm</h4>\n<ol>\n<li>Initialize the <code>tortoise</code> and <code>hare</code> pointers to the head of the linked list.</li>\n<li>Move the <code>tortoise</code> one step and the <code>hare</code> two steps at a time until they meet or either <code>hare</code> or <code>hare.next</code> becomes <code>null</code>.</li>\n<li>If the <code>hare</code> or <code>hare.next</code> pointer is <code>null</code>, it means the hare came to the dead end and we return <code>null</code> as there is no cycle.</li>\n<li>Reset the <code>hare</code> pointer to the head of the linked list.</li>\n<li>Move both pointers one step at a time until they meet again. The meeting point is the node where the cycle begins.</li>\n<li>Return the meeting point node.</li>\n</ol>\n<h4>Implementation</h4>\n<pre><code>class Solution {\n    public ListNode detectCycle(ListNode head) {\n        // Initialize tortoise and hare pointers\n        ListNode tortoise = head;\n        ListNode hare = head;\n\n        // Move tortoise one step and hare two steps\n        while (hare != null && hare.next != null) {\n            tortoise = tortoise.next;\n            hare = hare.next.next;\n\n            // Check if the hare meets the tortoise\n            if (tortoise == hare) {\n                break;\n            }\n        }\n\n        // Check if there is no cycle\n        if (hare == null || hare.next == null) {\n            return null;\n        }\n\n        // Reset the hare pointer to the head\n        hare = head;\n\n        // Move both pointers one step until they meet again\n        while (tortoise != hare) {\n            tortoise = tortoise.next;\n            hare = hare.next;\n        }\n\n        // Return the node where the cycle begins\n        return tortoise;\n    }\n}</code></pre>\n<h4>Complexity Analysis</h4>\n<p>Let n be the total number of nodes in the linked list.</p>\n<ul>\n<li>Time complexity: O(n).</li>\n</ul>\n<p>The algorithm consists of two phases. In the first phase, we use two pointers (the \"hare\" and the \"tortoise\") to traverse the list. The slow pointer (tortoise) will go through the list only once until it meets the hare. Therefore, this phase runs in O(n) time.</p>\n<p>In the second phase, we again have two pointers traversing the list at the same speed until they meet. The maximum distance to be covered in this phase will not be greater than the length of the list (recall that the hare just needs to get back to the entrance of the cycle). So, this phase also runs in O(n) time.</p>\n<p>As a result, the total time complexity of the algorithm is O(n)+O(n), which simplifies to O(n).</p>\n<ul>\n<li>Space complexity: O(1).</li>\n</ul>\n<p>The space complexity is constant, O(1), because we are only using a fixed amount of space to store the slow and fast pointers. No additional space is used that scales with the input size. So the space complexity of the algorithm is O(1), which means it uses constant space.</p>",
        "isOfficial": true,
        "scrapedAt": "2026-02-18T07:14:57.999Z"
    }
}