{
    "questionId": "132",
    "questionFrontendId": "132",
    "title": "Palindrome Partitioning II",
    "titleSlug": "palindrome-partitioning-ii",
    "content": "<p>Given a string <code>s</code>, partition <code>s</code> such that every <span data-keyword=\"substring-nonempty\">substring</span> of the partition is a <span data-keyword=\"palindrome-string\">palindrome</span>.</p>\n\n<p>Return <em>the <strong>minimum</strong> cuts needed for a palindrome partitioning of</em> <code>s</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;aab&quot;\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> The palindrome partitioning [&quot;aa&quot;,&quot;b&quot;] could be produced using 1 cut.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;a&quot;\n<strong>Output:</strong> 0\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;ab&quot;\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 2000</code></li>\n\t<li><code>s</code> consists of lowercase English letters only.</li>\n</ul>\n",
    "difficulty": "Hard",
    "stats": "{\"totalAccepted\": \"394.1K\", \"totalSubmission\": \"1.1M\", \"totalAcceptedRaw\": 394127, \"totalSubmissionRaw\": 1078771, \"acRate\": \"36.5%\"}",
    "hints": [],
    "similarQuestions": "[{\"title\": \"Palindrome Partitioning\", \"titleSlug\": \"palindrome-partitioning\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Palindrome Partitioning IV\", \"titleSlug\": \"palindrome-partitioning-iv\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Maximum Number of Non-overlapping Palindrome Substrings\", \"titleSlug\": \"maximum-number-of-non-overlapping-palindrome-substrings\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Number of Great Partitions\", \"titleSlug\": \"number-of-great-partitions\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
    "topicTags": [
        {
            "name": "String",
            "slug": "string"
        },
        {
            "name": "Dynamic Programming",
            "slug": "dynamic-programming"
        }
    ],
    "companyTags": null,
    "codeSnippets": [
        {
            "lang": "Java",
            "langSlug": "java",
            "code": "class Solution {\n    public int minCut(String s) {\n        \n    }\n}"
        }
    ],
    "solution": {
        "content": "<h2><a href=\"#solution\"><svg><path></path></svg></a>Solution</h2>\n<hr/>\n<h3><a href=\"#overview\"><svg><path></path></svg></a>Overview</h3>\n<p>The problem is to partition the given string <code>s</code> into palindromic substrings such that the number of partitions is <em>minimum</em>.</p>\n<p>Now, how can we achieve this?<br/>\nGenerate all possible substrings of the string <code>s</code> that are palindromes and find the number of cuts. In the end, you will find the partitioning scheme with the minimum number of cuts.</p>\n<p>If you have solved similar problems before like <a href=\"https://leetcode.com/problems/palindrome-partitioning/\">Palindrome Partitioning I</a>, you know that this can be implemented using backtracking. But there is more to it. It is interesting to see how this problem touches various algorithm concepts as we move forward towards more optimized solutions.</p>\n<p>It is recommended for the reader to be patient and read through all the approaches as it will help in understanding how a naive solution can be iteratively optimized into an efficient solution. So stay tuned!!</p>\n<hr/>\n<h3><a href=\"#approach-1-backtracking\"><svg><path></path></svg></a>Approach 1: Backtracking</h3>\n<p><strong>Intuition</strong></p>\n<p>In this approach, we will partition the given string <code>s</code> in all possible ways such that, each substring is a palindrome. In the end, we can find the partitioning scheme with the minimum cut.</p>\n<p>Consider string <code>s = aab</code>. Let's take a pen and paper and find the palindromic partitioning of this string.</p>\n<p><em>First Iteration</em></p>\n<pre><code>String string = \"aab\";\nint numberOfCuts = 0;</code></pre><svg><path></path></svg>\n<p>Pick the first substring beginning with the start of the string: <code>a</code>. (<strong>a</strong>ab)</p>\n<p>As <code>a</code> is a palindrome, place a cut after the first <code>a</code> and move ahead towards the remaining substring.</p>\n<p></p>\n<pre><code>String string = \"ab\";\nint numberOfCuts = 1;</code></pre><svg><path></path></svg>\n<p>Again, <code>a</code> is a palindrome. (a<strong>a</strong>b) Place a cut after 2nd <code>a</code> and move towards the remaining substring.</p>\n<p></p>\n<pre><code>String string = \"b\";\nint numberOfCuts = 2;</code></pre><svg><path></path></svg>\n<p>The next substring <code>b</code>(aa<strong>b</strong>) is also a palindrome. With this, we have reached the end of the string. We have found our first palindrome partitioning scheme wherein each substring is a palindrome.</p>\n<p></p>\n<p>Now, we will go back to <code>string = b</code> and <code>number of cuts = 1</code>  and choose the next substring <code>ab</code> (a<strong>ab</strong>), but since it is not a palindrome, we will not explore this choice.</p>\n<p>Let's go back to the original substring again and find out other possible ways to partition the string.</p>\n<p><em>Second Iteration</em></p>\n<pre><code>String string = \"aab\";\nint numberOfCuts = 0;</code></pre><svg><path></path></svg>\n<p>In the previous iteration, we picked up the first substring <code>a</code> and found a partitioning scheme. Let's move ahead to pick the next<br/>\nsubstring <code>aa</code> (<strong>aa</strong>b)</p>\n<pre><code>String string = \"b\";\nint numberOfCuts = 1;</code></pre><svg><path></path></svg>\n<p></p>\n<p>The next substring <code>b</code>(aa<strong>b</strong>) is a palindrome. With this, we have reached the end of the string and we found our 2nd palindrome partitioning scheme.</p>\n<p></p>\n<p><em>Third Iteration</em></p>\n<pre><code>String string = \"aab\";\nint numberOfCuts = 0;</code></pre><svg><path></path></svg>\n<p>In this iteration, we would pick the next substring <code>aab</code> (<strong>aab</strong>). It is not a palindrome. As we have reached the end of the string, we terminate our search.</p>\n<p>We can conclude that we found 2 possible partitioning schemes such that each substring is a palindrome and the minimum cut obtained is <code>1</code>.</p>\n<p></p>\n<p>What are we doing here?</p>\n<p>We are breaking the string <code>aab</code>  into all possible substrings, starting with <code>a</code>, then <code>aa</code>, then <code>aab</code>, and so on. If any of the substrings is a palindrome, we are placing a cut at that position and continuing the same process for the remaining string.</p>\n<p>That's exactly how <a href=\"https://leetcode.com/explore/learn/card/recursion-ii/472/backtracking/\">Backtracking</a> works!! It incrementally builds the candidates for the solution and discards the candidates (backtrack) if it doesn't satisfy the condition.</p>\n<p>In the Backtracking algorithm we must identify following parameters:</p>\n<p><em>Choose Candidates</em>: The potential candidates are all substrings that can be generated from the given string.</p>\n<p><em>Define Constraint</em>: We will explore a potential candidate if and only if it is a <em>palindrome</em>.</p>\n<p><em>Identify Terminating Condition</em>: The search will terminate when we reach the end of the string.</p>\n<p>Let's understand how we can implement this approach.</p>\n<p><strong>Algorithm</strong></p>\n<ol>\n<li>\n<p>The backtracking algorithm is implemented by recursively exploring the candidate substrings. We define a recursive method <code>findMinimumCut</code> that will find the minimum number of cuts for a substring starting at index <code>start</code> and ending at index <code>end</code>.</p>\n<p>To find the minimum cuts, we must also know the minimum cuts seen so far for other palindrome partitions. This information is tracked in the variable <code>minimumCut</code>.</p>\n<p>The initial value of <code>minimumCut</code> would be the maximum possible number of cuts in a string which is equal to the length of string <em>minus</em> 1 (i.e. cut in between each character).</p>\n</li>\n<li>\n<p>Now, that we know the <code>start</code> and <code>end</code> indices, we must generate all possible substrings beginning at the <code>start</code> index. For this, we will keep the <code>start</code> index constant. The <code>currentEndIndex</code> marks the end of the current substring.</p>\n<p>If the current substring is a palindrome, we will place a cut after <code>currentEndIndex</code> and recursively find the minimum cut for the remaining string.</p>\n</li>\n</ol>\n<p>The minimum cut will be calculated as,</p>\n<pre><code>Math.min(minimumCut, 1 + minimumCutsForRemainingSubstring)</code></pre><svg><path></path></svg>\n<p>The following figure illustrates how the recursive backtracking process works:</p>\n<p></p>\n<p><strong>Implementation</strong></p>\n<pre><code>class Solution {\n    public int minCut(String s) {\n        return findMinimumCut(s, 0, s.length() - 1, s.length() - 1);\n    }\n\n    private int findMinimumCut(String s, int start, int end, int minimumCut) {\n        // base condition, no cut needed for an empty substring or palindrome substring.\n        if (start == end || isPalindrome(s, start, end)) {\n            return 0;\n        }\n        for (int currentEndIndex = start; currentEndIndex &lt;= end; currentEndIndex++) {\n            // find result for substring (start, currentEnd) if it is palindrome\n            if (isPalindrome(s, start, currentEndIndex)) {\n                minimumCut = Math.min(\n                    minimumCut,\n                    1 + findMinimumCut(s, currentEndIndex + 1, end, minimumCut)\n                );\n            }\n        }\n        return minimumCut;\n    }\n\n    private boolean isPalindrome(String s, int start, int end) {\n        while (start &lt; end) {\n            if (s.charAt(start++) != s.charAt(end--)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: O(N\u22c52N), where <code>N</code> is the length of string <code>s</code>.</p>\n<p>Let's understand the time complexity of the backtracking method call <code>findMinimumCut</code> given by <code>T(N)</code>.</p>\n<p>For a string of size <code>N</code> the recursive method <code>findMinimumCut</code> will recur for substrings of size <code>N-1</code>, <code>N-2</code>, <code>N-3</code> and so on. This can be written as,</p>\n<p>T(N)=T(N\u22121)+T(N\u22122)+...+T(1).</p>\n<p>Similarly, T(N - 1) can be written as,</p>\n<p>T(N\u22121)=T(N\u22122)+T(N\u22123)+...+T(1)</p>\n<p>Subtracting the above 2 expressions and solving the expression, we get,</p>\n<p>T(N)=2T(N\u22121)</p>\n<p>The time complexity of above recurrence relation is given by,</p>\n<p>T(N)=O(2N)</p>\n<blockquote>\n<p>T(N)=2T(N\u22121)          ... <em>Equation 1</em></p>\n<p>Substituting N = N - 1 in <em>Equation 1</em></p>\n<p>T(N\u22121)=2T(N\u22122)    ... <em>Equation 2</em></p>\n<p>Putting the value of <em>Equation 2</em> in <em>Equation 1</em></p>\n<p>T(N)=2\u22c5[2T(N\u22122)]</p>\n<p>T(N)=4T(N\u22122)    ... <em>Equation 3</em></p>\n<p>Substituting N = N - 2 in <em>Equation 1</em></p>\n<p>T(N\u22122)=2T(N\u22123)    ... <em>Equation 4</em></p>\n<p>Putting the value of <em>Equation 4</em> in <em>Equation 3</em></p>\n<p>T(N)=4\u22c5[2T(N\u22123)]</p>\n<p>T(N)=8T(N\u22123)=2KT(N\u2212K)  ... <em>Equation 5</em></p>\n<p>Substituting K = N in <em>Equation 5</em></p>\n<p>T(N)=2NT(N\u2212N)</p>\n<p>T(N)=2N=O(2N)</p>\n</blockquote>\n<p>Thus, we can say that for a given string of size N, the worst-case time complexity of the recursive method call <code>findMinimumCut</code> would be O(2N).<br/>\nAdditionally, to check if a substring is a palindrome or not we must iterate O(N/2) times within each recursive call.</p>\n<p>This gives us total time complexity of O(2N)\u22c5O(N/2)=O(2N\u22c5N).</p>\n<p>This approach is exhaustive and results in <em>Time Limit Exceeded(TLE)</em>.</p>\n</li>\n<li>\n<p>Space Complexity: O(n). The recursive method uses an internal call stack. In this case, if we place a cut after every character in the string <code>(a|a|b)</code>, the size of the internal stack would be at most <code>n</code>.</p>\n</li>\n</ul>\n<hr/>\n<h3><a href=\"#approach-2-dynamic-programming---top-down-recursion-memoization\"><svg><path></path></svg></a>Approach 2: Dynamic Programming - Top Down (Recursion, Memoization)</h3>\n<p><strong>Intuition</strong></p>\n<p>We found that the Backtracking approach is exhaustive. What do we observe?</p>\n<p>In the above recursion tree, the result of substring <code>b</code> for <code>s = aab</code> is calculated twice. For larger substrings, there would be many such substrings for which the results would be unnecessarily computed again and again. In fact, for every repeated computation the results would be always the same.</p>\n<blockquote>\n<p>How about if our algorithm remembers the result for a subproblem when it is computed the first time and reuses the stored result every other time.</p>\n</blockquote>\n<p>If you have learned the basics of <a href=\"https://en.wikipedia.org/wiki/Dynamic_programming\">Dynamic Programming</a>, you know that if a recursive problem computes and solves the same subproblem multiple times, it has an <em>Overlapping Subproblem</em> property. Such problems can be optimized using a dynamic programming technique called Memoization.</p>\n<p>In this approach, the result after computing minimum cuts for a substring is stored. The subsequent calls can look at these stored results before going ahead and computing the minimum number of cuts for a substring.<br/>\nMoreover, we can observe that the same optimization can be also applied to determine if a substring is a palindrome.</p>\n<p>The following figure illustrates the recursive tree for s = <code>aaab</code> and how we can use memoization to optimize the approach.</p>\n<p></p>\n<blockquote>\n<p>Fact: The recursion plus memoization approach starts with the larger problem and recursively breaks it into smaller subproblems. Hence it is also called Top-Down Dynamic Programming.</p>\n</blockquote>\n<p><strong>Algorithm</strong></p>\n<ul>\n<li>\n<p>To record the results of computation on every substring, we must store the substring and its result.</p>\n<p>Now, instead of storing the substring, we can just store its <code>start</code> and <code>end</code> index. We will use a 2-dimensional array <code>memoCuts</code>, where the value of  <code>memoCuts[start][end]</code> would give the minimum number of cuts for a substring starting at index start and ending at index <code>end</code>.</p>\n<p>Similarly, we need another 2-dimensional array <code>memoPalindrome</code> to store the results for palindrome computations.</p>\n<p>The implementation is the same as in <em>Approach 1</em> with the following differences in each recursive call:</p>\n</li>\n<li>\n<p>In <code>findMinimumCut</code>, check if <code>memoCuts</code> has the result for the current substring. If so, return the result, otherwise, proceed with the next steps to compute the result.</p>\n</li>\n<li>\n<p>After computing the result, store the result in <code>memoCuts[start][end]</code>.</p>\n</li>\n<li>\n<p>A similar approach is followed in <code>isPalindrome</code> to store the results of palindrome computations.</p>\n</li>\n</ul>\n<p><strong>Implementation</strong></p>\n<pre><code>import java.util.*;\n\nclass Solution {\n    private int[][] memoCuts;\n    private Boolean[][] memoPalindrome;\n\n    public int minCut(String s) {\n        int n = s.length();\n        memoCuts = new int[n][n];\n        memoPalindrome = new Boolean[n][n];\n        for (int[] row : memoCuts) {\n            Arrays.fill(row, -1);\n        }\n        return findMinimumCut(s, 0, n - 1, n - 1);\n    }\n\n    private int findMinimumCut(String s, int start, int end, int minimumCut) {\n        // base case\n        if (start == end || isPalindrome(s, start, end)) {\n            return 0;\n        }\n\n        // check for results in memoCuts\n        if (memoCuts[start][end] != -1) {\n            return memoCuts[start][end];\n        }\n\n        for (int currentEndIndex = start; currentEndIndex &lt;= end; currentEndIndex++) {\n            if (isPalindrome(s, start, currentEndIndex)) {\n                minimumCut = Math.min(\n                    minimumCut,\n                    1 + findMinimumCut(s, currentEndIndex + 1, end, minimumCut)\n                );\n            }\n        }\n        memoCuts[start][end] = minimumCut;\n        return minimumCut;\n    }\n\n    private boolean isPalindrome(String s, int start, int end) {\n        if (start &gt;= end) return true;\n        if (memoPalindrome[start][end] != null) {\n            return memoPalindrome[start][end];\n        }\n        memoPalindrome[start][end] =\n            (s.charAt(start) == s.charAt(end)) &amp;&amp; isPalindrome(s, start + 1, end - 1);\n        return memoPalindrome[start][end];\n    }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: O(N2\u22c5N), where <code>N</code> is the length of string <code>s</code>.</p>\n<p>In the recursive method <code>findMinimumCut</code>, we are calculating the results for any substring only once. We know that a string size N has N2 possible substrings. Thus, the worst-case time complexity of the recursive method <code>findMinimumCut</code> is O(N2).</p>\n<p>Additionally, within each recursive call, we are also checking if a substring is palindrome or not. The worst-case time complexity for method <code>isPalindrome</code> is O(N/2).</p>\n<p>This gives us total time complexity as, O(N2)\u22c5O(N/2)=O(N2\u22c5N)</p>\n</li>\n<li>\n<p>Space Complexity: O(N2), as we are using two 2-dimensional arrays <code>memoCuts</code> and <code>memoPalindrome</code> of size N\u22c5N.</p>\n<p>This gives us total space complexity as (N2+N2)=N2.</p>\n</li>\n</ul>\n<hr/>\n<h3><a href=\"#approach-3-dynamic-programming---top-down-optimized-space-complexity\"><svg><path></path></svg></a>Approach 3: Dynamic Programming - Top Down (Optimized Space Complexity)</h3>\n<p><strong>Intuition</strong></p>\n<p>In <em>Approach 2</em>, we used a 2-dimensional array for <code>memoCuts</code>. On careful observation, we notice that when we update or access the stored values to or from <code>memoCuts</code>, the value of variable <code>end</code> always remains the same.</p>\n<p>Thus, we only need to track and update the <code>start</code> index when finding the minimum number of cuts. The <code>memoCuts[start]</code> will determine the minimum number of cuts for a substring starting at index <code>start</code> and ending at index <code>length(s) - 1</code>.</p>\n<p><strong>Algorithm</strong></p>\n<p>The algorithm is similar as in <em>Approach 2</em> with a minor difference:</p>\n<ul>\n<li>\n<p>Store the results of a substring starting at index <code>start</code> in <code>memoCuts[start]</code>.</p>\n</li>\n<li>\n<p>Before calculating the result of any substring starting at index <code>start</code> and ending at index <code>end</code>, check if <code>memoCuts[start]</code> already contains the computed result.</p>\n</li>\n</ul>\n<p><strong>Implementation</strong></p>\n<pre><code>import java.util.*;\n\nclass Solution {\n    private int[] memoCuts;\n    private Boolean[][] memoPalindrome;\n\n    public int minCut(String s) {\n        int n = s.length();\n        memoCuts = new int[n];\n        Arrays.fill(memoCuts, -1);\n        memoPalindrome = new Boolean[n][n];\n        return findMinimumCut(s, 0, n - 1, n - 1);\n    }\n\n    private int findMinimumCut(String s, int start, int end, int minimumCut) {\n        // base case\n        if (start == end || isPalindrome(s, start, end)) {\n            return 0;\n        }\n\n        // check for results in memoCuts\n        if (memoCuts[start] != -1) {\n            return memoCuts[start];\n        }\n\n        for (int currentEndIndex = start; currentEndIndex &lt;= end; currentEndIndex++) {\n            if (isPalindrome(s, start, currentEndIndex)) {\n                minimumCut = Math.min(\n                    minimumCut,\n                    1 + findMinimumCut(s, currentEndIndex + 1, end, minimumCut)\n                );\n            }\n        }\n        memoCuts[start] = minimumCut;\n        return minimumCut;\n    }\n\n    private boolean isPalindrome(String s, int start, int end) {\n        if (start &gt;= end) return true;\n        if (memoPalindrome[start][end] != null) {\n            return memoPalindrome[start][end];\n        }\n        memoPalindrome[start][end] =\n            (s.charAt(start) == s.charAt(end)) &amp;&amp; isPalindrome(s, start + 1, end - 1);\n        return memoPalindrome[start][end];\n    }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: O(N2\u22c5N), where <code>N</code> is the length of string <code>s</code>.</p>\n<p>The time complexity is the same as in <em>Approach 2</em>.</p>\n</li>\n<li>\n<p>Space Complexity: O(N2), as we are using one 1-dimensional array <code>memoCuts</code> of size N and one 2-dimensional array <code>memoPalindrome</code> of size N\u22c5N.<br/>\nThis gives us a total space complexity of (N+NN)=N2.</p>\n</li>\n</ul>\n<hr/>\n<h3><a href=\"#approach-4-dynamic-programming---bottom-up-tabulation\"><svg><path></path></svg></a>Approach 4: Dynamic Programming - Bottom Up (Tabulation)</h3>\n<p><strong>Intuition</strong></p>\n<p>There is yet another technique to implement Dynamic Programming problems. Here, we will use an iterative approach and store the result of subproblems in a bottom-up fashion, also known as Tabulation.</p>\n<blockquote>\n<p>Challenge: Can you try this on your own?</p>\n</blockquote>\n<p>We must understand that the basic insight of dynamic programming: to compute the result of a problem, we must first compute the results of its subproblems. For example, to find the minimum number of cuts for the string <code>aab</code>, we must know the result for all the substrings <code>a</code>, <code>aa</code>, <code>ab</code>, and so on.</p>\n<p>Memoization follows the top-down approach. We started by finding the result for the original string <code>aab</code> and recursively moved towards computing the result of smaller subproblems like <code>a</code>, <code>aa</code>, <code>ab</code>.</p>\n<p>Tabulation solves it in a bottom-up manner. We must compute the results of all the subproblems before moving towards the larger problem. As the name suggests, the results of subproblems are stored in a table which can be referred to in the future for computing the result of a larger problem.</p>\n<p><strong>Algorithm</strong></p>\n<ol>\n<li>\n<p>Bottom-up Dynamic Programming follows an iterative approach to solve the problem. We have to start by finding the minimum possible cuts in the smallest substring and move towards a larger substring.</p>\n<p>This can be implemented using a nested loop. The outer loop sets the upper bound for the substring index with variable <code>end</code>. The inner loop takes each substring between <code>start</code> and <code>end</code> and calculates the minimum number of cuts for substring from index 0 to <code>end</code>.</p>\n</li>\n<li>\n<p>Build a one-dimensional array <code>cutsDp</code> to store the results of subproblems. <code>cutsDp[i]</code> stores the minimum number of cuts for a substring ending at index <code>i</code>.</p>\n</li>\n<li>\n<p>Calculating the minimum number of cuts is similar to the Memoization approach.</p>\n<p>Initially, the <code>minimumCut</code> will be equal to the maximum possible cuts for a substring. So for a substring ending at index <code>end</code>, the <code>minimumCut</code> would be equal to the value of index <code>end</code>.</p>\n<p>The minimum cut for <code>s.substring(start, end)</code> can be calculated as,</p>\n<pre><code>minimum(minimumCut, 1 + cutsDp[start - 1])</code></pre><svg><path></path></svg>\n<p>In the end, we will store the results of the current calculation at <code>cutsDp[end]</code> as every chosen substring ends at index <code>end</code>.</p>\n</li>\n<li>\n<p>We are using a similar iterative approach to check if a substring is a palindrome or not. We will build the <code>palindromeDp</code> beforehand. While finding the minimum cuts will refer to the stored values in <code>palindromeDp</code> and proceed only if the current substring is a palindrome. Refer to Approach 2 in <a href=\"https://leetcode.com/problems/palindrome-partitioning/solution/\">Palindrome Partitioning Solution</a>.</p>\n</li>\n<li>\n<p>Return the minimum number of cuts for the original substring starting at index <code>0</code> and ending at <code>n - 1</code> which will be given by <code>cutsDp[n - 1]</code>.</p>\n</li>\n</ol>\n<p><strong>Implementation</strong></p>\n<pre><code>import java.util.*;\n\nclass Solution {\n    private int[] cutsDp;\n    private boolean[][] palindromeDp;\n\n    public int minCut(String s) {\n        int n = s.length();\n        cutsDp = new int[n];\n        palindromeDp = new boolean[n][n];\n        buildPalindromeDp(s, n);\n\n        for (int end = 0; end &lt; n; end++) {\n            int minimumCut = end;\n            for (int start = 0; start &lt;= end; start++) {\n                if (palindromeDp[start][end]) {\n                    minimumCut = (start == 0) ? 0 : Math.min(minimumCut, cutsDp[start - 1] + 1);\n                }\n            }\n            cutsDp[end] = minimumCut;\n        }\n        return cutsDp[n - 1];\n    }\n\n    private void buildPalindromeDp(String s, int n) {\n        for (int end = 0; end &lt; n; end++) {\n            for (int start = 0; start &lt;= end; start++) {\n                if (s.charAt(start) == s.charAt(end) &amp;&amp;\n                    (end - start &lt;= 2 || palindromeDp[start + 1][end - 1])) {\n                    palindromeDp[start][end] = true;\n                }\n            }\n        }\n    }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: O(N2), where <code>N</code> is the length of string <code>s</code>.</p>\n<p>We are iterating N\u22c5N times to build the <code>palindromeDp</code> array and N\u22c5N times to find the minimum cuts in a nested for-loop. This gives us a total time complexity of O(N\u22c5N)+O(N\u22c5N)=O(N\u22c5N).</p>\n</li>\n<li>\n<p>Space Complexity: O(N2), as we are using a 2-dimensional arrays <code>palindromeDp</code> of size N\u22c5N and a 1-dimensional array <code>cutsDp</code> of size N. Thus, the space complexity can be given by, O(N\u22c5N)+O(N)=O(N\u22c5N).</p>\n</li>\n</ul>\n<hr/>\n<h3><a href=\"#approach-5-optimized-tabulation-approach\"><svg><path></path></svg></a>Approach 5: Optimized Tabulation Approach</h3>\n<p><strong>Intuition</strong></p>\n<p>In Approach 4, we built the palindrome array beforehand. However, both the process of building the palindrome array and finding the minimum cuts iterate in a similar fashion.<br/>\nThere is no need to build the array beforehand. We can combine both processes into a single loop.<br/>\nThere is no need to build the matrix beforehand. We can combine both processes into a single loop.</p>\n<p><strong>Algorithm</strong></p>\n<ul>\n<li>\n<p>Iterate over the string and generate all possible substrings in a nested for loop as in <em>Approach 4</em>.</p>\n</li>\n<li>\n<p>Check if the substring is a palindrome using the previously calculated values in <code>palindromeDp</code>.<br/>\nIf the substring is a palindrome, update the results in the <code>palindromeDp</code> array. Keep doing this to find the minimum cut for the substring ending at index <code>end</code> and save it in <code>cutsDp[end]</code>.</p>\n</li>\n</ul>\n<p><strong>Implementation</strong></p>\n<pre><code>import java.util.*;\n\nclass Solution {\n    public int minCut(String s) {\n        int n = s.length();\n        int[] cutsDp = new int[n];\n        boolean[][] palindromeDp = new boolean[n][n];\n\n        for (int end = 0; end &lt; n; end++) {\n            int minimumCut = end;\n            for (int start = 0; start &lt;= end; start++) {\n                // check if substring (start, end) is palindrome\n                if (s.charAt(start) == s.charAt(end) &amp;&amp;\n                    (end - start &lt;= 2 || palindromeDp[start + 1][end - 1])) {\n                    palindromeDp[start][end] = true;\n                    minimumCut = (start == 0) ? 0 : Math.min(minimumCut, cutsDp[start - 1] + 1);\n                }\n            }\n            cutsDp[end] = minimumCut;\n        }\n        return cutsDp[n - 1];\n    }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: O(N2), where <code>N</code> is the length of string <code>s</code>.</p>\n<p>We are iterating N\u22c5N times only once to find the minimum cuts.</p>\n</li>\n<li>\n<p>Space Complexity: O(N2), as we are using two 2-dimensional arrays <code>palindromeDp</code> and  1-dimensional array <code>cutsDp</code> of size N\u22c5N. Thus the space complexity can be given by, O(N\u22c5N)+O(N)=O(N\u22c5N) .</p>\n</li>\n</ul>\n<hr/>\n<h3><a href=\"#approach-6-expand-around-the-center\"><svg><path></path></svg></a>Approach 6: Expand Around the Center</h3>\n<p><strong>Intuition</strong></p>\n<p>This approach takes advantage of <em>Palindrome Property</em>. We know that a palindrome is a sequence of characters that reads the same backward and forward. If you cut any palindromic string at the center, the characters from the middle till the beginning of the string would be the same as the characters from the middle till the end.<br/>\nIn other words, the palindromic string mirrors around the center.</p>\n<p></p>\n<p>We will fix the middle index and expand the string in both directions,</p>\n<ol>\n<li>The <code>start</code> index will begin at the middle index and expand to the left (towards the beginning of the string).</li>\n<li>The <code>end</code> index will begin at the middle index and expand to the right (towards the end of the string).</li>\n</ol>\n<p>This expansion will continue as long as <code>s[start] == s[end]</code>, making the substring a palindrome. Once we have found the boundaries of our current palindromic string, we will place a cut after the <code>end</code> index.</p>\n<p>In this way, we will fix every index in the string as a middle index and find the palindrome around that index. We will also take the advantage of pre-calculated results using the dynamic programming technique (tabulation).</p>\n<p><strong>Algorithm</strong></p>\n<ol>\n<li>\n<p>Build an array <code>cutsDp</code> to store the results of every computation. Initially, the value of <code>cutsDp[i]</code> would be the maximum possible number of cuts till index <code>i</code>, which is equivalent to <code>i</code>.</p>\n<p>As we progress, after every computation of minimum cuts for a substring ending at index <code>i</code>, the value of <code>cutsDp[i]</code> would be updated.</p>\n</li>\n<li>\n<p>Start by fixing the middle index <code>mid</code> at every position beginning from index <code>0</code> till the index length to string <code>s</code>.</p>\n<p>We know from the above examples that, for even length palindromes, the middle index is between 2 characters (<em>Example: noon</em>) and for odd length palindromes the middle index is at 1 character. (<em>Example: madam</em>). To consider both scenarios, we will expand around the middle index twice.</p>\n<ul>\n<li>\n<p>First, check if there is an odd length palindrome around the middle index. The <code>start</code> and <code>end</code> index will begin iteration from the <code>mid</code> position.</p>\n</li>\n<li>\n<p>Second, check if there is an even-length palindrome around the middle index. The <code>end</code> index will begin iteration from the <code>mid</code> position and the <code>start</code> index will begin from the <code>mid - 1</code> position.</p>\n</li>\n</ul>\n</li>\n</ol>\n<p></p>\n<ol>\n<li>\n<p>The substring will be expanded i.e <code>start</code> index would be <em>incremented</em> and <code>end</code> index <em>decremented</em> until the characters at those indices are the same.</p>\n<p>As the expansion stops, we will place a cut after the <code>end</code> index. This can be calculated as,</p>\n<pre><code>Math.min(cutsDp[end], (start == 0 ? 0 : cutsDp[start - 1] + 1))</code></pre><svg><path></path></svg>\n</li>\n</ol>\n<p></p>\n<ol>\n<li>\n<p>After every computation, update <code>cutsDp[end]</code> with a new minimum value.</p>\n</li>\n<li>\n<p>At the end return <code>cutsDp[n - 1]</code> that has the value of the minimum number of cuts for the original string ending at index <code>n - 1</code>.</p>\n</li>\n</ol>\n<p><strong>Implementation</strong></p>\n<pre><code>import java.util.*;\n\nclass Solution {\n    public int minCut(String s) {\n        int n = s.length();\n        int[] cutsDp = new int[n];\n        for (int i = 0; i &lt; n; i++) {\n            cutsDp[i] = i;\n        }\n\n        for (int mid = 0; mid &lt; n; mid++) {\n            // check for odd length palindrome around mid index\n            findMinimumCuts(mid, mid, cutsDp, s);\n            // check for even length palindrome around mid index\n            findMinimumCuts(mid - 1, mid, cutsDp, s);\n        }\n        return cutsDp[n - 1];\n    }\n\n    private void findMinimumCuts(int startIndex, int endIndex, int[] cutsDp, String s) {\n        for (int start = startIndex, end = endIndex;\n             start &gt;= 0 &amp;&amp; end &lt; s.length() &amp;&amp; s.charAt(start) == s.charAt(end);\n             start--, end++) {\n            int newCut = (start == 0) ? 0 : cutsDp[start - 1] + 1;\n            cutsDp[end] = Math.min(cutsDp[end], newCut);\n        }\n    }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: O(N2), where <code>N</code> is the length of string <code>s</code>.</p>\n<p>The outer loop that fixes the middle index iterates N times. The are 2 inner loops iterates for N/2 times each. This gives us time complexity as, O(N\u22c5(N/2+N/2))=O(N2).</p>\n</li>\n<li>\n<p>Space Complexity: O(N), as we are using single 1 dimensional array <code>cutsDp</code> of size N.</p>\n</li>\n</ul>",
        "isOfficial": true,
        "scrapedAt": "2026-02-18T08:36:36.847Z"
    }
}