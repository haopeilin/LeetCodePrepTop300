{
    "questionId": "172",
    "questionFrontendId": "172",
    "title": "Factorial Trailing Zeroes",
    "titleSlug": "factorial-trailing-zeroes",
    "content": "<p>Given an integer <code>n</code>, return <em>the number of trailing zeroes in </em><code>n!</code>.</p>\n\n<p>Note that <code>n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 3\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> 3! = 6, no trailing zero.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 5\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> 5! = 120, one trailing zero.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 0\n<strong>Output:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= n &lt;= 10<sup>4</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Could you write a solution that works in logarithmic time complexity?</p>\n",
    "difficulty": "Medium",
    "stats": "{\"totalAccepted\": \"640.6K\", \"totalSubmission\": \"1.4M\", \"totalAcceptedRaw\": 640589, \"totalSubmissionRaw\": 1389335, \"acRate\": \"46.1%\"}",
    "hints": [],
    "similarQuestions": "[{\"title\": \"Number of Digit One\", \"titleSlug\": \"number-of-digit-one\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Preimage Size of Factorial Zeroes Function\", \"titleSlug\": \"preimage-size-of-factorial-zeroes-function\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Abbreviating the Product of a Range\", \"titleSlug\": \"abbreviating-the-product-of-a-range\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Maximum Trailing Zeros in a Cornered Path\", \"titleSlug\": \"maximum-trailing-zeros-in-a-cornered-path\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
    "topicTags": [
        {
            "name": "Math",
            "slug": "math"
        }
    ],
    "companyTags": null,
    "codeSnippets": [
        {
            "lang": "Java",
            "langSlug": "java",
            "code": "class Solution {\n    public int trailingZeroes(int n) {\n        \n    }\n}"
        }
    ],
    "solution": {
        "content": "<h2><a href=\"#solution\"><svg><path></path></svg></a>Solution</h2>\n<hr/>\n<h3><a href=\"#approach-1-compute-the-factorial\"><svg><path></path></svg></a>Approach 1: Compute the Factorial</h3>\n<p><strong>Intuition</strong></p>\n<p><em>This approach is too slow, but is a good starting point. You wouldn't implement it in an interview, although you might briefly describe it as a possible way of solving the problem.</em></p>\n<p>The simplest way of solving this problem would be to compute n! and then count the number of zeroes on the end of it. Recall that factorials are calculated by multiplying all the numbers between 1 and n. For example, 10!=10\u22c59\u22c58\u22c57\u22c56\u22c55\u22c54\u22c53\u22c52\u22c51=3,628,800. Therefore, factorials can be calculated iteratively using the following algorithm.</p>\n<pre><code>static BigInteger factorial(int n) {\n    BigInteger nFactorial = BigInteger.ONE;\n    for (int i = 1; i &lt;= n; i++) {\n        nFactorial = nFactorial.multiply(BigInteger.valueOf(i));\n    }\n    return nFactorial;\n}</code></pre><svg><path></path></svg>\n<p>Recall that if a number has a zero on the end of it, then it is divisible by 10. Dividing by 10 will remove that zero, and shift all the other digits to the right by one place. We can, therefore, count the number of zeroes by repeatedly checking if the number is divisible by 10, and if it is then dividing it by 10. The number of divisions we're able to do is equal to the number of 0's on the end of it. This is the algorithm to count the zeroes (assuming x\u22651, which is fine for this problem, as factorials are always positive integers).</p>\n<pre><code>static int zeroCount(BigInteger x) {\n    int zeroCount = 0;\n    while (x.mod(BigInteger.TEN).equals(BigInteger.ZERO)) {\n        zeroCount++;\n        x = x.divide(BigInteger.TEN);\n    }\n    return zeroCount;\n}</code></pre><svg><path></path></svg>\n<p>By putting these two functions together, we can count the number of zeroes on the end of n!.</p>\n<p><strong>Algorithm</strong></p>\n<p>For Java, we need to use BigInteger, because n! won't fit into a <code>long</code> for even moderately small values of n.</p>\n<pre><code>import java.math.BigInteger;\n\nclass Solution {\n    public int trailingZeroes(int n) {\n        BigInteger factorial = BigInteger.ONE;\n        for (int i = 2; i &lt;= n; i++) {\n            factorial = factorial.multiply(BigInteger.valueOf(i));\n        }\n\n        int zeroCount = 0;\n        while (factorial.mod(BigInteger.TEN).equals(BigInteger.ZERO)) {\n            factorial = factorial.divide(BigInteger.TEN);\n            zeroCount++;\n        }\n\n        return zeroCount;\n    }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<p>The math involved here is very advanced, however we don't need to be precise. We can get a reasonable approximation with a little mathematical reasoning. An interviewer probably won't expect you to calculate it exactly, or even derive the approximation as carefully as we have here. However, they <em>might</em> expect you to at least have some ideas and at least attempt to reason about it. Of course, if you've claimed to be an <em>expert</em> in algorithms analysis on your r\u00e9sum\u00e9/CV, then they might expect you to derive the entire thing! Our main reason for including it here is because it is a nice example of working with an algorithm that is mathematically challenging to analyse.</p>\n<p>Let n be the number we're taking the factorial of.</p>\n<ul>\n<li>\n<p>Time complexity : Worse than O(n2).</p>\n<p>Computing a factorial is repeated multiplication. Generally when we know multiplications are on numbers within a fixed bit-size (e.g. 32 bit or 64 bit ints), we treat them as O(1) operations. However, we can't do that here because the size of the numbers to be multiplied grow with the size of n.</p>\n<p>So, the first step here is to think about what the cost of multiplication might be, given that we can't assume it's O(1). A popular way people multiply two large numbers, that you probably learned in school, has a cost of O((logx)\u22c5(logy)). We'll use that in our approximation.</p>\n<p>Next, let's think about what multiplications we do when calculating n!. The first few multiplications would be as follows:</p>\n<p>1\u22c52=2<br/><br/>\n2\u22c53=6<br/><br/>\n6\u22c54=24<br/><br/>\n24\u22c55=120<br/><br/>\n120\u22c56=720<br/><br/>\n...</p>\n<p>In terms of cost, these multiplications would have costs of:</p>\n<p>log1\u22c5log2<br/><br/>\nlog2\u22c5log3<br/><br/>\nlog6\u22c5log4<br/><br/>\nlog24\u22c5log5<br/><br/>\nlog120\u22c5log6<br/><br/>\n...</p>\n<p>Recognising that the first column are all logs of factorials, we can rewrite it as follows:</p>\n<p>log1!\u22c5log2<br/><br/>\nlog2!\u22c5log3<br/><br/>\nlog3!\u22c5log4<br/><br/>\nlog4!\u22c5log5<br/><br/>\nlog5!\u22c5log6<br/><br/>\n...</p>\n<p>See the pattern? Each line is of the form (logk!)\u22c5(logk+1). What would the <em>last</em> line be? Well, the last step in calculating a factorial is to multiply by n. Therefore, the last line must be:</p>\n<p>log((n\u22121)!)\u22c5log(n)</p>\n<p>Because we're doing each of these multiplications one-by-one, we should <em>add</em> them to get the total time complexity. This gives us:</p>\n<p>log1!\u22c5log2+log2!\u22c5log3+log3!\u22c5log4+\u22ef+log((n\u22122)!)\u22c5log(n\u22121)+log((n\u22121)!)\u22c5logn</p>\n<p>This sequence is quite complicated to add up; instead of trying to find an exact answer, we're going to now focus on a rough <em>lower bound</em> approximation by throwing away the less significant terms. While this is not something you'd do if we needed to find the exact time complexity, it will allow us to quickly see that the time complexity is \"too big\" for our purposes. Often finding lower (and upper) bounds is enough to decide whether or not an algorithm is worth using. This includes in interviews!</p>\n<p>At this point, you'll ideally realise that the algorithm is <em>worse</em> than O(n), as we're adding n terms. Given that the question asked us to come up with an algorithm that's no worse than O(logn), this is definitely not good enough. We're going to explore it a little further, but if you've understood up to this point, you're doing really well! The rest is optional.</p>\n<p>Continuing on, notice that log((n\u22121)!) is \"a lot bigger\" than logn. Therefore, we'll just drop all these parts, leaving the logs of factorials. This gives us:</p>\n<p>log1!+log2!+log,3!+\u22ef+log((n\u22122)!)+log((n\u22121)!)</p>\n<p>The next part involves a log rule that you might or might not have heard of. It's definitely worth remembering if you haven't heard of it though, as it can be very useful.</p>\n<p>O(logn!)=O(nlogn)</p>\n<p>So, let's rewrite the sequence using this rule.</p>\n<p>1\u22c5log1+2\u22c5log2+3\u22c5log3+\u22ef+(n\u22122)\u22c5log(n\u22122)+(n\u22121)\u22c5log(n\u22121)</p>\n<p>Like before, we'll just drop the \"small\" log terms, and see what we're left with.</p>\n<p>1+2+3+...+(n\u22122)+(n\u22121)</p>\n<p>This is a very familiar sequence, that you should be familiar with\u2014it describes a cost of O(n2).</p>\n<p>So, what can we conclude? Well, all the discarding of terms leaves us with a time complexity <em>less</em> than the real one. In other words, this factorial algorithm must be <em>slower</em> than O(n2).</p>\n<p>O(n2) is <em>definitely</em> not good enough!</p>\n<p>While this technique of throwing away terms here and there might seem a bit strange, it's very useful to make early decisions quickly, without needing to mess around with advanced math. Only once we had decided we were interested in looking at the algorithm further, would we try to come up with a more exact time complexity. And in this case, our lower bound was enough to convince us that it definitely isn't worth looking at!</p>\n<p>The second part, counting the zeroes at the end, is insignificant compared to the first part. There are O(logn!)=O(nlogn) digits, which is smaller than O(n2). Not to mention, only a few of them will be zeroes!</p>\n</li>\n<li>\n<p>Space complexity : O(logn!)=O(nlogn).</p>\n<p>In order to store n!, we need O(logn!) bits. As we saw above, this is the same as O(nlogn).</p>\n</li>\n</ul>\n<br/>\n<hr/>\n<h3><a href=\"#approach-2-counting-factors-of-5\"><svg><path></path></svg></a>Approach 2: Counting Factors of 5</h3>\n<p><strong>Intuition</strong></p>\n<p><em>This approach is also too slow, however it's a likely step in the problem solving process for coming up with a logarithmic approach.</em></p>\n<p>Instead of computing the factorial like in Approach 1, we can instead recognize that each 0 on the end of the factorial represents a multiplication by 10.</p>\n<p>So, how many times do we multiply by 10 while calculating n! ? Well, to multiply two numbers, a and b, we're effectively multiplying all their factors together. For example, to do 42\u22c575=3150, we can rewrite it as follows:</p>\n<p>42=2\u22c53\u22c57<br/><br/>\n75=3\u22c55\u22c55<br/><br/>\n42\u22c575=2\u22c53\u22c57\u22c53\u22c55\u22c55</p>\n<p>Now, in order to determine how many zeroes are on the end, we should look at how many complete pairs of 2 and 5 are among the factors. In the case of the example above, we have one 2 and two 5s, giving us <strong>one</strong> complete pair.</p>\n<p>So, how does this relate to factorials? Well, in a factorial we're multiplying <em>all</em> the numbers between 1 and n together, which is the same as multiplying all the factors of the numbers between 1 and n.</p>\n<p>For example, if n=16, we need to look at the factors of all the numbers between 1 and 16. Keeping in mind that only 2s and 5s are of interest, we'll focus on those factors only. The numbers that contain a factor of 5 are 5,10,15. The numbers that contain a factor of 2 are 2,4,6,8,10,12,14,16. Because there are only three numbers with a factor of 5, we can make three complete pairs, and therefore there must be three zeroes on the end of 16!.</p>\n<p>Putting this into an algorithm, we get:</p>\n<pre><code>int twos = 0;\nfor (int i = 1; i &lt;= n; i++) {\n    if (i % 2 == 0) {\n        twos++;\n    }\n}\n\nint fives = 0;\nfor (int i = 1; i &lt;= n; i++) {\n    if (i % 5 == 0) {\n        fives++;\n    }\n}\n\nint tens = Math.min(fives, twos);</code></pre><svg><path></path></svg>\n<p>This gets us most of the way, but it doesn't consider numbers with more than one factor. For example, if <code>i = 25</code>, then we've only done <code>fives += 1</code>. However, we should've done <code>fives += 2</code>, because 25 has <em>two</em> factors of 5.</p>\n<p>Therefore, we need to count the 5 factors in each number. One way we can do this is by having a loop instead of the if statement, where each time we determine <code>i</code> has a 5 factor, we divide that 5 out. The loop will then repeat if there are further remaining 5 factors.</p>\n<p>We can do that like this:</p>\n<pre><code>int twos = 0;\nfor (int i = 1; i &lt;= n; i++) {\n    int remainingI = i;\n    while (remainingI % 2 == 0) {\n        twos++;\n        remainingI /= 2;\n    }\n}\n\nint fives = 0;\nfor (int i = 1; i &lt;= n; i++) {\n    int remainingI = i;\n    while (remainingI % 5 == 0) {\n        fives++;\n        remainingI /= 5;\n    }\n}\n\nint tens = Math.min(twos, fives);</code></pre><svg><path></path></svg>\n<p>This gives us the right answer now. However, there are still some improvements we can make.</p>\n<p>Firstly, we can notice that <code>twos</code> is <strong>always bigger</strong> than <code>fives</code>. Why? Well, every second number counts for a 2 factor, but only every fifth number counts as a 5 factor. Similarly every 4th number counts as an additional 2 factor, yet only every 25th number counts an additional 5 factor. This goes on and on for each power of 2 and 5. Here's a visualisation that illustrates how the density between 2 factors and 5 factors differs.</p>\n<p></p>\n<p>As such, we can simply remove the whole <code>twos</code> calculation, leaving us with:</p>\n<pre><code>int fives = 0;\nfor (int i = 1; i &lt;= n; i++) {\n    int remainingI = i;\n    while (remainingI % 5 == 0) {\n        fives++;\n        remainingI /= 5;\n    }\n}\n\nint tens = fives;</code></pre><svg><path></path></svg>\n<p>There is one final optimization we can do. In the above algorithm, we analyzed <em>every</em> number from 1 to n. However, only 5,10,15,20,25,30,...etc even have at least one factor of 5. So, instead of going up in steps of 1, we can go up in steps of 5. Making this modification gives us:</p>\n<pre><code>int fives = 0;\nfor (int i = 5; i &lt;= n; i += 5) {\n    int remainingI = i;\n    while (remainingI % 5 == 0) {\n        fives++;\n        remainingI /= 5;\n    }\n}\n\nint tens = fives;</code></pre><svg><path></path></svg>\n<p><strong>Algorithm</strong></p>\n<p>Here's the algorithm as we designed it above.</p>\n<pre><code>class Solution {\n    public int trailingZeroes(int n) {\n        int zeroCount = 0;\n        for (int i = 5; i &lt;= n; i += 5) {\n            int currentFactor = i;\n            while (currentFactor % 5 == 0) {\n                zeroCount++;\n                currentFactor /= 5;\n            }\n        }\n        return zeroCount;\n    }\n}</code></pre>\n<p>Alternatively, instead of dividing by 5 each time, we can check each power of 5 to count how many times 5 is a factor. This works by checking if <code>i</code> is divisible by 5, then 25, then 125, etc. We stop when this number does not divide into <code>i</code> without leaving a remainder. The number of times we can do this is equivalent to the number of 5 factors in <code>i</code>.</p>\n<pre><code>class Solution {\n    public int trailingZeroes(int n) {\n        int zeroCount = 0;\n        for (int i = 5; i &lt;= n; i += 5) {\n            int powerOf5 = 5;\n            while (i % powerOf5 == 0) {\n                zeroCount++;\n                powerOf5 *= 5;\n            }\n        }\n        return zeroCount;\n    }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : O(n).</p>\n<p>In Approach 1, we couldn't treat division as O(1), because we went well outside the 32-bit integer range. In this Approach though, we stay within it, and so can treat division and multiplication as O(1).</p>\n<p>To calculate the zero count, we loop through every fifth number from 5 to n, this is O(n) steps (the 5<sup>\u22121</sup> is treated as a constant).</p>\n<p>At each step, while it might look like we do a O(logn) operation to count the number of fives, it actually amortizes to O(1), because the vast majority of numbers checked only contain a single factor of 5. It can be proven that the total number of fives is less than 5<sup>2</sup>\u22c5n.</p>\n<p>So we get O(n)\u22c5O(1)=O(n).</p>\n</li>\n<li>\n<p>Space complexity : O(1).</p>\n<p>We use only a fixed number of integer variables, therefore the space complexity is O(1).</p>\n</li>\n</ul>\n<br/>\n<hr/>\n<h3><a href=\"#approach-3-counting-factors-of-5-efficiently\"><svg><path></path></svg></a>Approach 3: Counting Factors of 5 Efficiently</h3>\n<p><strong>Intuition</strong></p>\n<p>In Approach 2, we found a way to count the number of zeroes in the factorial, <em>without</em> actually calculating the factorial. This was by looping over each multiple of 5, from 5 up to n, and counting how many factors of 5 were in each multiple of 5. We added all these counts together to get our final result.</p>\n<p>However, Approach 2 was still too slow, both for practical means, and for the requirements of the question. To come up with a sufficient algorithm, we need to make one final observation. This observation will allow us to calculate our answer in logarithmic time.</p>\n<p>Consider our simplified (but incorrect) algorithm that counted each multiple of 5. Recall that the reason it's incorrect is because it won't count both the 5 factors in numbers such as 25, for example.</p>\n<pre><code>int fives = 0;\nfor (int i = 1; i &lt;= n; i++) {\n    if (i % 5 == 0) {\n        fives++;\n    }\n}</code></pre><svg><path></path></svg>\n<p>If you think about this overly simplified algorithm a little, you might notice that this is simply an inefficient way of performing integer division for 5n. Why? Well, by counting the number of multiples of 5 up to n, we're just counting how many 5s go into n. That's the <em>exact</em> definition of integer division!</p>\n<p>So, a way of simplifying the above algorithm is as follows.</p>\n<pre><code>int fives = n / 5;\nint tens = fives;</code></pre><svg><path></path></svg>\n<p>So, how can we fix the \"duplicate factors\" problem? Observe that <em>all</em> numbers that have (at least) two factors of 5 are multiples of 25. Like with the 5 factors, we can simply divide by 25 to find how many multiples of 25 are below n. Also, notice that because we've already counted the multiples of 25 in 5n once, we only need to count n / 25 extra factors of 5 (not 2\u22c5(n / 25)), as this is one extra for each multiple of 25.</p>\n<p>So combining this together we get:</p>\n<pre><code>int fives = n / 5 + n / 25;\nint tens = fives;</code></pre><svg><path></path></svg>\n<p>We still aren't there yet though! What about the numbers which contain <em>three</em> factors of 5 (the multiples of 125). We've only counted them twice! In order to get our final result, we'll need to add together all of n / 5, n / 25, n / 125, n / 625, and so on. This gives us:</p>\n<p>fives = n / 5 + n / 25 + n / 125 + n / 625 + n / 3125 + \u22ef</p>\n<p>This might look like it goes on forever, but it doesn't! Remember that we're using <strong>integer division</strong>. Eventually, the denominator will be <em>larger than</em> n, and so all the terms from there will be 0. Therefore, we can stop once the term is 0.</p>\n<p>For example with n=12345 we get:</p>\n<p>fives = 12345 / 5 + 12345 / 25 + 12345 / 125 + 12345 / 625 + 12345 / 3125 + 12345 / 15625 + \u22ef</p>\n<p>Which is equal to:</p>\n<p>fives = 2469 + 493 + 98 + 19 + 3 + 0 + \u22ef = 3082</p>\n<p>In code, we can do this by looping over each power of 5, calculating how many times it divides into n, and then adding that to a running <code>fives</code> count. Once we have a power of 5 that's bigger than n, we stop and return the final value of <code>fives</code>.</p>\n<pre><code>int fives = 0;\nlong powerOf5 = 5;\nwhile (n &gt;= powerOf5) {\n    fives += n / powerOf5;\n    powerOf5 *= 5;\n}\n\nint tens = fives;</code></pre><svg><path></path></svg>\n<p><strong>Algorithm</strong></p>\n<pre><code>class Solution {\n    public int trailingZeroes(int n) {\n        int zeroCount = 0;\n        long currentMultiple = 5;\n        while (n &gt;= currentMultiple) {\n            zeroCount += n / currentMultiple;\n            currentMultiple *= 5;\n        }\n        return zeroCount;\n    }\n}</code></pre>\n<p>An alternative way of writing this algorithm, is instead of trying each power of 5, we can instead divide n itself by 5 each time. This works out the same because we wind up with the sequence:</p>\n<p>fives = n / 5 + (n / 5) / 5 + ((n / 5) / 5) / 5 + \u22ef</p>\n<p>Notice that on the second step, we have (n / 5) / 5. This is because the previous step divided n itself by 5. And so on.</p>\n<p>If you're familiar with the rules of fractions, you'll notice that (n / 5) / 5 is just the same thing as n / 25. This means the sequence is exactly the same as:</p>\n<p>n / 5 + n / 25 + n / 125 + \u22ef</p>\n<p>So, this alternative way of writing the algorithm is equivalent.</p>\n<pre><code>class Solution {\n    public int trailingZeroes(int n) {\n        int zeroCount = 0;\n        while (n &gt; 0) {\n            n /= 5;\n            zeroCount += n;\n        }\n        return zeroCount;\n    }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : O(logn).</p>\n<p>In this approach, we divide n by each power of 5. By definition, there are log<sub>5</sub>n powers of 5 less-than-or-equal-to n. Because the multiplications and divisions are within the 32-bit integer range, we treat these calculations as O(1). Therefore, we are doing log<sub>5</sub>n\u22c5O(1)=O(logn) operations (keeping in mind that log bases are insignificant in big-oh notation).</p>\n</li>\n<li>\n<p>Space complexity : O(1).</p>\n<p>We use only a fixed number of integer variables, therefore the space complexity is O(1).</p>\n</li>\n</ul>\n<br/>",
        "isOfficial": true,
        "scrapedAt": "2026-02-18T07:43:00.046Z"
    }
}