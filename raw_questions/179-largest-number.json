{
    "questionId": "179",
    "questionFrontendId": "179",
    "title": "Largest Number",
    "titleSlug": "largest-number",
    "content": "<p>Given a list of non-negative integers <code>nums</code>, arrange them such that they form the largest number and return it.</p>\n\n<p>Since the result may be very large, so you need to return a string instead of an integer.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [10,2]\n<strong>Output:</strong> &quot;210&quot;\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,30,34,5,9]\n<strong>Output:</strong> &quot;9534330&quot;\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
    "difficulty": "Medium",
    "stats": "{\"totalAccepted\": \"801.3K\", \"totalSubmission\": \"1.9M\", \"totalAcceptedRaw\": 801334, \"totalSubmissionRaw\": 1883900, \"acRate\": \"42.5%\"}",
    "hints": [],
    "similarQuestions": "[{\"title\": \"Smallest Value of the Rearranged Number\", \"titleSlug\": \"smallest-value-of-the-rearranged-number\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Find the Key of the Numbers\", \"titleSlug\": \"find-the-key-of-the-numbers\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
    "topicTags": [
        {
            "name": "Array",
            "slug": "array"
        },
        {
            "name": "String",
            "slug": "string"
        },
        {
            "name": "Greedy",
            "slug": "greedy"
        },
        {
            "name": "Sorting",
            "slug": "sorting"
        }
    ],
    "companyTags": null,
    "codeSnippets": [
        {
            "lang": "Java",
            "langSlug": "java",
            "code": "class Solution {\n    public String largestNumber(int[] nums) {\n        \n    }\n}"
        }
    ],
    "solution": {
        "content": "<h2><a href=\"#solution\"><svg><path></path></svg></a>Solution</h2>\n<hr/>\n<h3><a href=\"#overview\"><svg><path></path></svg></a>Overview</h3>\n<p>We need to arrange a list of non-negative integers such that their concatenation results in the largest possible number. Return this largest number as a string.</p>\n<p>To solve this, we use a custom comparator\u2014a function or object that defines how two elements are compared for sorting. It\u2019s used when the default comparison operations (like <code>&lt;</code> or <code>&gt;</code>) do not fit the requirements of a particular task. In this case, we want to compare numbers based on the result of their concatenation in two different orders.</p>\n<p>First, we convert each integer to a string. Then, we sort the array of strings.</p>\n<p>Sorting the numbers in descending order might seem like a good idea, but it leads to issues when numbers share the same leading digit. For example, sorting <code>[9, 5, 34, 3, 30]</code> in descending order gives <code>\"9534303\"</code>, but the correct answer is <code>\"9534330\"</code>. The problem arises because <code>\"3\"</code> and <code>\"30\"</code> share the same leading digit.</p>\n<p>To fix this, we compare the concatenated results of pairs of numbers. For example, given two numbers <code>a</code> and <code>b</code>, we compare <code>a + b</code> and <code>b + a</code> (where <code>+</code> denotes string concatenation). If <code>a + b</code> is larger, we place <code>a</code> before <code>b</code>. This ensures that the numbers are ordered correctly for the largest possible result.</p>\n<p>The key is that this comparison ensures that the greedy approach of comparing pairs of numbers leads to the correct result. The difficult part is proving that this greedy logic always gives the correct answer.</p>\n<h5>Proof of Correctness</h5>\n<p>Objective: To ensure that our custom comparator for sorting numbers produces the largest possible concatenated number.</p>\n<ol>\n<li>\n<p>Transitivity of the Comparator:</p>\n<p>To verify the validity of the comparator, we need to prove that it is transitive. In other words, if number <code>A</code> should come before <code>B</code>, and <code>B</code> should come before <code>C</code>, then <code>A</code> must come before <code>C</code> in the final order.</p>\n<p>We define the function:</p>\nf(X)\u200b=10lg(X)+1\u200b\n<p>where lg(X) denotes the logarithm base 10 of X. This function helps in determining the power of 10 needed to position <code>X</code> correctly when concatenating.</p>\n</li>\n<li>\n<p>Comparator Verification:</p>\n<p>If concatenating <code>A</code> and <code>B</code> as <code>AB</code> is less than or equal to <code>BA</code>, we need to verify that:</p>\nf(B)A+B(f(B)\u22121)AA\u200b\u2264f(A)B+A\u2264(f(A)\u22121)B\u2264f(B)\u22121B\u22c5(f(A)\u22121)\u200b\u200b\n<p>Similarly, if <code>B</code> and <code>C</code> satisfy:</p>\nBC(f(C)\u22121)BB\u200b\u2264CB\u2264(f(B)\u22121)C\u2264f(C)\u22121C\u22c5(f(B)\u22121)\u200b\u200b\n</li>\n<li>\n<p>By Combining These Inequalities:</p>\nA(f(C)\u22121)Af(C)A+CAC\u200b\u2264f(C)\u22121C\u22c5(f(A)\u22121)\u200b\u2264(f(A)\u22121)C\u2264f(A)C+A\u2264CA\u200b\n<p>This demonstrates that if <code>A</code> is before <code>B</code> and <code>B</code> is before <code>C</code>, then <code>A</code> must come before <code>C</code>, maintaining a consistent ordering.</p>\n</li>\n<li>\n<p>By Establishing the Consistency of the Comparator:</p>\n<p>We confirm that sorting numbers with this comparator yields the largest concatenated number. For example, sorting <code>[3, 30, 34, 5, 9]</code> yields <code>[9, 5, 34, 3, 30]</code>, which concatenates to <code>\"9534330\"</code>, the largest possible number.</p>\n</li>\n</ol>\n<hr/>\n<h3><a href=\"#approach-1-using-built-in-function\"><svg><path></path></svg></a>Approach 1: Using Built-in Function</h3>\n<h4>Intuition</h4>\n<p>To begin with, we need to determine the best order for the numbers to form the largest possible number when concatenated. We first convert each integer in the list to a string. This conversion allows us to compare different concatenated results. For instance, if we have the numbers <code>56</code> and <code>9</code>, converting them to strings allows us to compare <code>\"569\"</code> and <code>\"956\"</code>.</p>\n<p>Next, we use a custom sorting function to order these strings. This function compares two strings, <code>a</code> and <code>b</code>, by evaluating <code>a + b</code> against <code>b + a</code>. If <code>a + b</code> is greater, then <code>a</code> should come before <code>b</code> in the sorted list to maximize the final result.</p>\n<p>Once sorted, we concatenate all the strings. If the first element in this sorted list is \"0\", it indicates that all numbers were zeros, so the largest number possible is \"0\". In this case, we return \"0\". If not, we return the concatenated result.</p>\n<h4>Algorithm</h4>\n<ul>\n<li>\n<p>Initialize <code>numStrings</code> as an array of strings to hold string representations of numbers.</p>\n</li>\n<li>\n<p>Convert each integer in <code>nums</code> to a string and store it in <code>numStrings</code>.</p>\n</li>\n<li>\n<p>Sort <code>numStrings</code> based on concatenated values:</p>\n<ul>\n<li>Use a lambda function to compare concatenated results (<code>a + b</code> and <code>b + a</code>).</li>\n<li>Ensure that the concatenation which forms a larger number determines the order.</li>\n</ul>\n</li>\n<li>\n<p>Check if the largest number formed is \"0\":</p>\n<ul>\n<li>If the first element in <code>numStrings</code> is \"0\", return \"0\" (handles cases where all numbers are zero).</li>\n</ul>\n</li>\n<li>\n<p>Concatenate all strings in <code>numStrings</code> to form the largest number.</p>\n</li>\n<li>\n<p>Return the concatenated result as the largest number.</p>\n</li>\n</ul>\n<h4>Implementation</h4>\n<pre><code>class Solution {\n    public String largestNumber(int[] nums) {\n        List&lt;String&gt; numStrings = new ArrayList&lt;&gt;();\n        // Convert each integer to a string\n        for (int num : nums) {\n            numStrings.add(String.valueOf(num));\n        }\n\n        // Sort strings based on concatenated values\n        Collections.sort(numStrings, (a, b) -&gt; (b + a).compareTo(a + b));\n\n        // Handle the case where the largest number is zero\n        if (numStrings.get(0).equals(\"0\")) return \"0\";\n\n        // Concatenate sorted strings to form the largest number\n        StringBuilder largestNum = new StringBuilder();\n        for (String numStr : numStrings) {\n            largestNum.append(numStr);\n        }\n\n        return largestNum.toString();\n    }\n}</code></pre>\n<h4>Complexity Analysis</h4>\n<p>Let n be the size of the <code>nums</code> array.</p>\n<ul>\n<li>\n<p>Time Complexity: O(nlogn)</p>\n<p>The most time-consuming operation is the sorting step, which uses a custom comparator. The sorting algorithm has a time complexity of O(nlogn). The conversion of numbers to strings and concatenation operations are linear with respect to the number of elements.</p>\n</li>\n<li>\n<p>Space Complexity: O(n+S)</p>\n<p>Additional space is used for storing the string representations of the numbers and the final concatenated result, which scales linearly with the size of the input array.</p>\n<p>Some extra space is used when we sort an array of size n in place. The space complexity of the sorting algorithm (S) depends on the programming language. The value of S depends on the programming language and the sorting algorithm being used:</p>\n<ul>\n<li>In Python, the sort method sorts a list using the Timsort algorithm which is a combination of Merge Sort and Insertion Sort and has a space complexity of O(n)</li>\n<li>In Java, <code>Collections.sort()</code> uses Timsort with a worst-case space complexity of O(n)</li>\n</ul>\n<p>Thus, the total space complexity of the algorithm is O(n+S).</p>\n</li>\n</ul>\n<hr/>\n<h3><a href=\"#approach-2-quick-sort\"><svg><path></path></svg></a>Approach 2: Quick Sort</h3>\n<h4>Implementation</h4>\n<pre><code>class Solution {\n    public String largestNumber(int[] nums) {\n        quickSort(nums, 0, nums.length - 1);\n        StringBuilder largestNum = new StringBuilder();\n        for (int num : nums) {\n            largestNum.append(num);\n        }\n        return largestNum.charAt(0) == '0' ? \"0\" : largestNum.toString();\n    }\n\n    private void quickSort(int[] nums, int left, int right) {\n        if (left &gt;= right) return;\n        int pivotIndex = partition(nums, left, right);\n        quickSort(nums, left, pivotIndex - 1);\n        quickSort(nums, pivotIndex + 1, right);\n    }\n\n    private int partition(int[] nums, int left, int right) {\n        int pivot = nums[right];\n        int lowIndex = left;\n        for (int i = left; i &lt; right; i++) {\n            if (compare(nums[i], pivot)) {\n                int temp = nums[i];\n                nums[i] = nums[lowIndex];\n                nums[lowIndex] = temp;\n                lowIndex++;\n            }\n        }\n        int temp = nums[lowIndex];\n        nums[lowIndex] = nums[right];\n        nums[right] = temp;\n        return lowIndex;\n    }\n\n    private boolean compare(int a, int b) {\n        return (String.valueOf(a) + b).compareTo(String.valueOf(b) + a) &gt; 0;\n    }\n}</code></pre>\n<hr/>\n<h3><a href=\"#approach-3-merge-sort\"><svg><path></path></svg></a>Approach 3: Merge Sort</h3>\n<h4>Implementation</h4>\n<pre><code>class Solution {\n    public String largestNumber(int[] nums) {\n        nums = mergeSort(nums, 0, nums.length - 1);\n        StringBuilder largestNum = new StringBuilder();\n        for (int num : nums) {\n            largestNum.append(num);\n        }\n        return largestNum.charAt(0) == '0' ? \"0\" : largestNum.toString();\n    }\n\n    private int[] mergeSort(int[] nums, int left, int right) {\n        if (left == right) return new int[]{nums[left]};\n        int mid = left + (right - left) / 2;\n        int[] leftHalf = mergeSort(nums, left, mid);\n        int[] rightHalf = mergeSort(nums, mid + 1, right);\n        return merge(leftHalf, rightHalf);\n    }\n\n    private int[] merge(int[] left, int[] right) {\n        int[] result = new int[left.length + right.length];\n        int i = 0, j = 0, k = 0;\n        while (i &lt; left.length &amp;&amp; j &lt; right.length) {\n            if (compare(left[i], right[j])) {\n                result[k++] = left[i++];\n            } else {\n                result[k++] = right[j++];\n            }\n        }\n        while (i &lt; left.length) result[k++] = left[i++];\n        while (j &lt; right.length) result[k++] = right[j++];\n        return result;\n    }\n\n    private boolean compare(int a, int b) {\n        return (String.valueOf(a) + b).compareTo(String.valueOf(b) + a) &gt; 0;\n    }\n}</code></pre>\n<hr/>\n<h3><a href=\"#approach-4-heapsort\"><svg><path></path></svg></a>Approach 4: HeapSort</h3>\n<h4>Implementation</h4>\n<pre><code>class Solution {\n    public String largestNumber(int[] nums) {\n        PriorityQueue&lt;String&gt; maxHeap = new PriorityQueue&lt;&gt;(\n            (a, b) -&gt; (b + a).compareTo(a + b)\n        );\n\n        int totalLength = 0;\n        for (int num : nums) {\n            String s = String.valueOf(num);\n            totalLength += s.length();\n            maxHeap.offer(s);\n        }\n\n        StringBuilder result = new StringBuilder(totalLength);\n        while (!maxHeap.isEmpty()) {\n            result.append(maxHeap.poll());\n        }\n\n        return result.length() == 0 || result.charAt(0) == '0' ? \"0\" : result.toString();\n    }\n}</code></pre>\n<hr/>\n<h3><a href=\"#approach-5-timsort\"><svg><path></path></svg></a>Approach 5: TimSort</h3>\n<h4>Implementation</h4>\n<pre><code>class Solution {\n    public String largestNumber(int[] nums) {\n        Integer[] arr = Arrays.stream(nums).boxed().toArray(Integer[]::new);\n        Arrays.sort(arr, (a, b) -&gt; (String.valueOf(b) + a).compareTo(String.valueOf(a) + b));\n\n        StringBuilder largestNum = new StringBuilder();\n        for (int num : arr) {\n            largestNum.append(num);\n        }\n        return largestNum.charAt(0) == '0' ? \"0\" : largestNum.toString();\n    }\n}</code></pre>\n<hr/>\n<br/>\n<br/>\n<h3><a href=\"#further-thoughts\"><svg><path></path></svg></a>Further Thoughts:</h3>\n<p>You might be wondering why merging is most effective when the number of runs is equal to or just below a power of two, and why it becomes less efficient when the number of runs exceeds this number.</p>\n<p>The main reason for this is that merging is most balanced when the number of runs is a power of two. In general, if the data is randomly ordered, each run will typically be about the size of <code>minrun</code>. When the number of runs matches a power of two, merging operations can proceed in a perfectly balanced manner throughout the process. This balance minimizes the number of comparisons and data movements needed.</p>\n<p>If the number of runs is slightly more than a power of two, the merging process becomes less balanced. This imbalance results in inefficient merges, as you end up with uneven merge sizes, leading to increased comparisons and data movement.</p>\n<p>Conversely, if the number of runs is slightly fewer than a power of two, the merges remain relatively balanced, although not perfectly. This slight imbalance causes only a minor increase in inefficiency compared to the ideal scenario.</p>\n<p>For example, if you have nine natural runs with lengths of 800, 100, 100, 100, 100, 100, 100, 100, and 100 elements, the merges will still be well-balanced, even though the number of runs is slightly above a power of two.</p>\n<p>Tim Peters talks about this in his <a href=\"https://github.com/python/cpython/blob/main/Objects/listsort.txt\">listsort.txt</a> file.</p>\n<hr/>",
        "isOfficial": true,
        "scrapedAt": "2026-02-18T08:18:13.206Z"
    }
}