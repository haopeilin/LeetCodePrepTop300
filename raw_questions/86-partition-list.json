{
    "questionId": "86",
    "questionFrontendId": "86",
    "title": "Partition List",
    "titleSlug": "partition-list",
    "content": "<p>Given the <code>head</code> of a linked list and a value <code>x</code>, partition it such that all nodes <strong>less than</strong> <code>x</code> come before nodes <strong>greater than or equal</strong> to <code>x</code>.</p>\n\n<p>You should <strong>preserve</strong> the original relative order of the nodes in each of the two partitions.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"images/86/partition.jpg\" style=\"width: 662px; height: 222px;\" />\n<pre>\n<strong>Input:</strong> head = [1,4,3,2,5,2], x = 3\n<strong>Output:</strong> [1,2,2,4,3,5]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> head = [2,1], x = 2\n<strong>Output:</strong> [1,2]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the list is in the range <code>[0, 200]</code>.</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n\t<li><code>-200 &lt;= x &lt;= 200</code></li>\n</ul>\n",
    "difficulty": "Medium",
    "stats": "{\"totalAccepted\": \"875.4K\", \"totalSubmission\": \"1.4M\", \"totalAcceptedRaw\": 875406, \"totalSubmissionRaw\": 1445827, \"acRate\": \"60.5%\"}",
    "hints": [],
    "similarQuestions": "[{\"title\": \"Partition Array According to Given Pivot\", \"titleSlug\": \"partition-array-according-to-given-pivot\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
    "topicTags": [
        {
            "name": "Linked List",
            "slug": "linked-list"
        },
        {
            "name": "Two Pointers",
            "slug": "two-pointers"
        }
    ],
    "companyTags": null,
    "codeSnippets": [
        {
            "lang": "C++",
            "langSlug": "cpp",
            "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* partition(ListNode* head, int x) {\n        \n    }\n};"
        },
        {
            "lang": "Java",
            "langSlug": "java",
            "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode partition(ListNode head, int x) {\n        \n    }\n}"
        },
        {
            "lang": "Python3",
            "langSlug": "python3",
            "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def partition(self, head: Optional[ListNode], x: int) -> Optional[ListNode]:\n        "
        },
        {
            "lang": "Python",
            "langSlug": "python",
            "code": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def partition(self, head, x):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :type x: int\n        :rtype: Optional[ListNode]\n        \"\"\"\n        "
        },
        {
            "lang": "JavaScript",
            "langSlug": "javascript",
            "code": "/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} x\n * @return {ListNode}\n */\nvar partition = function(head, x) {\n    \n};"
        },
        {
            "lang": "TypeScript",
            "langSlug": "typescript",
            "code": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\nfunction partition(head: ListNode | null, x: number): ListNode | null {\n    \n};"
        },
        {
            "lang": "C#",
            "langSlug": "csharp",
            "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int val=0, ListNode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode Partition(ListNode head, int x) {\n        \n    }\n}"
        },
        {
            "lang": "C",
            "langSlug": "c",
            "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\nstruct ListNode* partition(struct ListNode* head, int x) {\n    \n}"
        },
        {
            "lang": "Go",
            "langSlug": "golang",
            "code": "/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc partition(head *ListNode, x int) *ListNode {\n    \n}"
        },
        {
            "lang": "Kotlin",
            "langSlug": "kotlin",
            "code": "/**\n * Example:\n * var li = ListNode(5)\n * var v = li.`val`\n * Definition for singly-linked list.\n * class ListNode(var `val`: Int) {\n *     var next: ListNode? = null\n * }\n */\nclass Solution {\n    fun partition(head: ListNode?, x: Int): ListNode? {\n        \n    }\n}"
        },
        {
            "lang": "Swift",
            "langSlug": "swift",
            "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public var val: Int\n *     public var next: ListNode?\n *     public init() { self.val = 0; self.next = nil; }\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\n * }\n */\nclass Solution {\n    func partition(_ head: ListNode?, _ x: Int) -> ListNode? {\n        \n    }\n}"
        },
        {
            "lang": "Rust",
            "langSlug": "rust",
            "code": "// Definition for singly-linked list.\n// #[derive(PartialEq, Eq, Clone, Debug)]\n// pub struct ListNode {\n//   pub val: i32,\n//   pub next: Option<Box<ListNode>>\n// }\n// \n// impl ListNode {\n//   #[inline]\n//   fn new(val: i32) -> Self {\n//     ListNode {\n//       next: None,\n//       val\n//     }\n//   }\n// }\nimpl Solution {\n    pub fn partition(head: Option<Box<ListNode>>, x: i32) -> Option<Box<ListNode>> {\n        \n    }\n}"
        },
        {
            "lang": "Ruby",
            "langSlug": "ruby",
            "code": "# Definition for singly-linked list.\n# class ListNode\n#     attr_accessor :val, :next\n#     def initialize(val = 0, _next = nil)\n#         @val = val\n#         @next = _next\n#     end\n# end\n# @param {ListNode} head\n# @param {Integer} x\n# @return {ListNode}\ndef partition(head, x)\n    \nend"
        },
        {
            "lang": "PHP",
            "langSlug": "php",
            "code": "/**\n * Definition for a singly-linked list.\n * class ListNode {\n *     public $val = 0;\n *     public $next = null;\n *     function __construct($val = 0, $next = null) {\n *         $this->val = $val;\n *         $this->next = $next;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param ListNode $head\n     * @param Integer $x\n     * @return ListNode\n     */\n    function partition($head, $x) {\n        \n    }\n}"
        },
        {
            "lang": "Dart",
            "langSlug": "dart",
            "code": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *   int val;\n *   ListNode? next;\n *   ListNode([this.val = 0, this.next]);\n * }\n */\nclass Solution {\n  ListNode? partition(ListNode? head, int x) {\n    \n  }\n}"
        },
        {
            "lang": "Scala",
            "langSlug": "scala",
            "code": "/**\n * Definition for singly-linked list.\n * class ListNode(_x: Int = 0, _next: ListNode = null) {\n *   var next: ListNode = _next\n *   var x: Int = _x\n * }\n */\nobject Solution {\n    def partition(head: ListNode, x: Int): ListNode = {\n        \n    }\n}"
        },
        {
            "lang": "Elixir",
            "langSlug": "elixir",
            "code": "# Definition for singly-linked list.\n#\n# defmodule ListNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           next: ListNode.t() | nil\n#         }\n#   defstruct val: 0, next: nil\n# end\n\ndefmodule Solution do\n  @spec partition(head :: ListNode.t | nil, x :: integer) :: ListNode.t | nil\n  def partition(head, x) do\n    \n  end\nend"
        },
        {
            "lang": "Erlang",
            "langSlug": "erlang",
            "code": "%% Definition for singly-linked list.\n%%\n%% -record(list_node, {val = 0 :: integer(),\n%%                     next = null :: 'null' | #list_node{}}).\n\n-spec partition(Head :: #list_node{} | null, X :: integer()) -> #list_node{} | null.\npartition(Head, X) ->\n  ."
        },
        {
            "lang": "Racket",
            "langSlug": "racket",
            "code": "; Definition for singly-linked list:\n#|\n\n; val : integer?\n; next : (or/c list-node? #f)\n(struct list-node\n  (val next) #:mutable #:transparent)\n\n; constructor\n(define (make-list-node [val 0])\n  (list-node val #f))\n\n|#\n\n(define/contract (partition head x)\n  (-> (or/c list-node? #f) exact-integer? (or/c list-node? #f))\n  )"
        }
    ],
    "solution": {
        "content": "<div class=\"flex flex-col w-full\" style=\"position: relative;\"><div class=\"mYe_l WRmCx\"><h2 id=\"solution\" level=\"2\" class=\"group/heading relative\"><a href=\"#solution\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" aria-hidden=\"true\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"link\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" role=\"img\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 640 512\" spacing=\"square\"><path fill=\"currentColor\" d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\"></path></svg></div></a>Solution</h2>\n<p>The problem wants us to reform the linked list structure, such that the<br>\nelements lesser that a certain value <code>x</code>, come before the elements greater or<br>\nequal to <code>x</code>. This essentially means in this reformed list, there would be a<br>\npoint in the linked list <code>before</code> which all the elements would be smaller than<br>\n<code>x</code> and <code>after</code> which all the elements would be greater or equal to <code>x</code>.<br>\nLet's call this point as the <code>JOINT</code>.</p>\n\n<img alt=\"\" width=\"700\" src=\"../Figures/86/86_Partition_List_1.png\">\n\n<p>Reverse engineering the question tells us that if we break the reformed list<br>\nat the <code>JOINT</code>, we will get two smaller linked lists, one with lesser elements<br>\nand the other with elements greater or equal to <code>x</code>. In the solution, our main aim<br>\nis to create these two linked lists and join them.</p>\n<h3 id=\"approach-1-two-pointer-approach\" level=\"3\" class=\"group/heading relative\"><a href=\"#approach-1-two-pointer-approach\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" aria-hidden=\"true\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"link\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" role=\"img\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 640 512\" spacing=\"square\"><path fill=\"currentColor\" d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\"></path></svg></div></a>Approach 1: Two Pointer Approach</h3>\n<p><strong>Intuition</strong></p>\n<p>We can take two pointers <code>before</code> and <code>after</code> to keep track of the two linked<br>\nlists as described above. These two pointers could be<br>\nused two create two separate lists and then these lists could be combined to<br>\nform the desired reformed list.</p>\n<p><strong>Algorithm</strong></p>\n<ol>\n<li data-length=\"1\">\n<p>Initialize two pointers <code>before</code> and <code>after</code>. In the implementation we have<br>\ninitialized these two with a dummy <code>ListNode</code>. This helps to reduce the number<br>\nof conditional checks we would need otherwise. You can try an implementation<br>\nwhere you don't initialize with a dummy node and see it yourself!</p>\n \n <img alt=\"\" width=\"400\" src=\"../Figures/86/86_Partition_List_2.png\">\n \n Dummy Node Initialization<br>\n</li>\n<li data-length=\"1\">\n<p>Iterate the original linked list, using the <code>head</code> pointer.</p>\n</li>\n<li data-length=\"1\">\n<p>If the node's value pointed by <code>head</code> is <em>lesser</em> than <code>x</code>, the node should<br>\nbe part of the <code>before</code> list. So we move it to <code>before</code> list.</p>\n \n <img alt=\"\" width=\"700\" src=\"../Figures/86/86_Partition_List_3.png\">\n \n</li>\n<li data-length=\"1\">\n<p>Else, the node should be part of <code>after</code> list. So we move it to <code>after</code> list.</p>\n \n <img alt=\"\" width=\"700\" src=\"../Figures/86/86_Partition_List_4.png\">\n \n</li>\n<li data-length=\"1\">\n<p>Once we are done with all the nodes in the original linked list, we would<br>\nhave two list <code>before</code> and <code>after</code>. The original list nodes are either part of<br>\n<code>before</code> list or <code>after</code> list, depending on its value.</p>\n \n <img alt=\"\" width=\"700\" src=\"../Figures/86/86_Partition_List_5.png\">\n \n<p><em><code>Note:</code> Since we traverse the original linked list from left to right,<br>\nat no point would the order of nodes change relatively in the two lists. Another important thing to note here is that we show the original linked list intact in the above diagrams. However, in the implementation, we remove the nodes from the original linked list and attach them in the before or after list. We don't utilize any additional space. We simply move the nodes from the original list around.</em></p>\n</li>\n<li data-length=\"1\">\n<p>Now, these two lists <code>before</code> and <code>after</code> can be combined to form the reformed list.</p>\n \n <img alt=\"\" width=\"700\" src=\"../Figures/86/86_Partition_List_6.png\">\n \n</li>\n</ol>\n<p>We did a dummy node initialization at the start to make implementation<br>\neasier, you don't want that to be part of the returned list, hence just<br>\nmove ahead one node in both the lists while combining the two list. Since both<br>\nbefore and after have an extra node at the front.</p>\n<pre><code>class Solution {\npublic:\n    ListNode* partition(ListNode* head, int x) {\n        ListNode* before_head = new ListNode(0);\n        ListNode* before = before_head;\n        ListNode* after_head = new ListNode(0);\n        ListNode* after = after_head;\n        while (head != NULL) {\n            if (head-&gt;val &lt; x) {\n                before-&gt;next = head;\n                before = before-&gt;next;\n            } else {\n                after-&gt;next = head;\n                after = after-&gt;next;\n            }\n            head = head-&gt;next;\n        }\n        after-&gt;next = NULL;\n        before-&gt;next = after_head-&gt;next;\n        return before_head-&gt;next;\n    }\n};</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time Complexity: <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span></span>, where <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span></span></span></span></span> is the number of nodes in the original<br>\nlinked list and we iterate the original list.</li>\n<li>Space Complexity: <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></span>, we have not utilized any extra space, the point to<br>\nnote is that we are reforming the original list, by moving the original nodes, we<br>\nhave not used any extra space as such.</li>\n</ul></div><span style=\"font-size: 0px; line-height: 0;\">&nbsp;</span></div>",
        "isOfficial": true,
        "scrapedAt": "2026-02-18T07:32:52.570Z"
    }
}