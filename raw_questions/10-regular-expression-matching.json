{
    "questionId": "10",
    "questionFrontendId": "10",
    "title": "Regular Expression Matching",
    "titleSlug": "regular-expression-matching",
    "content": "<p>Given an input string <code>s</code>&nbsp;and a pattern <code>p</code>, implement regular expression matching with support for <code>&#39;.&#39;</code> and <code>&#39;*&#39;</code> where:</p>\n\n<ul>\n\t<li><code>&#39;.&#39;</code> Matches any single character.\u200b\u200b\u200b\u200b</li>\n\t<li><code>&#39;*&#39;</code> Matches zero or more of the preceding element.</li>\n</ul>\n\n<p>The matching should cover the <strong>entire</strong> input string (not partial).</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;aa&quot;, p = &quot;a&quot;\n<strong>Output:</strong> false\n<strong>Explanation:</strong> &quot;a&quot; does not match the entire string &quot;aa&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;aa&quot;, p = &quot;a*&quot;\n<strong>Output:</strong> true\n<strong>Explanation:</strong> &#39;*&#39; means zero or more of the preceding element, &#39;a&#39;. Therefore, by repeating &#39;a&#39; once, it becomes &quot;aa&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;ab&quot;, p = &quot;.*&quot;\n<strong>Output:</strong> true\n<strong>Explanation:</strong> &quot;.*&quot; means &quot;zero or more (*) of any character (.)&quot;.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length&nbsp;&lt;= 20</code></li>\n\t<li><code>1 &lt;= p.length&nbsp;&lt;= 20</code></li>\n\t<li><code>s</code> contains only lowercase English letters.</li>\n\t<li><code>p</code> contains only lowercase English letters, <code>&#39;.&#39;</code>, and&nbsp;<code>&#39;*&#39;</code>.</li>\n\t<li>It is guaranteed for each appearance of the character <code>&#39;*&#39;</code>, there will be a previous valid character to match.</li>\n</ul>\n",
    "difficulty": "Hard",
    "stats": "{\"totalAccepted\": \"1.3M\", \"totalSubmission\": \"4.4M\", \"totalAcceptedRaw\": 1332247, \"totalSubmissionRaw\": 4384627, \"acRate\": \"30.4%\"}",
    "hints": [],
    "similarQuestions": "[{\"title\": \"Wildcard Matching\", \"titleSlug\": \"wildcard-matching\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
    "topicTags": [
        {
            "name": "String",
            "slug": "string"
        },
        {
            "name": "Dynamic Programming",
            "slug": "dynamic-programming"
        },
        {
            "name": "Recursion",
            "slug": "recursion"
        }
    ],
    "companyTags": null,
    "codeSnippets": [
        {
            "lang": "Java",
            "langSlug": "java",
            "code": "class Solution {\n    public boolean isMatch(String s, String p) {\n        \n    }\n}"
        }
    ],
    "solution": {
        "content": "<h2><a href=\"#solution\"><svg><path></path></svg></a>Solution</h2>\n<hr/>\n<h3><a href=\"#approach-1-recursion\"><svg><path></path></svg></a>Approach 1: Recursion</h3>\n<p><strong>Intuition</strong></p>\n<p>If there were no Kleene stars (the <code>*</code> wildcard character for regular expressions), the problem would be easier - we simply check from left to right if each character of the text matches the pattern.</p>\n<p>When a star is present, we may need to check many different suffixes of the text and see if they match the rest of the pattern.  A recursive solution is a straightforward way to represent this relationship.</p>\n<p><strong>Algorithm</strong></p>\n<p>Without a Kleene star, our solution would look like this:</p>\n<p>If a star is present in the pattern, it will be in the second position pattern[1].  Then, we may ignore this part of the pattern, or delete a matching character in the text.  If we have a match on the remaining strings after any of these operations, then the initial inputs matched.</p>\n<pre><code>class Solution {\n \u00a0 \u00a0public boolean isMatch(String text, String pattern) {\n \u00a0 \u00a0 \u00a0 \u00a0if (pattern.isEmpty()) return text.isEmpty();\n \u00a0 \u00a0 \u00a0 \u00a0boolean first_match =\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  (!text.isEmpty() &amp;&amp;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  (pattern.charAt(0) == text.charAt(0) ||\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0pattern.charAt(0) == '.'));\n\u200b\n \u00a0 \u00a0 \u00a0 \u00a0if (pattern.length() &gt;= 2 &amp;&amp; pattern.charAt(1) == '*') {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0return (\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0isMatch(text, pattern.substring(2)) ||\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  (first_match &amp;&amp; isMatch(text.substring(1), pattern))\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  );\n \u00a0 \u00a0 \u00a0  } else {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0return (\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0first_match &amp;&amp; isMatch(text.substring(1), pattern.substring(1))\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  );\n \u00a0 \u00a0 \u00a0  }\n \u00a0  }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: Let T,P be the lengths of the text and the pattern respectively.  In the worst case, a call to <code>match(text[i:], pattern[2j:])</code> will be made (ii+j\u200b) times, and strings of the order O(T\u2212i) and O(P\u22122\u2217j) will be made.  Thus, the complexity has the order \u2211i=0T\u200b\u2211j=0P/2\u200b(ii+j\u200b)O(T+P\u2212i\u22122j).  With some effort outside the scope of this article, we can show this is bounded by O((T+P)2T+2P\u200b).</p>\n</li>\n<li>\n<p>Space Complexity:  For every call to <code>match</code>, we will create those strings as described above, possibly creating duplicates.  If memory is not freed, this will also take a total of O((T+P)2T+2P\u200b) space, even though there are only order O(T2+P2) unique suffixes of P and  T that are actually required.</p>\n<br/>\n</li>\n</ul>\n<br/>\n<hr/>\n<h3><a href=\"#approach-2-dynamic-programming\"><svg><path></path></svg></a>Approach 2: Dynamic Programming</h3>\n<p><strong>Intuition</strong></p>\n<p>As the problem has an <strong>optimal substructure</strong>, it is natural to cache intermediate results.  We ask the question dp(i,\u00a0j): does text[i:] and pattern[j:] match?  We can describe our answer in terms of answers to questions involving smaller strings.</p>\n<p><strong>Algorithm</strong></p>\n<p>We proceed with the same recursion as in <a href=\"#approach-1-recursion\">Approach 1</a>, except because calls will only ever be made to <code>match(text[i:], pattern[j:])</code>, we use dp(i,\u00a0j) to handle those calls instead, saving us expensive string-building operations and allowing us to cache the intermediate results.</p>\n<p><em>Top-Down Variation</em></p>\n<pre><code>enum Result {\n \u00a0 \u00a0TRUE,\n \u00a0 \u00a0FALSE,\n}\n\u200b\nclass Solution {\n \u00a0 \u00a0Result[][] memo;\n\u200b\n \u00a0 \u00a0public boolean isMatch(String text, String pattern) {\n \u00a0 \u00a0 \u00a0 \u00a0memo = new Result[text.length() + 1][pattern.length() + 1];\n \u00a0 \u00a0 \u00a0 \u00a0return dp(0, 0, text, pattern);\n \u00a0  }\n\u200b\n \u00a0 \u00a0public boolean dp(int i, int j, String text, String pattern) {\n \u00a0 \u00a0 \u00a0 \u00a0if (memo[i][j] != null) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0return memo[i][j] == Result.TRUE;\n \u00a0 \u00a0 \u00a0  }\n \u00a0 \u00a0 \u00a0 \u00a0boolean ans;\n \u00a0 \u00a0 \u00a0 \u00a0if (j == pattern.length()) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0ans = i == text.length();\n \u00a0 \u00a0 \u00a0  } else {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0boolean first_match =\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  (i &lt; text.length() &amp;&amp;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  (pattern.charAt(j) == text.charAt(i) ||\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0pattern.charAt(j) == '.'));\n\u200b\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0if (j + 1 &lt; pattern.length() &amp;&amp; pattern.charAt(j + 1) == '*') {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0ans = (dp(i, j + 2, text, pattern) ||\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  (first_match &amp;&amp; dp(i + 1, j, text, pattern)));\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  } else {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0ans = first_match &amp;&amp; dp(i + 1, j + 1, text, pattern);\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  }\n \u00a0 \u00a0 \u00a0  }\n \u00a0 \u00a0 \u00a0 \u00a0memo[i][j] = ans ? Result.TRUE : Result.FALSE;\n \u00a0 \u00a0 \u00a0 \u00a0return ans;\n \u00a0  }\n}</code></pre>\n<p><em>Bottom-Up Variation</em></p>\n<pre><code>class Solution {\n \u00a0 \u00a0public boolean isMatch(String text, String pattern) {\n \u00a0 \u00a0 \u00a0 \u00a0boolean[][] dp = new boolean[text.length() + 1][pattern.length() + 1];\n \u00a0 \u00a0 \u00a0 \u00a0dp[text.length()][pattern.length()] = true;\n\u200b\n \u00a0 \u00a0 \u00a0 \u00a0for (int i = text.length(); i &gt;= 0; i--) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0for (int j = pattern.length() - 1; j &gt;= 0; j--) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0boolean first_match =\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  (i &lt; text.length() &amp;&amp;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  (pattern.charAt(j) == text.charAt(i) ||\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0pattern.charAt(j) == '.'));\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0if (j + 1 &lt; pattern.length() &amp;&amp; pattern.charAt(j + 1) == '*') {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0dp[i][j] = dp[i][j + 2] || (first_match &amp;&amp; dp[i + 1][j]);\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  } else {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0dp[i][j] = first_match &amp;&amp; dp[i + 1][j + 1];\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  }\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  }\n \u00a0 \u00a0 \u00a0  }\n \u00a0 \u00a0 \u00a0 \u00a0return dp[0][0];\n \u00a0  }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: Let T,P be the lengths of the text and the pattern respectively.  The work for every call to <code>dp(i, j)</code> for i=0,...,T; j=0,...,P is done once, and it is O(1) work.  Hence, the time complexity is O(TP).</p>\n</li>\n<li>\n<p>Space Complexity:  The only memory we use is the O(TP) boolean entries in our cache.  Hence, the space complexity is O(TP).</p>\n</li>\n</ul>",
        "isOfficial": true,
        "scrapedAt": "2026-02-18T07:22:13.133Z"
    }
}