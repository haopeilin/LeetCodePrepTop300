{
    "questionId": "134",
    "questionFrontendId": "134",
    "title": "Gas Station",
    "titleSlug": "gas-station",
    "content": "<p>There are <code>n</code> gas stations along a circular route, where the amount of gas at the <code>i<sup>th</sup></code> station is <code>gas[i]</code>.</p>\n\n<p>You have a car with an unlimited gas tank and it costs <code>cost[i]</code> of gas to travel from the <code>i<sup>th</sup></code> station to its next <code>(i + 1)<sup>th</sup></code> station. You begin the journey with an empty tank at one of the gas stations.</p>\n\n<p>Given two integer arrays <code>gas</code> and <code>cost</code>, return <em>the starting gas station&#39;s index if you can travel around the circuit once in the clockwise direction, otherwise return</em> <code>-1</code>. If there exists a solution, it is <strong>guaranteed</strong> to be <strong>unique</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> gas = [1,2,3,4,5], cost = [3,4,5,1,2]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong>\nStart at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4\nTravel to station 4. Your tank = 4 - 1 + 5 = 8\nTravel to station 0. Your tank = 8 - 2 + 1 = 7\nTravel to station 1. Your tank = 7 - 3 + 2 = 6\nTravel to station 2. Your tank = 6 - 4 + 3 = 5\nTravel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.\nTherefore, return 3 as the starting index.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> gas = [2,3,4], cost = [3,4,3]\n<strong>Output:</strong> -1\n<strong>Explanation:</strong>\nYou can&#39;t start at station 0 or 1, as there is not enough gas to travel to the next station.\nLet&#39;s start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4\nTravel to station 0. Your tank = 4 - 3 + 2 = 3\nTravel to station 1. Your tank = 3 - 3 + 3 = 3\nYou cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.\nTherefore, you can&#39;t travel around the circuit once no matter where you start.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == gas.length == cost.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= gas[i], cost[i] &lt;= 10<sup>4</sup></code></li>\n\t<li>The input is generated such that the answer is unique.</li>\n</ul>\n",
    "difficulty": "Medium",
    "stats": "{\"totalAccepted\": \"1.3M\", \"totalSubmission\": \"2.7M\", \"totalAcceptedRaw\": 1292088, \"totalSubmissionRaw\": 2721422, \"acRate\": \"47.5%\"}",
    "hints": [],
    "similarQuestions": "[{\"title\": \"Maximize the Topmost Element After K Moves\", \"titleSlug\": \"maximize-the-topmost-element-after-k-moves\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
    "topicTags": [
        {
            "name": "Array",
            "slug": "array"
        },
        {
            "name": "Greedy",
            "slug": "greedy"
        }
    ],
    "companyTags": null,
    "codeSnippets": [
        {
            "lang": "Java",
            "langSlug": "java",
            "code": "class Solution {\n    public int canCompleteCircuit(int[] gas, int[] cost) {\n        \n    }\n}"
        }
    ],
    "solution": {
        "content": "<h2><a href=\"#solution\"><svg><path></path></svg></a>Solution</h2>\n<hr/>\n<h3><a href=\"#overview\"><svg><path></path></svg></a>Overview</h3>\n<p>The gas stations in the problem are characterized by two attributes, namely, <code>gas[i]</code> and <code>cost[i]</code>, each corresponding to the amount of gas gained and consumed, respectively, when reaching the next station <code>i + 1</code>. This means that the net change in the amount of gas in our tank when moving from station <code>i</code> to <code>i + 1</code> is given by <code>gas[i]</code> - <code>cost[i]</code>.</p>\n<p>The illustration below depicts an example scenario where we move from station 0 to station 1, our tank gains 1 (unit of) gas and consumes 3 gas, resulting in a net loss of 2 gas.</p>\n<p></p>\n<p>Similarly, when moving from station 3 to station 4, our tank gains 4 gas and consumes 1 gas, which leads to a net gain of 3 gas.</p>\n<p></p>\n<p>To represent the gas gain and consumption at each station using a single array, we can define <code>gain[i] = gas[i] - cost[i]</code>. The value of <code>gain[i]</code> represents the <strong>net change</strong> in the amount of gas in our tank when moving from station <code>i</code> to <code>i + 1</code>. At each station <code>i</code>, the amount of gas in the tank is changed by <code>gain[i]</code>. If, at any point, the gas in our tank drops below zero, we cannot reach the next station nor finish the circular route.</p>\n<p></p>\n<hr/>\n<h3><a href=\"#approach-one-pass\"><svg><path></path></svg></a>Approach: One Pass</h3>\n<h4>Intuition</h4>\n<p>Upon adopting the given idea, we start our journey from <code>i = 0</code> and verify if station 0 is a valid starting station by accumulating gas <code>gain[i]</code> at each station along the way.</p>\n<p>We begin with station <code>0</code> and gain 1 gas upon reaching station <code>1</code>, a promising start.</p>\n<p></p>\n<p>However, we need to address a question. Even though it requires 0 net gas to reach station <code>2</code> from station <code>1</code>, which implies that one can reach station <code>2</code> with 0 initial gas, should we consider station <code>1</code> as a valid starting station? The answer is no.</p>\n<p></p>\n<p>The problem's hint states that there can be <strong>at most one valid station</strong>. We can refer to the following figure. If we complete a circular route starting from station 1, we can also start from station 0 to finish the journey because the car, starting from station 1, will have no less gas at every other station than the car that started from station 0.</p>\n<p>Having two valid starting stations contradicts the statement given in the problem. Therefore, we only need to consider if station 0 is valid because station 1 is guaranteed not to be valid.</p>\n<p></p>\n<p>We continue the journey until encountering a station that reduces our gas below 0. As shown in the picture below, we only have 3 gas and cannot cross this gap that costs 4 gas. It seems like our trip ends here.</p>\n<p></p>\n<p>An intuitive idea is to skip this \"valley\" and try completing the circular route starting from the next gas station with a non-negative net gain of gas.</p>\n<p></p>\n<p>Consequently, we treat the previous part as a single segment, which we failed to pass through with 0 initial gas. Let's temporarily leave it behind and start over from the next station with 0 initial gas.</p>\n<p></p>\n<p>During the following journey, we keep track of the current accumulated gas at each station. If we have a negative gas value after passing gas station <code>i</code>, we treat the stations that have been passed as a separate segment and start over from the next station <code>i + 1</code>. This means that we will test if station <code>i + 1</code> is a valid starting station <code>answer</code>.</p>\n<p>By visualizing this process, we can see that it involves dividing our journey into segments, each of which ends in a \"valley\" station where the accumulated gas becomes negative. These segments cannot be crossed with 0 initial gas, and any station within them is not a valid starting station.</p>\n<blockquote>\n<p>To pass these segments, we must hold enough extra gas before entering them.</p>\n</blockquote>\n<p></p>\n<p>When we complete the entire trip, there may still be some gas stations that do not belong to any segment. Since we visit the gas stations in a circular manner, these ending stations are actually the starting part of the first segment (segment 1, as shown below).</p>\n<p>We have verified that none of the segments is crossable. However, with the addition of these stations by the end of the journey, the situation with segment 1 may change, and we have to try again.</p>\n<p></p>\n<p>Fortunately, we do not need another iteration to calculate the gas gained in segment 1. We can simply calculate <code>total_gain</code>, which is the sum of <code>gain</code>. Note that <code>total_gain</code> also represents the sum of gained gas from each segment:</p>\n<p>total_gain=gain1\u200b+gain2\u200b+gain3\u200b+...</p>\n<p>If total_gain\u22650 holds, there is:</p>\n<p>gain1\u200b+gain2\u200b+gain3\u200b+...\u22650</p>\n<p>gain1\u200b\u2265\u2212(gain2\u200b+gain3\u200b+...)</p>\n<p>This implies that the gas gained in the segment 1 is enough to support us passing through each remaining segment and return to the starting point of segment 1.</p>\n<p></p>\n<p>Otherwise, total_gain&lt;0 indicates that the gas gained after traversing segment 1 isn't enough to support us passing through the remaining segments, and there is no valid station.</p>\n<blockquote>\n<p>Note: We don't need to create a separate <code>gain</code> array; instead, we can calculate the gas gained for each station as we iterate through them. This way, we avoid the need for additional space of size O(n).</p>\n</blockquote>\n<br/>\n<h4>Algorithm</h4>\n<ol>\n<li>\n<p>Initialize <code>curr_gain</code>, <code>total_gain</code> and <code>answer</code> to 0.</p>\n</li>\n<li>\n<p>Traverse through <code>gas</code> and <code>cost</code>. For each index <code>i</code>, increment <code>total_gain</code> and <code>curr_gain</code> by <code>gas[i] - cost[i]</code>.</p>\n</li>\n<li>\n<p>If <code>curr_gain</code> is smaller than 0, we will test if station <code>i + 1</code> is a valid starting station by setting <code>answer</code> as <code>i + 1</code>, resetting <code>curr_gain</code> to 0, and repeating step 2.</p>\n</li>\n<li>\n<p>When the iteration is complete, if <code>total_gain</code> is smaller than 0, return <code>-1</code>. Otherwise, return <code>answer</code>.</p>\n</li>\n</ol>\n<h4>Implementation</h4>\n<pre><code>class Solution {\n    public int canCompleteCircuit(int[] gas, int[] cost) {\n        int currGain = 0, totalGain = 0, answer = 0;\n\n        for (int i = 0; i &lt; gas.length; i++) {\n            // gain[i] = gas[i] - cost[i]\n            totalGain += gas[i] - cost[i];\n            currGain += gas[i] - cost[i];\n\n            // If we meet a \"valley\", start over from the next station\n            // with 0 initial gas.\n            if (currGain &lt; 0) {\n                answer = i + 1;\n                currGain = 0;\n            }\n        }\n\n        return totalGain &gt;= 0 ? answer : -1;\n    }\n}</code></pre>\n<h4>Complexity Analysis</h4>\n<p>Let n be the length of the input array <code>gas</code>.</p>\n<ul>\n<li>\n<p>Time complexity: O(n)</p>\n<ul>\n<li>The algorithm traverses through <code>gas</code> and <code>cost</code> once. Updating <code>total_gain</code>, <code>curr_gain</code> and <code>answer</code> takes O(1) time at each step.</li>\n</ul>\n</li>\n<li>\n<p>Space complexity: O(1)</p>\n<ul>\n<li>We only need to keep track of some parameters <code>total_gain</code>, <code>curr_gain</code>, and <code>answer</code>, which take O(1) space.</li>\n</ul>\n</li>\n</ul>\n<br/>",
        "isOfficial": true,
        "scrapedAt": "2026-02-18T07:23:01.964Z"
    }
}