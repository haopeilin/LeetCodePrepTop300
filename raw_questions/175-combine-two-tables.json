{
    "questionId": "175",
    "questionFrontendId": "175",
    "title": "Combine Two Tables",
    "titleSlug": "combine-two-tables",
    "content": "<p>Table: <code>Person</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| personId    | int     |\n| lastName    | varchar |\n| firstName   | varchar |\n+-------------+---------+\npersonId is the primary key (column with unique values) for this table.\nThis table contains information about the ID of some persons and their first and last names.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Table: <code>Address</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| addressId   | int     |\n| personId    | int     |\n| city        | varchar |\n| state       | varchar |\n+-------------+---------+\naddressId is the primary key (column with unique values) for this table.\nEach row of this table contains information about the city and state of one person with ID = PersonId.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to report the first name, last name, city, and state of each person in the <code>Person</code> table. If the address of a <code>personId</code> is not present in the <code>Address</code> table, report <code>null</code> instead.</p>\n\n<p>Return the result table in <strong>any order</strong>.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nPerson table:\n+----------+----------+-----------+\n| personId | lastName | firstName |\n+----------+----------+-----------+\n| 1        | Wang     | Allen     |\n| 2        | Alice    | Bob       |\n+----------+----------+-----------+\nAddress table:\n+-----------+----------+---------------+------------+\n| addressId | personId | city          | state      |\n+-----------+----------+---------------+------------+\n| 1         | 2        | New York City | New York   |\n| 2         | 3        | Leetcode      | California |\n+-----------+----------+---------------+------------+\n<strong>Output:</strong> \n+-----------+----------+---------------+----------+\n| firstName | lastName | city          | state    |\n+-----------+----------+---------------+----------+\n| Allen     | Wang     | Null          | Null     |\n| Bob       | Alice    | New York City | New York |\n+-----------+----------+---------------+----------+\n<strong>Explanation:</strong> \nThere is no address in the address table for the personId = 1 so we return null in their city and state.\naddressId = 1 contains information about the address of personId = 2.\n</pre>\n",
    "difficulty": "Easy",
    "stats": "{\"totalAccepted\": \"1.7M\", \"totalSubmission\": \"2.1M\", \"totalAcceptedRaw\": 1693302, \"totalSubmissionRaw\": 2138257, \"acRate\": \"79.2%\"}",
    "hints": [],
    "similarQuestions": "[{\"title\": \"Employee Bonus\", \"titleSlug\": \"employee-bonus\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
    "topicTags": [
        {
            "name": "Database",
            "slug": "database"
        }
    ],
    "companyTags": null,
    "codeSnippets": [],
    "solution": {
        "content": "<h1><a href=\"#solution\"><svg><path></path></svg></a>Solution</h1>\n<hr/>\n<h2><a href=\"#pandas\"><svg><path></path></svg></a>pandas</h2>\n<h3><a href=\"#approach-1-using-merge\"><svg><path></path></svg></a>Approach 1: Using <code>merge</code></h3>\n<p><strong>Visualization of approach 1</strong></p>\n<p></p>\n<h4>Intuition</h4>\n<p>Let's breakdown the steps given the following input DataFrames:</p>\n<p><code>person</code>:</p>\n<table><tbody><tr><th>personId</th><th>lastName</th><th>firstName</th></tr><tr><td>1</td><td>Wang</td><td>Allen</td></tr><tr><td>2</td><td>Alice</td><td>Bob</td></tr></tbody></table>\n<br/>\n<p><code>address</code>:</p>\n<table><tbody><tr><th>addressId</th><th>personId</th><th>city</th><th>state</th></tr><tr><td>1</td><td>2</td><td>New York City</td><td>New York</td></tr><tr><td>2</td><td>3</td><td>Leetcode</td><td>California</td></tr></tbody></table>\n<br/>\n<ol>\n<li>\n<p><strong>Merging the DataFrames</strong></p>\n<pre><code>// Perform a left join between person and address based on personId\nMap&lt;Integer, Address&gt; addressMap = addressList.stream()\n        .collect(Collectors.toMap(Address::getPersonId, a -&gt; a, (a, b) -&gt; a));\n\nList&lt;Result&gt; result = new ArrayList&lt;&gt;();\nfor (Person p : personList) {\n    Address a = addressMap.get(p.getPersonId());\n    result.add(new Result(\n            p.getFirstName(),\n            p.getLastName(),\n            a != null ? a.getCity() : null,\n            a != null ? a.getState() : null\n    ));\n}</code></pre><svg><path></path></svg>\n<p>In this step, we are merging the <code>person</code> and <code>address</code> data collections using a left join operation implemented in Java. Here:</p>\n<ul>\n<li>The <code>personId</code> field is used as the key for joining the data. This field is present in both objects, and it holds unique identifiers for the individuals.</li>\n<li>The logic mirrors a left join, meaning all the records from the <code>person</code> collection are retained, and the matching records from the <code>address</code> collection are merged where the <code>personId</code> values match. If a <code>personId</code> from the <code>person</code> collection does not have a matching <code>personId</code> in the <code>address</code> collection, the <code>city</code> and <code>state</code> fields for that record will contain <code>null</code> values (representing missing data).</li>\n</ul>\n</li>\n</ol>\n<table><tbody><tr><th>personId</th><th>lastName</th><th>firstName</th><th>addressId</th><th>city</th><th>state</th></tr><tr><td>1</td><td>Wang</td><td>Allen</td><td>Null</td><td>Null</td><td>Null</td></tr><tr><td>2</td><td>Alice</td><td>Bob</td><td>1.0</td><td>New York City</td><td>New York</td></tr></tbody></table>\n<br/>\n<ol>\n<li>\n<p><strong>Selecting Relevant Columns</strong></p>\n<pre><code>// The Result class already contains only the required fields:\n// firstName, lastName, city, and state\nList&lt;Result&gt; finalResult = result;</code></pre><svg><path></path></svg>\n<p>In this step, we ensure that only the fields we are interested in are included in the final output. Since the merging operation can potentially bring in other fields from the <code>address</code> objects, the <code>Result</code> class is designed to contain only the <code>firstName</code>, <code>lastName</code>, <code>city</code>, and <code>state</code> fields. This helps in maintaining a clean and focused dataset which contains only the information we are interested in.</p>\n</li>\n</ol>\n<table><tbody><tr><th>firstName</th><th>lastName</th><th>city</th><th>state</th></tr><tr><td>Allen</td><td>Wang</td><td>Null</td><td>Null</td></tr><tr><td>Bob</td><td>Alice</td><td>New York City</td><td>New York</td></tr></tbody></table>\n<br/>\n<p>In summary, this script is taking two separate data collections and merging them into a single result where each row represents a person and contains their first name, last name, city, and state. This is done using the person's unique identifier to correctly match each person with their address. It's a common operation when you want to bring together information from different sources into a unified view.</p>\n<h4>Implementation</h4>\n<pre><code>import java.util.*;\nimport java.util.stream.Collectors;\n\npublic class Solution {\n\n    public static List&lt;Result&gt; combineTwoTables(List&lt;Person&gt; personList, List&lt;Address&gt; addressList) {\n        Map&lt;Integer, Address&gt; addressMap = addressList.stream()\n                .collect(Collectors.toMap(Address::getPersonId, a -&gt; a, (a, b) -&gt; a));\n\n        List&lt;Result&gt; result = new ArrayList&lt;&gt;();\n        for (Person p : personList) {\n            Address a = addressMap.get(p.getPersonId());\n            result.add(new Result(\n                    p.getFirstName(),\n                    p.getLastName(),\n                    a != null ? a.getCity() : null,\n                    a != null ? a.getState() : null\n            ));\n        }\n        return result;\n    }\n}</code></pre>\n<hr/>\n<h2><a href=\"#database\"><svg><path></path></svg></a>Database</h2>\n<h3><a href=\"#approach-1-using-outer-join\"><svg><path></path></svg></a>Approach 1: Using <code>outer join</code></h3>\n<h4>Intuition</h4>\n<p>Since the <em>PersonId</em> in table <strong>Address</strong> is the foreign key of table <strong>Person</strong>, we can join these two tables to get the address information of a person.</p>\n<p>Considering there might be no address information for every person, we should use <code>outer join</code> instead of the default <code>inner join</code>.</p>\n<h4>Implementation</h4>\n<blockquote>\n<p>Note: For MySQL, an <code>outer join</code> is performed either using <code>left join</code> or <code>right join</code>.</p>\n</blockquote>\n<pre><code>String sql = \"SELECT FirstName, LastName, City, State \" +\n             \"FROM Person LEFT JOIN Address \" +\n             \"ON Person.PersonId = Address.PersonId\";\n\nPreparedStatement statement = connection.prepareStatement(sql);\nResultSet resultSet = statement.executeQuery();</code></pre><svg><path></path></svg>\n<blockquote>\n<p>Note: Using the <code>where</code> clause to filter the records will fail if there is no address information for a person because it will not display the name information.</p>\n</blockquote>",
        "isOfficial": true,
        "scrapedAt": "2026-02-18T07:17:01.976Z"
    }
}