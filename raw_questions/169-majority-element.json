{
    "questionId": "169",
    "questionFrontendId": "169",
    "title": "Majority Element",
    "titleSlug": "majority-element",
    "content": "<p>Given an array <code>nums</code> of size <code>n</code>, return <em>the majority element</em>.</p>\n\n<p>The majority element is the element that appears more than <code>&lfloor;n / 2&rfloor;</code> times. You may assume that the majority element always exists in the array.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> nums = [3,2,3]\n<strong>Output:</strong> 3\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> nums = [2,2,1,1,1,2,2]\n<strong>Output:</strong> 2\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li>The input is generated such that a majority element will exist in the array.</li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow-up:</strong> Could you solve the problem in linear time and in <code>O(1)</code> space?",
    "difficulty": "Easy",
    "stats": "{\"totalAccepted\": \"5.2M\", \"totalSubmission\": \"7.9M\", \"totalAcceptedRaw\": 5218666, \"totalSubmissionRaw\": 7895900, \"acRate\": \"66.1%\"}",
    "hints": [],
    "similarQuestions": "[{\"title\": \"Majority Element II\", \"titleSlug\": \"majority-element-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Check If a Number Is Majority Element in a Sorted Array\", \"titleSlug\": \"check-if-a-number-is-majority-element-in-a-sorted-array\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Most Frequent Even Element\", \"titleSlug\": \"most-frequent-even-element\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Minimum Index of a Valid Split\", \"titleSlug\": \"minimum-index-of-a-valid-split\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Minimum Operations to Exceed Threshold Value I\", \"titleSlug\": \"minimum-operations-to-exceed-threshold-value-i\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Find the Most Common Response\", \"titleSlug\": \"find-the-most-common-response\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Find Valid Pair of Adjacent Digits in String\", \"titleSlug\": \"find-valid-pair-of-adjacent-digits-in-string\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
    "topicTags": [
        {
            "name": "Array",
            "slug": "array"
        },
        {
            "name": "Hash Table",
            "slug": "hash-table"
        },
        {
            "name": "Divide and Conquer",
            "slug": "divide-and-conquer"
        },
        {
            "name": "Sorting",
            "slug": "sorting"
        },
        {
            "name": "Counting",
            "slug": "counting"
        }
    ],
    "companyTags": null,
    "codeSnippets": [
        {
            "lang": "Java",
            "langSlug": "java",
            "code": "class Solution {\n    public int majorityElement(int[] nums) {\n        \n    }\n}"
        }
    ],
    "solution": {
        "content": "<h2><a href=\"#solution\"><svg><path></path></svg></a>Solution</h2>\n<hr/>\n<h3><a href=\"#approach-1-brute-force\"><svg><path></path></svg></a>Approach 1: Brute Force</h3>\n<h4>Intuition</h4>\n<p>We can exhaust the search space in quadratic time by checking whether each<br/>\nelement is the majority element.</p>\n<h4>Algorithm</h4>\n<p>The brute force algorithm iterates over the array, and then iterates again<br/>\nfor each number to count its occurrences. As soon as a number is found to<br/>\nhave appeared more than any other can possibly have appeared, return it.</p>\n<h4>Implementation</h4>\n\n<h4>Complexity Analysis</h4>\n<ul>\n<li>\n<p>Time complexity : O(n2)</p>\n<p>The brute force algorithm contains two nested <code>for</code> loops that each run<br/>\nfor n iterations, adding up to quadratic time complexity.</p>\n</li>\n<li>\n<p>Space complexity : O(1)</p>\n<p>The brute force solution does not allocate additional space proportional<br/>\nto the input size.</p>\n</li>\n</ul>\n<br/>\n<hr/>\n<h3><a href=\"#approach-2-hashmap\"><svg><path></path></svg></a>Approach 2: HashMap</h3>\n<h4>Intuition</h4>\n<p>We know that the majority element occurs more than \u230a2n\u200b\u230b<br/>\ntimes, and a <code>HashMap</code> allows us to count element occurrences efficiently.</p>\n<h4>Algorithm</h4>\n<p>We can use a <code>HashMap</code> that maps elements to counts in order to count<br/>\noccurrences in linear time by looping over <code>nums</code>. Then, we simply return the<br/>\nkey with maximum value.</p>\n<h4>Implementation</h4>\n\n<h4>Complexity Analysis</h4>\n<ul>\n<li>\n<p>Time complexity : O(n)</p>\n<p>We iterate over <code>nums</code> once and make a constant time <code>HashMap</code> insertion<br/>\non each iteration. Therefore, the algorithm runs in O(n) time.</p>\n</li>\n<li>\n<p>Space complexity : O(n)</p>\n<p>At most, the <code>HashMap</code> can contain n\u2212\u230a2n\u200b\u230b<br/>\nassociations, so it occupies O(n) space. This is because an arbitrary<br/>\narray of length n can contain n distinct values, but <code>nums</code> is<br/>\nguaranteed to contain a majority element, which will occupy (at minimum)<br/>\n\u230a2n\u200b\u230b+1 array indices. Therefore,<br/>\nn\u2212(\u230a2n\u200b\u230b+1) indices can be occupied by<br/>\ndistinct, non-majority elements (plus 1 for the majority element itself),<br/>\nleaving us with (at most) n\u2212\u230a2n\u200b\u230b distinct<br/>\nelements.</p>\n</li>\n</ul>\n<br/>\n<hr/>\n<h3><a href=\"#approach-3-sorting\"><svg><path></path></svg></a>Approach 3: Sorting</h3>\n<h4>Intuition</h4>\n<p>If the elements are sorted in monotonically increasing (or decreasing) order,<br/>\nthe majority element can be found at index<br/>\n\u230a2n\u200b\u230b (and also at \u230a2n\u200b\u230b\u22121, if n is even).</p>\n<h4>Algorithm</h4>\n<p>For this algorithm, we simply do exactly what is described: sort <code>nums</code>, and<br/>\nreturn the element in question. To see why this will always return the<br/>\nmajority element (given that the array has one), consider the figure below<br/>\n(the top example is for an odd-length array and the bottom is for an<br/>\neven-length array):</p>\n<p></p>\n<p>For each example, the line below the array denotes the range of indices that<br/>\nare covered by a majority element that happens to be the array minimum. As<br/>\nyou might expect, the line above the array is similar, but for the case where<br/>\nthe majority element is also the array maximum. In all other cases, this line<br/>\nwill lie somewhere between these two, but notice that even in these two most<br/>\nextreme cases, they overlap at index \u230a2n\u200b\u230b for both<br/>\neven- and odd-length arrays. Therefore, no matter what value the majority<br/>\nelement has in relation to the rest of the array, returning the value at<br/>\n\u230a2n\u200b\u230b will never be wrong.</p>\n<h4>Implementation</h4>\n\n<h4>Complexity Analysis</h4>\n<ul>\n<li>\n<p>Time complexity : O(nlgn)</p>\n<p>Sorting the array costs O(nlgn) time in Java, so it<br/>\ndominates the overall runtime.</p>\n</li>\n<li>\n<p>Space complexity : O(1) or (O(n))</p>\n<p>We sorted <code>nums</code> in place here - if that is not allowed, then we must<br/>\nspend linear additional space on a copy of <code>nums</code> and sort the copy<br/>\ninstead.</p>\n</li>\n</ul>\n<br/>\n<hr/>\n<h3><a href=\"#approach-4-bit-manipulation\"><svg><path></path></svg></a>Approach 4: Bit Manipulation</h3>\n<h4>Intuition</h4>\n<p>If an element <code>majority_element</code> occurs more than \u230a2n\u200b\u230b times, then there are at least \u230a2n\u200b\u230b elements of identical values with <code>num</code> at each bit. That is, we can reconstruct the exact value of <code>num</code> by combining the most frequent value (0 or 1) at each bit.</p>\n<h4>Algorithm</h4>\n<p>Starting from the least significant bit, we enumerate each bit to determine which value is the majority at this bit, 0 or 1, and put this value to the corresponding bit of the result. Finally, we end up with the most least significant bit of all elements and return the result.</p>\n<h4>Implementation</h4>\n<p>Because all numbers are in the range [\u2212109,109], which can be represented in 32-bit, we only need to enumerate 32 bits.</p>\n<p>For the Java solution, note that integers are represented using 32-bit two's complement. To handle negative numbers correctly, we must ensure that the sign bit (the most significant bit) is reconstructed consistently with the majority count, so the final result naturally represents the correct positive or negative value.</p>\n\n<h4>Complexity Analysis</h4>\n<ul>\n<li>\n<p>Time complexity : O(nlogC)</p>\n<p>C is the max absolute value in <code>nums</code>, i.e., 105 in this problem. We enumerate all logC bits for each number in <code>nums</code>.</p>\n</li>\n<li>\n<p>Space complexity: O(1)</p>\n<p>We count the majority of each bit in O(1) space as it only has the two potential values, 0 and 1. After that, we only need to put the majority values to their corresponding bit in the returned result, and no extra space is used.</p>\n</li>\n</ul>\n<hr/>\n<h3><a href=\"#approach-5-randomization\"><svg><path></path></svg></a>Approach 5: Randomization</h3>\n<h4>Intuition</h4>\n<p>Because more than \u230a2n\u200b\u230b array indices are occupied<br/>\nby the majority element, a random array index is likely to contain the<br/>\nmajority element.</p>\n<h4>Algorithm</h4>\n<p>Because a given index is likely to have the majority element, we can just<br/>\nselect a random index, check whether its value is the majority element,<br/>\nreturn if it is, and repeat if it is not. The algorithm is verifiably correct<br/>\nbecause we ensure that the randomly chosen value is the majority element<br/>\nbefore ever returning.</p>\n<h4>Implementation</h4>\n\n<h4>Complexity Analysis</h4>\n<ul>\n<li>\n<p>Time complexity : O(\u221e)</p>\n<p>It is technically possible for this algorithm to run indefinitely (if we<br/>\nnever manage to randomly select the majority element), so the worst<br/>\npossible runtime is unbounded. However, the expected runtime is far<br/>\nbetter - linear, in fact. For ease of analysis, convince yourself that<br/>\nbecause the majority element is guaranteed to occupy <em>more</em> than half of<br/>\nthe array, the expected number of iterations will be less than it would<br/>\nbe if the element we sought occupied exactly <em>half</em> of the array.<br/>\nTherefore, we can calculate the expected number of iterations for this<br/>\nmodified version of the problem and assert that our version is easier.</p>\nEV(itersprob\u200b)\u200b\u2264EV(itersmod\u200b)=n\u2192\u221elim\u200bi=1\u2211n\u200bi\u22c52i1\u200b=2\u200b\n<p>Because the series converges, the expected number of iterations for the<br/>\nmodified problem is constant. Based on an expected-constant number of<br/>\niterations in which we perform linear work, the expected runtime is<br/>\nlinear for the modifed problem. Therefore, the expected runtime for our<br/>\nproblem is also linear, as the runtime of the modifed problem serves as<br/>\nan upper bound for it.</p>\n</li>\n<li>\n<p>Space complexity : O(1)</p>\n<p>Much like the brute force solution, the randomized approach runs with<br/>\nconstant additional space.</p>\n</li>\n</ul>\n<br/>\n<hr/>\n<h3><a href=\"#approach-6-divide-and-conquer\"><svg><path></path></svg></a>Approach 6: Divide and Conquer</h3>\n<h4>Intuition</h4>\n<p>If we know the majority element in the left and right halves of an array, we<br/>\ncan determine which is the global majority element in linear time.</p>\n<h4>Algorithm</h4>\n<p>Here, we apply a classical divide &amp; conquer approach that recurses on the<br/>\nleft and right halves of an array until an answer can be trivially achieved<br/>\nfor a length-1 array. Note that because actually passing copies of subarrays<br/>\ncosts time and space, we instead pass <code>lo</code> and <code>hi</code> indices that describe the<br/>\nrelevant slice of the overall array. In this case, the majority element for a<br/>\nlength-1 slice is trivially its only element, so the recursion stops there.<br/>\nIf the current slice is longer than length-1, we must combine the answers for<br/>\nthe slice's left and right halves. If they agree on the majority element,<br/>\nthen the majority element for the overall slice is obviously the same<sup><a href=\"#user-content-fn-1\">1</a></sup>. If<br/>\nthey disagree, only one of them can be \"right\", so we need to count the<br/>\noccurrences of the left and right majority elements to determine which<br/>\nsubslice's answer is globally correct. The overall answer for the array is<br/>\nthus the majority element between indices 0 and n.</p>\n<h4>Implementation</h4>\n\n<h4>Complexity Analysis</h4>\n<ul>\n<li>\n<p>Time complexity : O(nlgn)</p>\n<p>Each recursive call to <code>majority_element_rec</code> performs two recursive<br/>\ncalls on subslices of size 2n\u200b and two linear scans of length<br/>\nn. Therefore, the time complexity of the divide &amp; conquer approach<br/>\ncan be represented by the following recurrence relation:</p>\n<p>T(n)=2T(2n\u200b)+2n</p>\n<p>By the <a href=\"https://en.wikipedia.org/wiki/Master_theorem_(analysis_of_algorithms)\">master theorem</a>,<br/>\nthe recurrence satisfies case 2, so the complexity can be analyzed as such:</p>\n<p>T(n)\u200b=\u0398(nlogb\u200balogn)=\u0398(nlog2\u200b2logn)=\u0398(nlogn)\u200b</p>\n</li>\n<li>\n<p>Space complexity : O(lgn)</p>\n<p>Although the divide &amp; conquer does not explicitly allocate any additional<br/>\nmemory, it uses a non-constant amount of additional memory in stack<br/>\nframes due to recursion. Because the algorithm \"cuts\" the array in half<br/>\nat each level of recursion, it follows that there can only be O(lgn)<br/>\n\"cuts\" before the base case of 1 is reached. It follows from this fact<br/>\nthat the resulting recursion tree is balanced, and therefore all paths<br/>\nfrom the root to a leaf are of length O(lgn). Because the recursion<br/>\ntree is traversed in a depth-first manner, the space complexity is<br/>\ntherefore equivalent to the length of the longest path, which is, of<br/>\ncourse, O(lgn).</p>\n</li>\n</ul>\n<br/>\n<hr/>\n<h3><a href=\"#approach-7-boyer-moore-voting-algorithm\"><svg><path></path></svg></a>Approach 7: Boyer-Moore Voting Algorithm</h3>\n<h4>Intuition</h4>\n<p>If we had some way of counting instances of the majority element as +1<br/>\nand instances of any other element as \u22121, summing them would make it<br/>\nobvious that the majority element is indeed the majority element.</p>\n<h4>Algorithm</h4>\n<p>Essentially, what Boyer-Moore does is look for a suffix suf of <code>nums</code><br/>\nwhere suf[0] is the majority element in that suffix. To do this, we<br/>\nmaintain a count, which is incremented whenever we see an instance of our<br/>\ncurrent candidate for majority element and decremented whenever we see<br/>\nanything else. Whenever <code>count</code> equals 0, we effectively forget about<br/>\neverything in <code>nums</code> up to the current index and consider the current number<br/>\nas the candidate for majority element. It is not immediately obvious why we can<br/>\nget away with forgetting prefixes of <code>nums</code> - consider the following<br/>\nexamples (pipes are inserted to separate runs of nonzero <code>count</code>).</p>\n<p>[7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]</p>\n<p>Here, the <code>7</code> at index 0 is selected to be the first candidate for majority<br/>\nelement. <code>count</code> will eventually reach 0 after index 5 is processed, so the<br/>\n<code>5</code> at index 6 will be the next candidate. In this case, <code>7</code> is the true<br/>\nmajority element, so by disregarding this prefix, we are ignoring an equal<br/>\nnumber of majority and minority elements - therefore, <code>7</code> will still be the<br/>\nmajority element in the suffix formed by throwing away the first prefix.</p>\n<p>[7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | <strong>5, 5, 5, 5</strong>]</p>\n<p>Now, the majority element is <code>5</code> (we changed the last run of the array from<br/>\n<code>7</code>s to <code>5</code>s), but our first candidate is still <code>7</code>. In this case, our<br/>\ncandidate is not the true majority element, but we still cannot discard more<br/>\nmajority elements than minority elements (this would imply that <code>count</code> could<br/>\nreach -1 before we reassign <code>candidate</code>, which is obviously false).</p>\n<p>Therefore, given that it is impossible (in both cases) to discard more<br/>\nmajority elements than minority elements, we are safe in discarding the<br/>\nprefix and attempting to recursively solve the majority element problem for the<br/>\nsuffix. Eventually, a suffix will be found for which <code>count</code> does not hit<br/>\n<code>0</code>, and the majority element of that suffix will necessarily be the same as<br/>\nthe majority element of the overall array.</p>\n<h4>Implementation</h4>\n\n<h4>Complexity Analysis</h4>\n<ul>\n<li>\n<p>Time complexity : O(n)</p>\n<p>Boyer-Moore performs constant work exactly n times, so the algorithm<br/>\nruns in linear time.</p>\n</li>\n<li>\n<p>Space complexity : O(1)</p>\n<p>Boyer-Moore allocates only constant additional memory.</p>\n</li>\n</ul>\n<br/>\n<h3><a href=\"#footnotes\"><svg><path></path></svg></a>Footnotes</h3>\n<h2><a href=\"#user-content-footnote-label\"><svg><path></path></svg></a>Footnotes</h2>\n<ol>\n<li>\n<p>This is a constant optimization that could be excluded without hurting our<br/>\noverall runtime. <a href=\"#user-content-fnref-1\">\u21a9</a></p>\n</li>\n</ol>",
        "isOfficial": true,
        "scrapedAt": "2026-02-18T06:55:19.598Z"
    }
}