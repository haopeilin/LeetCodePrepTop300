{
    "questionId": "167",
    "questionFrontendId": "167",
    "title": "Two Sum II - Input Array Is Sorted",
    "titleSlug": "two-sum-ii-input-array-is-sorted",
    "content": "<p>Given a <strong>1-indexed</strong> array of integers <code>numbers</code> that is already <strong><em>sorted in non-decreasing order</em></strong>, find two numbers such that they add up to a specific <code>target</code> number. Let these two numbers be <code>numbers[index<sub>1</sub>]</code> and <code>numbers[index<sub>2</sub>]</code> where <code>1 &lt;= index<sub>1</sub> &lt; index<sub>2</sub> &lt;= numbers.length</code>.</p>\n\n<p>Return<em> the indices of the two numbers, </em><code>index<sub>1</sub></code><em> and </em><code>index<sub>2</sub></code><em>, <strong>added by one</strong> as an integer array </em><code>[index<sub>1</sub>, index<sub>2</sub>]</code><em> of length 2.</em></p>\n\n<p>The tests are generated such that there is <strong>exactly one solution</strong>. You <strong>may not</strong> use the same element twice.</p>\n\n<p>Your solution must use only constant extra space.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> numbers = [<u>2</u>,<u>7</u>,11,15], target = 9\n<strong>Output:</strong> [1,2]\n<strong>Explanation:</strong> The sum of 2 and 7 is 9. Therefore, index<sub>1</sub> = 1, index<sub>2</sub> = 2. We return [1, 2].\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> numbers = [<u>2</u>,3,<u>4</u>], target = 6\n<strong>Output:</strong> [1,3]\n<strong>Explanation:</strong> The sum of 2 and 4 is 6. Therefore index<sub>1</sub> = 1, index<sub>2</sub> = 3. We return [1, 3].\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> numbers = [<u>-1</u>,<u>0</u>], target = -1\n<strong>Output:</strong> [1,2]\n<strong>Explanation:</strong> The sum of -1 and 0 is -1. Therefore index<sub>1</sub> = 1, index<sub>2</sub> = 2. We return [1, 2].\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= numbers.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>-1000 &lt;= numbers[i] &lt;= 1000</code></li>\n\t<li><code>numbers</code> is sorted in <strong>non-decreasing order</strong>.</li>\n\t<li><code>-1000 &lt;= target &lt;= 1000</code></li>\n\t<li>The tests are generated such that there is <strong>exactly one solution</strong>.</li>\n</ul>\n",
    "difficulty": "Medium",
    "stats": "{\"totalAccepted\": \"3.2M\", \"totalSubmission\": \"5M\", \"totalAcceptedRaw\": 3222354, \"totalSubmissionRaw\": 4989714, \"acRate\": \"64.6%\"}",
    "hints": [],
    "similarQuestions": "[{\"title\": \"Two Sum\", \"titleSlug\": \"two-sum\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Two Sum IV - Input is a BST\", \"titleSlug\": \"two-sum-iv-input-is-a-bst\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Two Sum Less Than K\", \"titleSlug\": \"two-sum-less-than-k\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
    "topicTags": [
        {
            "name": "Array",
            "slug": "array"
        },
        {
            "name": "Two Pointers",
            "slug": "two-pointers"
        },
        {
            "name": "Binary Search",
            "slug": "binary-search"
        }
    ],
    "companyTags": null,
    "codeSnippets": [
        {
            "lang": "Java",
            "langSlug": "java",
            "code": "class Solution {\n    public int[] twoSum(int[] numbers, int target) {\n        \n    }\n}"
        }
    ],
    "solution": {
        "content": "<h2><a href=\"#solution\"><svg><path></path></svg></a>Solution</h2>\n<hr/>\n<h3><a href=\"#approach-1-two-pointers\"><svg><path></path></svg></a>Approach 1: Two Pointers</h3>\n<p><strong>Algorithm</strong></p>\n<p>We can apply <a href=\"https://leetcode.com/articles/two-sum/\">Two Sum's solutions</a> directly to get O(n2) time, O(1) space using brute force and O(n) time, O(n) space using hash table. However, both existing solutions do not make use of the property that the input array is sorted. We can do better.</p>\n<p>We use two indices, initially pointing to the first and the last element, respectively. Compare the sum of these two elements with <code>target</code>. If the sum is equal to <code>target</code>, we found the exactly only solution. If it is less than <code>target</code>, we increase the smaller index by one. If it is greater than <code>target</code>, we decrease the larger index by one. Move the indices and repeat the comparison until the solution is found.</p>\n<p>Let [...,a,b,c,...,d,e,f,...] be the input array that is sorted in ascending order and let the elements b and e be the exactly only solution. Because we are moving the smaller index from left to right, and the larger index from right to left, at some point, one of the indices must reach either b or e. Without loss of generality, suppose the smaller index reaches b first. At this time, the sum of these two elements must be greater than <code>target</code>. Based on our algorithm, we will keep moving the larger index to the left until we reach the solution.</p>\n<p><strong>Implementation</strong></p>\n<pre><code>class Solution {\n    public int[] twoSum(int[] numbers, int target) {\n        int low = 0;\n        int high = numbers.length - 1;\n        while (low &lt; high) {\n            int sum = numbers[low] + numbers[high];\n\n            if (sum == target) {\n                return new int[] { low + 1, high + 1 };\n            } else if (sum &lt; target) {\n                low++;\n            } else {\n                high--;\n            }\n        }\n        // In case there is no solution, return {-1, -1}.\n        return new int[] { -1, -1 };\n    }\n}</code></pre>\n<p><strong>Follow-Up</strong></p>\n<p>What if the problem constraints were different and we needed to consider integer overflow when adding numbers[low] and numbers[high]? In that case, to prevent an overflow error, we could cast our numbers from <code>int</code> data type to <code>long</code> data type before adding them together, e.g.: <code>long sum = (long) numbers[low] + numbers[high]</code> for Java. Casting ensures that we will not get the overflow error since the signed <code>long</code> data type supports numbers up to <code>2^63 - 1</code>. Alternatively, if we cannot use long integers, then we can check if <code>numbers[low] &gt; Integer.MAX_VALUE - numbers[high]</code> at the beginning of each iteration. If this condition is true, then <code>numbers[low] + numbers[high]</code> will result in integer overflow, and so we would move the larger index to the left.</p>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity: O(n).<br/>\nThe input array is traversed at most once. Thus the time complexity is O(n).</p>\n</li>\n<li>\n<p>Space complexity: O(1).<br/>\nWe only use additional space to store two indices and the sum, so the space complexity is O(1).</p>\n</li>\n</ul>",
        "isOfficial": true,
        "scrapedAt": "2026-02-18T07:07:36.876Z"
    }
}