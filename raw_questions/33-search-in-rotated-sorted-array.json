{
  "questionId": "33",
  "questionFrontendId": "33",
  "title": "Search in Rotated Sorted Array",
  "titleSlug": "search-in-rotated-sorted-array",
  "content": "<p>There is an integer array <code>nums</code> sorted in ascending order (with <strong>distinct</strong> values).</p>\n\n<p>Prior to being passed to your function, <code>nums</code> is <strong>possibly left rotated</strong> at an unknown index <code>k</code> (<code>1 &lt;= k &lt; nums.length</code>) such that the resulting array is <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code> (<strong>0-indexed</strong>). For example, <code>[0,1,2,4,5,6,7]</code> might be left rotated by&nbsp;<code>3</code>&nbsp;indices and become <code>[4,5,6,7,0,1,2]</code>.</p>\n\n<p>Given the array <code>nums</code> <strong>after</strong> the possible rotation and an integer <code>target</code>, return <em>the index of </em><code>target</code><em> if it is in </em><code>nums</code><em>, or </em><code>-1</code><em> if it is not in </em><code>nums</code>.</p>\n\n<p>You must write an algorithm with <code>O(log n)</code> runtime complexity.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> nums = [4,5,6,7,0,1,2], target = 0\n<strong>Output:</strong> 4\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> nums = [4,5,6,7,0,1,2], target = 3\n<strong>Output:</strong> -1\n</pre><p><strong class=\"example\">Example 3:</strong></p>\n<pre><strong>Input:</strong> nums = [1], target = 0\n<strong>Output:</strong> -1\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 5000</code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n\t<li>All values of <code>nums</code> are <strong>unique</strong>.</li>\n\t<li><code>nums</code> is an ascending array that is possibly rotated.</li>\n\t<li><code>-10<sup>4</sup> &lt;= target &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
  "difficulty": "Medium",
  "stats": "{\"totalAccepted\": \"4.2M\", \"totalSubmission\": \"9.6M\", \"totalAcceptedRaw\": 4242984, \"totalSubmissionRaw\": 9627486, \"acRate\": \"44.1%\"}",
  "hints": [],
  "similarQuestions": "[{\"title\": \"Search in Rotated Sorted Array II\", \"titleSlug\": \"search-in-rotated-sorted-array-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Find Minimum in Rotated Sorted Array\", \"titleSlug\": \"find-minimum-in-rotated-sorted-array\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Pour Water Between Buckets to Make Water Levels Equal\", \"titleSlug\": \"pour-water-between-buckets-to-make-water-levels-equal\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
  "topicTags": [
    {
      "name": "Array",
      "slug": "array"
    },
    {
      "name": "Binary Search",
      "slug": "binary-search"
    }
  ],
  "companyTags": null,
  "codeSnippets": [
    {
      "lang": "C++",
      "langSlug": "cpp",
      "code": "class Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        \n    }\n};"
    },
    {
      "lang": "Java",
      "langSlug": "java",
      "code": "class Solution {\n    public int search(int[] nums, int target) {\n        \n    }\n}"
    },
    {
      "lang": "Python3",
      "langSlug": "python3",
      "code": "class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        "
    },
    {
      "lang": "Python",
      "langSlug": "python",
      "code": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        "
    },
    {
      "lang": "JavaScript",
      "langSlug": "javascript",
      "code": "/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nvar search = function(nums, target) {\n    \n};"
    },
    {
      "lang": "TypeScript",
      "langSlug": "typescript",
      "code": "function search(nums: number[], target: number): number {\n    \n};"
    },
    {
      "lang": "C#",
      "langSlug": "csharp",
      "code": "public class Solution {\n    public int Search(int[] nums, int target) {\n        \n    }\n}"
    },
    {
      "lang": "C",
      "langSlug": "c",
      "code": "int search(int* nums, int numsSize, int target) {\n    \n}"
    },
    {
      "lang": "Go",
      "langSlug": "golang",
      "code": "func search(nums []int, target int) int {\n    \n}"
    },
    {
      "lang": "Kotlin",
      "langSlug": "kotlin",
      "code": "class Solution {\n    fun search(nums: IntArray, target: Int): Int {\n        \n    }\n}"
    },
    {
      "lang": "Swift",
      "langSlug": "swift",
      "code": "class Solution {\n    func search(_ nums: [Int], _ target: Int) -> Int {\n        \n    }\n}"
    },
    {
      "lang": "Rust",
      "langSlug": "rust",
      "code": "impl Solution {\n    pub fn search(nums: Vec<i32>, target: i32) -> i32 {\n        \n    }\n}"
    },
    {
      "lang": "Ruby",
      "langSlug": "ruby",
      "code": "# @param {Integer[]} nums\n# @param {Integer} target\n# @return {Integer}\ndef search(nums, target)\n    \nend"
    },
    {
      "lang": "PHP",
      "langSlug": "php",
      "code": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer $target\n     * @return Integer\n     */\n    function search($nums, $target) {\n        \n    }\n}"
    },
    {
      "lang": "Dart",
      "langSlug": "dart",
      "code": "class Solution {\n  int search(List<int> nums, int target) {\n    \n  }\n}"
    },
    {
      "lang": "Scala",
      "langSlug": "scala",
      "code": "object Solution {\n    def search(nums: Array[Int], target: Int): Int = {\n        \n    }\n}"
    },
    {
      "lang": "Elixir",
      "langSlug": "elixir",
      "code": "defmodule Solution do\n  @spec search(nums :: [integer], target :: integer) :: integer\n  def search(nums, target) do\n    \n  end\nend"
    },
    {
      "lang": "Erlang",
      "langSlug": "erlang",
      "code": "-spec search(Nums :: [integer()], Target :: integer()) -> integer().\nsearch(Nums, Target) ->\n  ."
    },
    {
      "lang": "Racket",
      "langSlug": "racket",
      "code": "(define/contract (search nums target)\n  (-> (listof exact-integer?) exact-integer? exact-integer?)\n  )"
    }
  ],
  "solution": {
    "content": "<div class=\"flex flex-col w-full\" style=\"position: relative;\"><div class=\"mYe_l WRmCx\"><h2 id=\"solution\" level=\"2\" class=\"group/heading relative\"><a href=\"#solution\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" aria-hidden=\"true\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"link\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" role=\"img\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 640 512\" spacing=\"square\"><path fill=\"currentColor\" d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\"></path></svg></div></a>Solution</h2>\n<hr>\n<h3 id=\"overview\" level=\"3\" class=\"group/heading relative\"><a href=\"#overview\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" aria-hidden=\"true\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"link\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" role=\"img\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 640 512\" spacing=\"square\"><path fill=\"currentColor\" d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\"></path></svg></div></a>Overview</h3>\n<p>Define the <strong>pivot</strong> index as representing the <strong>smallest</strong> element in <code>nums</code>.</p>\n<p><img alt=\"img\" src=\"../Figures/33/1.png\"></p>\n<p>In a rotated sorted array, the pivot value signifies where the rotation occurs. It partitions the array (of length <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></span>) into two sorted portions <code>nums[0 ~ pivot - 1]</code> and <code>nums[pivot ~ n - 1]</code>.</p>\n<hr>\n<h3 id=\"approach-1-find-pivot-index--binary-search\" level=\"3\" class=\"group/heading relative\"><a href=\"#approach-1-find-pivot-index--binary-search\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" aria-hidden=\"true\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"link\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" role=\"img\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 640 512\" spacing=\"square\"><path fill=\"currentColor\" d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\"></path></svg></div></a>Approach 1: Find Pivot Index + Binary Search</h3>\n<h4 id=\"intuition\">Intuition</h4>\n<blockquote>\n<p>If you are not familiar with binary search, please refer to our explore cards <a href=\"https://leetcode.com/explore/learn/card/binary-search/\" target=\"_blank\">Binary Search Explore Card</a>. We will focus on the usage in this article and not the underlying principles or implementation details.</p>\n</blockquote>\n<p>To pinpoint the pivot value, we can employ a modified binary search algorithm and find the leftmost element that is smaller than or equal to the last element in <code>nums</code>.</p>\n<p><img alt=\"img\" src=\"../Figures/33/o1.png\"></p>\n<p>After identifying the middle element in the searching space <code>[left ~ right]</code>, we compare <code>nums[mid]</code> with <code>nums[-1]</code>.</p>\n<ul>\n<li>If <code>nums[mid] &gt; nums[-1]</code>, it suggests that the pivot value lies on the right of <code>nums[mid]</code>. We will then proceed with the right half of the search space, which is <code>[mid + 1 ~ right]</code>.</li>\n<li>Otherwise, the pivot value is <code>nums[mid]</code> or it's situated to the left of <code>nums[mid]</code>, we continue with the left half of the searching space, which is <code>[left ~ mid - 1]</code>.</li>\n</ul>\n<p><img alt=\"img\" src=\"../Figures/33/o2.png\"></p>\n<p>By determining the pivot value, we set the boundaries for our subsequent binary searches. Once we have the pivot value, we can execute two binary searches on each half of the array to locate the target element.</p>\n<br>\n<blockquote>\n<blockquote>\n<p>Note: the typical way to calculate <code>mid</code> is <code>(left + right) / 2</code>. However, a safer way is <code>left + (right - left) / 2</code>. The two equations are equivalent, but the second one is safer because it guarantees no number larger than <code>right</code> is ever stored. In the first equation, if <code>left + right</code> is huge, then it could end up overflowing.</p>\n</blockquote>\n</blockquote>\n<h4 id=\"algorithm\">Algorithm</h4>\n<ol>\n<li data-length=\"1\">\n<p>Perform a binary search to locate the pivot element by initializing the boundaries of the searching space as <code>left = 0</code> and <code>right = n - 1</code>. While <code>left &lt; right</code>:</p>\n<ul>\n<li>Let <code>mid = left + (right - left) // 2</code>.</li>\n<li>If <code>nums[mid] &gt; nums[n - 1]</code>, this suggests that <code>pivot</code> is located to the right of <code>mid</code>, hence we set <code>left = mid + 1</code>. Otherwise, <code>pivot</code> could be either at <code>mid</code> or to the left of <code>mid</code>, in which case we should set <code>right = mid - 1</code>.</li>\n</ul>\n</li>\n<li data-length=\"1\">\n<p>Upon completion of the binary search, we have the pivot index denoted as <code>pivot = left</code>.</p>\n</li>\n<li data-length=\"1\">\n<p><code>nums</code> consists of two sorted subarrays, <code>nums[0 ~ left - 1]</code> and <code>nums[left ~ n - 1]</code>.</p>\n</li>\n<li data-length=\"1\">\n<p>Perform a binary search over <code>nums[0 ~ left - 1]</code> for <code>target</code>. If <code>target</code> is within this subarray, return its index.</p>\n</li>\n<li data-length=\"1\">\n<p>Otherwise, perform a binary search over <code>nums[left ~ n - 1]</code> for <code>target</code>. If <code>target</code> is within this subarray, return its index. Otherwise, return <code>-1</code>.</p>\n</li>\n</ol>\n<h4 id=\"implementation\">Implementation</h4>\n<iframe src=\"https://leetcode.com/playground/ULivn3qC/shared\" width=\"100%\" height=\"500\" name=\"user-content-ULivn3qC\" allowfullscreen=\"\" translate=\"no\"></iframe>\n<h4 id=\"complexity-analysis\">Complexity Analysis</h4>\n<p>Let <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></span> be the length of <code>nums</code>.</p>\n<ul>\n<li>\n<p>Time complexity: <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mop\">lo<span style=\"margin-right: 0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right: 0.1667em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<ul>\n<li>The algorithm requires one binary search to locate <code>pivot</code>, and at most 2 binary searches to find <code>target</code>. Each binary search takes <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mop\">lo<span style=\"margin-right: 0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right: 0.1667em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span> time.</li>\n</ul>\n</li>\n<li>\n<p>Space complexity: <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<ul>\n<li>We only need to update several parameters <code>left</code>, <code>right</code> and <code>mid</code>, which takes <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></span> space.</li>\n</ul>\n</li>\n</ul>\n<br>\n<hr>\n<h3 id=\"approach-2-find-pivot-index--binary-search-with-shift\" level=\"3\" class=\"group/heading relative\"><a href=\"#approach-2-find-pivot-index--binary-search-with-shift\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" aria-hidden=\"true\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"link\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" role=\"img\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 640 512\" spacing=\"square\"><path fill=\"currentColor\" d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\"></path></svg></div></a>Approach 2: Find Pivot Index + Binary Search with Shift</h3>\n<h4 id=\"intuition-1\">Intuition</h4>\n<p>The array we're working with has been rotated by a certain number of steps, which means we can't apply a regular binary search to the modified array. However, if we can revert this array to its original sorted form, then a conventional binary search becomes a viable approach.</p>\n<p>Our key task is to locate <code>pivot</code>, the index of the smallest value in <code>nums</code>. Notably, <code>nums[pivot]</code> would have been at index 0 in the unrotated, original array. Hence, if we were to rotate it to the right by <code>n - pivot</code> steps (taking the modulus of <code>n</code> into account), it would return to its original position, index 0.</p>\n<p>Applying the same transformation to every element enables us to revert the rotated array back to its original, sorted form.</p>\n<p><img alt=\"img\" src=\"../Figures/33/t1.png\"></p>\n<p>At this point, we can perform a conventional binary search to locate the target. Let's assume that <code>nums[i] = target</code>. Remembering that we had to shift every element to the right by <code>n - pivot</code> steps to reach the sorted version of nums, we now need to shift the index in the sorted nums to the left by <code>n - pivot</code> steps to find its corresponding index, <code>i</code>, in the original nums. This gives us <code>i - (n - pivot)</code> (taking the modulus of <code>n</code> into account).</p>\n<p><img alt=\"img\" src=\"../Figures/33/t2.png\"></p>\n<p>Crucially, there's no need to actually create the sorted version of <code>nums</code> from the original <code>nums</code>. We can simply represent the sorted <code>nums</code> by shifting the indices.</p>\n<br>\n<h4 id=\"algorithm-1\">Algorithm</h4>\n<ol>\n<li data-length=\"1\">\n<p>Perform a binary search to locate the pivot element by initializing the boundaries of the searching space as <code>left = 0</code> and <code>right = n - 1</code>. While <code>left &lt; right</code>:</p>\n<ul>\n<li>Let <code>mid = left + (right - left) // 2</code>.</li>\n<li>If <code>nums[mid] &gt; nums[n - 1]</code>, this suggests that <code>pivot</code> is located to the right of <code>mid</code>, hence we set <code>left = mid + 1</code>. Otherwise, <code>pivot</code> could be either at <code>mid</code> or to the left of <code>mid</code>, in which case we should set <code>right = mid - 1</code>.</li>\n</ul>\n</li>\n<li data-length=\"1\">\n<p>Upon completion of the binary search, we have the pivot index denoted as <code>pivot = left</code>.</p>\n</li>\n<li data-length=\"1\">\n<p>Set the boundaries of the search space as <code>(pivot + shift) % n</code> and <code>(pivot - 1 + shift) % n</code>.</p>\n</li>\n<li data-length=\"1\">\n<p>While <code>left &lt; right</code>, we get the middle index <code>mid = (left + right) // 2</code>, and compare <code>nums[(mid - shift + n) % n]</code> with <code>target</code>.</p>\n<ul>\n<li>If <code>nums[(mid - shift + n) % n]</code> is equal to <code>target</code>, return <code>mid - shift + n</code></li>\n<li>If <code>nums[(mid - shift + n) % n] &gt; target</code>, continue with the left half by setting <code>right</code> as <code>mid - 1</code>.</li>\n<li>If <code>nums[(mid - shift + n) % n] &lt; target</code>, continue with the right half by setting <code>left</code> as <code>mid + 1</code>.</li>\n</ul>\n</li>\n<li data-length=\"1\">\n<p>Return <code>-1</code> once the binary search is complete.</p>\n</li>\n</ol>\n<h4 id=\"implementation-1\">Implementation</h4>\n<iframe src=\"https://leetcode.com/playground/ikPeDTXM/shared\" width=\"100%\" height=\"500\" name=\"user-content-ikPeDTXM\" allowfullscreen=\"\" translate=\"no\"></iframe>\n<h4 id=\"complexity-analysis-1\">Complexity Analysis</h4>\n<p>Let <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></span> be the length of <code>nums</code>.</p>\n<ul>\n<li>\n<p>Time complexity: <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mop\">lo<span style=\"margin-right: 0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right: 0.1667em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<ul>\n<li>The algorithm requires one binary search to locate <code>pivot</code> and one binary search over the shifted indices to find <code>target</code>. Each binary search takes <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mop\">lo<span style=\"margin-right: 0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right: 0.1667em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span> time.</li>\n</ul>\n</li>\n<li>\n<p>Space complexity: <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<ul>\n<li>We only need to update several parameters <code>left</code>, <code>right</code> <code>mid</code> and <code>shift</code>, which takes <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></span> space.</li>\n</ul>\n</li>\n</ul>\n<br>\n<hr>\n<h3 id=\"approach-3-one-binary-search\" level=\"3\" class=\"group/heading relative\"><a href=\"#approach-3-one-binary-search\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" aria-hidden=\"true\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"link\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" role=\"img\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 640 512\" spacing=\"square\"><path fill=\"currentColor\" d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\"></path></svg></div></a>Approach 3: One Binary Search</h3>\n<h4 id=\"intuition-2\">Intuition</h4>\n<p>The two preceding approaches both comprise two steps:</p>\n<ul>\n<li>Perform a binary search to identify the pivot index.</li>\n<li>Conduct another binary search to locate the target value.</li>\n</ul>\n<p>However, we can perform these two steps within a single binary search.</p>\n<br>\n<p>Let's take a step back and consider a regular binary search. Why are we able to confidently discard half of the array after comparing <code>target</code> with the middle value <code>nums[mid]</code>? The reason is that both halves of the array are sorted. Hence, if <code>target</code> is less than the middle value, it's assured to be smaller than every value in the right half. If <code>target</code> is larger than the middle value, it's guaranteed to be larger than every value in the left half. Therefore, we can safely discard one half of <code>nums</code> in either case.</p>\n<p>However, a rotated sorted array may not possess this characteristic â€“ we can't determine whether <code>target</code> is definitively not in the array just by comparing boundary values.</p>\n<br>\n<p>If we cut a subarray <code>nums[left ~ right]</code> by the index <code>mid</code>. We split this subarray into 3 parts:</p>\n<ul>\n<li>subarray <code>nums[left ~ mid - 1]</code></li>\n<li>element <code>nums[mid]</code>.</li>\n<li>subarray <code>nums[mid + 1, right]</code>.</li>\n</ul>\n<p>It is important to note that there is at most one rotated sorted array in the two subarrays, which means that there is at least one sorted array for comparison.</p>\n<p><img alt=\"img\" src=\"../Figures/33/q0.png\"></p>\n<p>Therefore, we can compare <code>target</code> with the sorted half to decide which subarray to retain for the next round.</p>\n<blockquote>\n<p>It is straightforward to determine if a sorted array <code>A[l ~ r]</code> could possibly contain <code>target</code>, we can simply compare <code>target</code> with two boundary values <code>A[l]</code> and <code>A[r]</code>.</p>\n<ul>\n<li>If <code>A[l] &lt;= target &lt;= A[r]</code>, then <code>A[l ~ r]</code> might contain <code>target</code>, which needs to be verified by binary search, we will continue with this subarray.</li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li>Otherwise, <code>target</code> is guaranteed to not be in <code>A[l ~ r]</code>, and there is no need to search over this array, we will continue with the other subarray.</li>\n</ul>\n</blockquote>\n<br>\n<p>To sum up, there are 3 possible cases after comparing <code>target</code> with <code>nums[mid]</code>:</p>\n<p>Case 1. If <code>nums[mid] = target</code>, which denotes that we have found <code>target</code>, return <code>mid</code> as its index.</p>\n<p>Case 2. If <code>nums[mid] &gt;= nums[left]</code>. It implies that the left subarray <code>nums[left ~ mid]</code> is sorted. We can determine whether to proceed with this subarray by comparing <code>target</code> with the boundary elements:</p>\n<ul>\n<li>If <code>nums[left] &lt;= target</code> and <code>target &lt; nums[mid]</code>, it suggests that the sorted left half might include <code>target</code> while the other half does not contain <code>target</code>. Consequently, we focus on the left half for further steps.</li>\n<li>Otherwise, the left half is guaranteed not to contain <code>target</code>, and we will move on to the right half.</li>\n</ul>\n<p><img alt=\"img\" src=\"../Figures/33/q1.png\"></p>\n<p>Case 3. If <code>nums[mid] &lt; nums[left]</code>, it implies that the left subarray is rotated and the right subarray <code>nums[mid ~ right]</code> is sorted. Therefore, we can determine whether to proceed with the right subarray by comparing the target with its boundary elements:</p>\n<ul>\n<li>If <code>nums[mid] &lt; target</code> and <code>target &lt; nums[right]</code>, it implies that the sorted right half might contain <code>target</code>. As a result, we will move on with the right half.</li>\n<li>Otherwise, the right half is guaranteed not to contain <code>target</code>, and we will move on to the left half.</li>\n</ul>\n<p><img alt=\"img\" src=\"../Figures/33/q2.png\"></p>\n<br>\n<h4 id=\"algorithm-2\">Algorithm</h4>\n<ul>\n<li>\n<p>Initialize pointers:</p>\n<ul>\n<li>Set <code>left</code> to 0.</li>\n<li>Set <code>right</code> to <code>n - 1</code> where <code>n</code> is the length of the array <code>nums</code>.</li>\n</ul>\n</li>\n<li>\n<p>Perform binary search:</p>\n<ul>\n<li>While <code>left</code> is less than or equal to <code>right</code>:\n<ul>\n<li>\n<p>Calculate the middle index <code>mid</code> as <code>left + (right - left) / 2</code>.</p>\n</li>\n<li>\n<p>Case 1: Check if the middle element <code>nums[mid]</code> is equal to <code>target</code>.</p>\n<ul>\n<li>If true, return <code>mid</code> as the index of <code>target</code>.</li>\n</ul>\n</li>\n<li>\n<p>Case 2: Check if the subarray from <code>left</code> to <code>mid</code> is sorted (<code>nums[mid] &gt;= nums[left]</code>).</p>\n<ul>\n<li>If <code>target</code> is within the range <code>[nums[left], nums[mid])</code>:\n<ul>\n<li>Adjust the search range by setting <code>right</code> to <code>mid - 1</code>.</li>\n</ul>\n</li>\n<li>Otherwise:\n<ul>\n<li>Adjust the search range by setting <code>left</code> to <code>mid + 1</code>.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>Case 3: If the subarray from <code>mid</code> to <code>right</code> is sorted (<code>nums[mid] &gt; nums[right]</code>):</p>\n<ul>\n<li>If <code>target</code> is within the range <code>(nums[mid], nums[right]]</code>:\n<ul>\n<li>Adjust the search range by setting <code>left</code> to <code>mid + 1</code>.</li>\n</ul>\n</li>\n<li>Otherwise:\n<ul>\n<li>Adjust the search range by setting <code>right</code> to <code>mid - 1</code>.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>If the target is not found, return <code>-1</code>.</p>\n</li>\n</ul>\n<h4 id=\"implementation-2\">Implementation</h4>\n<iframe src=\"https://leetcode.com/playground/ChfaVX79/shared\" width=\"100%\" height=\"500\" name=\"user-content-ChfaVX79\" allowfullscreen=\"\" translate=\"no\"></iframe>\n<h4 id=\"complexity-analysis-2\">Complexity Analysis</h4>\n<p>Let <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></span> be the length of <code>nums</code>.</p>\n<ul>\n<li>\n<p>Time complexity: <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mop\">lo<span style=\"margin-right: 0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right: 0.1667em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<ul>\n<li>This algorithm only requires one binary search over <code>nums</code>.</li>\n</ul>\n</li>\n<li>\n<p>Space complexity: <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<ul>\n<li>We only need to update several parameters <code>left</code>, <code>right</code> and <code>mid</code>, which takes <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></span> space.</li>\n</ul>\n</li>\n</ul>\n<br></div><span style=\"font-size: 0px; line-height: 0;\">&nbsp;</span></div>",
    "isOfficial": true,
    "scrapedAt": "2026-02-18T06:56:57.106Z"
  }
}