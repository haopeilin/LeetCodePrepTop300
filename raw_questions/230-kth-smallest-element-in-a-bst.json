{
    "questionId": "230",
    "questionFrontendId": "230",
    "title": "Kth Smallest Element in a BST",
    "titleSlug": "kth-smallest-element-in-a-bst",
    "content": "<p>Given the <code>root</code> of a binary search tree, and an integer <code>k</code>, return <em>the</em> <code>k<sup>th</sup></code> <em>smallest value (<strong>1-indexed</strong>) of all the values of the nodes in the tree</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"images/230/kthtree1.jpg\" style=\"width: 212px; height: 301px;\" />\n<pre>\n<strong>Input:</strong> root = [3,1,4,null,2], k = 1\n<strong>Output:</strong> 1\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"images/230/kthtree2.jpg\" style=\"width: 382px; height: 302px;\" />\n<pre>\n<strong>Input:</strong> root = [5,3,6,2,4,null,null,1], k = 3\n<strong>Output:</strong> 3\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is <code>n</code>.</li>\n\t<li><code>1 &lt;= k &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= Node.val &lt;= 10<sup>4</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> If the BST is modified often (i.e., we can do insert and delete operations) and you need to find the kth smallest frequently, how would you optimize?</p>\n",
    "difficulty": "Medium",
    "stats": "{\"totalAccepted\": \"2.2M\", \"totalSubmission\": \"2.8M\", \"totalAcceptedRaw\": 2167047, \"totalSubmissionRaw\": 2834557, \"acRate\": \"76.5%\"}",
    "hints": [
        "Try to utilize the property of a BST.",
        "Try in-order traversal. (Credits to @chan13)",
        "What if you could modify the BST node's structure?",
        "The optimal runtime complexity is O(height of BST)."
    ],
    "similarQuestions": "[{\"title\": \"Binary Tree Inorder Traversal\", \"titleSlug\": \"binary-tree-inorder-traversal\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Second Minimum Node In a Binary Tree\", \"titleSlug\": \"second-minimum-node-in-a-binary-tree\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
    "topicTags": [
        {
            "name": "Tree",
            "slug": "tree"
        },
        {
            "name": "Depth-First Search",
            "slug": "depth-first-search"
        },
        {
            "name": "Binary Search Tree",
            "slug": "binary-search-tree"
        },
        {
            "name": "Binary Tree",
            "slug": "binary-tree"
        }
    ],
    "companyTags": null,
    "codeSnippets": [
        {
            "lang": "Java",
            "langSlug": "java",
            "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int kthSmallest(TreeNode root, int k) {\n        \n    }\n}"
        }
    ],
    "solution": {
        "content": "<h2><a href=\"#solution\"><svg><path></path></svg></a>Solution</h2>\n<hr/>\n<h3><a href=\"#how-to-traverse-the-tree\"><svg><path></path></svg></a>How to traverse the tree</h3>\n<p>There are two general strategies to traverse a tree:</p>\n<ul>\n<li>\n<p><em>Depth First Search</em> (<code>DFS</code>)</p>\n<p>In this strategy, we adopt the <code>depth</code> as the priority, so that one would start from a root and reach all the way down to a certain leaf, and then backtracks until it finds another unexplored branch. The DFS strategy can further be distinguished as <code>preorder</code>, <code>inorder</code>, and <code>postorder</code> depending on the relative order among the root node, left node, and right node.</p>\n</li>\n<li>\n<p><em>Breadth First Search</em> (<code>BFS</code>)</p>\n<p>We scan through the tree level by level, following the order of height, from top to bottom. The nodes on higher levels would be visited before the ones with lower levels.</p>\n</li>\n</ul>\n<p>In the following figure, the nodes are enumerated in the order you visit them, please follow <code>1-2-3-4-5</code> to compare different strategies.</p>\n<p></p>\n<blockquote>\n<p>To solve the problem, one could use the property of BST: inorder traversal of BST is an array sorted in ascending order.</p>\n</blockquote>\n<br/>\n<br/>\n<hr/>\n<h3><a href=\"#approach-1-recursive-inorder-traversal\"><svg><path></path></svg></a>Approach 1: Recursive Inorder Traversal</h3>\n<p>It's a very straightforward approach with O(N) time complexity. The idea is to build an inorder traversal of BST which is an array sorted in the ascending order. Now the answer is the <code>k - 1</code>th element of this array.</p>\n<p></p>\n<pre><code>class Solution {\n  public ArrayList&lt;Integer&gt; inorder(TreeNode root, ArrayList&lt;Integer&gt; arr) {\n    if (root == null) return arr;\n    inorder(root.left, arr);\n    arr.add(root.val);\n    inorder(root.right, arr);\n    return arr;\n  }\n​\n  public int kthSmallest(TreeNode root, int k) {\n    ArrayList&lt;Integer&gt; nums = inorder(root, new ArrayList&lt;Integer&gt;());\n    return nums.get(k - 1);\n  }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time complexity : O(N) to build a traversal.</li>\n<li>Space complexity : O(N) to keep an inorder traversal.\n<br/>\n</li>\n</ul>\n<br/>\n<hr/>\n<h3><a href=\"#approach-2-iterative-inorder-traversal\"><svg><path></path></svg></a>Approach 2: Iterative Inorder Traversal</h3>\n<p>The above recursion could be converted into iteration, with the help of stack. This way one could speed up the solution because there is no need to build the entire inorder traversal, and one could stop after the kth element.</p>\n<p></p>\n<pre><code>class Solution {\n  public int kthSmallest(TreeNode root, int k) {\n    LinkedList&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;();\n​\n    while (true) {\n      while (root != null) {\n        stack.push(root);\n        root = root.left;\n      }\n      root = stack.pop();\n      if (--k == 0) return root.val;\n      root = root.right;\n    }\n  }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity: O(H+k), where H is a tree height. This complexity is defined by the stack, which contains at least H+k elements, since before starting to pop out one has to go down to a leaf. This results in O(logN+k) for the balanced tree and O(N+k) for a completely unbalanced tree with all the nodes in the left subtree.</p>\n</li>\n<li>\n<p>Space complexity: O(H) to keep the stack, where H is a tree height. That makes O(N) in the worst case of the skewed tree, and O(logN) in the average case of the balanced tree.</p>\n<br/>\n</li>\n</ul>\n<br/>\n<hr/>\n<h3><a href=\"#follow-up\"><svg><path></path></svg></a>Follow up</h3>\n<blockquote>\n<p>What if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?</p>\n</blockquote>\n<p>Click here to learn how to <a href=\"https://leetcode.com/articles/insert-into-a-bst/\">insert a node into a BST</a> and <a href=\"https://leetcode.com/articles/delete-node-in-a-bst/\">delete a node from a BST</a>, the time complexity of these operations is O(H), where H is a height of the binary tree. H=logN for the balanced tree and H=N for a skewed tree.</p>\n<p>Hence without any optimisation insert/delete + search of kth element has O(2H+k) complexity. How to optimize that?</p>\n<p>That's a design question, basically, we're asked to implement a structure that contains a BST inside and optimises the following operations :</p>\n<ul>\n<li>\n<p>Insert</p>\n</li>\n<li>\n<p>Delete</p>\n</li>\n<li>\n<p>Find kth smallest</p>\n</li>\n</ul>\n<p>Seems like a database description, isn't it? Let's use here the same logic as for <a href=\"https://leetcode.com/articles/lru-cache/\">LRU cache</a> design, and combine an indexing structure (we could keep BST here) with a doubly-linked list.</p>\n<p>Such a structure would provide:</p>\n<ul>\n<li>\n<p>O(H) time for the insert and delete.</p>\n</li>\n<li>\n<p>O(k) for the search of kth smallest.</p>\n</li>\n</ul>\n<p></p>\n<p>The overall time complexity for insert/delete + search of kth smallest is O(H+k) instead of O(2H+k).</p>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity for insert/delete + search of kth smallest: O(H+k), where H is a tree height. O(logN+k) in the average case, O(N+k) in the worst case.</p>\n</li>\n<li>\n<p>Space complexity : O(N) to keep the linked list.</p>\n</li>\n</ul>",
        "isOfficial": true,
        "scrapedAt": "2026-02-18T07:13:25.139Z"
    }
}