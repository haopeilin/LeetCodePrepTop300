{
    "questionId": "108",
    "questionFrontendId": "108",
    "title": "Convert Sorted Array to Binary Search Tree",
    "titleSlug": "convert-sorted-array-to-binary-search-tree",
    "content": "<p>Given an integer array <code>nums</code> where the elements are sorted in <strong>ascending order</strong>, convert <em>it to a </em><span data-keyword=\"height-balanced\"><strong><em>height-balanced</em></strong></span> <em>binary search tree</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"images/108/btree1.jpg\" style=\"width: 302px; height: 222px;\" />\n<pre>\n<strong>Input:</strong> nums = [-10,-3,0,5,9]\n<strong>Output:</strong> [0,-3,9,-10,null,5]\n<strong>Explanation:</strong> [0,-10,5,null,-3,null,9] is also accepted:\n<img alt=\"\" src=\"images/108/btree2.jpg\" style=\"width: 302px; height: 222px;\" />\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"images/108/btree.jpg\" style=\"width: 342px; height: 142px;\" />\n<pre>\n<strong>Input:</strong> nums = [1,3]\n<strong>Output:</strong> [3,1]\n<strong>Explanation:</strong> [1,null,3] and [3,1] are both height-balanced BSTs.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>nums</code> is sorted in a <strong>strictly increasing</strong> order.</li>\n</ul>\n",
    "difficulty": "Easy",
    "stats": "{\"totalAccepted\": \"1.7M\", \"totalSubmission\": \"2.2M\", \"totalAcceptedRaw\": 1672705, \"totalSubmissionRaw\": 2225246, \"acRate\": \"75.2%\"}",
    "hints": [],
    "similarQuestions": "[{\"title\": \"Convert Sorted List to Binary Search Tree\", \"titleSlug\": \"convert-sorted-list-to-binary-search-tree\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
    "topicTags": [
        {
            "name": "Array",
            "slug": "array"
        },
        {
            "name": "Divide and Conquer",
            "slug": "divide-and-conquer"
        },
        {
            "name": "Tree",
            "slug": "tree"
        },
        {
            "name": "Binary Search Tree",
            "slug": "binary-search-tree"
        },
        {
            "name": "Binary Tree",
            "slug": "binary-tree"
        }
    ],
    "companyTags": null,
    "codeSnippets": [
        {
            "lang": "Java",
            "langSlug": "java",
            "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode sortedArrayToBST(int[] nums) {\n        \n    }\n}"
        }
    ],
    "solution": {
        "content": "<h2><a href=\"#solution\"><svg><path></path></svg></a>Solution</h2>\n<hr/>\n<h3><a href=\"#how-to-traverse-the-tree-dfs-preorder-inorder-postorder-bfs\"><svg><path></path></svg></a>How to Traverse the Tree. DFS: Preorder, Inorder, Postorder; BFS.</h3>\n<p>There are two general strategies to traverse a tree:</p>\n<ul>\n<li>\n<p><em>Depth First Search</em> (<code>DFS</code>)</p>\n<p>In this strategy, we adopt the <code>depth</code> as the priority, so that one would start from a root and reach all the way down to a certain leaf, and then back to the root to reach another branch.</p>\n<p>The DFS strategy can further be distinguished as <code>preorder</code>, <code>inorder</code>, and <code>postorder</code> depending on the relative order among the root node, left node, and right node.</p>\n</li>\n<li>\n<p><em>Breadth First Search</em> (<code>BFS</code>)</p>\n<p>We scan through the tree level by level, following the order of height, from top to bottom. The nodes on higher levels would be visited before the ones with lower levels.</p>\n</li>\n</ul>\n<p>In the following figure, the nodes are enumerated in the order you visit them, please follow <code>1-2-3-4-5</code> to compare different strategies.</p>\n<p><br/>\n<br/><br/>\n<br/></p>\n<hr/>\n<h3><a href=\"#construct-bst-from-inorder-traversal-why-the-solution-is-not-unique\"><svg><path></path></svg></a>Construct BST from Inorder Traversal: Why the Solution is <em>Not</em> Unique</h3>\n<p>It's known that <a href=\"https://leetcode.com/articles/delete-node-in-a-bst/\">inorder traversal of BST is an array sorted in the ascending order</a>.</p>\n<p>Having the sorted array as an input, we could rewrite the problem as <em>Construct Binary Search Tree from Inorder Traversal</em>.</p>\n<blockquote>\n<p>Does this problem have a unique solution, i.e. could inorder traversal be used as a unique identifier to encore/decode BST? The answer is <em>no</em>.</p>\n</blockquote>\n<p>Here is the funny thing about BST. Inorder traversal is <em>not</em> a unique identifier of BST. At the same time, both preorder and postorder traversals <em>are</em> unique identifiers of BST. <a href=\"https://leetcode.com/articles/construct-bst-from-preorder-traversal/\">From these traversals one could restore the inorder one</a>:<br/>\n<code>inorder = sorted(postorder) = sorted(preorder)</code>, and <a href=\"https://leetcode.com/articles/construct-binary-tree-from-inorder-and-postorder-t/\">inorder + postorder or inorder + preorder are both unique identifiers of whatever binary tree</a>.</p>\n<p>So, the problem \"sorted array -&gt; BST\" has multiple solutions.</p>\n<p></p>\n<p>Here we have an additional condition: <em>the tree should be height-balanced</em>, i.e. the depths of the two subtrees of every node never differ by more than 1.</p>\n<blockquote>\n<p>Does it make the solution to be unique? Still no.</p>\n</blockquote>\n<p></p>\n<p>Basically, the height-balanced restriction means that at each step one has to pick up the number in the middle as a root. That works fine with arrays containing an odd number of elements but there is no predefined choice for arrays with an even number of elements.</p>\n<p></p>\n<p>One could choose the left middle element, or the right middle one, and both choices will lead to <em>different</em> height-balanced BSTs. Let's see that in practice: in Approach 1 we will always pick up the left middle element and in Approach 2 - the right middle one. That will generate <em>different</em> BSTs but both solutions will be accepted.<br/>\n<br/><br/>\n<br/></p>\n<hr/>\n<h3><a href=\"#approach-1-preorder-traversal-always-choose-left-middle-node-as-a-root\"><svg><path></path></svg></a>Approach 1: Preorder Traversal: Always Choose Left Middle Node as a Root</h3>\n<p><strong>Algorithm</strong></p>\n<p></p>\n<ul>\n<li>\n<p>Implement helper function <code>helper(left, right)</code>, which constructs BST from nums elements between indexes <code>left</code> and <code>right</code>:</p>\n<ul>\n<li>\n<p>If left &gt; right, then there is no elements available for that subtree. Return None.</p>\n</li>\n<li>\n<p>Pick left middle element: <code>p = (left + right) // 2</code>.</p>\n</li>\n<li>\n<p>Initiate the root: <code>root = TreeNode(nums[p])</code>.</p>\n</li>\n<li>\n<p>Compute recursively left and right subtrees: <code>root.left = helper(left, p - 1)</code>, <code>root.right = helper(p + 1, right)</code>.</p>\n</li>\n</ul>\n</li>\n<li>\n<p>Return <code>helper(0, len(nums) - 1)</code>.</p>\n</li>\n</ul>\n<p><strong>Implementation</strong></p>\n<pre><code>class Solution {\n    public TreeNode sortedArrayToBST(int[] nums) {\n        return helper(nums, 0, nums.length - 1);\n    }\n\n    private TreeNode helper(int[] nums, int left, int right) {\n        if (left &gt; right) {\n            return null;\n        }\n        int p = (left + right) / 2;\n        TreeNode root = new TreeNode(nums[p]);\n        root.left = helper(nums, left, p - 1);\n        root.right = helper(nums, p + 1, right);\n        return root;\n    }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity: O(N) since we visit each node exactly once.</p>\n</li>\n<li>\n<p>Space complexity: O(logN).</p>\n<p>The recursion stack requires O(logN) space because the tree is height-balanced. Note that the O(N) space used to store the output does not count as auxiliary space, so it is not included in the space complexity.</p>\n<br/>\n</li>\n</ul>\n<br/>\n<hr/>\n<h3><a href=\"#approach-2-preorder-traversal-always-choose-right-middle-node-as-a-root\"><svg><path></path></svg></a>Approach 2: Preorder Traversal: Always Choose Right Middle Node as a Root</h3>\n<p><strong>Algorithm</strong></p>\n<p></p>\n<ul>\n<li>\n<p>Implement helper function <code>helper(left, right)</code>, which constructs BST from nums elements between indexes <code>left</code> and <code>right</code>:</p>\n<ul>\n<li>\n<p>If left &gt; right, then there are no elements available for that subtree. Return None.</p>\n</li>\n<li>\n<p>Pick the right middle element:</p>\n<ul>\n<li>\n<p><code>p = (left + right) // 2</code>.</p>\n</li>\n<li>\n<p>If <code>left + right</code> is odd, add 1 to p-index.</p>\n</li>\n</ul>\n</li>\n<li>\n<p>Initiate the root: <code>root = TreeNode(nums[p])</code>.</p>\n</li>\n<li>\n<p>Compute recursively left and right subtrees: <code>root.left = helper(left, p - 1)</code>, <code>root.right = helper(p + 1, right)</code>.</p>\n</li>\n</ul>\n</li>\n<li>\n<p>Return <code>helper(0, len(nums) - 1)</code>.</p>\n</li>\n</ul>\n<p><strong>Implementation</strong></p>\n<pre><code>class Solution {\n    private TreeNode helper(int[] nums, int left, int right) {\n        if (left &gt; right) return null;\n        // always choose right middle node as a root\n        int p = (left + right) / 2;\n        if ((left + right) % 2 == 1) p++;\n        // preorder traversal: node -&gt; left -&gt; right\n        TreeNode root = new TreeNode(nums[p]);\n        root.left = helper(nums, left, p - 1);\n        root.right = helper(nums, p + 1, right);\n        return root;\n    }\n\n    public TreeNode sortedArrayToBST(int[] nums) {\n        return helper(nums, 0, nums.length - 1);\n    }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity: O(N) since we visit each node exactly once.</p>\n</li>\n<li>\n<p>Space complexity: O(logN).</p>\n<p>The recursion stack requires O(logN) space because the tree is height-balanced. Note that the O(N) space used to store the output does not count as auxiliary space, so it is not included in the space complexity.</p>\n<br/>\n</li>\n</ul>\n<br/>\n<hr/>\n<h3><a href=\"#approach-3-preorder-traversal-choose-a-random-middle-node-as-a-root\"><svg><path></path></svg></a>Approach 3: Preorder Traversal: Choose a Random Middle Node as a Root</h3>\n<p>This one is for fun. Instead of a predefined choice, we will pick randomly the left or right middle node at each step. Each run will result in a different solution and they all will be accepted.</p>\n<p></p>\n<p><strong>Algorithm</strong></p>\n<ul>\n<li>\n<p>Implement helper function <code>helper(left, right)</code>, which constructs BST from nums elements between indexes <code>left</code> and <code>right</code>:</p>\n<ul>\n<li>\n<p>If left &gt; right, then there are no elements available for that subtree. Return None.</p>\n</li>\n<li>\n<p>Pick a random middle element:</p>\n<ul>\n<li>\n<p><code>p = (left + right) // 2</code>.</p>\n</li>\n<li>\n<p>If <code>left + right</code> is odd, add randomly 0 or 1 to p-index.</p>\n</li>\n</ul>\n</li>\n<li>\n<p>Initiate the root: <code>root = TreeNode(nums[p])</code>.</p>\n</li>\n<li>\n<p>Compute recursively left and right subtrees: <code>root.left = helper(left, p - 1)</code>, <code>root.right = helper(p + 1, right)</code>.</p>\n</li>\n</ul>\n</li>\n<li>\n<p>Return <code>helper(0, len(nums) - 1)</code>.</p>\n</li>\n</ul>\n<p><strong>Implementation</strong></p>\n<pre><code>import java.util.Random;\n\nclass Solution {\n    private final Random random = new Random();\n\n    public TreeNode sortedArrayToBST(int[] nums) {\n        return helper(nums, 0, nums.length - 1);\n    }\n\n    private TreeNode helper(int[] nums, int left, int right) {\n        if (left &gt; right) return null;\n        // choose random middle node as a root\n        int p = (left + right) / 2;\n        if ((left + right) % 2 == 1) p += random.nextInt(2);\n        TreeNode root = new TreeNode(nums[p]);\n        root.left = helper(nums, left, p - 1);\n        root.right = helper(nums, p + 1, right);\n        return root;\n    }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity: O(N) since we visit each node exactly once.</p>\n</li>\n<li>\n<p>Space complexity: O(logN).</p>\n<p>The recursion stack requires O(logN) space because the tree is height-balanced. Note that the O(N) space used to store the output does not count as auxiliary space, so it is not included in the space complexity.</p>\n</li>\n</ul>",
        "isOfficial": true,
        "scrapedAt": "2026-02-18T07:17:29.535Z"
    }
}