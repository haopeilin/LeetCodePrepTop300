{
    "questionId": "54",
    "questionFrontendId": "54",
    "title": "Spiral Matrix",
    "titleSlug": "spiral-matrix",
    "content": "<p>Given an <code>m x n</code> <code>matrix</code>, return <em>all elements of the</em> <code>matrix</code> <em>in spiral order</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"images/54/spiral1.jpg\" style=\"width: 242px; height: 242px;\" />\n<pre>\n<strong>Input:</strong> matrix = [[1,2,3],[4,5,6],[7,8,9]]\n<strong>Output:</strong> [1,2,3,6,9,8,7,4,5]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"images/54/spiral.jpg\" style=\"width: 322px; height: 242px;\" />\n<pre>\n<strong>Input:</strong> matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]\n<strong>Output:</strong> [1,2,3,4,8,12,11,10,9,5,6,7]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == matrix.length</code></li>\n\t<li><code>n == matrix[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 10</code></li>\n\t<li><code>-100 &lt;= matrix[i][j] &lt;= 100</code></li>\n</ul>\n",
    "difficulty": "Medium",
    "stats": "{\"totalAccepted\": \"2.3M\", \"totalSubmission\": \"4.1M\", \"totalAcceptedRaw\": 2286624, \"totalSubmissionRaw\": 4077884, \"acRate\": \"56.1%\"}",
    "hints": [
        "Well for some problems, the best way really is to come up with some algorithms for simulation. Basically, you need to simulate what the problem asks us to do.",
        "We go boundary by boundary and move inwards. That is the essential operation. First row, last column, last row, first column, and then we move inwards by 1 and repeat. That's all. That is all the simulation that we need.",
        "Think about when you want to switch the progress on one of the indexes. If you progress on i out of [i, j], you'll shift in the same column. Similarly, by changing values for j, you'd be shifting in the same row.\r\nAlso, keep track of the end of a boundary so that you can move inwards and then keep repeating. It's always best to simulate edge cases like a single column or a single row to see if anything breaks or not."
    ],
    "similarQuestions": "[{\"title\": \"Spiral Matrix II\", \"titleSlug\": \"spiral-matrix-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Spiral Matrix III\", \"titleSlug\": \"spiral-matrix-iii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Spiral Matrix IV\", \"titleSlug\": \"spiral-matrix-iv\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
    "topicTags": [
        {
            "name": "Array",
            "slug": "array"
        },
        {
            "name": "Matrix",
            "slug": "matrix"
        },
        {
            "name": "Simulation",
            "slug": "simulation"
        }
    ],
    "companyTags": null,
    "codeSnippets": [
        {
            "lang": "C++",
            "langSlug": "cpp",
            "code": "class Solution {\npublic:\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\n        \n    }\n};"
        },
        {
            "lang": "Java",
            "langSlug": "java",
            "code": "class Solution {\n    public List<Integer> spiralOrder(int[][] matrix) {\n        \n    }\n}"
        },
        {
            "lang": "Python3",
            "langSlug": "python3",
            "code": "class Solution:\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        "
        },
        {
            "lang": "Python",
            "langSlug": "python",
            "code": "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        "
        },
        {
            "lang": "JavaScript",
            "langSlug": "javascript",
            "code": "/**\n * @param {number[][]} matrix\n * @return {number[]}\n */\nvar spiralOrder = function(matrix) {\n    \n};"
        },
        {
            "lang": "TypeScript",
            "langSlug": "typescript",
            "code": "function spiralOrder(matrix: number[][]): number[] {\n    \n};"
        },
        {
            "lang": "C#",
            "langSlug": "csharp",
            "code": "public class Solution {\n    public IList<int> SpiralOrder(int[][] matrix) {\n        \n    }\n}"
        },
        {
            "lang": "C",
            "langSlug": "c",
            "code": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* spiralOrder(int** matrix, int matrixSize, int* matrixColSize, int* returnSize) {\n    \n}"
        },
        {
            "lang": "Go",
            "langSlug": "golang",
            "code": "func spiralOrder(matrix [][]int) []int {\n    \n}"
        },
        {
            "lang": "Kotlin",
            "langSlug": "kotlin",
            "code": "class Solution {\n    fun spiralOrder(matrix: Array<IntArray>): List<Int> {\n        \n    }\n}"
        },
        {
            "lang": "Swift",
            "langSlug": "swift",
            "code": "class Solution {\n    func spiralOrder(_ matrix: [[Int]]) -> [Int] {\n        \n    }\n}"
        },
        {
            "lang": "Rust",
            "langSlug": "rust",
            "code": "impl Solution {\n    pub fn spiral_order(matrix: Vec<Vec<i32>>) -> Vec<i32> {\n        \n    }\n}"
        },
        {
            "lang": "Ruby",
            "langSlug": "ruby",
            "code": "# @param {Integer[][]} matrix\n# @return {Integer[]}\ndef spiral_order(matrix)\n    \nend"
        },
        {
            "lang": "PHP",
            "langSlug": "php",
            "code": "class Solution {\n\n    /**\n     * @param Integer[][] $matrix\n     * @return Integer[]\n     */\n    function spiralOrder($matrix) {\n        \n    }\n}"
        },
        {
            "lang": "Dart",
            "langSlug": "dart",
            "code": "class Solution {\n  List<int> spiralOrder(List<List<int>> matrix) {\n    \n  }\n}"
        },
        {
            "lang": "Scala",
            "langSlug": "scala",
            "code": "object Solution {\n    def spiralOrder(matrix: Array[Array[Int]]): List[Int] = {\n        \n    }\n}"
        },
        {
            "lang": "Elixir",
            "langSlug": "elixir",
            "code": "defmodule Solution do\n  @spec spiral_order(matrix :: [[integer]]) :: [integer]\n  def spiral_order(matrix) do\n    \n  end\nend"
        },
        {
            "lang": "Erlang",
            "langSlug": "erlang",
            "code": "-spec spiral_order(Matrix :: [[integer()]]) -> [integer()].\nspiral_order(Matrix) ->\n  ."
        },
        {
            "lang": "Racket",
            "langSlug": "racket",
            "code": "(define/contract (spiral-order matrix)\n  (-> (listof (listof exact-integer?)) (listof exact-integer?))\n  )"
        }
    ],
    "solution": {
        "content": "<div class=\"flex flex-col w-full\" style=\"position: relative;\"><div class=\"mYe_l WRmCx\"><h2 id=\"solution\" level=\"2\" class=\"group/heading relative\"><a href=\"#solution\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" aria-hidden=\"true\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"link\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" role=\"img\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 640 512\" spacing=\"square\"><path fill=\"currentColor\" d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\"></path></svg></div></a>Solution</h2>\n<hr>\n<h3 id=\"overview\" level=\"3\" class=\"group/heading relative\"><a href=\"#overview\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" aria-hidden=\"true\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"link\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" role=\"img\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 640 512\" spacing=\"square\"><path fill=\"currentColor\" d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\"></path></svg></div></a>Overview</h3>\n<p>The problem statement asks us to <em>return all elements of the <code>matrix</code> in spiral order</em>, which means we will start from the top left corner and move towards right, then down, then left, and then up. Let's break this into further details:</p>\n<ol>\n<li data-length=\"1\">We can achieve moving in different directions by modifying row and column indices. Specifically, we have:</li>\n</ol>\n<div class=\"font-menlo mb-6 rounded-lg px-3 py-2.5 text-sm bg-fill-3 dark:bg-dark-fill-3\"><div class=\"group relative\" translate=\"no\"><pre style=\"color: black; font-size: 13px; text-shadow: none; font-family: Menlo, Monaco, Consolas; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 4; hyphens: none; padding: 0px; margin: 0px; overflow: auto; background: transparent; overflow-wrap: normal;\"><code class=\"language-plain\" style=\"white-space: pre; text-shadow: none;\"><span><span>Given that we are at (row, col), where row is the row index, and col is the column index.\n</span></span><span>\n</span><span>move right: (row, col + 1)\n</span><span>move downwards: (row + 1, col)\n</span><span>move left: (row, col - 1)\n</span><span>move upwards: (row - 1, col)</span></code></pre><div class=\"absolute -right-1.5 -top-0.5 flex gap-2\"><div class=\"z-base-1 hidden rounded border group-hover:block border-border-quaternary dark:border-border-quaternary bg-layer-02 dark:bg-layer-02\"><div class=\"relative cursor-pointer flex h-[22px] w-[22px] items-center justify-center bg-layer-02 dark:bg-layer-02 hover:bg-fill-tertiary dark:hover:bg-fill-tertiary rounded-[4px]\" data-state=\"closed\"><div><div data-state=\"closed\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3 h-3.5 w-3.5 text-text-primary dark:text-text-primary\"><svg aria-hidden=\"true\" focusable=\"false\" data-prefix=\"far\" data-icon=\"clone\" class=\"svg-inline--fa fa-clone absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" role=\"img\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 512 512\"><path fill=\"currentColor\" d=\"M64 464H288c8.8 0 16-7.2 16-16V384h48v64c0 35.3-28.7 64-64 64H64c-35.3 0-64-28.7-64-64V224c0-35.3 28.7-64 64-64h64v48H64c-8.8 0-16 7.2-16 16V448c0 8.8 7.2 16 16 16zM224 304H448c8.8 0 16-7.2 16-16V64c0-8.8-7.2-16-16-16H224c-8.8 0-16 7.2-16 16V288c0 8.8 7.2 16 16 16zm-64-16V64c0-35.3 28.7-64 64-64H448c35.3 0 64 28.7 64 64V288c0 35.3-28.7 64-64 64H224c-35.3 0-64-28.7-64-64z\"></path></svg></div></div></div></div></div></div></div></div>\n<ol start=\"2\">\n<li data-length=\"1\">When shall we change our direction? We need to turn when we either <em>reach the matrix boundaries</em>, or we <em>reach the cells in the array that we have visited before</em>. Matrix boundaries are fixed and provided already, but how could we know if we have visited a particular cell or not?<br>\nIn fact, we have two different strategies and they will be introduced in the following approaches. Generally speaking, they are as follows:\n<ul>\n<li>Approach 1. We can move the boundaries towards the center of the matrix after we have traversed a row or a column. Then when we meet a boundary, we know it's time to change the direction and update the boundary.</li>\n<li>Approach 2. While traversing the matrix, we can record each location that we have visited. Then when we meet a matrix boundary or a previously visited cell, we know it's time to change the direction.</li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<p>This is a good time to stop and see if you can come up with the implementations yourselves!</p>\n</blockquote>\n<br>\n<hr>\n<h3 id=\"approach-1-set-up-boundaries\" level=\"3\" class=\"group/heading relative\"><a href=\"#approach-1-set-up-boundaries\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" aria-hidden=\"true\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"link\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" role=\"img\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 640 512\" spacing=\"square\"><path fill=\"currentColor\" d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\"></path></svg></div></a>Approach 1: Set Up Boundaries</h3>\n<p><strong>Intuition</strong></p>\n<p>Our goal is to update boundaries as follows: when we finish traversing a row or column, we want to set up a boundary on it so that next time we get there, we know we need to change the direction. Here is a demo for the first round of updating the top, right, bottom, and left boundaries.</p>\n<p></p>\n<br>\n<p><strong>Algorithm</strong></p>\n<ol>\n<li data-length=\"1\">Initialize the top, right, bottom, and left boundaries as <code>up</code>, <code>right</code>, <code>down</code>, and <code>left</code>.</li>\n<li data-length=\"1\">Initialize the output array <code>result</code>.</li>\n<li data-length=\"1\">Traverse the elements in spiral order and add each element to <code>result</code>:\n<ul>\n<li>Traverse from <code>left</code> boundary to <code>right</code> boundary.</li>\n<li>Traverse from <code>up</code> boundary to <code>down</code> boundary.</li>\n<li>Before we traverse from right to left, we need to make sure that we are not on a row that has already been traversed. If we are not, then we can traverse from <code>right</code> to <code>left</code>.</li>\n<li>Similarly, before we traverse from top to bottom, we need to make sure that we are not on a column that has already been traversed. Then we can traverse from <code>down</code> to <code>up</code>.</li>\n<li>Remember to move the boundaries by updating <code>left</code>, <code>right</code>, <code>up</code>, and <code>down</code> accordingly.</li>\n</ul>\n</li>\n<li data-length=\"1\">Return <code>result</code>.</li>\n</ol>\n<pre><code>class Solution {\npublic:\n    vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;& matrix) {\n        vector&lt;int&gt; result;\n        int rows = matrix.size();\n        int columns = matrix[0].size();\n        int up = 0;\n        int left = 0;\n        int right = columns - 1;\n        int down = rows - 1;\n        while (result.size() &lt; rows * columns) {\n            // Traverse from left to right.\n            for (int col = left; col &lt;= right; col++) {\n                result.push_back(matrix[up][col]);\n            }\n            // Traverse downwards.\n            for (int row = up + 1; row &lt;= down; row++) {\n                result.push_back(matrix[row][right]);\n            }\n            // Make sure we are now on a different row.\n            if (up != down) {\n                // Traverse from right to left.\n                for (int col = right - 1; col &gt;= left; col--) {\n                    result.push_back(matrix[down][col]);\n                }\n            }\n            // Make sure we are now on a different column.\n            if (left != right) {\n                // Traverse upwards.\n                for (int row = down - 1; row &gt; up; row--) {\n                    result.push_back(matrix[row][left]);\n                }\n            }\n            left++;\n            right--;\n            up++;\n            down--;\n        }\n        return result;\n    }\n};</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<p>Let <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">M</span></span></span></span></span> be the number of rows and <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span></span></span></span></span> be the number of columns.</p>\n<ul>\n<li>\n<p>Time complexity: <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span></span>. This is because we visit each element once.</p>\n</li>\n<li>\n<p>Space complexity: <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></span>. This is because we don't use other data structures. Remember that we don't include the output array in the space complexity.</p>\n</li>\n</ul>\n<br>\n<hr>\n<h3 id=\"approach-2-mark-visited-elements\" level=\"3\" class=\"group/heading relative\"><a href=\"#approach-2-mark-visited-elements\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" aria-hidden=\"true\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"link\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" role=\"img\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 640 512\" spacing=\"square\"><path fill=\"currentColor\" d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\"></path></svg></div></a>Approach 2: Mark Visited Elements</h3>\n<p><strong>Intuition</strong></p>\n<p>If we mark the cells that we have visited, then when we run into a visited cell, we know we need to turn.</p>\n<blockquote>\n<p>How do we know which direction we need to turn to? Well, we are always following this loop: right, down, left, up, right again, and so on. Therefore, when we run into a cell that we have visited, we can simply turn to the next direction in the aforementioned loop.</p>\n</blockquote>\n<p>Note that elements in the matrix are constrained to <code>-100 &lt;= matrix[row][col] &lt;= 100</code>, therefore we can select a number that is out of this range to mark it. In this article, <code>101</code> is selected for marking purposes.</p>\n<blockquote>\n<p>Modifying the original data may not be a good choice sometimes. Therefore, we can also prepare another boolean matrix to store the cells we visited. However, the implementation of this approach is quite similar. You are welcome to explore this implementation as an exercise.</p>\n</blockquote>\n<p>The last puzzle piece is when shall we stop. An interesting observation is that if we reach the visited cell, we need to turn.  However, when we meet another visited cell immediately after changing the direction, it means we reached the last element in the matrix. You'll see that an integer <code>changeDirection</code> is used to track the number of times we changed the direction consecutively.</p>\n<p><strong>Algorithm</strong></p>\n<ul>\n<li>Initializations:\n<ul>\n<li>Initialize a 2D array <code>directions </code> to represent the four directions that we will move.</li>\n<li>Initialize <code>currentDirection</code> to 0 to signify that we are moving right at the beginning.</li>\n<li>Initialize <code>VISITED</code> to 101 to mark visited cells.</li>\n<li>Initialize <code>changeDirection</code> to 0.</li>\n<li>Initialize <code>row</code> and <code>col</code> to 0 since our initial position is <code>(0, 0)</code>.</li>\n</ul>\n</li>\n<li>We follow the current direction until we reach the matrix boundaries or a visited cell.\n<ul>\n<li>While traversing in the current direction, remember to reset <code>changeDirection</code> to 0 at every step.</li>\n<li>Move to the next cell by updating the row and column indices.</li>\n<li>Append the element to the result and mark the location as visited.</li>\n</ul>\n</li>\n<li>Update the direction and <code>changeDirection</code>. If <code>changeDirection</code> is larger than 1, it means we are continuously changing our directions, and therefore we've visited all of the elements.</li>\n</ul>\n<pre><code>class Solution {\npublic:\n    vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;& matrix) {\n        const int VISITED = 101;\n        int rows = matrix.size(), columns = matrix[0].size();\n        // Four directions that we will move: right, down, left, up.\n        vector&lt;vector&lt;int&gt;&gt; directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n        // Initial direction: moving right.\n        int currentDirection = 0;\n        // The number of times we change the direction.\n        int changeDirection = 0;\n        // Current place that we are at is (row, col).\n        // row is the row index; col is the column index.\n        int row = 0, col = 0;\n        // Store the first element and mark it as visited.\n        vector&lt;int&gt; result = {matrix[0][0]};\n        matrix[0][0] = VISITED;\n        while (changeDirection &lt; 2) {\n            while (0 &lt;= row + directions[currentDirection][0] &&\n                   row + directions[currentDirection][0] &lt; rows &&\n                   0 &lt;= col + directions[currentDirection][1] &&\n                   col + directions[currentDirection][1] &lt; columns &&\n                   matrix[row + directions[currentDirection][0]]\n                         [col + directions[currentDirection][1]] != VISITED) {\n                // Reset this to 0 since we did not break and change the\n                // direction.\n                changeDirection = 0;\n                // Calculate the next place that we will move to.\n                row += directions[currentDirection][0];\n                col += directions[currentDirection][1];\n                result.push_back(matrix[row][col]);\n                matrix[row][col] = VISITED;\n            }\n            // Change our direction.\n            currentDirection = (currentDirection + 1) % 4;\n            // Increment change_direction because we changed our direction.\n            changeDirection++;\n        }\n        return result;\n    }\n};</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<p>Let <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">M</span></span></span></span></span> be the number of rows and <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span></span></span></span></span> be the number of columns.</p>\n<ul>\n<li>\n<p>Time complexity: <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span></span>. This is because we visit each element once.</p>\n</li>\n<li>\n<p>Space complexity: <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></span>. This is because we don't use other data structures. Remember that we don't consider the output array or the input matrix when calculating the space complexity. However, if we were prohibited from mutating the input matrix, then this would be an <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span></span> space solution.  This is because we would need to use a boolean matrix to track all of the previously seen cells.</p>\n</li>\n</ul>\n<br>\n<hr></div><span style=\"font-size: 0px; line-height: 0;\">&nbsp;</span></div>",
        "isOfficial": true,
        "scrapedAt": "2026-02-18T08:06:59.073Z"
    }
}