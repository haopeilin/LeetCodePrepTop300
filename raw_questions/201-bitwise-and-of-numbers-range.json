{
  "questionId": "201",
  "questionFrontendId": "201",
  "title": "Bitwise AND of Numbers Range",
  "titleSlug": "bitwise-and-of-numbers-range",
  "content": "<p>Given two integers <code>left</code> and <code>right</code> that represent the range <code>[left, right]</code>, return <em>the bitwise AND of all numbers in this range, inclusive</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> left = 5, right = 7\n<strong>Output:</strong> 4\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> left = 0, right = 0\n<strong>Output:</strong> 0\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> left = 1, right = 2147483647\n<strong>Output:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= left &lt;= right &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
  "difficulty": "Medium",
  "stats": "{\"totalAccepted\": \"501.2K\", \"totalSubmission\": \"1M\", \"totalAcceptedRaw\": 501237, \"totalSubmissionRaw\": 1030858, \"acRate\": \"48.6%\"}",
  "hints": [],
  "similarQuestions": "[{\"title\": \"Longest Nice Subarray\", \"titleSlug\": \"longest-nice-subarray\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
  "topicTags": [
    {
      "name": "Bit Manipulation",
      "slug": "bit-manipulation"
    }
  ],
  "companyTags": null,
  "codeSnippets": [
    {
      "lang": "C++",
      "langSlug": "cpp",
      "code": "class Solution {\npublic:\n    int rangeBitwiseAnd(int left, int right) {\n        \n    }\n};"
    },
    {
      "lang": "Java",
      "langSlug": "java",
      "code": "class Solution {\n    public int rangeBitwiseAnd(int left, int right) {\n        \n    }\n}"
    },
    {
      "lang": "Python3",
      "langSlug": "python3",
      "code": "class Solution:\n    def rangeBitwiseAnd(self, left: int, right: int) -> int:\n        "
    },
    {
      "lang": "Python",
      "langSlug": "python",
      "code": "class Solution(object):\n    def rangeBitwiseAnd(self, left, right):\n        \"\"\"\n        :type left: int\n        :type right: int\n        :rtype: int\n        \"\"\"\n        "
    },
    {
      "lang": "JavaScript",
      "langSlug": "javascript",
      "code": "/**\n * @param {number} left\n * @param {number} right\n * @return {number}\n */\nvar rangeBitwiseAnd = function(left, right) {\n    \n};"
    },
    {
      "lang": "TypeScript",
      "langSlug": "typescript",
      "code": "function rangeBitwiseAnd(left: number, right: number): number {\n    \n};"
    },
    {
      "lang": "C#",
      "langSlug": "csharp",
      "code": "public class Solution {\n    public int RangeBitwiseAnd(int left, int right) {\n        \n    }\n}"
    },
    {
      "lang": "C",
      "langSlug": "c",
      "code": "int rangeBitwiseAnd(int left, int right) {\n    \n}"
    },
    {
      "lang": "Go",
      "langSlug": "golang",
      "code": "func rangeBitwiseAnd(left int, right int) int {\n    \n}"
    },
    {
      "lang": "Kotlin",
      "langSlug": "kotlin",
      "code": "class Solution {\n    fun rangeBitwiseAnd(left: Int, right: Int): Int {\n        \n    }\n}"
    },
    {
      "lang": "Swift",
      "langSlug": "swift",
      "code": "class Solution {\n    func rangeBitwiseAnd(_ left: Int, _ right: Int) -> Int {\n        \n    }\n}"
    },
    {
      "lang": "Rust",
      "langSlug": "rust",
      "code": "impl Solution {\n    pub fn range_bitwise_and(left: i32, right: i32) -> i32 {\n        \n    }\n}"
    },
    {
      "lang": "Ruby",
      "langSlug": "ruby",
      "code": "# @param {Integer} left\n# @param {Integer} right\n# @return {Integer}\ndef range_bitwise_and(left, right)\n    \nend"
    },
    {
      "lang": "PHP",
      "langSlug": "php",
      "code": "class Solution {\n\n    /**\n     * @param Integer $left\n     * @param Integer $right\n     * @return Integer\n     */\n    function rangeBitwiseAnd($left, $right) {\n        \n    }\n}"
    },
    {
      "lang": "Dart",
      "langSlug": "dart",
      "code": "class Solution {\n  int rangeBitwiseAnd(int left, int right) {\n    \n  }\n}"
    },
    {
      "lang": "Scala",
      "langSlug": "scala",
      "code": "object Solution {\n    def rangeBitwiseAnd(left: Int, right: Int): Int = {\n        \n    }\n}"
    },
    {
      "lang": "Elixir",
      "langSlug": "elixir",
      "code": "defmodule Solution do\n  @spec range_bitwise_and(left :: integer, right :: integer) :: integer\n  def range_bitwise_and(left, right) do\n    \n  end\nend"
    },
    {
      "lang": "Erlang",
      "langSlug": "erlang",
      "code": "-spec range_bitwise_and(Left :: integer(), Right :: integer()) -> integer().\nrange_bitwise_and(Left, Right) ->\n  ."
    },
    {
      "lang": "Racket",
      "langSlug": "racket",
      "code": "(define/contract (range-bitwise-and left right)\n  (-> exact-integer? exact-integer? exact-integer?)\n  )"
    }
  ],
  "solution": {
    "content": "<div class=\"flex flex-col w-full\" style=\"position: relative;\"><div class=\"mYe_l WRmCx\"><h2 id=\"solution\" level=\"2\" class=\"group/heading relative\"><a href=\"#solution\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" aria-hidden=\"true\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"link\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" role=\"img\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 640 512\" spacing=\"square\"><path fill=\"currentColor\" d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\"></path></svg></div></a>Solution</h2>\n<hr>\n<h3 id=\"overview\" level=\"3\" class=\"group/heading relative\"><a href=\"#overview\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" aria-hidden=\"true\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"link\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" role=\"img\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 640 512\" spacing=\"square\"><path fill=\"currentColor\" d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\"></path></svg></div></a>Overview</h3>\n<p>First of all, one of the most intuitive solutions that one might come up with might be to iterate all the numbers <em><strong>one by one</strong></em> in the range and do the bit AND operation to obtain the result.</p>\n<p>This could work for test cases with a small range. Unfortunately, it would exceed the time limit set by the online judge for test cases with a relatively large range. In this article, we will illustrate some other solutions that do not require the iteration of all numbers.</p>\n<p>First of all, let us look into the characteristics of the AND operation.</p>\n<blockquote>\n<p>For a series of bits, <em>e.g.</em> <code>[1, 1, 0, 1, 1]</code>, as long as there is one bit of zero value, then the result of AND operation on this series of bits would be zero.</p>\n</blockquote>\n<p>Back to our problem, first, we could represent each number in the range in its binary form which we could view as a string of binary numbers (<em>e.g.</em> <code>9 = 00001001</code>).<br>\nWe then align the numbers according to the position of the binary string.</p>\n<p><img alt=\"pic\" src=\"../Figures/201/201_prefix.png\"></p>\n<p>In the above example, one might notice that after the AND operation on all the numbers, the remaining part of bit strings is the <em><strong>common prefix</strong></em> of all these bit strings.</p>\n<p>The final result asked by the problem consists of this common prefix of a bit string as its left part, with the rest of the bits as zeros.</p>\n<p>More specifically, the <em>common prefix</em> of all these bit strings is also the common prefix between the <strong><em>starting</em></strong> and <strong><em>ending</em></strong> numbers of the specified range (<em>i.e.</em> 9 and 12 respectively in the above example).</p>\n<blockquote>\n<p>As a result, we then can reformulate the problem as <em>\"given two integer numbers, we are asked to find the <em><strong>common prefix</strong></em> of their binary strings.\"</em></p>\n</blockquote>\n<hr>\n<h3 id=\"approach-1-bit-shift\" level=\"3\" class=\"group/heading relative\"><a href=\"#approach-1-bit-shift\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" aria-hidden=\"true\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"link\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" role=\"img\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 640 512\" spacing=\"square\"><path fill=\"currentColor\" d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\"></path></svg></div></a>Approach 1: Bit Shift</h3>\n<p><strong>Intuition</strong></p>\n<p>Given the above intuition about the problem, our task is to calculate the <em>common prefix</em> for the bit strings of the two given numbers. One of the solutions would be to resort to the <em><strong>bit shift</strong></em> operation.</p>\n<blockquote>\n<p>The idea is that we shift both numbers to the right, until the numbers become equal, <em>i.e.</em> the numbers are reduced into their common prefix. Then we append zeros to the common prefix in order to obtain the desired result, by shifting the common prefix to the left.</p>\n</blockquote>\n<p><img alt=\"pic\" src=\"../Figures/201/201_bit_shifting.png\"></p>\n<h4 id=\"algorithm\">Algorithm</h4>\n<p>As stated in the intuition section, the algorithm consists of two steps:</p>\n<ul>\n<li>\n<p>We reduce both numbers into their common prefix, by doing right shift iteratively. During the iteration, we keep the count on the number of shift operations we perform.</p>\n<br>\n</li>\n<li>\n<p>With the common prefix, we restore it to its previous position, by left shifting.</p>\n</li>\n</ul>\n<p></p>\n<h4 id=\"implementation\">Implementation</h4>\n<pre><code>class Solution {\npublic:\n    int rangeBitwiseAnd(int m, int n) {\n        int shift = 0;\n        // find the common 1-bits\n        while (m &lt; n) {\n            m &gt;&gt;= 1;\n            n &gt;&gt;= 1;\n            ++shift;\n        }\n        return m &lt;&lt; shift;\n    }\n};</code></pre>\n<h4 id=\"complexity-analysis\">Complexity Analysis</h4>\n<ul>\n<li>\n<p>Time Complexity: <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathcal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n<ul>\n<li>\n<p>Although there is a loop in the algorithm, the number of iterations is bounded by the number of bits that an integer has, which is fixed.</p>\n  <br>\n</li>\n<li>\n<p>Therefore, the time complexity of the algorithm is constant.</p>\n  <br>\n</li>\n</ul>\n</li>\n<li>\n<p>Space Complexity: <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathcal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></span>. The consumption of the memory for our algorithm is constant, regardless the input.</p>\n</li>\n</ul>\n<hr>\n<h3 id=\"approach-2-brian-kernighans-algorithm\" level=\"3\" class=\"group/heading relative\"><a href=\"#approach-2-brian-kernighans-algorithm\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" aria-hidden=\"true\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"link\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" role=\"img\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 640 512\" spacing=\"square\"><path fill=\"currentColor\" d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\"></path></svg></div></a>Approach 2: Brian Kernighan's Algorithm</h3>\n<h4 id=\"intuition\">Intuition</h4>\n<p>Speaking of bit shifting, there is another related algorithm called <a href=\"http://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetKernighan\" target=\"_blank\">Brian Kernighan's algorithm</a> which is applied to turn off the rightmost bit of one in a number.</p>\n<p>The secret sauce of the <em>Brian Kernighan's algorithm</em> can be summarized as follows:</p>\n<blockquote>\n<p>When we do an AND bit operation between <code>number</code> and <code>number - 1</code>, the rightmost bit of one in the original <code>number</code> would be turned off (from one to zero).</p>\n</blockquote>\n<p><img alt=\"pic\" src=\"../Figures/201/201_bk_example.png\"></p>\n<p>Based on the above trick, we could apply it to figure out the common prefix of two-bit strings.</p>\n<h4 id=\"algorithm-1\">Algorithm</h4>\n<blockquote>\n<p>The idea is that for a given range <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">m</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right: 0.1667em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">]</span></span></span></span></span> (<em>i.e.</em> <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.5782em; vertical-align: -0.0391em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></span>), we could iteratively apply the trick on the number <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></span> to <em>turn off</em> its rightmost bit of one until it becomes less or equal than the beginning of the range (<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.4306em;\"></span><span class=\"mord mathnormal\">m</span></span></span></span></span>), which we denote as <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.7519em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.7519em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span></span></span></span></span>. Finally, we return <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></span> as the final result, which contains the common prefix.</p>\n</blockquote>\n<p>By applying Brian Kernighan's algorithm, we basically turn off the bits that lie on the right side of the <em>common prefix</em>, from the ending number <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></span>.<br>\nWith the rest of the bits reset, we can easily obtain the desired result.</p>\n<p><img alt=\"pic\" src=\"../Figures/201/201_kernighan.png\"></p>\n<p>In the example (<code>m=9, n=12</code>) shown in the above figure, the common prefix would be <code>00001</code>. After applying Brian Kernighan's algorithm on the number <code>n</code>, it's trailing 3 bits would all become zeros. Finally, return <code>n</code> to obtain the common prefix.</p>\n<h4 id=\"implementation-1\">Implementation</h4>\n<pre><code>class Solution {\npublic:\n    int rangeBitwiseAnd(int m, int n) {\n        while (m &lt; n) {\n            // turn off rightmost 1-bit\n            n = n & (n - 1);\n        }\n        return n;\n    }\n};</code></pre>\n<p>By the way, one could refer to the problem called <a href=\"https://leetcode.com/articles/hamming-distance/\" target=\"_blank\">Hamming distance</a> as another exercise to apply Brian Kernighan's algorithm.</p>\n<h4 id=\"complexity-analysis-1\">Complexity Analysis</h4>\n<ul>\n<li>\n<p>Time Complexity: <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathcal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n<ul>\n<li>\n<p>Similar to the bit shift approach, the number of iterations in the algorithm is bounded by the number of bits in an integer number, which is constant.</p>\n  <br>\n</li>\n<li>\n<p>Though having the same asymptotic complexity as the bit shift approach, Brian Kernighan's algorithm requires fewer iterations, since it skips all the zero bits in between.</p>\n</li>\n</ul>\n</li>\n<li>\n<p>Space Complexity: <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathcal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></span>, since no additional memory is consumed by the algorithm.</p>\n</li>\n</ul></div><span style=\"font-size: 0px; line-height: 0;\">&nbsp;</span></div>",
    "isOfficial": true,
    "scrapedAt": "2026-02-18T08:24:43.488Z"
  }
}