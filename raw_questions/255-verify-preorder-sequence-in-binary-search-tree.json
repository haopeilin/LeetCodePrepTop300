{
    "questionId": "255",
    "questionFrontendId": "255",
    "title": "Verify Preorder Sequence in Binary Search Tree",
    "titleSlug": "verify-preorder-sequence-in-binary-search-tree",
    "content": "<p>Given an array of <strong>unique</strong> integers <code>preorder</code>, return <code>true</code> <em>if it is the correct preorder traversal sequence of a binary search tree</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"images/255/preorder-tree.jpg\" style=\"width: 292px; height: 302px;\" />\n<pre>\n<strong>Input:</strong> preorder = [5,2,1,3,6]\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> preorder = [5,2,6,1,3]\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= preorder.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= preorder[i] &lt;= 10<sup>4</sup></code></li>\n\t<li>All the elements of <code>preorder</code> are <strong>unique</strong>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Could you do it using only constant space complexity?</p>\n",
    "difficulty": "Medium",
    "stats": "{\"totalAccepted\": \"93.4K\", \"totalSubmission\": \"180.8K\", \"totalAcceptedRaw\": 93424, \"totalSubmissionRaw\": 180817, \"acRate\": \"51.7%\"}",
    "hints": [],
    "similarQuestions": "[{\"title\": \"Binary Tree Preorder Traversal\", \"titleSlug\": \"binary-tree-preorder-traversal\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
    "topicTags": [
        {
            "name": "Array",
            "slug": "array"
        },
        {
            "name": "Stack",
            "slug": "stack"
        },
        {
            "name": "Tree",
            "slug": "tree"
        },
        {
            "name": "Binary Search Tree",
            "slug": "binary-search-tree"
        },
        {
            "name": "Recursion",
            "slug": "recursion"
        },
        {
            "name": "Monotonic Stack",
            "slug": "monotonic-stack"
        },
        {
            "name": "Binary Tree",
            "slug": "binary-tree"
        }
    ],
    "companyTags": null,
    "codeSnippets": [
        {
            "lang": "C++",
            "langSlug": "cpp",
            "code": "class Solution {\npublic:\n    bool verifyPreorder(vector<int>& preorder) {\n        \n    }\n};"
        },
        {
            "lang": "Java",
            "langSlug": "java",
            "code": "class Solution {\n    public boolean verifyPreorder(int[] preorder) {\n        \n    }\n}"
        },
        {
            "lang": "Python3",
            "langSlug": "python3",
            "code": "class Solution:\n    def verifyPreorder(self, preorder: List[int]) -> bool:\n        "
        },
        {
            "lang": "Python",
            "langSlug": "python",
            "code": "class Solution(object):\n    def verifyPreorder(self, preorder):\n        \"\"\"\n        :type preorder: List[int]\n        :rtype: bool\n        \"\"\"\n        "
        },
        {
            "lang": "JavaScript",
            "langSlug": "javascript",
            "code": "/**\n * @param {number[]} preorder\n * @return {boolean}\n */\nvar verifyPreorder = function(preorder) {\n    \n};"
        },
        {
            "lang": "TypeScript",
            "langSlug": "typescript",
            "code": "function verifyPreorder(preorder: number[]): boolean {\n    \n};"
        },
        {
            "lang": "C#",
            "langSlug": "csharp",
            "code": "public class Solution {\n    public bool VerifyPreorder(int[] preorder) {\n        \n    }\n}"
        },
        {
            "lang": "C",
            "langSlug": "c",
            "code": "bool verifyPreorder(int* preorder, int preorderSize) {\n    \n}"
        },
        {
            "lang": "Go",
            "langSlug": "golang",
            "code": "func verifyPreorder(preorder []int) bool {\n    \n}"
        },
        {
            "lang": "Kotlin",
            "langSlug": "kotlin",
            "code": "class Solution {\n    fun verifyPreorder(preorder: IntArray): Boolean {\n        \n    }\n}"
        },
        {
            "lang": "Swift",
            "langSlug": "swift",
            "code": "class Solution {\n    func verifyPreorder(_ preorder: [Int]) -> Bool {\n        \n    }\n}"
        },
        {
            "lang": "Rust",
            "langSlug": "rust",
            "code": "impl Solution {\n    pub fn verify_preorder(preorder: Vec<i32>) -> bool {\n        \n    }\n}"
        },
        {
            "lang": "Ruby",
            "langSlug": "ruby",
            "code": "# @param {Integer[]} preorder\n# @return {Boolean}\ndef verify_preorder(preorder)\n    \nend"
        },
        {
            "lang": "PHP",
            "langSlug": "php",
            "code": "class Solution {\n\n    /**\n     * @param Integer[] $preorder\n     * @return Boolean\n     */\n    function verifyPreorder($preorder) {\n        \n    }\n}"
        },
        {
            "lang": "Dart",
            "langSlug": "dart",
            "code": "class Solution {\n  bool verifyPreorder(List<int> preorder) {\n    \n  }\n}"
        },
        {
            "lang": "Scala",
            "langSlug": "scala",
            "code": "object Solution {\n    def verifyPreorder(preorder: Array[Int]): Boolean = {\n        \n    }\n}"
        },
        {
            "lang": "Elixir",
            "langSlug": "elixir",
            "code": "defmodule Solution do\n  @spec verify_preorder(preorder :: [integer]) :: boolean\n  def verify_preorder(preorder) do\n    \n  end\nend"
        },
        {
            "lang": "Erlang",
            "langSlug": "erlang",
            "code": "-spec verify_preorder(Preorder :: [integer()]) -> boolean().\nverify_preorder(Preorder) ->\n  ."
        },
        {
            "lang": "Racket",
            "langSlug": "racket",
            "code": "(define/contract (verify-preorder preorder)\n  (-> (listof exact-integer?) boolean?)\n  )"
        }
    ],
    "solution": {
        "content": "<div class=\"flex flex-col w-full\" style=\"position: relative;\"><div class=\"mYe_l WRmCx\"><h2 id=\"solution\" level=\"2\" class=\"group/heading relative\"><a href=\"#solution\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" aria-hidden=\"true\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"link\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" role=\"img\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 640 512\" spacing=\"square\"><path fill=\"currentColor\" d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\"></path></svg></div></a>Solution</h2>\n<hr>\n<h3 id=\"approach-1-monotonic-stack\" level=\"3\" class=\"group/heading relative\"><a href=\"#approach-1-monotonic-stack\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" aria-hidden=\"true\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"link\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" role=\"img\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 640 512\" spacing=\"square\"><path fill=\"currentColor\" d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\"></path></svg></div></a>Approach 1: Monotonic Stack</h3>\n<p><strong>Intuition</strong></p>\n<p>In a preorder traversal, a node is handled before its children. This makes our lives a lot easier - if we instead had to verify a postorder or inorder traversal, it would be more challenging.</p>\n<p>Because a node is handled before its children, we can essentially iterate over the sequence <code>preorder</code> and decide what subtree each subsequent value should be in. For example, let's say we have <code>preorder = [5, 2, 1, 3, 6]</code>. The first value <code>5</code> must be the root. We then compare it with the next value <code>2</code>. Because <code>2 &lt; 5</code>, the <code>2</code> must be in the left subtree, so we can \"walk\" left. The next value <code>1</code> is less than <code>2</code>, so it must be in the left subtree of <code>2</code> - we can \"walk\" left again.</p>\n<p>The next value is <code>3</code>, which is greater than <code>1</code>. You may think: we should put <code>3</code> in the right subtree of <code>1</code>. This is wrong because we are currently in the left subtree of <code>2</code>, and the BST rule is that all nodes in the left subtree of <code>2</code> must be less than <code>2</code>. As such, we need to backtrack to put the <code>3</code> in the right subtree of <code>2</code> instead.</p>\n<p><img alt=\"\" width=\"960\" src=\"../Figures/255/1.png\"> <br></p>\n<p>When we perform a standard DFS on a binary tree with recursion, we traverse as far down the left branch as possible. Once we reach a leaf node, we backtrack up the tree by returning from the DFS function. Under the hood, the computer implements this by using a call stack. We can create our own stack to emulate this functionality.</p>\n<p><img alt=\"\" width=\"960\" src=\"../Figures/255/2.png\"> <br></p>\n<p>When we encounter a sequence of decreasing numbers, we're happy to continuously \"walk\" left. For example, let's say we had <code>preorder = [10, 9, 8, 7, 6, 5]</code>. The <code>10</code> is the root. The <code>9</code> is the left child of <code>10</code>. The <code>8</code> is the left child of <code>9</code>. The <code>7</code> is the left child of <code>8</code>, and so on. The issue arises when we find a larger value, because it must be a right child, and we need to identify which node should be its parent.</p>\n<p>Let's call this node with a large value <code>x</code>. We need to identify which node will have <code>x</code> as its right child. As we saw above in the images, we can't just immediately \"walk\" right as we might violate the BST property due to an ancestor that's higher up the tree.</p>\n<p><img alt=\"\" width=\"960\" src=\"../Figures/255/3.png\"> <br></p>\n<p>We need to find the ancestor with the greatest value that is less than <code>x</code>. The value needs to be less than <code>x</code> because <code>x</code> is going to be its right child. We need to find the greatest value, otherwise, there would be some other node that would break the BST property.</p>\n<p><img alt=\"\" width=\"960\" src=\"../Figures/255/4.png\"> <br></p>\n<p><img alt=\"\" width=\"960\" src=\"../Figures/255/5.png\"> <br></p>\n<p>We have established two things so far:</p>\n<ol>\n<li data-length=\"1\">We need to use a stack to emulate \"moving\" back up the tree, just like how recursion is implemented under the hood.</li>\n<li data-length=\"1\">When we have decreasing values, we can continuously walk left.</li>\n</ol>\n<details><summary><b>A monotonic stack is perfect for this problem. If you aren't familiar with monotonic stacks, click here.</b></summary>\n<p>A monotonic stack is a stack whose elements are always sorted. In our case, we want a monotonic <strong>decreasing</strong> stack, i.e. the elements in the stack are always sorted in descending order.</p>\n<p>To maintain this monotonic stack, we need to make sure that whenever we push a new element, it is the smallest value in the stack. Before we push an element <code>num</code>, we check the top of the stack. If the top of the stack is less than <code>num</code>, we pop from it. Since there may be many elements less than <code>num</code> in the stack, we need to use a while loop to \"clean\" the stack before pushing <code>num</code>.</p>\n<p>Only once there are no elements in the stack less than <code>num</code> will we push <code>num</code>.</p>\n</details>\n<br>\n<p>At any given moment, the node at the top of the stack is the current node we are at in the tree. For each node <code>num</code> we encounter, if the top of the stack is greater than <code>num</code>, we can just push it onto the stack. If the top of the stack is less than <code>num</code>, we will need to backtrack up the tree by popping from the stack.</p>\n<p><img alt=\"\" width=\"960\" src=\"../Figures/255/6.png\"> <br></p>\n<p>After we clean the stack to ensure monotonic order, we can push <code>num</code> to the stack. The interesting thing here is that the entire left subtree of the parent is now irrelevant. In a preorder traversal, a node's left subtree is visited completely before any node in the right subtree is visited. Because we are now in the right subtree, we can completely forget about the left subtree.</p>\n<blockquote>\n<p>If you're having trouble understanding the \"node at the top of the stack is the current node we are at in the tree\" concept, think about it like this:</p>\n<p>In any binary tree problem, we typically use a function like <code>dfs</code> that takes an argument <code>node</code> to traverse the tree. At any given moment, there will be one \"active\" function call to <code>dfs</code> (wherever the computer is currently at during execution). Whatever <code>node</code> was passed to this call is the current node we are visiting in the tree.</p>\n<p>The top of the stack is analogous to the current function call we are at. As you can see in the above image, we can move back up the tree by popping from the stack.</p>\n</blockquote>\n<p>We are missing one thing. What if we have <code>preorder = [5, 2, 6, 1, 3]</code>?</p>\n<p><img alt=\"\" width=\"960\" src=\"../Figures/255/7.png\"> <br></p>\n<p>When we encounter the <code>6</code>, we must pop the <code>2</code> and <code>5</code> to maintain monotonic decreasing order. The next element to handle is <code>1</code>.</p>\n<p><img alt=\"\" width=\"960\" src=\"../Figures/255/8.png\"> <br></p>\n<p>Because <code>1</code> is less than <code>6</code>, we would just push it onto the stack, which is equivalent to walking left. However, this is actually invalid because we are in the right subtree of <code>5</code>, and <code>1 &lt; 5</code>.</p>\n<p>We said above that in a preorder traversal, the entire left subtree of a node is visited before any node in the right subtree is visited. This means once we start visiting a node's right subtree, there is no way for us to get back to the left subtree. We have started visiting the right subtree of <code>5</code>, so <strong>every value we encounter from now on</strong> must be greater than <code>5</code>, since there is no way for us to get back to the left subtree.</p>\n<p>We made the analogy between a recursive implementation of a <code>dfs</code> function and our stack - popping from the stack is like returning from a function call. When we return from a <code>node</code> and go back to the <code>parent</code>, we can <strong>never</strong> go back to the left subtree of <code>parent</code> again:</p>\n<ol>\n<li data-length=\"1\">If <code>node = parent.left</code>, then we just finished traversing the left subtree of <code>parent</code> and will never come back to it.</li>\n<li data-length=\"1\">If <code>node = parent.right</code>, we must have already traversed the left subtree of <code>parent</code> earlier, and will never come back to it.</li>\n</ol>\n<p>We can combine these facts to make the following observation:</p>\n<blockquote>\n<p>When we return from a <code>node</code> (pop from the stack), every value we encounter from now on must be greater than <code>node</code>.</p>\n</blockquote>\n<p>If we encountered a value <code>small</code> less than or equal to <code>node</code> in the future, it would mean that <code>small</code> belongs in the left subtree of <code>node</code>, but since we already \"returned\" from <code>node</code>, we have already visited all the nodes in the left subtree!</p>\n<p>We can use an integer <code>minLimit</code> that we update every time we pop from the stack. We need to make sure every value we encounter as we iterate over the input is greater than <code>minLimit</code>, otherwise the sequence is invalid.</p>\n<p><strong>Algorithm</strong></p>\n<ol>\n<li data-length=\"1\">Declare an integer <code>minLimit</code> to a small value like negative infinity, and a <code>stack</code>.</li>\n<li data-length=\"1\">Iterate over <code>preorder</code>. For each <code>num</code>:\n<ul>\n<li>Clean the stack. While the top of the stack is less than <code>num</code>, pop from it and update <code>minLimit</code>.</li>\n<li>If <code>num &lt;= minLimit</code>, return <code>false</code>.</li>\n<li>Push <code>num</code> onto the stack.</li>\n</ul>\n</li>\n<li data-length=\"1\">Return <code>true</code> if we get through the whole input.</li>\n</ol>\n<p><strong>Implementation</strong></p>\n<pre><code>class Solution {\npublic:\n    bool verifyPreorder(vector&lt;int&gt;& preorder) {\n        int minLimit = INT_MIN;\n        stack&lt;int&gt; stack;\n        \n        for (int num: preorder) {\n            while (!stack.empty() && stack.top() &lt; num) {\n                minLimit = stack.top();\n                stack.pop();\n            }\n            \n            if (num &lt;= minLimit) {\n                return false;\n            }\n            \n            stack.push(num);\n        }\n        \n        return true;\n    }\n};</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<p>Given <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></span> as the length of <code>preorder</code>,</p>\n<ul>\n<li>\n<p>Time complexity: <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p>Despite the while loop, each iteration of the for loop is amortized <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></span>. The while loop only runs <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span> times across all iterations. This is because each element in <code>preorder</code> can only be pushed and popped from the stack at most once, giving us a maximum of <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6444em;\"></span><span class=\"mord\">2</span><span class=\"mord mathnormal\">n</span></span></span></span></span> stack operations.</p>\n</li>\n<li>\n<p>Space complexity: <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p>The stack can grow to a size of <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span>, such as in the case where <code>preorder</code> is descending.</p>\n</li>\n</ul>\n<br>\n<hr>\n<h3 id=\"approach-2-constant-auxiliary-space\" level=\"3\" class=\"group/heading relative\"><a href=\"#approach-2-constant-auxiliary-space\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" aria-hidden=\"true\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"link\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" role=\"img\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 640 512\" spacing=\"square\"><path fill=\"currentColor\" d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\"></path></svg></div></a>Approach 2: Constant Auxiliary Space</h3>\n<p><strong>Intuition</strong></p>\n<p>We can implement the stack from the previous approach by modifying the input array.</p>\n<blockquote>\n<p>It is generally considered a bad practice to modify the input, especially arrays since they are passed by reference. You should always ask an interviewer if it's OK to do so first. The problem description has a follow-up that alludes to this approach, which is why we have included it.</p>\n</blockquote>\n<p>This algorithm is identical to the previous one. The only difference is how we implement the stack. Let's use an integer <code>i</code> that represents the length of the stack. Then <code>preorder[i - 1]</code> holds the top of the stack at any given moment. If <code>i == 0</code>, the stack is empty.</p>\n<p>To \"add\" an element <code>num</code> to the top of the stack, we can do <code>preorder[i] = num</code>, and then increment <code>i</code>. After incrementing <code>i</code>, <code>preorder[i - 1]</code> holds the element we just added (the top of the stack). Notice that <code>i</code> is the index where an element would end up after being pushed.</p>\n<p>To \"remove\" an element from the stack, we simply decrement <code>i</code>. Before doing so, we should update <code>minLimit</code> with the top of the stack, which is <code>preorder[i - 1]</code>.</p>\n<p><strong>Algorithm</strong></p>\n<ol>\n<li data-length=\"1\">Declare an integer <code>minLimit</code> to a small value like negative infinity, and an integer <code>i = 0</code>.</li>\n<li data-length=\"1\">Iterate over the elements of <code>preorder</code>. For each <code>num</code>:\n<ul>\n<li>Clean the \"stack\". While <code>preorder[i - 1]</code> is less than <code>num</code>, \"pop\" it by decrementing <code>i</code> while updating <code>minLimit</code>.</li>\n<li>If <code>num &lt;= minLimit</code>, return <code>false</code>.</li>\n<li>\"Push\" <code>num</code> onto the stack by setting <code>preorder[i] = num</code> and incrementing <code>i</code>.</li>\n</ul>\n</li>\n<li data-length=\"1\">Return <code>true</code> if we get through the whole input.</li>\n</ol>\n<p><strong>Implementation</strong></p>\n<pre><code>class Solution {\npublic:\n    bool verifyPreorder(vector&lt;int&gt;& preorder) {\n        int minLimit = INT_MIN;\n        int i = 0;\n        \n        for (int num: preorder) {\n            while (i &gt; 0 && preorder[i - 1] &lt; num) {\n                minLimit = preorder[i - 1];\n                i--;\n            }\n            \n            if (num &lt;= minLimit) {\n                return false;\n            }\n            \n            preorder[i] = num;\n            i++;\n        }\n        \n        return true;\n    }\n};</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<p>Given <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></span> as the length of <code>preorder</code>,</p>\n<ul>\n<li>\n<p>Time complexity: <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p>The time complexity is identical to the previous approach for the same reasons.</p>\n</li>\n<li>\n<p>Space complexity: <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></span> auxiliary</p>\n<p>A common misconception is that modifying an input array for use in an algorithm leads to an <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></span> space complexity. In reality, you are still using <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span> space, but <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></span> <strong>auxiliary</strong> space.</p>\n<p>Because we are modifying the input to directly use in the algorithm, we must count it as part of the space complexity. However, we are not using any auxiliary space other than a few integers.</p>\n<blockquote>\n<p>The exception to this is in-place algorithms where the input is also returned as the output. For example: sorting algorithms.</p>\n</blockquote>\n</li>\n</ul>\n<br>\n<hr>\n<h3 id=\"approach-3-recursion\" level=\"3\" class=\"group/heading relative\"><a href=\"#approach-3-recursion\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" aria-hidden=\"true\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"link\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" role=\"img\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 640 512\" spacing=\"square\"><path fill=\"currentColor\" d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\"></path></svg></div></a>Approach 3: Recursion</h3>\n<p><strong>Intuition</strong></p>\n<blockquote>\n<p>Note: this approach is unintuitive and difficult to implement. Typically, recursion is used to break problems into subproblems and you would expect the recursive function to return the answer to the subproblems.</p>\n<p>Unfortunately, there is no way easy way to solve this problem recursively in a way that the function returns something uniform. If you face this problem in an interview, we recommend approach 1 or 2. This approach has been added for the sake of completeness. As such, we will not explain the approach in detail.</p>\n</blockquote>\n<p>This algorithm is similar to the one used to solve <a href=\"https://leetcode.com/problems/validate-binary-search-tree/\" target=\"_blank\">Validate Binary Search Tree</a>. It is highly recommended that you solve that problem recursively before continuing with this approach.</p>\n<p>The key idea in Validate Binary Search Tree is that we pass two parameters with each node that represent the range the node's value is allowed to be in. When we move to <code>node.left</code>, we update the max bound with <code>node.val</code> to make sure all nodes in the left subtree are less than <code>node.val</code>. Vice versa with <code>node.right</code> and the min bound.</p>\n<p>We will use a similar idea here. Let's define a function <code>helper</code> that takes arguments <code>i, minLimit, maxLimit</code>. The limit variables are the same as the ones just mentioned. <code>i</code> will be an index variable that we will use to iterate over <code>preorder</code>.</p>\n<p>The goal is to process all nodes <code>(i == preorder.length)</code>. If we can do that, then the sequence is valid. The previous two approaches had the same idea: if we found a node that broke the sequence, we returned <code>false</code>. If we could process all nodes without returning <code>false</code>, then we returned <code>true</code>.</p>\n<p>The base case of <code>helper</code> will be to return <code>true</code> if <code>i == preorder.length</code>. If <strong>any</strong> call to <code>helper</code> returns <code>true</code>, then it means we have processed all nodes, and the sequence is valid.</p>\n<blockquote>\n<p>The thing that makes this solution very unintuitive is that <code>i</code> is shared between all function calls - i.e., it acts as a global variable. This is inconsistent with recursive solutions where each function call stores its own state.</p>\n<p>The reason for this is that we need to process the nodes of <code>preorder</code> in the same order that they appear in the input.</p>\n</blockquote>\n<p>Now, the logic of the function. Let the value of the current node at index <code>i</code> be <code>root</code>. First, check the BST condition: if <code>root</code> is not between <code>minLimit</code> and <code>maxLimit</code>, return <code>false</code>.</p>\n<p>Next, increment <code>i</code> as the current node has passed the test. We will now test the next element as both the left and right child. To treat it as the left child, call <code>helper</code> while modifying <code>maxLimit</code> to <code>root</code>. To treat it as the right child, call <code>helper</code> while modifying <code>minLimit</code> to <code>root</code>. If either of these calls return <code>true</code>, then it means we managed to process all elements, and we should return <code>true</code> as well.</p>\n<p>If the sequence is invalid, all calls will eventually end up failing the BST condition check.</p>\n<p><strong>Algorithm</strong></p>\n<ol>\n<li data-length=\"1\">Create a function <code>helper</code> that takes arguments <code>i, minLimit, maxLimit</code>:\n<ul>\n<li>If <code>i == preorder.length</code>, return <code>true</code>.</li>\n<li>Set <code>root = preorder[i]</code>.</li>\n<li>If <code>root &lt;= minLimit</code> or <code>root &gt;= maxLimit</code>, return <code>false</code>. The BST condition is violated.</li>\n<li>Increment <code>i</code>.</li>\n<li>Call <code>helper</code> with <code>maxLimit</code> as <code>root</code>.</li>\n<li>Call <code>helper</code> with <code>minLimit</code> as <code>root</code>.</li>\n<li>If either call returns <code>true</code> return <code>true</code>. Otherwise, return <code>false</code>.</li>\n</ul>\n</li>\n<li data-length=\"1\">Call <code>helper</code> with <code>i = 0</code>, <code>minLimit = -infinity</code>, <code>maxLimit = infinity</code>.</li>\n</ol>\n<blockquote>\n<p>Note: because we want <code>i</code> to act as a global variable, we must pass it by reference. In Java and Python, we are using an array of length <code>1</code>. In C++, we pass the integer by reference.</p>\n</blockquote>\n<p><strong>Implementation</strong></p>\n<pre><code>class Solution {\npublic:\n    bool verifyPreorder(vector&lt;int&gt;& preorder) {\n        int i = 0;\n        return helper(preorder, i, INT_MIN, INT_MAX);\n    }\n    \n    bool helper(vector&lt;int&gt;& preorder, int& i, int minLimit, int maxLimit) {\n        if (i == preorder.size()) {\n            return true;\n        }\n        \n        int root = preorder[i];\n        if (root &lt;= minLimit || root &gt;= maxLimit) {\n            return false;\n        }\n        \n        i++;\n        bool left = helper(preorder, i, minLimit, root);\n        bool right = helper(preorder, i, root, maxLimit);\n        return left || right;\n    }\n};</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<p>Given <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></span> as the length of <code>preorder</code>,</p>\n<ul>\n<li>\n<p>Time complexity: <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p>For each <code>i</code>, two calls are made to calculate <code>left</code> and <code>right</code>. Once entering those calls, we either return <code>false</code> due to the BST condition being broken, or we increment <code>i</code>.</p>\n<p>Because <code>i</code> behaves as a global variable, after incrementing <code>i</code>, no more calls can be made from the previous value of <code>i</code>. As such, each value of <code>i</code> can only make two more calls, and <code>helper</code> is called at most <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6444em;\"></span><span class=\"mord\">2</span><span class=\"mord mathnormal\">n</span></span></span></span></span> times. Everything else in the function runs in <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></span>, so the time complexity is <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n</li>\n<li>\n<p>Space complexity: <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p>The recursion call stack uses <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span> space.</p>\n</li>\n</ul>\n<br>\n<hr></div><span style=\"font-size: 0px; line-height: 0;\">&nbsp;</span></div>",
        "isOfficial": true,
        "scrapedAt": "2026-02-18T10:41:46.963Z"
    }
}