{
  "questionId": "34",
  "questionFrontendId": "34",
  "title": "Find First and Last Position of Element in Sorted Array",
  "titleSlug": "find-first-and-last-position-of-element-in-sorted-array",
  "content": "<p>Given an array of integers <code>nums</code> sorted in non-decreasing order, find the starting and ending position of a given <code>target</code> value.</p>\n\n<p>If <code>target</code> is not found in the array, return <code>[-1, -1]</code>.</p>\n\n<p>You must&nbsp;write an algorithm with&nbsp;<code>O(log n)</code> runtime complexity.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> nums = [5,7,7,8,8,10], target = 8\n<strong>Output:</strong> [3,4]\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> nums = [5,7,7,8,8,10], target = 6\n<strong>Output:</strong> [-1,-1]\n</pre><p><strong class=\"example\">Example 3:</strong></p>\n<pre><strong>Input:</strong> nums = [], target = 0\n<strong>Output:</strong> [-1,-1]\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>9</sup>&nbsp;&lt;= nums[i]&nbsp;&lt;= 10<sup>9</sup></code></li>\n\t<li><code>nums</code> is a non-decreasing array.</li>\n\t<li><code>-10<sup>9</sup>&nbsp;&lt;= target&nbsp;&lt;= 10<sup>9</sup></code></li>\n</ul>\n",
  "difficulty": "Medium",
  "stats": "{\"totalAccepted\": \"3.2M\", \"totalSubmission\": \"6.6M\", \"totalAcceptedRaw\": 3167176, \"totalSubmissionRaw\": 6557781, \"acRate\": \"48.3%\"}",
  "hints": [],
  "similarQuestions": "[{\"title\": \"First Bad Version\", \"titleSlug\": \"first-bad-version\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Plates Between Candles\", \"titleSlug\": \"plates-between-candles\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Find Target Indices After Sorting Array\", \"titleSlug\": \"find-target-indices-after-sorting-array\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
  "topicTags": [
    {
      "name": "Array",
      "slug": "array"
    },
    {
      "name": "Binary Search",
      "slug": "binary-search"
    }
  ],
  "companyTags": null,
  "codeSnippets": [
    {
      "lang": "C++",
      "langSlug": "cpp",
      "code": "class Solution {\npublic:\n    vector<int> searchRange(vector<int>& nums, int target) {\n        \n    }\n};"
    },
    {
      "lang": "Java",
      "langSlug": "java",
      "code": "class Solution {\n    public int[] searchRange(int[] nums, int target) {\n        \n    }\n}"
    },
    {
      "lang": "Python3",
      "langSlug": "python3",
      "code": "class Solution:\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\n        "
    },
    {
      "lang": "Python",
      "langSlug": "python",
      "code": "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        "
    },
    {
      "lang": "JavaScript",
      "langSlug": "javascript",
      "code": "/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\nvar searchRange = function(nums, target) {\n    \n};"
    },
    {
      "lang": "TypeScript",
      "langSlug": "typescript",
      "code": "function searchRange(nums: number[], target: number): number[] {\n    \n};"
    },
    {
      "lang": "C#",
      "langSlug": "csharp",
      "code": "public class Solution {\n    public int[] SearchRange(int[] nums, int target) {\n        \n    }\n}"
    },
    {
      "lang": "C",
      "langSlug": "c",
      "code": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* searchRange(int* nums, int numsSize, int target, int* returnSize) {\n    \n}"
    },
    {
      "lang": "Go",
      "langSlug": "golang",
      "code": "func searchRange(nums []int, target int) []int {\n    \n}"
    },
    {
      "lang": "Kotlin",
      "langSlug": "kotlin",
      "code": "class Solution {\n    fun searchRange(nums: IntArray, target: Int): IntArray {\n        \n    }\n}"
    },
    {
      "lang": "Swift",
      "langSlug": "swift",
      "code": "class Solution {\n    func searchRange(_ nums: [Int], _ target: Int) -> [Int] {\n        \n    }\n}"
    },
    {
      "lang": "Rust",
      "langSlug": "rust",
      "code": "impl Solution {\n    pub fn search_range(nums: Vec<i32>, target: i32) -> Vec<i32> {\n        \n    }\n}"
    },
    {
      "lang": "Ruby",
      "langSlug": "ruby",
      "code": "# @param {Integer[]} nums\n# @param {Integer} target\n# @return {Integer[]}\ndef search_range(nums, target)\n    \nend"
    },
    {
      "lang": "PHP",
      "langSlug": "php",
      "code": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer $target\n     * @return Integer[]\n     */\n    function searchRange($nums, $target) {\n        \n    }\n}"
    },
    {
      "lang": "Dart",
      "langSlug": "dart",
      "code": "class Solution {\n  List<int> searchRange(List<int> nums, int target) {\n    \n  }\n}"
    },
    {
      "lang": "Scala",
      "langSlug": "scala",
      "code": "object Solution {\n    def searchRange(nums: Array[Int], target: Int): Array[Int] = {\n        \n    }\n}"
    },
    {
      "lang": "Elixir",
      "langSlug": "elixir",
      "code": "defmodule Solution do\n  @spec search_range(nums :: [integer], target :: integer) :: [integer]\n  def search_range(nums, target) do\n    \n  end\nend"
    },
    {
      "lang": "Erlang",
      "langSlug": "erlang",
      "code": "-spec search_range(Nums :: [integer()], Target :: integer()) -> [integer()].\nsearch_range(Nums, Target) ->\n  ."
    },
    {
      "lang": "Racket",
      "langSlug": "racket",
      "code": "(define/contract (search-range nums target)\n  (-> (listof exact-integer?) exact-integer? (listof exact-integer?))\n  )"
    }
  ],
  "solution": {
    "content": "<div class=\"flex flex-col w-full\" style=\"position: relative;\"><div class=\"mYe_l WRmCx\"><h2 id=\"solution\" level=\"2\" class=\"group/heading relative\"><a href=\"#solution\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" aria-hidden=\"true\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"link\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" role=\"img\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 640 512\" spacing=\"square\"><path fill=\"currentColor\" d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\"></path></svg></div></a>Solution</h2>\n<hr>\n<h3 id=\"overview\" level=\"3\" class=\"group/heading relative\"><a href=\"#overview\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" aria-hidden=\"true\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"link\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" role=\"img\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 640 512\" spacing=\"square\"><path fill=\"currentColor\" d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\"></path></svg></div></a>Overview</h3>\n<p>Let's briefly look at a brute-force way of solving this problem. Given a target element, we can simply do a linear scan over the entire array to find the first and the last position. The first occurrence will be the first time when we encounter this target. Thereafter, we continue to scan elements until we find one that is greater than the target or until we reach the end of the array. This will help us determine the last position of the target.</p>\n<p>The downside of this approach is that it doesn't take advantage of the <em>sorted</em> nature of the array. This linear scan approach has a time complexity of <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span></span> because there are <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span></span></span></span></span> elements in the array. That doesn't sound too bad, right? Well, it does if we compare it to an approach with logarithmic time complexity. We'll look at a <em>binary search-based approach</em> to solve this problem which will take advantage of the sorted nature of the array.</p>\n<br>\n<hr>\n<h3 id=\"approach-binary-search\" level=\"3\" class=\"group/heading relative\"><a href=\"#approach-binary-search\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" aria-hidden=\"true\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"link\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" role=\"img\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 640 512\" spacing=\"square\"><path fill=\"currentColor\" d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\"></path></svg></div></a>Approach: Binary Search</h3>\n<p><strong>Intuition</strong></p>\n<p>Let's review binary search a bit. Given a sorted array, binary search works by looking at the middle element of the given array, and based on the value of the middle element, it decides to discard one half of the array. At each step, we reduce the length of the array to search by half and that is what leads to the logarithmic time complexity of the algorithm. Usually, we employ the binary search algorithm to determine if an element is in a sorted array. Here, we can tweak the binary search algorithm to find the first and the last position of a given element.</p>\n<p>Let's look at the basic binary search algorithm one step at a time:</p>\n<ul>\n<li>We use 2 variables to keep track of the subarray that we are scanning. Let's call them <code>begin</code> and <code>end</code>. Initially, <code>begin</code> is set to <code>0</code> and <code>end</code> is set to the last index of the array.</li>\n<li>We iterate until <code>begin</code> is greater than <code>end</code>.</li>\n<li>At each step, we calculate the middle element <code>mid = (begin + end) / 2</code>. We use the value of the middle element to decide which half of the array we need to search.\n<ul>\n<li>If the target that we're searching for has a value lower than the <code>mid</code> element, we discard the right half of the array i.e. <code>end = mid - 1</code>.</li>\n<li>If the target that we're searching for has a value higher than the <code>mid</code> element, we discard the left half of the array i.e. <code>begin = mid + 1</code>.</li>\n<li>If <code>nums[mid] == element</code>, then we found our target and we return from there.</li>\n</ul>\n</li>\n</ul>\n<p><strong>Binary Search and Bidirectional Scan</strong></p>\n<p>A naive way to use binary search to find the first and the last position of a target is to first determine the index of <strong>any</strong> occurrence of the given target. Suppose we know that the target is at the index <code>i</code> in the array. From there on, we do a linear scan to the left and keep going until we find the first occurrence of this target. Similarly, we do a linear scan to the right to find the last position. This works just fine. However, in the worst case when our entire array (or say 90% or more of it) is filled with the target, then this is a linear-time algorithm. In that case, the linear scan will end up taking more time than the binary-search itself.</p>\n<p><strong>Two Binary Searches</strong></p>\n<p>Instead of using a linear-scan approach to find the boundaries once the target has been found, let's use two binary searches to find the first and last position of the target. We can make a small tweak to the checks we perform on the middle element.  This tweak will help us determine the first and the last position of an element</p>\n<p>Normally, we compare <code>nums[mid] == target</code> because we simply need to check if we found our target or not. But now, apart from checking for equality, we also need to check if <code>mid</code> is the first or the last index where the target occurs. Let's see how we can do that.</p>\n<p><strong>First position in the array</strong></p>\n<p>There are two situations where an index will be the first occurrence of the target in the array.</p>\n<ol>\n<li data-length=\"1\">If <code>mid</code> is the same as <code>begin</code> which implies our <code>mid</code> element is the <em>first</em> element in the remaining subarray.</li>\n<li data-length=\"1\">The element to the left of this index is not equal to the target that we are searching for. I.e. <code>nums[mid - 1] != target</code>. If this condition is not met, we should keep searching on the left side of the array for the first occurrence of the target.</li>\n</ol>\n<p>Let's take a look at an example depicting this idea. In the example below, we are searching for the first occurrence of the number <code>7</code>.</p>\n<p><img alt=\"Example for finding the first position of a target\" src=\"../Figures/34/img1.png\"></p>\n<p><em>Figure 1. Find the first position of \"7\" in the array.</em></p>\n<p>Initially, the variables <code>begin</code> and <code>end</code> are <code>0</code> and <code>5</code> respectively. So, our <code>mid</code> element is <code>(0 + 5) / 2 = 2</code>.</p>\n<p><img alt=\"Middle element not the first occurrence\" src=\"../Figures/34/img2.png\"></p>\n<p><em>Figure 2. The middle element is a match but it is not the first occurrence.</em></p>\n<p>Now, <code>begin</code> is still <code>0</code> but <code>end</code> has moved to <code>mid - 1 = 1</code>. Now we have narrowed our search down to the first two elements of the array. Our updated <code>mid</code> is <code>(0 + 1) / 2 = 0</code>. This element is lower than the target we are looking for <code>2 &lt; 7</code>. So, we discard the \"left\" side of this subarray and update <code>begin = mid + 1</code>.  This leaves us with a single index, which is in fact the first occurrence of the element \"7\".</p>\n<p><strong>Last position in the array</strong></p>\n<p>There are two situations where an index will be the last occurrence of the target in the array.</p>\n<ol>\n<li data-length=\"1\">If <code>mid</code> is the same as <code>end</code> which implies our <code>mid</code> element is the <em>last</em> element of the remaining subarray.</li>\n<li data-length=\"1\">If the element to the right of <code>mid</code> is not equal to the target we are searching for. I.e. <code>nums[mid + 1] != target</code>. If this condition is not met, we should keep searching on the right side of the array for the last occurrence of the target.</li>\n</ol>\n<p>Let's take a look at an example depicting this idea. In the example below, we are searching for the last occurrence of the number <code>7</code>.</p>\n<p><img alt=\"Example for finding the last position of an element\" src=\"../Figures/34/img3.png\"></p>\n<p><em>Figure 3. Find the last position of \"7\" in the array.</em></p>\n<p>Initially, the variables <code>begin</code> and <code>end</code> are <code>0</code> and <code>5</code> respectively. So, our <code>mid</code> element is <code>(0 + 5) / 2 = 2</code>.</p>\n<p><img alt=\"Middle element not the last occurrence\" src=\"../Figures/34/img4.png\"></p>\n<p><em>Figure 4. The middle element is not a match.</em></p>\n<p>The updated <code>mid</code> is greater than \"7\". So, we discard the right side of the array.  This leaves us with just a single element in the array which is \"7\" and it is also the last occurrence.</p>\n<p><strong>Algorithm</strong></p>\n<ol>\n<li data-length=\"1\">Define a function called <code>findBound</code> which takes three arguments: the <code>array</code>, the <code>target</code> to search for, and a boolean value <code>isFirst</code> which indicates if we are trying to find the first or the last occurrence of <code>target</code>.</li>\n<li data-length=\"1\">We use 2 variables to keep track of the subarray that we are scanning. Let's call them <code>begin</code> and <code>end</code>. Initially, <code>begin</code> is set to <code>0</code> and <code>end</code> is set to the last index of the array.</li>\n<li data-length=\"1\">We iterate until <code>begin</code> is greater than to <code>end</code>.</li>\n<li data-length=\"1\">At each step, we calculate the middle element <code>mid = (begin + end) / 2</code>. We use the value of the middle element to decide which half of the array we need to search.\n<ul>\n<li><em>nums[mid] == target</em>\n<ul>\n<li><em>isFirst is true</em> ~ This implies that we are trying to find the first occurrence of the element. If <code>mid == begin</code> or <code>nums[mid - 1] != target</code>, then we return <code>mid</code> as the first occurrence of the <code>target</code>. Otherwise, we update <code>end = mid - 1</code></li>\n<li><em>isFirst is false</em> ~ This implies we are trying to find the last occurrence of the element. If <code>mid == end</code> or <code>nums[mid + 1] != target</code>, then we return <code>mid</code> as the last occurrence of the <code>target</code>. Otherwise, we update <code>begin = mid + 1</code></li>\n</ul>\n</li>\n<li><em>nums[mid] &gt; target</em> ~ We update <code>end = mid - 1</code> since we must discard the right side of the array as the middle element is greater than <code>target</code>.</li>\n<li><em>nums[mid] &lt; target</em> ~ We update <code>begin = mid + 1</code> since we must discard the left side of the array as the middle element is less than <code>target</code>.</li>\n</ul>\n</li>\n<li data-length=\"1\">We return a value of <code>-1</code> at the end of our function which indicates that <code>target</code> was not found in the array.</li>\n<li data-length=\"1\">In the main <code>searchRange</code> function, we first call <code>findBound</code> with <code>isFirst</code> set to <code>true</code>. If this value is <code>-1</code>, we can simply return <code>[-1, -1]</code>. Otherwise, we call <code>findBound</code> with <code>isFirst</code> set to false to get the last occurrence and then return the result.</li>\n</ol>\n<p><strong>Implementation</strong></p>\n<pre><code>class Solution {\npublic:\n    vector&lt;int&gt; searchRange(vector&lt;int&gt;& nums, int target) {\n        int firstOccurrence = this-&gt;findBound(nums, target, true);\n        if (firstOccurrence == -1) {\n            return vector&lt;int&gt;{-1, -1};\n        }\n        int lastOccurrence = this-&gt;findBound(nums, target, false);\n        return vector&lt;int&gt;{firstOccurrence, lastOccurrence};\n    }\n​\nprivate:\n    int findBound(vector&lt;int&gt;& nums, int target, bool isFirst) {\n        int N = nums.size();\n        int begin = 0, end = N - 1;\n        while (begin &lt;= end) {\n            int mid = (begin + end) / 2;\n            if (nums[mid] == target) {\n                if (isFirst) {\n                    if (mid == begin || nums[mid - 1] != target) {\n                        return mid;\n                    }\n                    end = mid - 1;\n                } else {\n                    if (mid == end || nums[mid + 1] != target) {\n                        return mid;\n                    }\n                    begin = mid + 1;\n                }\n            } else if (nums[mid] &gt; target) {\n                end = mid - 1;\n            } else {\n                begin = mid + 1;\n            }\n        }\n        return -1;\n    }\n};</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord text\"><span class=\"mord\">log</span></span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span></span> considering there are <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span></span></span></span></span> elements in the array. This is because binary search takes logarithmic time to scan an array of <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span></span></span></span></span> elements. Why? Because at each step we discard half of the array we are scanning and hence, we're done after a logarithmic number of steps. We simply perform binary search twice in this case.</p>\n</li>\n<li>\n<p>Space Complexity: <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></span> since we only use space for a few variables and our result array, all of which require constant space.</p>\n</li>\n</ul></div><span style=\"font-size: 0px; line-height: 0;\">&nbsp;</span></div>",
    "isOfficial": true,
    "scrapedAt": "2026-02-18T07:07:42.534Z"
  }
}