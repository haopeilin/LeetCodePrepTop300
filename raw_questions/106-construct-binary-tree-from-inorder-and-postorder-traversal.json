{
    "questionId": "106",
    "questionFrontendId": "106",
    "title": "Construct Binary Tree from Inorder and Postorder Traversal",
    "titleSlug": "construct-binary-tree-from-inorder-and-postorder-traversal",
    "content": "<p>Given two integer arrays <code>inorder</code> and <code>postorder</code> where <code>inorder</code> is the inorder traversal of a binary tree and <code>postorder</code> is the postorder traversal of the same tree, construct and return <em>the binary tree</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"images/106/tree.jpg\" style=\"width: 277px; height: 302px;\" />\n<pre>\n<strong>Input:</strong> inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]\n<strong>Output:</strong> [3,9,20,null,null,15,7]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> inorder = [-1], postorder = [-1]\n<strong>Output:</strong> [-1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= inorder.length &lt;= 3000</code></li>\n\t<li><code>postorder.length == inorder.length</code></li>\n\t<li><code>-3000 &lt;= inorder[i], postorder[i] &lt;= 3000</code></li>\n\t<li><code>inorder</code> and <code>postorder</code> consist of <strong>unique</strong> values.</li>\n\t<li>Each value of <code>postorder</code> also appears in <code>inorder</code>.</li>\n\t<li><code>inorder</code> is <strong>guaranteed</strong> to be the inorder traversal of the tree.</li>\n\t<li><code>postorder</code> is <strong>guaranteed</strong> to be the postorder traversal of the tree.</li>\n</ul>\n",
    "difficulty": "Medium",
    "stats": "{\"totalAccepted\": \"920.8K\", \"totalSubmission\": \"1.4M\", \"totalAcceptedRaw\": 920770, \"totalSubmissionRaw\": 1354318, \"acRate\": \"68.0%\"}",
    "hints": [],
    "similarQuestions": "[{\"title\": \"Construct Binary Tree from Preorder and Inorder Traversal\", \"titleSlug\": \"construct-binary-tree-from-preorder-and-inorder-traversal\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
    "topicTags": [
        {
            "name": "Array",
            "slug": "array"
        },
        {
            "name": "Hash Table",
            "slug": "hash-table"
        },
        {
            "name": "Divide and Conquer",
            "slug": "divide-and-conquer"
        },
        {
            "name": "Tree",
            "slug": "tree"
        },
        {
            "name": "Binary Tree",
            "slug": "binary-tree"
        }
    ],
    "companyTags": null,
    "codeSnippets": [
        {
            "lang": "Java",
            "langSlug": "java",
            "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\n        \n    }\n}"
        }
    ],
    "solution": {
        "content": "<h2><a href=\"#solution\"><svg><path></path></svg></a>Solution</h2>\n<hr/>\n<h3><a href=\"#how-to-traverse-the-tree\"><svg><path></path></svg></a>How to traverse the tree</h3>\n<p>There are two general strategies to traverse a tree:</p>\n<ul>\n<li>\n<p><em>Depth First Search</em> (<code>DFS</code>)</p>\n<p>In this strategy, we adopt the <code>depth</code> as the priority, so that one would start from a root and reach all the way down to a certain leaf, and then back to the root to reach another branch.</p>\n<p>The DFS strategy can further be distinguished as <code>preorder</code>, <code>inorder</code>, and <code>postorder</code> depending on the relative order among the root node, left node, and right node.</p>\n</li>\n<li>\n<p><em>Breadth First Search</em> (<code>BFS</code>)</p>\n<p>We scan through the tree level by level, following the order of height, from top to bottom. The nodes on higher levels would be visited before the ones with lower levels.</p>\n</li>\n</ul>\n<p>In the following figure, the nodes are enumerated in the order you visit them, please follow <code>1-2-3-4-5</code> to compare different strategies.</p>\n<p></p>\n<blockquote>\n<p>In this problem one deals with inorder and postorder traversals.</p>\n</blockquote>\n<br/>\n<br/>\n<hr/>\n<h3><a href=\"#approach-1-recursion\"><svg><path></path></svg></a>Approach 1: Recursion</h3>\n<p><strong>How to construct the tree from two traversals: inorder and preorder/postorder/etc</strong></p>\n<p>Problems like this one are often at Facebook interviews and could be solved in O(N) time:</p>\n<ul>\n<li>\n<p>Start from not inorder traversal, usually it's a preorder or postorder one, and use the traversal picture above to define the strategy to pick the nodes. For example, for preorder traversal the <em>first</em> value is a root, then its left child, then its right child, etc. For postorder traversal the <em>last</em> value is a root, then its right child, then its left child, etc.</p>\n</li>\n<li>\n<p>The value picked from preorder/postorder traversal splits the inorder traversal into left and right subtrees. The only information one needs from inorder - if the current subtree is empty (= return <code>null</code>) or not (= continue to construct the subtree).</p>\n</li>\n</ul>\n<p></p>\n<p><strong>Algorithm</strong></p>\n<ul>\n<li>\n<p>Build hashmap <code>value -&gt; its index</code> for inorder traversal.</p>\n</li>\n<li>\n<p>Return <code>helper</code> function which takes as the arguments the left and right boundaries for the current subtree in the inorder traversal. These boundaries are used only to check if the subtree is empty or not. Here is how it works <code>helper(in_left = 0, in_right = n - 1)</code>:</p>\n<ul>\n<li>\n<p>If <code>in_left &gt; in_right</code>, the subtree is empty, return <code>null</code>.</p>\n</li>\n<li>\n<p>Pick the last element in postorder traversal as a root.</p>\n</li>\n<li>\n<p>Root value has index <code>index</code> in the inorder traversal, elements from <code>in_left</code> to <code>index - 1</code> belong to the left subtree, and elements from <code>index + 1</code> to <code>in_right</code> belong to the right subtree.</p>\n</li>\n<li>\n<p>Following the postorder logic, proceed recursively first to construct the right subtree <code>helper(index + 1, in_right)</code> and then to construct the left subtree <code>helper(in_left, index - 1)</code>.</p>\n</li>\n<li>\n<p>Return <code>root</code>.</p>\n</li>\n</ul>\n</li>\n</ul>\n<p><strong>Implementation</strong></p>\n<p></p>\n<pre><code>class Solution {\n    private int postIdx;\n    private int[] postorder;\n    private int[] inorder;\n    private java.util.Map&lt;Integer, Integer&gt; idxMap = new java.util.HashMap&lt;&gt;();\n\n    private TreeNode helper(int inLeft, int inRight) {\n        // if there are no elements to construct subtrees\n        if (inLeft &gt; inRight) return null;\n\n        // pick up postIdx element as a root\n        int rootVal = postorder[postIdx];\n        TreeNode root = new TreeNode(rootVal);\n\n        // root splits inorder list into left and right subtrees\n        int index = idxMap.get(rootVal);\n\n        // recursion\n        postIdx--;\n\n        // build the right subtree\n        root.right = helper(index + 1, inRight);\n        // build the left subtree\n        root.left = helper(inLeft, index - 1);\n\n        return root;\n    }\n\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\n        this.postorder = postorder;\n        this.inorder = inorder;\n\n        // start from the last postorder element\n        postIdx = postorder.length - 1;\n\n        // build a hashmap value -&gt; its index\n        for (int i = 0; i &lt; inorder.length; i++) {\n            idxMap.put(inorder[i], i);\n        }\n\n        return helper(0, inorder.length - 1);\n    }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : O(N). Let's compute the solution with the help of <a href=\"https://en.wikipedia.org/wiki/Master_theorem_(analysis_of_algorithms)\">master theorem</a> T(N)=aT(Nb​)+Θ(Nd). The equation represents dividing the problem up into a subproblems of size bN​ in Θ(Nd) time. Here one divides the problem into two subproblems <code>a = 2</code>, the size of each subproblem (to compute the left and right subtree) is half of the initial problem <code>b = 2</code>, and all this happens in a constant time <code>d = 0</code>. That means that logb​(a)&gt;d and hence we're dealing with <a href=\"https://en.wikipedia.org/wiki/Master_theorem_(analysis_of_algorithms)#Case_1_example\">case 1</a> that means O(Nlogb​(a))=O(N) time complexity.</p>\n</li>\n<li>\n<p>Space complexity : O(N), since we store the entire tree.</p>\n</li>\n</ul>",
        "isOfficial": true,
        "scrapedAt": "2026-02-18T08:15:00.796Z"
    }
}