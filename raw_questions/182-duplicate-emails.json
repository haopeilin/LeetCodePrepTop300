{
    "questionId": "182",
    "questionFrontendId": "182",
    "title": "Duplicate Emails",
    "titleSlug": "duplicate-emails",
    "content": "<p>Table: <code>Person</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| id          | int     |\n| email       | varchar |\n+-------------+---------+\nid is the primary key (column with unique values) for this table.\nEach row of this table contains an email. The emails will not contain uppercase letters.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to report all the duplicate emails. Note that it&#39;s guaranteed that the email&nbsp;field is not NULL.</p>\n\n<p>Return the result table in <strong>any order</strong>.</p>\n\n<p>The&nbsp;result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nPerson table:\n+----+---------+\n| id | email   |\n+----+---------+\n| 1  | a@b.com |\n| 2  | c@d.com |\n| 3  | a@b.com |\n+----+---------+\n<strong>Output:</strong> \n+---------+\n| Email   |\n+---------+\n| a@b.com |\n+---------+\n<strong>Explanation:</strong> a@b.com is repeated two times.\n</pre>\n",
    "difficulty": "Easy",
    "stats": "{\"totalAccepted\": \"1.1M\", \"totalSubmission\": \"1.5M\", \"totalAcceptedRaw\": 1092210, \"totalSubmissionRaw\": 1488476, \"acRate\": \"73.4%\"}",
    "hints": [],
    "similarQuestions": "[]",
    "topicTags": [
        {
            "name": "Database",
            "slug": "database"
        }
    ],
    "companyTags": null,
    "codeSnippets": [],
    "solution": {
        "content": "<h1><a href=\"#solution\"><svg><path></path></svg></a>Solution</h1>\n<hr/>\n<h2><a href=\"#pandas\"><svg><path></path></svg></a>pandas</h2>\n<h3><a href=\"#approach-1-frequency-based-filtering-for-duplicates\"><svg><path></path></svg></a>Approach 1: Frequency-based Filtering for Duplicates</h3>\n<p></p>\n<h4>Intuition</h4>\n<p><strong>Step 1 - Group and Count:</strong></p>\n<pre><code>// Java equivalent: count email frequencies using a Map\nMap&lt;String, Long&gt; emailCounts =\n    person.stream()\n          .collect(Collectors.groupingBy(\n              Person::getEmail,\n              Collectors.counting()\n          ));</code></pre><svg><path></path></svg>\n<ul>\n<li>Using Java Streams, we group the rows (Person objects) based on the values in the <code>email</code> field. This ensures that rows with identical email addresses are categorized into the same group. Subsequently, for each of these email groups, we count how many times that particular email appears. This process gives us a clear picture of the frequency of each unique email in our data.</li>\n</ul>\n<p><strong>Step 2 - Filter duplicates:</strong></p>\n<pre><code>// Keep only emails that appear more than once\nList&lt;String&gt; duplicatedEmails =\n    emailCounts.entrySet().stream()\n               .filter(e -&gt; e.getValue() &gt; 1)\n               .map(Map.Entry::getKey)\n               .collect(Collectors.toList());</code></pre><svg><path></path></svg>\n<ul>\n<li>With the frequencies of each email address in hand, our objective becomes simple: identify those emails that appear more than once. Hence, we filter the map entries to retain only those where the count exceeds 1. This effectively gives us a list of duplicated emails.</li>\n</ul>\n<h4>Implementation</h4>\n<pre><code>import java.util.*;\nimport java.util.stream.*;\n\npublic class Solution {\n\n    public static List&lt;String&gt; duplicateEmails(List&lt;Person&gt; person) {\n\n        // Group by email and count occurrences\n        Map&lt;String, Long&gt; emailCounts =\n            person.stream()\n                  .collect(Collectors.groupingBy(\n                      Person::getEmail,\n                      Collectors.counting()\n                  ));\n\n        // Filter for emails that occur more than once\n        List&lt;String&gt; duplicatedEmails =\n            emailCounts.entrySet().stream()\n                       .filter(e -&gt; e.getValue() &gt; 1)\n                       .map(Map.Entry::getKey)\n                       .collect(Collectors.toList());\n\n        return duplicatedEmails;\n    }\n}</code></pre>\n<hr/>\n<h3><a href=\"#approach-2-group-filter-deduplicate\"><svg><path></path></svg></a>Approach 2: Group-Filter-Deduplicate</h3>\n<h4>Intuition</h4>\n<p><strong>Input Data:</strong></p>\n<table><thead><tr><th>id</th><th>email</th></tr></thead><tbody><tr><td>1</td><td>a@b.com</td></tr><tr><td>2</td><td>c@d.com</td></tr><tr><td>3</td><td>a@b.com</td></tr></tbody></table>\n<br/>\n<p><strong>Step 1 -  Grouping by Email Addresses</strong>:</p>\n<pre><code>// Group Person objects by email\nMap&lt;String, List&lt;Person&gt;&gt; groupedEmails =\n    person.stream()\n          .collect(Collectors.groupingBy(Person::getEmail));</code></pre><svg><path></path></svg>\n<ul>\n<li>In many datasets, data can have repetitions. The first intuitive step to identifying which elements are repeated is to group or cluster them. In the context of our problem, emails are the elements in question. We group the list of Person objects by the <code>email</code> field. Think of it as putting the same emails into individual buckets.</li>\n</ul>\n<table><thead><tr><th>id</th><th>email</th></tr></thead><tbody><tr><td>1</td><td>a@b.com</td></tr><tr><td>3</td><td>a@b.com</td></tr><tr><td></td></tr><tr><td>2</td><td>c@d.com</td></tr></tbody></table>\n<br/>\n<p><em>(For illustrative purposes, the groups are separated with an empty row in the table)</em></p>\n<p><strong>Step 2 -   Identifying the Repeated Emails</strong>:</p>\n<pre><code>// Filter groups that have more than one element\nMap&lt;String, List&lt;Person&gt;&gt; filteredEmails =\n    groupedEmails.entrySet().stream()\n                 .filter(e -&gt; e.getValue().size() &gt; 1)\n                 .collect(Collectors.toMap(\n                     Map.Entry::getKey,\n                     Map.Entry::getValue\n                 ));</code></pre><svg><path></path></svg>\n<ul>\n<li>Once the emails are grouped, the next step is to figure out which groups (or buckets) have more than one email, i.e. duplicates. We check the size of each grouped list, and if it is greater than one, the group satisfies our condition.</li>\n</ul>\n<table><thead><tr><th>id</th><th>email</th></tr></thead><tbody><tr><td>1</td><td>a@b.com</td></tr><tr><td>3</td><td>a@b.com</td></tr></tbody></table>\n<br/>\n<p><strong>Step 3 -  Extracting Unique Repeated Emails</strong>:</p>\n<pre><code>// Extract unique duplicated email values\nList&lt;String&gt; duplicatedEmails =\n    filteredEmails.keySet().stream()\n                  .collect(Collectors.toList());</code></pre><svg><path></path></svg>\n<ul>\n<li>Given that our filtered groups already represent duplicated emails, we extract the unique email values directly from the map keys. This ensures that each repeated email appears only once in the result.</li>\n</ul>\n<table><thead><tr><th>id</th><th>email</th></tr></thead><tbody><tr><td>1</td><td>a@b.com</td></tr></tbody></table>\n<br/>\n<p><strong>Step 4 - Return Data</strong>:</p>\n<pre><code>return duplicatedEmails;</code></pre><svg><path></path></svg>\n<ul>\n<li>The final step is to return the list that contains the duplicated emails.</li>\n</ul>\n<table><thead><tr><th>id</th><th>email</th></tr></thead><tbody><tr><td>1</td><td>a@b.com</td></tr></tbody></table>\n<br/>\n<p>These steps together encapsulate the process of identifying and extracting duplicated emails from the data.</p>\n<h4>Implementation</h4>\n<pre><code>import java.util.*;\nimport java.util.stream.*;\n\npublic class Solution {\n\n    public static List&lt;String&gt; duplicateEmails(List&lt;Person&gt; person) {\n\n        List&lt;String&gt; duplicatedEmails =\n            person.stream()\n                  .collect(Collectors.groupingBy(Person::getEmail))\n                  .entrySet().stream()\n                  .filter(e -&gt; e.getValue().size() &gt; 1)\n                  .map(Map.Entry::getKey)\n                  .collect(Collectors.toList());\n\n        return duplicatedEmails;\n    }\n}</code></pre>\n<hr/>\n<h2><a href=\"#database\"><svg><path></path></svg></a>Database</h2>\n<h3><a href=\"#approach-1-using-group-by-and-subquery\"><svg><path></path></svg></a>Approach 1: Using <code>GROUP BY</code> and Subquery</h3>\n<h4>Intuition</h4>\n<p>Duplicated emails existed more than one time. To count the times each email exists, we can use the following Java code with an SQL query.</p>\n<pre><code>// Java string representing the SQL query\nString countQuery =\n    \"SELECT Email, COUNT(Email) AS num \" +\n    \"FROM Person \" +\n    \"GROUP BY Email\";</code></pre><svg><path></path></svg>\n<pre><code>// Example result after executing the query\n// | Email   | num |\n// |---------|-----|\n// | a@b.com | 2   |\n// | c@d.com | 1   |</code></pre><svg><path></path></svg>\n<p>Taking this as a temporary result set, we can get a solution as below.</p>\n<pre><code>// Java string representing a subquery-based SQL solution\nString duplicatedEmailQuery =\n    \"SELECT Email FROM (\" +\n    \"  SELECT Email, COUNT(Email) AS num \" +\n    \"  FROM Person \" +\n    \"  GROUP BY Email\" +\n    \") AS statistic \" +\n    \"WHERE num &gt; 1\";</code></pre><svg><path></path></svg>\n<h4>Implementation</h4>\n<pre><code>// Final SQL used in Java (e.g., via JDBC)\nString duplicatedEmailQuery =\n    \"SELECT Email FROM (\" +\n    \"  SELECT Email, COUNT(Email) AS num \" +\n    \"  FROM Person \" +\n    \"  GROUP BY Email\" +\n    \") AS statistic \" +\n    \"WHERE num &gt; 1\";</code></pre><svg><path></path></svg>\n<hr/>\n<h3><a href=\"#approach-2-using-group-by-and-having-condition\"><svg><path></path></svg></a>Approach 2: Using <code>GROUP BY</code> and <code>HAVING</code> condition</h3>\n<h4>Intuition</h4>\n<p>A more common used way to add a condition to a <code>GROUP BY</code> is to use the <code>HAVING</code> clause, which is much simpler and more efficient.</p>\n<p>So we can rewrite the above solution to this one.</p>\n<h4>Implementation</h4>\n<pre><code>// Java string representing the SQL query with HAVING\nString duplicatedEmailQuery =\n    \"SELECT Email \" +\n    \"FROM Person \" +\n    \"GROUP BY Email \" +\n    \"HAVING COUNT(Email) &gt; 1\";</code></pre><svg><path></path></svg>",
        "isOfficial": true,
        "scrapedAt": "2026-02-18T07:27:22.634Z"
    }
}