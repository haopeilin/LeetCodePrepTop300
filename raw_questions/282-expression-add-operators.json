{
  "questionId": "282",
  "questionFrontendId": "282",
  "title": "Expression Add Operators",
  "titleSlug": "expression-add-operators",
  "content": "<p>Given a string <code>num</code> that contains only digits and an integer <code>target</code>, return <em><strong>all possibilities</strong> to insert the binary operators </em><code>&#39;+&#39;</code><em>, </em><code>&#39;-&#39;</code><em>, and/or </em><code>&#39;*&#39;</code><em> between the digits of </em><code>num</code><em> so that the resultant expression evaluates to the </em><code>target</code><em> value</em>.</p>\n\n<p>Note that operands in the returned expressions <strong>should not</strong> contain leading zeros.</p>\n\n<p><strong>Note</strong> that a number can contain multiple digits.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> num = &quot;123&quot;, target = 6\n<strong>Output:</strong> [&quot;1*2*3&quot;,&quot;1+2+3&quot;]\n<strong>Explanation:</strong> Both &quot;1*2*3&quot; and &quot;1+2+3&quot; evaluate to 6.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> num = &quot;232&quot;, target = 8\n<strong>Output:</strong> [&quot;2*3+2&quot;,&quot;2+3*2&quot;]\n<strong>Explanation:</strong> Both &quot;2*3+2&quot; and &quot;2+3*2&quot; evaluate to 8.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> num = &quot;3456237490&quot;, target = 9191\n<strong>Output:</strong> []\n<strong>Explanation:</strong> There are no expressions that can be created from &quot;3456237490&quot; to evaluate to 9191.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num.length &lt;= 10</code></li>\n\t<li><code>num</code> consists of only digits.</li>\n\t<li><code>-2<sup>31</sup> &lt;= target &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
  "difficulty": "Hard",
  "stats": "{\"totalAccepted\": \"308.3K\", \"totalSubmission\": \"721.3K\", \"totalAcceptedRaw\": 308348, \"totalSubmissionRaw\": 721306, \"acRate\": \"42.7%\"}",
  "hints": [
    "Note that a number can contain multiple digits.",
    "Since the question asks us to find <b>all</b> of the valid expressions, we need a way to iterate over all of them. (<b>Hint:</b> Recursion!)",
    "We can keep track of the expression string and evaluate it at the very end. But that would take a lot of time. Can we keep track of the expression's value as well so as to avoid the evaluation at the very end of recursion?",
    "Think carefully about the multiply operator. It has a higher precedence than the addition and subtraction operators. \r\n\r\n<br> 1 + 2 = 3  <br>\r\n1 + 2 - 4 --> 3 - 4 --> -1 <br>\r\n1 + 2 - 4 * 12 --> -1 * 12 --> -12 (WRONG!) <br>\r\n1 + 2 - 4 * 12 --> -1 - (-4) + (-4 * 12) --> 3 + (-48) --> -45 (CORRECT!)",
    "We simply need to keep track of the last operand in our expression and reverse it's effect on the expression's value while considering the multiply operator."
  ],
  "similarQuestions": "[{\"title\": \"Evaluate Reverse Polish Notation\", \"titleSlug\": \"evaluate-reverse-polish-notation\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Basic Calculator\", \"titleSlug\": \"basic-calculator\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Basic Calculator II\", \"titleSlug\": \"basic-calculator-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Different Ways to Add Parentheses\", \"titleSlug\": \"different-ways-to-add-parentheses\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Target Sum\", \"titleSlug\": \"target-sum\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
  "topicTags": [
    {
      "name": "Math",
      "slug": "math"
    },
    {
      "name": "String",
      "slug": "string"
    },
    {
      "name": "Backtracking",
      "slug": "backtracking"
    }
  ],
  "companyTags": null,
  "codeSnippets": [
    {
      "lang": "C++",
      "langSlug": "cpp",
      "code": "class Solution {\npublic:\n    vector<string> addOperators(string num, int target) {\n        \n    }\n};"
    },
    {
      "lang": "Java",
      "langSlug": "java",
      "code": "class Solution {\n    public List<String> addOperators(String num, int target) {\n        \n    }\n}"
    },
    {
      "lang": "Python3",
      "langSlug": "python3",
      "code": "class Solution:\n    def addOperators(self, num: str, target: int) -> List[str]:\n        "
    },
    {
      "lang": "Python",
      "langSlug": "python",
      "code": "class Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        "
    },
    {
      "lang": "JavaScript",
      "langSlug": "javascript",
      "code": "/**\n * @param {string} num\n * @param {number} target\n * @return {string[]}\n */\nvar addOperators = function(num, target) {\n    \n};"
    },
    {
      "lang": "TypeScript",
      "langSlug": "typescript",
      "code": "function addOperators(num: string, target: number): string[] {\n    \n};"
    },
    {
      "lang": "C#",
      "langSlug": "csharp",
      "code": "public class Solution {\n    public IList<string> AddOperators(string num, int target) {\n        \n    }\n}"
    },
    {
      "lang": "C",
      "langSlug": "c",
      "code": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nchar** addOperators(char* num, int target, int* returnSize) {\n    \n}"
    },
    {
      "lang": "Go",
      "langSlug": "golang",
      "code": "func addOperators(num string, target int) []string {\n    \n}"
    },
    {
      "lang": "Kotlin",
      "langSlug": "kotlin",
      "code": "class Solution {\n    fun addOperators(num: String, target: Int): List<String> {\n        \n    }\n}"
    },
    {
      "lang": "Swift",
      "langSlug": "swift",
      "code": "class Solution {\n    func addOperators(_ num: String, _ target: Int) -> [String] {\n        \n    }\n}"
    },
    {
      "lang": "Rust",
      "langSlug": "rust",
      "code": "impl Solution {\n    pub fn add_operators(num: String, target: i32) -> Vec<String> {\n        \n    }\n}"
    },
    {
      "lang": "Ruby",
      "langSlug": "ruby",
      "code": "# @param {String} num\n# @param {Integer} target\n# @return {String[]}\ndef add_operators(num, target)\n    \nend"
    },
    {
      "lang": "PHP",
      "langSlug": "php",
      "code": "class Solution {\n\n    /**\n     * @param String $num\n     * @param Integer $target\n     * @return String[]\n     */\n    function addOperators($num, $target) {\n        \n    }\n}"
    },
    {
      "lang": "Dart",
      "langSlug": "dart",
      "code": "class Solution {\n  List<String> addOperators(String num, int target) {\n    \n  }\n}"
    },
    {
      "lang": "Scala",
      "langSlug": "scala",
      "code": "object Solution {\n    def addOperators(num: String, target: Int): List[String] = {\n        \n    }\n}"
    },
    {
      "lang": "Elixir",
      "langSlug": "elixir",
      "code": "defmodule Solution do\n  @spec add_operators(num :: String.t, target :: integer) :: [String.t]\n  def add_operators(num, target) do\n    \n  end\nend"
    },
    {
      "lang": "Erlang",
      "langSlug": "erlang",
      "code": "-spec add_operators(Num :: unicode:unicode_binary(), Target :: integer()) -> [unicode:unicode_binary()].\nadd_operators(Num, Target) ->\n  ."
    },
    {
      "lang": "Racket",
      "langSlug": "racket",
      "code": "(define/contract (add-operators num target)\n  (-> string? exact-integer? (listof string?))\n  )"
    }
  ],
  "solution": {
    "content": "<div class=\"flex flex-col w-full\" style=\"position: relative;\"><div class=\"mYe_l WRmCx\"><h2 id=\"solution\" level=\"2\" class=\"group/heading relative\"><a href=\"#solution\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" aria-hidden=\"true\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"link\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" role=\"img\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 640 512\" spacing=\"square\"><path fill=\"currentColor\" d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\"></path></svg></div></a>Solution</h2>\n<hr>\n<h3 id=\"approach-1-backtracking\" level=\"3\" class=\"group/heading relative\"><a href=\"#approach-1-backtracking\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" aria-hidden=\"true\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"link\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" role=\"img\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 640 512\" spacing=\"square\"><path fill=\"currentColor\" d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\"></path></svg></div></a>Approach 1: Backtracking</h3>\n<p><strong>Intuition</strong></p>\n<p>Let us first look at what the question asks us to do before getting at the approach to solve it. So, we are given a string of numbers and 3 different operators:</p>\n<ul>\n<li><code>+</code> Addition,</li>\n<li><code>-</code> Subtraction or</li>\n<li><code>*</code> Multiplication</li>\n</ul>\n<p>We have to find all possible combinations of binary operators between the digits so that the overall value of the resulting expression becomes equal to a given target value. Let us look at a few possibilities of what it means exactly to <em>place the operators between digits</em> so that the question becomes clearer.</p>\n<p>Let's say we are given the following set of digits <code>\"123456789\"</code> and the target value given to us is <code>45</code>. Let us see some of the possible resulting expressions that we can get by placing the operators in different locations.</p>\n<pre>1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 = 45\n1 + 2 - 3 + 4 - 5 + 6 - 7 + 8 - 9 = -3\n1 + 2 * 3 - 4 + 5 + 6 - 7 * 8 - 9 = -51\n1 + 2 + 3 + 4 + 5 - 6 * 7 + 8 * 9 = 45\n</pre>\n<p>These are just 4 of the many resulting expressions that are possible by using the given string of digits and the three operators.</p>\n<p>By looking at the above examples we can't really figure out any specific pattern among the resulting expressions that tells us which of them will give us the resulting target.</p>\n<p>Since the question explicitly states that we are given binary operators, this means that each of the operator would require two operands.</p>\n<blockquote>\n<p>We can consider each of our digits as an operand.</p>\n</blockquote>\n<p>This means that between every pair of digits we can have any of the three operators i.e. <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6667em; vertical-align: -0.0833em;\"></span><span class=\"mord\">+</span></span></span></span></span>, <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6667em; vertical-align: -0.0833em;\"></span><span class=\"mord\">−</span></span></span></span></span> or <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6667em; vertical-align: -0.0833em;\"></span><span class=\"mord\">×</span></span></span></span></span>.</p>\n<p>If you've looked at the question's statement and the examples that are given in the question, you would realize that there is an example where the digits are <code>\"105\"</code> and the target value is <code>5</code>. For this particular example, there are two expressions given to us and they are <code>1*0+5</code> and <code>10-5</code>.</p>\n<p>The second expression is something that you need to look out for before getting to solve this question because this complicates things a bit.</p>\n<p>It would have been an easier question to solve if we just had to consider those expressions that simply had <em>digits as operands</em>.</p>\n<p>But, in this question, we can have all sorts of digits getting together and forming a bigger number that becomes a part of the expression. Let us look at some example expressions for the digits <code>\"123456\"</code> and target <code>30</code>.</p>\n<pre>1 * 23 - 4 + 5 + 6 = 30\n12 - 3 * 4 + 5 * 6 = 30\n1 - 23 - 4 + 56 = 30\n</pre>\n<p>So this means that although the number of operators are defined for us i.e. 3 different binary operators, but the number of operands are <strong>not really well defined for us</strong>.</p>\n<p>This is a big portion of the original problem that we need to address in our solution.</p>\n<p>Since we are asked to find out all of the valid expressions whose value equals the given target and we don't really know what specific operator between two operands would eventually give us a valid expression,</p>\n<blockquote>\n<p>We try out all of the options.</p>\n</blockquote>\n<p>This means once we have defined what the operands are for our given expression, we would have three possible choices of operators between each consecutive pair of operands.</p>\n<p>From an implementation perspective, what would an operand imply with respect to our original string?</p>\n<blockquote>\n<p>An operand would be an integer formed from a substring of our original string.</p>\n</blockquote>\n<p>Let's look at two different array partitions for the given string <code>\"123456789\"</code></p>\n\n<img alt=\"\" height=\"300\" src=\"../Figures/282/282_Expression_Add_Operators_Diag_1.png\">\n<p>Since we are required to return all of the valid expressions that evaluate to a given target value, we have to try all possible partitions of the given array thereby considering all of the possible operands that can be formed from the digits.</p>\n<p>There is a very simple way of incorporating this into our algorithm. Right now, at every point in the algorithm, we have three different choices corresponding to the three different operators.</p>\n<blockquote>\n<p>The way we incorporate these partitions is by considering a 4th operator as well which simply moves one step forward and extends the current operand by one digit. Essentially, going from 12 --&gt; 123 is a NO OP operand in our implementation. (12 * 10) + 3.</p>\n</blockquote>\n<p>Now we have 4 different recursion paths in our algorithm and we have to try out all of them to see which ones lead to a potential solution.</p>\n<p>This <code>try out everything</code> hints at a backtracking solution and that is exactly what we are going to look at here.</p>\n<p><strong>Algorithm</strong></p>\n<p>Let's quickly look at the steps involved in our backtracking algorithm before looking at the pseudo-code.</p>\n<ol>\n<li data-length=\"1\">As discussed above, we have multiple choices of what operators to use and what the operands can be and hence, we have to look at all the possibilities to find <em><strong>all</strong></em> valid expressions.</li>\n<li data-length=\"1\">Our recursive call will have an <code>index</code> which represents the current digit we're looking at in the original <code>nums</code> string and also the expression string built till now.</li>\n<li data-length=\"1\">At every step, we have exactly 4 different recursive calls. The <code>NO OP</code> call simply extends the <code>current_operand</code> by the current digit and moves ahead. Rest of the recursive calls correspond to <code>+</code>, <code>-</code>, and <code>*</code>.</li>\n<li data-length=\"1\">We keep on building our expression like this and eventually, the entire <code>nums</code> string would be processed. At that time we check if the expression we built till now is a valid expression or not and we record it if it is a valid one.</li>\n</ol>\n<pre>1. procedure recurse(digits, index, expression):\n2.     if we have reached the end of the string:\n3.         if the expression evaluates to the target:\n4.             Valid Expression found!\n5.     else:\n6.         try out operator 'NO OP' and recurse\n7.         try out operator * and recurse\n8.         try out operator + and recurse\n9.         try out operator - and recurse\n</pre>\n<p>The algorithm now looks pretty straightforward. However, the implementation is something that needs more thought and there are some things that we need to address before actually looking at the implementation.</p>\n<p>When we are done building an expression out of all of the digits in our original string i.e. the base case, then we check if the expression is a valid expression or not. Right ?</p>\n<blockquote>\n<p>How do we actually check if an expression is a valid one or not if all we have is a string representing the expression and not the integer value for the same?</p>\n</blockquote>\n<p>Well, one way to go about this is to write a custom <code>eval</code> function that takes in a string and returns the value of that expression. If you do that (Python people can use the inbuilt function <code>eval</code> for this), you will get a TLE i.e. time limit exceeded error.</p>\n<br>\n<p><strong>Can't we keep track of the expression's value on the fly?</strong></p>\n<p>Well yes. That's the idea we will go with. Instead of just keeping track of what the expression string is, we will also keep track of it's value along the way so that when the recursion hits the base case, we can check in <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></span> time if the expression's value equals the target value or not.</p>\n<p>The implementation would have been straightforward had it just been <code>+</code> and <code>-</code> operators involved. This is because both these operators have an equal precedence. That means that we can continue to evaluate the expression on the fly without any problems. Have a look at the following example.</p>\n\n<img alt=\"\" width=\"550\" src=\"../Figures/282/282_Expression_Add_Operators_Diag_2.png\">\n<p>So far so good. Now let us add the <code>*</code> operator as well and see how building the expression on the fly like this breaks.</p>\n\n<img alt=\"\" width=\"550\" src=\"../Figures/282/282_Expression_Add_Operators_Diag_3.png\">\n<p>What we mean by building the expression on the fly is that we keep track of the expression's value till now and we simply consider that value as one of the two operands for our operators. As we can see from the two examples above, this would have worked had it just been <code>+</code> and <code>-</code> operators.</p>\n<p>But, this approach is bound to fail because the <code>*</code> operator takes precedence over <code>+</code> and <code>-</code>. The <code>*</code> operator would require the <em><strong>actual</strong></em> previous operand in our expression rather than the current value of the expression. i.e. In the above example, the <code>*</code> operator needed <code>2</code> rather than <code>12</code> to get us the correct value of <code>18</code>.</p>\n<br>\n<p><strong>How to handle this?</strong></p>\n<p>The idea on how to handle this problem springs from the discussion above. We simply need to keep track of the last operand in our expression and how it modified the expression's value overall so that when we consider the <code>*</code> operator, we can <strong>reverse</strong> the effects of the previous operand and consider it for multiplication. Let's take a look at the example that was breaking before.</p>\n\n<img alt=\"\" width=\"550\" src=\"../Figures/282/282_Expression_Add_Operators_Diag_4.png\">\n<p>Now we can look at the actual implementation of this algorithm.</p>\n<pre><code>class Solution {\n​\n  public ArrayList&lt;String&gt; answer;\n  public String digits;\n  public long target;\n​\n  public void recurse(\n      int index, long previousOperand, long currentOperand, long value, ArrayList&lt;String&gt; ops) {\n    String nums = this.digits;\n​\n    // Done processing all the digits in num\n    if (index == nums.length()) {\n​\n      // If the final value == target expected AND\n      // no operand is left unprocessed\n      if (value == this.target && currentOperand == 0) {\n        StringBuilder sb = new StringBuilder();\n        ops.subList(1, ops.size()).forEach(v -&gt; sb.append(v));\n        this.answer.add(sb.toString());\n      }\n      return;\n    }\n​\n    // Extending the current operand by one digit\n    currentOperand = currentOperand * 10 + Character.getNumericValue(nums.charAt(index));\n    String current_val_rep = Long.toString(currentOperand);\n    int length = nums.length();\n​\n    // To avoid cases where we have 1 + 05 or 1 * 05 since 05 won't be a\n    // valid operand. Hence this check\n    if (currentOperand &gt; 0) {\n​\n      // NO OP recursion\n      recurse(index + 1, previousOperand, currentOperand, value, ops);\n    }\n​\n    // ADDITION\n    ops.add(\"+\");\n    ops.add(current_val_rep);\n    recurse(index + 1, currentOperand, 0, value + currentOperand, ops);\n    ops.remove(ops.size() - 1);\n    ops.remove(ops.size() - 1);\n​\n    if (ops.size() &gt; 0) {\n​\n      // SUBTRACTION\n      ops.add(\"-\");\n      ops.add(current_val_rep);\n      recurse(index + 1, -currentOperand, 0, value - currentOperand, ops);\n      ops.remove(ops.size() - 1);\n      ops.remove(ops.size() - 1);\n​\n      // MULTIPLICATION\n      ops.add(\"*\");\n      ops.add(current_val_rep);\n      recurse(\n          index + 1,\n          currentOperand * previousOperand,\n          0,\n          value - previousOperand + (currentOperand * previousOperand),\n          ops);\n      ops.remove(ops.size() - 1);\n      ops.remove(ops.size() - 1);\n    }\n  }\n​\n  public List&lt;String&gt; addOperators(String num, int target) {\n​\n    if (num.length() == 0) {\n      return new ArrayList&lt;String&gt;();\n    }\n​\n    this.target = target;\n    this.digits = num;\n    this.answer = new ArrayList&lt;String&gt;();\n    this.recurse(0, 0, 0, 0, new ArrayList&lt;String&gt;());\n    return this.answer;\n  }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity:</p>\n<ul>\n<li>At every step along the way, we consider exactly 4 different choices or 4 different recursive paths. The base case is when the value of <code>index</code> reaches <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span></span></span></span></span> i.e. the length of the <code>nums</code> array. Hence, our complexity would be <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1.0913em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord\">4</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.8413em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right: 0.10903em;\">N</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span>.</li>\n<li>For the base case we use a <code>StringBuilder::toString</code> operation in Java and <code>.join()</code> operation in Python and that takes <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span></span> time. Here <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span></span></span></span></span> represents the length of our expression. In the worst case, each digit would be an operand and we would have <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span></span></span></span></span> digits and <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.7667em; vertical-align: -0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.6444em;\"></span><span class=\"mord\">1</span></span></span></span></span> operators. So <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span></span>. This is for one expression. In the worst case, we can have <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1.0913em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord\">4</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.8413em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right: 0.10903em;\">N</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span> valid expressions.</li>\n<li>Overall time complexity = <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1.0913em; vertical-align: -0.25em;\"></span><span class=\"mord\"><span class=\"mord\">4</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.8413em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right: 0.10903em;\">N</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span>.</li>\n</ul>\n</li>\n<li>\n<p>Space Complexity:</p>\n<ul>\n<li>For both Python and Java implementations we have a list data structure that we update on the fly and only for valid expressions do we create a new string and add to our <code>answers</code> array. So, the space occupied by the intermediate list would be <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span></span> since in the worst case the expression would be built out of all the digits as operands.</li>\n<li>Additionally, the space used up by the recursion stack would also be <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span></span> since the size of recursion stack is determined by the value of <code>index</code> and it goes from <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6444em;\"></span><span class=\"mord\">0</span></span></span></span></span> all the way to <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span></span></span></span></span>.</li>\n<li>We don't consider the space occupied by the <code>answers</code> array since that is a part of the question's requirement and we can't reduce that in any way</li>\n</ul>\n</li>\n</ul>\n<p><strong>EDIT:</strong><br>\nThe previous implementation of the algorithm, although correct, lead me to write an incorrect complexity analysis section. I've re-written the algorithm from scratch and corrected the complexity analysis as well. Sorry for the inconvenience to all the readers. The core idea of the algorithm is still the same. That hasn't changed.</p>\n<p>Special thanks to <a href=\"https://leetcode.com/ufarooqi/\" target=\"_blank\">@ufarooqi</a>, <a href=\"https://leetcode.com/vortexwolf\" target=\"_blank\">@vortexwolf</a> for providing correct complexity analysis in the discussion forum leading to corrections in the article. Pardon me if I've missed out on any other names :)</p>\n<br></div><span style=\"font-size: 0px; line-height: 0;\">&nbsp;</span></div>",
    "isOfficial": true,
    "scrapedAt": "2026-02-18T08:54:11.598Z"
  }
}