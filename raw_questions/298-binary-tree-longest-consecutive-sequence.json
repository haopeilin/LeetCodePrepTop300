{
    "questionId": "298",
    "questionFrontendId": "298",
    "title": "Binary Tree Longest Consecutive Sequence",
    "titleSlug": "binary-tree-longest-consecutive-sequence",
    "content": "<p>Given the <code>root</code> of a binary tree, return <em>the length of the longest <strong>consecutive sequence path</strong></em>.</p>\n\n<p>A <strong>consecutive sequence path</strong> is a path where the values <strong>increase by one</strong> along the path.</p>\n\n<p>Note that the path can start <strong>at any node</strong> in the tree, and you cannot go from a node to its parent in the path.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"images/298/consec1-1-tree.jpg\" style=\"width: 306px; height: 400px;\" />\n<pre>\n<strong>Input:</strong> root = [1,null,3,2,4,null,null,null,5]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> Longest consecutive sequence path is 3-4-5, so return 3.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"images/298/consec1-2-tree.jpg\" style=\"width: 249px; height: 400px;\" />\n<pre>\n<strong>Input:</strong> root = [2,null,3,2,null,1]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> Longest consecutive sequence path is 2-3, not 3-2-1, so return 2.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[1, 3 * 10<sup>4</sup>]</code>.</li>\n\t<li><code>-3 * 10<sup>4</sup> &lt;= Node.val &lt;= 3 * 10<sup>4</sup></code></li>\n</ul>\n",
    "difficulty": "Medium",
    "stats": "{\"totalAccepted\": \"163.9K\", \"totalSubmission\": \"299.9K\", \"totalAcceptedRaw\": 163878, \"totalSubmissionRaw\": 299932, \"acRate\": \"54.6%\"}",
    "hints": [],
    "similarQuestions": "[{\"title\": \"Longest Consecutive Sequence\", \"titleSlug\": \"longest-consecutive-sequence\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Binary Tree Longest Consecutive Sequence II\", \"titleSlug\": \"binary-tree-longest-consecutive-sequence-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Check if an Array Is Consecutive\", \"titleSlug\": \"check-if-an-array-is-consecutive\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
    "topicTags": [
        {
            "name": "Tree",
            "slug": "tree"
        },
        {
            "name": "Depth-First Search",
            "slug": "depth-first-search"
        },
        {
            "name": "Binary Tree",
            "slug": "binary-tree"
        }
    ],
    "companyTags": null,
    "codeSnippets": [
        {
            "lang": "C++",
            "langSlug": "cpp",
            "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int longestConsecutive(TreeNode* root) {\n        \n    }\n};"
        },
        {
            "lang": "Java",
            "langSlug": "java",
            "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int longestConsecutive(TreeNode root) {\n        \n    }\n}"
        },
        {
            "lang": "Python3",
            "langSlug": "python3",
            "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def longestConsecutive(self, root: Optional[TreeNode]) -> int:\n        "
        },
        {
            "lang": "Python",
            "langSlug": "python",
            "code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def longestConsecutive(self, root):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :rtype: int\n        \"\"\"\n        "
        },
        {
            "lang": "JavaScript",
            "langSlug": "javascript",
            "code": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar longestConsecutive = function(root) {\n    \n};"
        },
        {
            "lang": "TypeScript",
            "langSlug": "typescript",
            "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction longestConsecutive(root: TreeNode | null): number {\n    \n};"
        },
        {
            "lang": "C#",
            "langSlug": "csharp",
            "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public int LongestConsecutive(TreeNode root) {\n        \n    }\n}"
        },
        {
            "lang": "C",
            "langSlug": "c",
            "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\nint longestConsecutive(struct TreeNode* root) {\n    \n}"
        },
        {
            "lang": "Go",
            "langSlug": "golang",
            "code": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc longestConsecutive(root *TreeNode) int {\n    \n}"
        },
        {
            "lang": "Kotlin",
            "langSlug": "kotlin",
            "code": "/**\n * Example:\n * var ti = TreeNode(5)\n * var v = ti.`val`\n * Definition for a binary tree node.\n * class TreeNode(var `val`: Int) {\n *     var left: TreeNode? = null\n *     var right: TreeNode? = null\n * }\n */\nclass Solution {\n    fun longestConsecutive(root: TreeNode?): Int {\n        \n    }\n}"
        },
        {
            "lang": "Swift",
            "langSlug": "swift",
            "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\n *         self.val = val\n *         self.left = left\n *         self.right = right\n *     }\n * }\n */\nclass Solution {\n    func longestConsecutive(_ root: TreeNode?) -> Int {\n        \n    }\n}"
        },
        {
            "lang": "Rust",
            "langSlug": "rust",
            "code": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n// \n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\nimpl Solution {\n    pub fn longest_consecutive(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\n        \n    }\n}"
        },
        {
            "lang": "Ruby",
            "langSlug": "ruby",
            "code": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val = 0, left = nil, right = nil)\n#         @val = val\n#         @left = left\n#         @right = right\n#     end\n# end\n# @param {TreeNode} root\n# @return {Integer}\ndef longest_consecutive(root)\n    \nend"
        },
        {
            "lang": "PHP",
            "langSlug": "php",
            "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($val = 0, $left = null, $right = null) {\n *         $this->val = $val;\n *         $this->left = $left;\n *         $this->right = $right;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param TreeNode $root\n     * @return Integer\n     */\n    function longestConsecutive($root) {\n        \n    }\n}"
        },
        {
            "lang": "Dart",
            "langSlug": "dart",
            "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *   int val;\n *   TreeNode? left;\n *   TreeNode? right;\n *   TreeNode([this.val = 0, this.left, this.right]);\n * }\n */\nclass Solution {\n  int longestConsecutive(TreeNode? root) {\n    \n  }\n}"
        },
        {
            "lang": "Scala",
            "langSlug": "scala",
            "code": "/**\n * Definition for a binary tree node.\n * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {\n *   var value: Int = _value\n *   var left: TreeNode = _left\n *   var right: TreeNode = _right\n * }\n */\nobject Solution {\n    def longestConsecutive(root: TreeNode): Int = {\n        \n    }\n}"
        },
        {
            "lang": "Elixir",
            "langSlug": "elixir",
            "code": "# Definition for a binary tree node.\n#\n# defmodule TreeNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           left: TreeNode.t() | nil,\n#           right: TreeNode.t() | nil\n#         }\n#   defstruct val: 0, left: nil, right: nil\n# end\n\ndefmodule Solution do\n  @spec longest_consecutive(root :: TreeNode.t | nil) :: integer\n  def longest_consecutive(root) do\n    \n  end\nend"
        },
        {
            "lang": "Erlang",
            "langSlug": "erlang",
            "code": "%% Definition for a binary tree node.\n%%\n%% -record(tree_node, {val = 0 :: integer(),\n%%                     left = null  :: 'null' | #tree_node{},\n%%                     right = null :: 'null' | #tree_node{}}).\n\n-spec longest_consecutive(Root :: #tree_node{} | null) -> integer().\nlongest_consecutive(Root) ->\n  ."
        },
        {
            "lang": "Racket",
            "langSlug": "racket",
            "code": "; Definition for a binary tree node.\n#|\n\n; val : integer?\n; left : (or/c tree-node? #f)\n; right : (or/c tree-node? #f)\n(struct tree-node\n  (val left right) #:mutable #:transparent)\n\n; constructor\n(define (make-tree-node [val 0])\n  (tree-node val #f #f))\n\n|#\n\n(define/contract (longest-consecutive root)\n  (-> (or/c tree-node? #f) exact-integer?)\n  )"
        }
    ],
    "solution": {
        "content": "<h2><a href=\"#solution\"><svg><path></path></svg></a>Solution</h2>\n<hr/>\n<h3><a href=\"#approach-1-top-down-depth-first-search-accepted\"><svg><path></path></svg></a>Approach #1 (Top Down Depth-first Search) [Accepted]</h3>\n<p><strong>Algorithm</strong></p>\n<p>A top-down approach is used, using depth-first search in a manner similar to a pre-order traversal, where a variable <code>length</code> is maintained to track the current consecutive path length and is passed down the tree; at each node, the current value is compared with its parent to determine whether the sequence remains consecutive, and if it does not, the length is reset.</p>\n<pre><code>private int maxLength = 0;\npublic int longestConsecutive(TreeNode root) {\n    dfs(root, null, 0);\n    return maxLength;\n}\n​\nprivate void dfs(TreeNode p, TreeNode parent, int length) {\n    if (p == null) return;\n    length = (parent != null &amp;&amp; p.val == parent.val + 1) ? length + 1 : 1;\n    maxLength = Math.max(maxLength, length);\n    dfs(p.left, p, length);\n    dfs(p.right, p, length);\n}</code></pre>\n<p>@lightmark presents <a href=\"https://leetcode.com/discuss/66486/short-and-simple-c-solution\">a neat approach</a> without storing the maxLength as a global variable.</p>\n<pre><code>public int longestConsecutive(TreeNode root) {\n    return dfs(root, null, 0);\n}\n​\nprivate int dfs(TreeNode p, TreeNode parent, int length) {\n    if (p == null) return length;\n    length = (parent != null &amp;&amp; p.val == parent.val + 1) ? length + 1 : 1;\n    return Math.max(length, Math.max(dfs(p.left, p, length),\n                                     dfs(p.right, p, length)));\n}</code></pre>\n<p><strong>Complexity analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : O(n).<br/>\nThe time complexity is the same as an in-order traversal of a binary tree with n nodes.</p>\n</li>\n<li>\n<p>Space complexity : O(n).<br/>\nThe extra space comes from implicit stack space due to recursion. For a skewed binary tree, the recursion could go up to n levels deep.</p>\n</li>\n</ul>\n<hr/>\n<h3><a href=\"#approach-2-bottom-up-depth-first-search-accepted\"><svg><path></path></svg></a>Approach #2 (Bottom Up Depth-first Search) [Accepted]</h3>\n<p><strong>Algorithm</strong></p>\n<p>The bottom-up approach is similar to a post-order traversal. We return the consecutive path length starting at current node to its parent. Then its parent can examine if its node value can be included in this consecutive path.</p>\n<pre><code>private int maxLength = 0;\npublic int longestConsecutive(TreeNode root) {\n    dfs(root);\n    return maxLength;\n}\n​\nprivate int dfs(TreeNode p) {\n    if (p == null) return 0;\n    int L = dfs(p.left) + 1;\n    int R = dfs(p.right) + 1;\n    if (p.left != null &amp;&amp; p.val + 1 != p.left.val) {\n        L = 1;\n    }\n    if (p.right != null &amp;&amp; p.val + 1 != p.right.val) {\n        R = 1;\n    }\n    int length = Math.max(L, R);\n    maxLength = Math.max(maxLength, length);\n    return length;\n}</code></pre>\n<p><strong>Complexity analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : O(n).<br/>\nThe time complexity is the same as a post-order traversal in a binary tree, which is O(n).</p>\n</li>\n<li>\n<p>Space complexity : O(n).<br/>\nThe extra space comes from implicit stack space due to recursion. For a skewed binary tree, the recursion could go up to n levels deep.</p>\n</li>\n</ul>",
        "isOfficial": true,
        "scrapedAt": "2026-02-18T09:52:00.741Z"
    }
}