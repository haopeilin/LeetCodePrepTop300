{
    "questionId": "165",
    "questionFrontendId": "165",
    "title": "Compare Version Numbers",
    "titleSlug": "compare-version-numbers",
    "content": "<p>Given two <strong>version strings</strong>, <code>version1</code> and <code>version2</code>, compare them. A version string consists of <strong>revisions</strong> separated by dots <code>&#39;.&#39;</code>. The <strong>value of the revision</strong> is its <strong>integer conversion</strong> ignoring leading zeros.</p>\n\n<p>To compare version strings, compare their revision values in <strong>left-to-right order</strong>. If one of the version strings has fewer revisions, treat the missing revision values as <code>0</code>.</p>\n\n<p>Return the following:</p>\n\n<ul>\n\t<li>If <code>version1 &lt; version2</code>, return -1.</li>\n\t<li>If <code>version1 &gt; version2</code>, return 1.</li>\n\t<li>Otherwise, return 0.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">version1 = &quot;1.2&quot;, version2 = &quot;1.10&quot;</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">-1</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p>version1&#39;s second revision is &quot;2&quot; and version2&#39;s second revision is &quot;10&quot;: 2 &lt; 10, so version1 &lt; version2.</p>\n</div>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">version1 = &quot;1.01&quot;, version2 = &quot;1.001&quot;</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">0</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p>Ignoring leading zeroes, both &quot;01&quot; and &quot;001&quot; represent the same integer &quot;1&quot;.</p>\n</div>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">version1 = &quot;1.0&quot;, version2 = &quot;1.0.0.0&quot;</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">0</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p>version1 has less revisions, which means every missing revision are treated as &quot;0&quot;.</p>\n</div>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= version1.length, version2.length &lt;= 500</code></li>\n\t<li><code>version1</code> and <code>version2</code>&nbsp;only contain digits and <code>&#39;.&#39;</code>.</li>\n\t<li><code>version1</code> and <code>version2</code>&nbsp;<strong>are valid version numbers</strong>.</li>\n\t<li>All the given revisions in&nbsp;<code>version1</code> and <code>version2</code>&nbsp;can be stored in&nbsp;a&nbsp;<strong>32-bit integer</strong>.</li>\n</ul>\n",
    "difficulty": "Medium",
    "stats": "{\"totalAccepted\": \"692.1K\", \"totalSubmission\": \"1.5M\", \"totalAcceptedRaw\": 692100, \"totalSubmissionRaw\": 1502079, \"acRate\": \"46.1%\"}",
    "hints": [
        "You can use two pointers for each version string to traverse them together while comparing the corresponding segments.",
        "Utilize the substring method to extract each version segment delimited by '.'. Ensure you're extracting the segments correctly by adjusting the start and end indices accordingly."
    ],
    "similarQuestions": "[]",
    "topicTags": [
        {
            "name": "Two Pointers",
            "slug": "two-pointers"
        },
        {
            "name": "String",
            "slug": "string"
        }
    ],
    "companyTags": null,
    "codeSnippets": [
        {
            "lang": "Java",
            "langSlug": "java",
            "code": "class Solution {\n    public int compareVersion(String version1, String version2) {\n        \n    }\n}"
        }
    ],
    "solution": {
        "content": "<h2><a href=\"#solution\"><svg><path></path></svg></a>Solution</h2>\n<hr/>\n<h3><a href=\"#approach-1-split--parse-two-pass\"><svg><path></path></svg></a>Approach 1: Split + Parse, Two Pass</h3>\n<p><strong>Intuition</strong></p>\n<p>The first idea is to split both strings by dot character into chunks and then compare the chunks one by one.</p>\n<p></p>\n<p>That works fine if the number of chunks is the same for both versions. If not, we need to pad the shorter string by adding <code>.0</code> at the end of the string with fewer chunks one or several times, so that the number of chunks will be the same.</p>\n<p></p>\n<p><strong>Algorithm</strong></p>\n<ul>\n<li>\n<p>Split both strings by dot character into two arrays.</p>\n</li>\n<li>\n<p>Iterate over the longest array and compare chunks one by one. If one of the arrays is over, virtually add as many zeros as needed to continue the comparison with the longer array.</p>\n<ul>\n<li>If two chunks are not equal, return 1 or -1.</li>\n</ul>\n</li>\n<li>\n<p>If we're here, the versions are equal. Return 0.</p>\n</li>\n</ul>\n<p><strong>Implementation</strong></p>\n<pre><code>class Solution {\n    public int compareVersion(String version1, String version2) {\n        String[] tokens1 = version1.split(\"\\\\.\");\n        String[] tokens2 = version2.split(\"\\\\.\");\n\n        for (int i = 0; i &lt; Math.max(tokens1.length, tokens2.length); i++) {\n            int i1 = i &lt; tokens1.length ? Integer.parseInt(tokens1[i]) : 0;\n            int i2 = i &lt; tokens2.length ? Integer.parseInt(tokens2[i]) : 0;\n\n            if (i1 != i2) {\n                return i1 &gt; i2 ? 1 : -1;\n            }\n        }\n        // The versions are equal\n        return 0;\n    }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : O(N+M), where N and M are lengths of input strings.</p>\n</li>\n<li>\n<p>Space complexity : O(N+M) to store arrays <code>nums1</code> and <code>nums2</code>.</p>\n</li>\n</ul>\n<hr/>\n<h3><a href=\"#approach-2-two-pointers-one-pass\"><svg><path></path></svg></a>Approach 2: Two Pointers, One Pass</h3>\n<p><strong>Intuition</strong></p>\n<p>Rather than splitting the string all at once with the <code>split()</code> function, we could also split the string <strong><em>on the fly</em></strong>, through which we only need to iterate through the revisions once.</p>\n<blockquote>\n<p>The idea is that we split the string <em>chunk by chunk</em>, <em>i.e.</em> each trunk represents a revision in the version number. The moment we retrieve a trunk from each string, we then compare them.</p>\n</blockquote>\n<p>In this way, one could move along both strings in parallel, and retrieve and compare corresponding chunks. Once both strings are parsed, the comparison is done as well.</p>\n<p>As a result, the process can be done in a <strong>single</strong> pass.</p>\n<p><strong>Algorithm</strong></p>\n<p>First, we define a function named <code>get_next_chunk(version, n, p)</code>, which is to retrieve the next chunk in the string.</p>\n<p>This function takes three arguments: the input string <code>version</code>, its length <code>n</code>, and a pointer <code>p</code> set to the first character of the chunk to retrieve. It returns an integer chunk in between the pointer <code>p</code> and the next dot. To help with the iteration, it returns a pointer set to the first character of the next chunk.</p>\n<p>Here is how one could solve the problem using this function:</p>\n<ul>\n<li>\n<p>Set a pointer <code>p1</code> pointed to the beginning of string <code>version1</code> and a pointer <code>p2</code> to the beginning of string <code>version2</code>: <code>p1 = p2 = 0</code>.</p>\n</li>\n<li>\n<p>Iterate over both strings in parallel. While <code>p1 &lt; n1 or p2 &lt; n2</code>:</p>\n<ul>\n<li>\n<p>Retrieve the next chunk <code>i1</code> from string <code>version1</code> and next chunk <code>i2</code> from string <code>version2</code> using the above-defined <code>get_next_chunk</code> function.</p>\n</li>\n<li>\n<p>Compare <code>i1</code> and <code>i2</code>. If they are not equal, return 1 or -1.</p>\n</li>\n</ul>\n</li>\n<li>\n<p>If we're here, the versions are equal. Return 0.</p>\n</li>\n</ul>\n<p>Now let's implement our <code>get_next_chunk(version, n, p)</code> function:</p>\n<ul>\n<li>\n<p>The beginning of the chunk is marked by the pointer <code>p</code>. If <code>p</code> is set to the end of the string, the string is already parsed. To continue the comparison, let's add a virtual <code>.0</code> at the end of this string by returning 0.</p>\n</li>\n<li>\n<p>If <code>p</code> is not at the end of the string, move the pointer <code>p_end</code> along the string to find the end of the chunk.</p>\n</li>\n<li>\n<p>Return the chunk <code>version.substring(p, p_end)</code>.</p>\n</li>\n</ul>\n<p><strong>Implementation</strong></p>\n<p></p>\n<pre><code>class Solution {\n\n    private int[] getNextChunk(String version, int n, int p) {\n        if (p &gt; n - 1) {\n            return new int[]{0, p};\n        }\n\n        int pEnd = p;\n        while (pEnd &lt; n &amp;&amp; version.charAt(pEnd) != '.') {\n            pEnd++;\n        }\n\n        int value = Integer.parseInt(version.substring(p, pEnd));\n        p = pEnd + 1;\n\n        return new int[]{value, p};\n    }\n\n    public int compareVersion(String version1, String version2) {\n        int p1 = 0, p2 = 0;\n        int n1 = version1.length(), n2 = version2.length();\n\n        while (p1 &lt; n1 || p2 &lt; n2) {\n            int[] pair1 = getNextChunk(version1, n1, p1);\n            p1 = pair1[1];\n            int[] pair2 = getNextChunk(version2, n2, p2);\n            p2 = pair2[1];\n\n            if (pair1[0] != pair2[0]) {\n                return pair1[0] &gt; pair2[0] ? 1 : -1;\n            }\n        }\n        return 0;\n    }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : O(max(N,M)), where N and M are the lengths of the input strings respectively. It's a one-pass solution.</p>\n</li>\n<li>\n<p>Space complexity : O(max(N,M)).</p>\n<ul>\n<li>Despite the fact that we did not keep arrays of revision numbers, we still need some additional space to store a substring of the input string for integer conversion.<br/>\nIn the worst case, the substring could be of the original string as well.</li>\n</ul>\n</li>\n</ul>\n<hr/>",
        "isOfficial": true,
        "scrapedAt": "2026-02-18T08:19:48.720Z"
    }
}