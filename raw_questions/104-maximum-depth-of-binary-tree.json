{
    "questionId": "104",
    "questionFrontendId": "104",
    "title": "Maximum Depth of Binary Tree",
    "titleSlug": "maximum-depth-of-binary-tree",
    "content": "<p>Given the <code>root</code> of a binary tree, return <em>its maximum depth</em>.</p>\n\n<p>A binary tree&#39;s <strong>maximum depth</strong>&nbsp;is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"images/104/tmp-tree.jpg\" style=\"width: 400px; height: 277px;\" />\n<pre>\n<strong>Input:</strong> root = [3,9,20,null,null,15,7]\n<strong>Output:</strong> 3\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [1,null,2]\n<strong>Output:</strong> 2\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 10<sup>4</sup>]</code>.</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n",
    "difficulty": "Easy",
    "stats": "{\"totalAccepted\": \"4.6M\", \"totalSubmission\": \"5.9M\", \"totalAcceptedRaw\": 4598951, \"totalSubmissionRaw\": 5903500, \"acRate\": \"77.9%\"}",
    "hints": [],
    "similarQuestions": "[{\"title\": \"Balanced Binary Tree\", \"titleSlug\": \"balanced-binary-tree\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Minimum Depth of Binary Tree\", \"titleSlug\": \"minimum-depth-of-binary-tree\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Maximum Depth of N-ary Tree\", \"titleSlug\": \"maximum-depth-of-n-ary-tree\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Time Needed to Inform All Employees\", \"titleSlug\": \"time-needed-to-inform-all-employees\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Amount of Time for Binary Tree to Be Infected\", \"titleSlug\": \"amount-of-time-for-binary-tree-to-be-infected\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Height of Binary Tree After Subtree Removal Queries\", \"titleSlug\": \"height-of-binary-tree-after-subtree-removal-queries\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
    "topicTags": [
        {
            "name": "Tree",
            "slug": "tree"
        },
        {
            "name": "Depth-First Search",
            "slug": "depth-first-search"
        },
        {
            "name": "Breadth-First Search",
            "slug": "breadth-first-search"
        },
        {
            "name": "Binary Tree",
            "slug": "binary-tree"
        }
    ],
    "companyTags": null,
    "codeSnippets": [
        {
            "lang": "Java",
            "langSlug": "java",
            "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        \n    }\n}"
        }
    ],
    "solution": {
        "content": "<h2><a href=\"#solution\"><svg><path></path></svg></a>Solution</h2>\n<p><strong>Tree definition</strong></p>\n<p>First of all, here is the definition of the <code>TreeNode</code> which we would use.</p>\n<pre><code>/* Definition for a binary tree node. */\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) {\n        val = x;\n        left = null;\n        right = null;\n    }\n}</code></pre>\n<br/>\n<br/>\n<hr/>\n<h3><a href=\"#approach-1-recursion\"><svg><path></path></svg></a>Approach 1: Recursion</h3>\n<p><strong>Intuition</strong><br/>\nBy definition, the maximum depth of a binary tree is the maximum number of steps to reach a leaf node from the root node.</p>\n<blockquote>\n<p>From the definition, an intuitive idea would be to traverse the tree and record the maximum depth during the traversal.</p>\n</blockquote>\n<p><strong>Algorithm</strong></p>\n<p></p>\n<p>One could traverse the tree either by Depth-First Search (DFS) strategy or Breadth-First Search (BFS) strategy.<br/>\nFor this problem, either way would do.<br/>\nHere we demonstrate a solution that is implemented with the <strong>DFS</strong> strategy and <strong>recursion</strong>.</p>\n<pre><code>class Solution {\n    public int maxDepth(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        return Math.max(1 + maxDepth(root.left), 1 + maxDepth(root.right));\n    }\n}</code></pre>\n<p><strong>Complexity analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity: we visit each node exactly once, thus the time complexity is O(N), where N is the number of nodes.</p>\n</li>\n<li>\n<p>Space complexity: in the worst case, the tree is completely unbalanced, <em>e.g.</em> each node has only left child node, the recursion call would occur N times (the height of the tree), therefore the storage to keep the call stack would be O(N). But in the best case (the tree is completely balanced), the height of the tree would be log(N). Therefore, the space complexity in this case would be O(log(N)).</p>\n<br/>\n</li>\n</ul>\n<br/>\n<hr/>\n<h3><a href=\"#approach-2-tail-recursion--bfs\"><svg><path></path></svg></a>Approach 2: Tail Recursion + BFS</h3>\n<p>One might have noticed that the above recursion solution is probably not the most optimal one in terms of space complexity, and in the extreme case, the overhead of the call stack might even lead to <em>stack overflow</em>.</p>\n<p>To address the issue, one can tweak the solution a bit to make it <strong>tail recursion</strong>, which is a specific form of recursion where the recursive call is the last action in the function.</p>\n<p>The benefit of having tail recursion is that for certain programming languages (<em>e.g.</em> <code>Java</code>) the compiler could optimize the memory allocation of the call stack by reusing the same space for every recursive call, rather than creating the space for each one. As a result, one could obtain the constant space complexity O(1) for the overhead of the recursive calls.</p>\n<p>Here is a sample solution. Note that the optimization of tail recursion is not supported by Python or Java.</p>\n<pre><code>import java.util.LinkedList;\nimport java.util.Queue;\n\nclass Solution {\n\n    private static class Pair {\n        TreeNode node;\n        int level;\n        Pair(TreeNode n, int l) {\n            node = n;\n            level = l;\n        }\n    }\n\n    // The queue that contains the next nodes to visit,\n    // along with the level/depth that each node is located.\n    private Queue<Pair> nextItems = new LinkedList<>();\n    private int maxDepth = 0;\n\n    /**\n     * A tail recursion function to calculate the max depth\n     * of the binary tree.\n     */\n    private int nextMaxDepth() {\n\n        if (nextItems.isEmpty()) {\n            return maxDepth;\n        }\n\n        Pair nextItem = nextItems.poll();\n        TreeNode nextNode = nextItem.node;\n        int nextLevel = nextItem.level + 1;\n\n        maxDepth = Math.max(maxDepth, nextLevel);\n\n        // Add the nodes to visit in the following recursive calls.\n        if (nextNode.left != null) {\n            nextItems.offer(new Pair(nextNode.left, nextLevel));\n        }\n        if (nextNode.right != null) {\n            nextItems.offer(new Pair(nextNode.right, nextLevel));\n        }\n\n        // The last action should be the ONLY recursive call\n        // in the tail-recursion function.\n        return nextMaxDepth();\n    }\n\n    public int maxDepth(TreeNode root) {\n        if (root == null) return 0;\n\n        // Clear the previous queue.\n        nextItems.clear();\n        maxDepth = 0;\n\n        // Push the root node into the queue to kick off the next visit.\n        nextItems.offer(new Pair(root, 0));\n\n        return nextMaxDepth();\n    }\n}</code></pre>\n<p><strong>Complexity analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity: O(N), still we visit each node once and only once.</p>\n</li>\n<li>\n<p>Space complexity: O(2(log2​N−1))=O(N/2)=O(N), <em>i.e.</em> the maximum number of nodes at the same level (the number of leaf nodes in a full binary tree), since we traverse the tree in the <strong>BFS</strong> manner.</p>\n</li>\n</ul>\n<p>As one can see, this probably is not the best example to apply the <em>tail recursion</em> technique. Because though we did gain the constant space complexity for the recursive calls, we pay the price of O(N) complexity to maintain the state information for recursive calls. This defeats the purpose of applying tail recursion.</p>\n<p>However, we would like to stress the point that the tail recursion is a useful form of recursion that could eliminate the space overhead incurred by the recursive function calls.</p>\n<p><em>Note: a function cannot be tail recursion if there are multiple occurrences of recursive calls in the function, even if the last action is the recursive call.</em> Because the system has to maintain the function call stack for the sub-function calls that occur within the same function.<br/>\n<br/><br/>\n<br/></p>\n<hr/>\n<h3><a href=\"#approach-3-iteration\"><svg><path></path></svg></a>Approach 3: Iteration</h3>\n<p><strong>Intuition</strong></p>\n<p>We could also convert the above recursion into iteration, with the help of the <em>stack</em> data structure. Similar to the behaviors of the function call stack, the stack data structure follows the pattern of FILO (First-In-Last-Out), <em>i.e.</em> the last element that is added to a stack would come out first.</p>\n<p>With the help of the <em>stack</em> data structure, one could mimic the behaviors of the function call stack that is involved in the recursion, to convert a recursive function to a function with iteration.</p>\n<p><strong>Algorithm</strong></p>\n<blockquote>\n<p>The idea is to keep the next nodes to visit in a stack.<br/>\nDue to the FILO behavior of the stack, one would get the order of visits the same as the one in recursion.</p>\n</blockquote>\n<p>We start from a stack that contains the root node and the corresponding depth which is <code>1</code>. Then we proceed to the iterations: pop the current node out of the stack and push the child nodes. The depth is updated at each step.</p>\n<pre><code>import java.util.ArrayDeque;\nimport java.util.Deque;\n\nclass Solution {\n\n    private static class Pair {\n        int depth;\n        TreeNode node;\n        Pair(int d, TreeNode n) {\n            depth = d;\n            node = n;\n        }\n    }\n\n    public int maxDepth(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n\n        Deque<Pair> stack = new ArrayDeque<>();\n        stack.push(new Pair(1, root));\n        int maxDepth = 0;\n\n        while (!stack.isEmpty()) {\n            Pair current = stack.pop();\n            int cDepth = current.depth;\n            TreeNode cNode = current.node;\n            maxDepth = Math.max(maxDepth, cDepth);\n\n            if (cNode.left != null) {\n                stack.push(new Pair(cDepth + 1, cNode.left));\n            }\n            if (cNode.right != null) {\n                stack.push(new Pair(cDepth + 1, cNode.right));\n            }\n        }\n        return maxDepth;\n    }\n}</code></pre>\n<p><strong>Complexity analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity: O(N).</p>\n</li>\n<li>\n<p>Space complexity: in the worst case, the tree is completely unbalanced, <em>e.g.</em> each node has only the left child node, the recursion call would occur N times (the height of the tree), the storage to keep the call stack would be O(N). But in the average case (the tree is balanced), the height of the tree would be log(N). Therefore, the space complexity in this case would be O(log(N)).</p>\n</li>\n</ul>",
        "isOfficial": true,
        "scrapedAt": "2026-02-18T08:02:38.710Z"
    }
}