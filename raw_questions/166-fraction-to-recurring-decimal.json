{
    "questionId": "166",
    "questionFrontendId": "166",
    "title": "Fraction to Recurring Decimal",
    "titleSlug": "fraction-to-recurring-decimal",
    "content": "<p>Given two integers representing the <code>numerator</code> and <code>denominator</code> of a fraction, return <em>the fraction in string format</em>.</p>\n\n<p>If the fractional part is repeating, enclose the repeating part in parentheses</p>\n\n<p>If multiple answers are possible, return <strong>any of them</strong>.</p>\n\n<p>It is <strong>guaranteed</strong> that the length of the answer string is less than <code>10<sup>4</sup></code> for all the given inputs.</p>\n\n<p><strong>Note</strong> that if the fraction can be represented as a <em>finite length string</em>, you <strong>must</strong> return it.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> numerator = 1, denominator = 2\n<strong>Output:</strong> &quot;0.5&quot;\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> numerator = 2, denominator = 1\n<strong>Output:</strong> &quot;2&quot;\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> numerator = 4, denominator = 333\n<strong>Output:</strong> &quot;0.(012)&quot;\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>-2<sup>31</sup> &lt;=&nbsp;numerator, denominator &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li><code>denominator != 0</code></li>\n</ul>\n",
    "difficulty": "Medium",
    "stats": "{\"totalAccepted\": \"354.9K\", \"totalSubmission\": \"1.2M\", \"totalAcceptedRaw\": 354915, \"totalSubmissionRaw\": 1163222, \"acRate\": \"30.5%\"}",
    "hints": [
        "No scary math, just apply elementary math knowledge. Still remember how to perform a <i>long division</i>?",
        "Try a long division on 4/9, the repeating part is obvious. Now try 4/333. Do you see a pattern?",
        "Notice that once the remainder starts repeating, so does the divided result.",
        "Be wary of edge cases! List out as many test cases as you can think of and test your code thoroughly."
    ],
    "similarQuestions": "[]",
    "topicTags": [
        {
            "name": "Hash Table",
            "slug": "hash-table"
        },
        {
            "name": "Math",
            "slug": "math"
        },
        {
            "name": "String",
            "slug": "string"
        }
    ],
    "companyTags": null,
    "codeSnippets": [
        {
            "lang": "Java",
            "langSlug": "java",
            "code": "class Solution {\n    public String fractionToDecimal(int numerator, int denominator) {\n        \n    }\n}"
        }
    ],
    "solution": {
        "content": "<h2><a href=\"#summary\"><svg><path></path></svg></a>Summary</h2>\n<p>This is a straight forward coding problem but with a fair amount of details to get right.</p>\n<h2><a href=\"#hints\"><svg><path></path></svg></a>Hints</h2>\n<ol>\n<li>No scary math, just apply elementary math knowledge. Still remember how to perform a <i>long division</i>?</li>\n<li>Try a long division on 94\u200b, the repeating part is obvious. Now try 3334\u200b. Do you see a pattern?</li>\n<li>Be wary of edge cases! List out as many test cases as you can think of and test your code thoroughly.</li>\n</ol>\n<h2><a href=\"#solution\"><svg><path></path></svg></a>Solution</h2>\n<hr/>\n<h3><a href=\"#approach-long-division\"><svg><path></path></svg></a>Approach: Long Division</h3>\n<p><strong>Intuition</strong></p>\n<p>The key insight here is to notice that once the remainder starts repeating, so does the divided result.</p>\n<p>0.166)1.000.00\u200b1.00060\u200b040036\u200b00400\u200b\u200b\u21d0remainder\u00a0=\u00a01,\u00a0mark\u00a01\u00a0as\u00a0seen\u00a0at\u00a0position\u00a0=\u00a00.\u21d0remainder\u00a0=\u00a04,\u00a0mark\u00a04\u00a0as\u00a0seen\u00a0at\u00a0position\u00a0=\u00a01.\u21d0remainder\u00a0=\u00a04\u00a0was\u00a0seen\u00a0before\u00a0at\u00a0position\u00a0=\u00a01,so\u00a0the\u00a0fractional\u00a0part\u00a0starts\u00a0repeating\u00a0at\u00a0position\u00a0=\u00a01\u21d21(6).\u200b</p>\n<br/>\n<p><strong>Algorithm</strong></p>\n<p>You will need a hash table that maps from the remainder to its position of the fractional part. Once you found a repeating remainder, you may enclose the reoccurring fractional part with parentheses by consulting the position from the table.</p>\n<p>The remainder could be zero while doing the division. That means there is no repeating fractional part and you should stop right away.</p>\n<p>Just like the question <a href=\"https://leetcode.com/problems/divide-two-integers/\">Divide Two Integers</a>, be wary of edge cases such as negative fractions and nasty extreme case such as \u22121\u22122147483648\u200b.</p>\n<p>Here are some good test cases:</p>\n<table><thead><tr><th>Test case</th><th>Explanation</th></tr></thead><tbody><tr><td>10\u200b</td><td>Numerator is zero.</td></tr><tr><td>01\u200b</td><td>Divisor is 0, should handle it by throwing an exception but here we ignore for simplicity sake.</td></tr><tr><td>420\u200b</td><td>Answer is a whole integer, should not contain the fractional part.</td></tr><tr><td>21\u200b</td><td>Answer is 0.5, no recurring decimal.</td></tr><tr><td>4\u22121\u200b or \u221241\u200b</td><td>One of the numerator or denominator is negative, fraction is negative.</td></tr><tr><td>\u22124\u22121\u200b</td><td>Both numerator and denominator are negative, should result in positive fraction.</td></tr><tr><td>\u22121\u22122147483648\u200b</td><td>Beware of overflow if you cast to positive.</td></tr></tbody></table>\n<br/>\n<pre><code>class Solution {\n    public String fractionToDecimal(int numerator, int denominator) {\n        if (numerator == 0) {\n            return \"0\";\n        }\n        StringBuilder fraction = new StringBuilder();\n        // If either one is negative (not both)\n        if ((numerator < 0) ^ (denominator < 0)) {\n            fraction.append(\"-\");\n        }\n        // Convert to long to prevent overflow\n        long dividend = Math.abs((long) numerator);\n        long divisor = Math.abs((long) denominator);\n        fraction.append(dividend / divisor);\n        long remainder = dividend % divisor;\n        if (remainder == 0) {\n            return fraction.toString();\n        }\n        fraction.append(\".\");\n        java.util.Map<Long, Integer> map = new java.util.HashMap<>();\n        while (remainder != 0) {\n            if (map.containsKey(remainder)) {\n                fraction.insert(map.get(remainder), \"(\");\n                fraction.append(\")\");\n                break;\n            }\n            map.put(remainder, fraction.length());\n            remainder *= 10;\n            fraction.append(remainder / divisor);\n            remainder %= divisor;\n        }\n        return fraction.toString();\n    }\n}</code></pre>\n<h4>Complexity Analysis</h4>\n<p>Let n be the number of digits in the repeating decimal representation of the fraction formed by <code>numerator / denominator</code>.</p>\n<ul>\n<li>\n<p>Time complexity: O(n)</p>\n<p>We perform integer division and remainder operations iteratively until the remainder becomes <code>0</code> or a repeating pattern is detected.</p>\n<p>Each unique remainder can appear at most once before a repetition occurs because once a remainder repeats, the decimal starts looping.</p>\n<p>Therefore, we process at most <code>n</code> distinct remainders, and each iteration involves constant-time operations like division, modulus, lookup, and insertion in the hash map (<code>HashMap</code>). Hence, the total time complexity is O(n).</p>\n</li>\n<li>\n<p>Space complexity: O(n)</p>\n<p>The hash map <code>map</code> stores each distinct remainder and its corresponding index in the result string. In the worst case, every remainder before repetition is unique, so we may store up to <code>n</code> entries. Additionally, the <code>fraction</code> string stores up to <code>n</code> digits for the decimal part. Therefore, the total space complexity is O(n).</p>\n</li>\n</ul>\n<hr/>",
        "isOfficial": true,
        "scrapedAt": "2026-02-18T08:43:13.582Z"
    }
}