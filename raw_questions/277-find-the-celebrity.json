{
    "questionId": "277",
    "questionFrontendId": "277",
    "title": "Find the Celebrity",
    "titleSlug": "find-the-celebrity",
    "content": "<p>Suppose you are at a party with <code>n</code> people labeled from <code>0</code> to <code>n - 1</code> and among them, there may exist one celebrity. The definition of a celebrity is that all the other <code>n - 1</code> people know the celebrity, but the celebrity does not know any of them.</p>\n\n<p>Now you want to find out who the celebrity is or verify that there is not one. You are only allowed to ask questions like: &quot;Hi, A. Do you know B?&quot; to get information about whether A knows B. You need to find out the celebrity (or verify there is not one) by asking as few questions as possible (in the asymptotic sense).</p>\n\n<p>You are given an integer <code>n</code> and a helper function <code>bool knows(a, b)</code> that tells you whether <code>a</code> knows <code>b</code>. Implement a function <code>int findCelebrity(n)</code>. There will be exactly one celebrity if they are at the party.</p>\n\n<p>Return <em>the celebrity&#39;s label if there is a celebrity at the party</em>. If there is no celebrity, return <code>-1</code>.</p>\n\n<p><strong>Note</strong> that the <code>n x n</code> 2D array <code>graph</code> given as input is <strong>not</strong> directly available to you, and instead <strong>only</strong> accessible through the helper function <code>knows</code>. <code>graph[i][j] == 1</code> represents person <code>i</code> knows person <code>j</code>, wherease <code>graph[i][j] == 0</code> represents person <code>j</code> does not know person <code>i</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"images/277/g1.jpg\" style=\"width: 224px; height: 145px;\" />\n<pre>\n<strong>Input:</strong> graph = [[1,1,0],[0,1,0],[1,1,1]]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> There are three persons labeled with 0, 1 and 2. graph[i][j] = 1 means person i knows person j, otherwise graph[i][j] = 0 means person i does not know person j. The celebrity is the person labeled as 1 because both 0 and 2 know him but 1 does not know anybody.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"images/277/g2.jpg\" style=\"width: 224px; height: 145px;\" />\n<pre>\n<strong>Input:</strong> graph = [[1,0,1],[1,1,0],[0,1,1]]\n<strong>Output:</strong> -1\n<strong>Explanation:</strong> There is no celebrity.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == graph.length == graph[i].length</code></li>\n\t<li><code>2 &lt;= n &lt;= 100</code></li>\n\t<li><code>graph[i][j]</code> is <code>0</code> or <code>1</code>.</li>\n\t<li><code>graph[i][i] == 1</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> If the maximum number of allowed calls to the API <code>knows</code> is <code>3 * n</code>, could you find a solution without exceeding the maximum number of calls?</p>\n",
    "difficulty": "Medium",
    "stats": "{\"totalAccepted\": \"321.3K\", \"totalSubmission\": \"657.5K\", \"totalAcceptedRaw\": 321289, \"totalSubmissionRaw\": 657454, \"acRate\": \"48.9%\"}",
    "hints": [
        "The best hint for this problem can be provided by the following figure:\r\n\r\n<br>\r\n<img src=\"https://assets.leetcode.com/uploads/2019/10/20/hint_find_celebrity.png\" width=\"700\"/>",
        "Well, if you understood the gist of the above idea, you can extend it to find a candidate that can possibly be a celebrity. Why do we say a \"candidate\"? That is for you to think. This is clearly a greedy approach to find the answer. However, there is some information that would still remain to be verified without which we can't obtain an answer with certainty. To get that stake in the ground, we would need some more calls to the knows API."
    ],
    "similarQuestions": "[{\"title\": \"Find the Town Judge\", \"titleSlug\": \"find-the-town-judge\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
    "topicTags": [
        {
            "name": "Two Pointers",
            "slug": "two-pointers"
        },
        {
            "name": "Graph Theory",
            "slug": "graph"
        },
        {
            "name": "Interactive",
            "slug": "interactive"
        }
    ],
    "companyTags": null,
    "codeSnippets": [
        {
            "lang": "C++",
            "langSlug": "cpp",
            "code": "/* The knows API is defined for you.\n      bool knows(int a, int b); */\n\nclass Solution {\npublic:\n    int findCelebrity(int n) {\n        \n    }\n};"
        },
        {
            "lang": "Java",
            "langSlug": "java",
            "code": "/* The knows API is defined in the parent class Relation.\n      boolean knows(int a, int b); */\n\npublic class Solution extends Relation {\n    public int findCelebrity(int n) {\n        \n    }\n}"
        },
        {
            "lang": "Python3",
            "langSlug": "python3",
            "code": "# The knows API is already defined for you.\n# return a bool, whether a knows b\n# def knows(a: int, b: int) -> bool:\n\nclass Solution:\n    def findCelebrity(self, n: int) -> int:\n        "
        },
        {
            "lang": "Python",
            "langSlug": "python",
            "code": "# The knows API is already defined for you.\n# @param a, person a\n# @param b, person b\n# @return a boolean, whether a knows b\n# def knows(a, b):\n\nclass Solution(object):\n    def findCelebrity(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        "
        },
        {
            "lang": "JavaScript",
            "langSlug": "javascript",
            "code": "/**\n * Definition for knows()\n * \n * @param {integer} person a\n * @param {integer} person b\n * @return {boolean} whether a knows b\n * knows = function(a, b) {\n *     ...\n * };\n */\n\n/**\n * @param {function} knows()\n * @return {function}\n */\nvar solution = function(knows) {\n    /**\n     * @param {integer} n Total people\n     * @return {integer} The celebrity\n     */\n    return function(n) {\n        \n    };\n};"
        },
        {
            "lang": "TypeScript",
            "langSlug": "typescript",
            "code": "/**\n * The knows API is defined in the parent class Relation.\n * knows(a: number, b: number): boolean {\n *     ...\n * };\n */\n\nvar solution = function(knows: any) {\n\n    return function(n: number): number {\n        \n    };\n};"
        },
        {
            "lang": "C#",
            "langSlug": "csharp",
            "code": "/* The Knows API is defined in the parent class Relation.\n      bool Knows(int a, int b); */\n\npublic class Solution : Relation {\n    public int FindCelebrity(int n) {\n        \n    }\n}"
        },
        {
            "lang": "C",
            "langSlug": "c",
            "code": "/* The knows API is defined for you.\n      bool knows(int a, int b); */\n\nint findCelebrity(int n) {\n    \n}"
        },
        {
            "lang": "Go",
            "langSlug": "golang",
            "code": "/**\n * The knows API is already defined for you.\n *     knows := func(a int, b int) bool\n */\nfunc solution(knows func(a int, b int) bool) func(n int) int {\n    return func(n int) int {\n        \n    }\n}"
        },
        {
            "lang": "Kotlin",
            "langSlug": "kotlin",
            "code": "/* The knows API is defined in the parent class Relation.\n      fun knows(a: Int, b: Int) : Boolean {} */\n\nclass Solution: Relation() {\n    override fun findCelebrity(n: Int) : Int {\n        \n\t}\n}"
        },
        {
            "lang": "Swift",
            "langSlug": "swift",
            "code": "/**\n * The knows API is defined in the parent class Relation.\n *     func knows(_ a: Int, _ b: Int) -> Bool;\n */\n\nclass Solution : Relation {\n    func findCelebrity(_ n: Int) -> Int {\n        \n    }\n}"
        },
        {
            "lang": "Rust",
            "langSlug": "rust",
            "code": "/* The knows API is defined for you.\n       knows(a: i32, b: i32)->bool;\n    to call it use self.knows(a,b)\n*/\n\nimpl Solution {\n    pub fn find_celebrity(&self, n: i32) -> i32 {\n \n    }\n}"
        },
        {
            "lang": "Ruby",
            "langSlug": "ruby",
            "code": "# The knows API is already defined for you.\n# @param {Integer} person a\n# @param {Integer} person b\n# @return {Boolean} whether a knows b\n# def knows(a, b)\n\n# @param {Integer} n\n# @return {Integer}\ndef find_celebrity(n)\n    \nend"
        },
        {
            "lang": "PHP",
            "langSlug": "php",
            "code": "/* The knows API is defined in the parent class Relation.\n      public function knows($a, $b){} */\n\nclass Solution extends Relation {\n    /**\n     * @param Integer $n\n     * @return Integer\n     */\n    function findCelebrity($n) {\n        \n    }\n}"
        },
        {
            "lang": "Scala",
            "langSlug": "scala",
            "code": "/* The knows API is defined in the parent class Relation.\n      def knows(a: Int, b: Int): Boolean = {} */\n\nclass Solution extends Relation {\n    def findCelebrity(n: Int): Int = {\n        \n    }\n}"
        }
    ],
    "solution": {
        "content": "<h2><a href=\"#solution-article\"><svg><path></path></svg></a>Solution Article</h2>\n<hr/>\n<h3><a href=\"#approach-1-brute-force\"><svg><path></path></svg></a>Approach 1: Brute Force</h3>\n<p><strong>Intuition</strong></p>\n<p>As per the problem statement, for a given person <code>i</code>, we can check whether or not <code>i</code> is a celebrity by using the <code>knows(...)</code> API to see if everybody knows <code>i</code>, and that <code>i</code> know nobody.</p>\n<p>Therefore, the simplest way of solving this problem is to go through each of the people in turn, and check whether or not they are a celebrity.</p>\n<p><strong>Algorithm</strong></p>\n<p>It's best to define a separate <code>isCelebrity(...)</code> function that takes the id number of a specific person and returns <code>true</code> if they are a celebrity and <code>false</code> if not. This avoids the need for complex loop-break conditions, thus keeping the code cleaner.</p>\n<p>One edge case we need to be cautious of is not asking person <code>i</code> if they know themselves. This can be handled by a check for <code>i == j</code> at the start of the main loop of <code>isCelebrity(...)</code> and then simply <code>continue</code>-ing when it is <code>true</code>.</p>\n<pre><code>public class Solution extends Relation {\n    \n    private int numberOfPeople;\n    \n    public int findCelebrity(int n) {\n        numberOfPeople = n;\n        for (int i = 0; i &lt; n; i++) {\n            if (isCelebrity(i)) {\n                return i;\n            }\n        }\n        return -1;\n    }\n    \n    private boolean isCelebrity(int i) {\n        for (int j = 0; j &lt; numberOfPeople; j++) {\n            if (i == j) continue; // Don't ask if they know themselves.\n            if (knows(i, j) || !knows(j, i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<p>We don't know what time and space the <code>knows(...)</code> API uses. Because it's not our concern, we'll assume it's O(1) for the purpose of analysing our algorithm.</p>\n<ul>\n<li>\n<p>Time Complexity : O(n2).</p>\n<p>For each of the n people, we need to check whether or not they are a celebrity.</p>\n<p>Checking whether or not somebody is a celebrity requires making 2 API calls for each of the n−1 other people, for a total of 2⋅(n−1)=2⋅n−2 calls. In big-oh notation, we drop the constants, leaving O(n).</p>\n<p>So each of the n celebrity checks will cost O(n), giving a total of O(n2).</p>\n</li>\n<li>\n<p>Space Complexity : O(1).</p>\n<p>Our code only uses constant extra space. The results of the API calls are not saved.</p>\n</li>\n</ul>\n<br/>\n<hr/>\n<h3><a href=\"#approach-2-logical-deduction\"><svg><path></path></svg></a>Approach 2: Logical Deduction</h3>\n<p><strong>Intuition</strong></p>\n<p>We can do far better than the above approach. Let's start by looking at another way of representing the problem, which is a great way for approaching it in an interview. What we actually have in this problem is a <strong>graph</strong>, where a <em>directed edge</em> going from person <code>A</code> to person <code>B</code> means that we have confirmed that <code>A knows B</code>.</p>\n<p>For example, here is a possible graph. Assume that we have made all possible calls to the <code>knows(...)</code> API to find these edges. Is there a celebrity here? If so, who is it?</p>\n<p></p>\n<p>What about in this graph?</p>\n<p></p>\n<p>And this one?</p>\n<p></p>\n<p>On the graph representation, a celebrity is a person who has <em>exactly</em> <code>n - 1</code> directed edges going in (everybody knows them) and <code>0</code> edges going out (they know nobody).</p>\n<p>On the first example we looked at above, person <code>4</code> is a celebrity because they have <code>5</code> directed edges going in, which is <code>n - 1</code>. They have no directed edges going out. Note that <code>3</code> <em>is not a celebrity</em> because they have <code>5</code> <em>outgoing</em> edges, not <code>5</code> ingoing.</p>\n<p>On the second example, there is no celebrity. Person <code>4</code> is not a celebrity, because person <code>2</code> doesn't know them. There are only <code>n - 2</code> directed edges going into <code>4</code>.</p>\n<p>On the third example, there is also no celebrity. Person <code>0</code> is not a celebrity, because they know person <code>5</code>, as represented by the directed edge going from <code>0</code> to <code>5</code>.</p>\n<p>At the start, we only know the <em>nodes</em> of the graph. The <em>edges</em> are all hidden. We can \"uncover\" <em>edges</em> by making calls to the <code>knows(...)</code> API. In the first approach, we uncovered <em>all</em> the edges this way. So, the question we need to ask now is... was it actually necessary to uncover <em>all</em> of them? A good way to answer this question in an interview is to work through an example on the whiteboard, where you decide which edges you want to ask for, and then draw them as you go.</p>\n<p>When you do your own example, you'll of course need to know what the full graph behind your example is, or at least the important aspects of it, but you also need to focus on what information you've \"uncovered\" by using the <code>knows(...)</code> API.</p>\n<p>Here is an animation of an example. To distinguish between <code>not (A knows B)</code> and we-haven't-yet-asked if <code>A knows B</code>, we use a green solid arrow to show <code>A knows B</code>, a red dotted arrow to show <code>not (A knows B)</code> and no arrow if we haven't yet asked.</p>\n<p></p>\n<p>During the example in the animation, we asked if <code>4</code> knows <code>6</code>. Why was this question not necessary to identify the celebrity?</p>\n<p></p>\n<p>Well, because we already know that both <code>4</code> and <code>6</code> know at least one other person, this means that neither of them could be the celebrity! Therefore, we've already ruled them out, there was no need to investigate them further.</p>\n<p>So, what can we conclude from the result of an <code>A knows B</code> check? If the result was <code>true</code>, could <code>A</code> be the celebrity? What about <code>B</code>?</p>\n<p></p>\n<p>And what about if <code>A knows B</code> returned <code>false</code>? Who couldn't be a celebrity now?</p>\n<p></p>\n<p>In the first example, we know that <code>A</code> can't be a celebrity, because <code>A</code> knows somebody, namely <code>B</code>. In the second example, we know that <code>B</code> can't be a celebrity, because <code>A</code>, doesn't know him/her.</p>\n<blockquote>\n<p>Therefore, with each call to <code>knows(...)</code>, we can conclusively determine that exactly <strong>1</strong> of the people is not a celebrity!</p>\n</blockquote>\n<p>The following algorithm can, therefore, be used to rule out <code>n - 1</code> of the people in O(n) time. We start by guessing that <code>0</code> might be a <code>celebrityCandidate</code>, and then we check if <code>0 knows 1</code> (within the loop). If <code>true</code>, then we know <code>0</code> isn't a celebrity (they know somebody), but <code>1</code> might be. We update the <code>celebrityCandidate</code> variable to <code>1</code> to reflect this. Otherwise, we know <code>1</code> is not a celebrity (somebody doesn't know them), but we haven't ruled out <code>0</code>, yet, so keep them as the <code>celebrityCandidate</code>. Whoever we kept is then asked if they know <code>2</code>, and so forth.</p>\n<svg><path></path></svg>\n<p>At the end, the only person we haven't ruled out is in the <code>celebrityCandidate</code> variable.</p>\n<p>Here is an animation of the algorithm.</p>\n<p></p>\n<p>At the end of the example in the animation, this is how our graph looked. The person who we haven't ruled out is <code>4</code>.</p>\n<p></p>\n<p>But do we actually know for <em>sure</em> that this person is a celebrity? (Remember, it's possible there's no celebrity, in which case we'd return <code>-1</code>).</p>\n<p>Nope! It's still possible that <code>0</code> doesn't know <code>4</code>, or perhaps <code>4</code> knows <code>3</code>. We can't rule these possibilities out from the information we have uncovered so far.</p>\n<p>So, what can we do? We can use our <code>isCelebrity(...)</code> function on <code>4</code> to check whether or not they are a celebrity. If they are, our function will return <code>4</code>. If not, then it should return <code>-1</code>.</p>\n<p><strong>Algorithm</strong></p>\n<p>Our algorithm firstly narrows the people down to a single <code>celebrityCandidate</code> using the algorithm just above, and then it checks whether or not that candidate is a celebrity using the <code>isCelebrity(...)</code>.</p>\n<pre><code>public class Solution extends Relation {\n    \n    private int numberOfPeople;\n    \n    public int findCelebrity(int n) {\n        numberOfPeople = n;\n        int celebrityCandidate = 0;\n        for (int i = 0; i &lt; n; i++) {\n            if (knows(celebrityCandidate, i)) {\n                celebrityCandidate = i;\n            }\n        }\n        if (isCelebrity(celebrityCandidate)) {\n            return celebrityCandidate;\n        }\n        return -1;\n    }\n    \n    private boolean isCelebrity(int i) {\n        for (int j = 0; j &lt; numberOfPeople; j++) {\n            if (i == j) continue; // Don't ask if they know themselves.\n            if (knows(i, j) || !knows(j, i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity : O(n).</p>\n<p>Our code is split into 2 parts.</p>\n<p>The first part finds a celebrity candidate. This requires doing n−1 calls to <code>knows(...)</code> API, and so is O(n).</p>\n<p>The second part is the same as before—checking whether or not a given person is a celebrity. We determined that this is O(n).</p>\n<p>Therefore, we have a total time complexity of O(n+n)=O(n).</p>\n</li>\n<li>\n<p>Space Complexity : O(1).</p>\n<p>Same as above. We are only using constant extra space.</p>\n</li>\n</ul>\n<br/>\n<hr/>\n<h3><a href=\"#approach-3-logical-deduction-with-caching\"><svg><path></path></svg></a>Approach 3: Logical Deduction with Caching</h3>\n<p><strong>Intuition</strong></p>\n<p><em>You probably won't need to implement this approach in an interview, however, I wouldn't be surprised if discussing these ideas was a follow up question. For that reason, we'll take a quick look at it!</em></p>\n<p>Have a look at our example from above again. These are the calls to the <code>knows(...)</code> API that were made to identify that <code>4</code> is a celebrity candidate.</p>\n<p></p>\n<p>Now, these are the calls that our Approach 2 would have made in the second phase to check whether or not our celebrity candidate, <code>4</code>, actually is a celebrity.</p>\n<p></p>\n<p>As shown in the above images, we made some of the same calls twice! The lower the number of the celebrity candidate, the more of these duplicated calls there will be, because the celebrity candidate spent longer in the <code>celebrityCandidate</code> variable, and so was involved in a lot more of the initial \"questioning\". Is this actually wasteful though?</p>\n<p>We know that the best possible time complexity we could ever achieve in the average/ worst case is O(n). The easiest way of proving this to point out that confirming that somebody <em>is</em> a celebrity requires O(n) checks. There's simply no way around it, if you miss just one of those checks, it could have been the one that showed they were <em>not</em>.</p>\n<p>So, because we can never do better than O(n) anyway, surely it really doesn't matter?</p>\n<p>Yes and no! It's possible that calls to the <code>knows(...)</code> API could be <em>really expensive</em> (i.e. slow). For example, in the scenario presented in the question, you need to ask the question to people and then listen for their answer. This is time consuming! As a computer-based example, what if the <code>knows(...)</code> API was retrieving its answers from a really slow web service on the other side of the world? What if somebody was having to sit in front of their computer, waiting patiently for this algorithm to finish running? They would definitely appreciate it taking 5 seconds instead of 10 seconds, even if that difference is constant.</p>\n<p>The cost of this, however, is space. We will now need to store the results of <code>n - 1</code> calls the the <code>knows(...)</code> API.</p>\n<p>This is similar to how web browsers cache data. Often, the cost of retrieving a page again is considered to more expensive than the cost of caching a page.</p>\n<p><strong>Algorithm</strong></p>\n<p>For Java and JavaScript, we'll store our cache in a <code>HashMap</code>. For Python, we'll use <code>lru_cache</code> in the <code>functools</code> library. Other than that, the code is the same as</p>\n<pre><code>public class Solution extends Relation {\n    \n    private int numberOfPeople;\n    private Map&lt;Pair&lt;Integer, Integer&gt;, Boolean&gt; cache = new HashMap&lt;&gt;(); \n    \n    @Override\n    public boolean knows(int a, int b) {\n        if (!cache.containsKey(new Pair(a, b))) {\n            cache.put(new Pair(a, b), super.knows(a, b));\n        }\n        return cache.get(new Pair(a, b));\n    }\n    \n    public int findCelebrity(int n) {\n        numberOfPeople = n;\n        int celebrityCandidate = 0;\n        for (int i = 0; i &lt; n; i++) {\n            if (knows(celebrityCandidate, i)) {\n                celebrityCandidate = i;\n            }\n        }\n        if (isCelebrity(celebrityCandidate)) {\n            return celebrityCandidate;\n        }\n        return -1;\n    }\n    \n    private boolean isCelebrity(int i) {\n        for (int j = 0; j &lt; numberOfPeople; j++) {\n            if (i == j) continue; // Don't ask if they know themselves.\n            if (knows(i, j) || !knows(j, i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity : O(n).</p>\n<p>The time complexity is still O(n). The only difference is that sometimes we're retrieving data from a cache inside our code instead of from the API.</p>\n</li>\n<li>\n<p>Space Complexity : O(n).</p>\n<p>We're storing the results of the n−1 calls to the <code>know(...)</code> API we made while finding a candidate.</p>\n<p>We could optimize the space complexity slightly, by dumping the cached contents each time the <code>celebrityCandidate</code> variable changes, which would be O(1) in the best case (which happens to be the worst case for reducing number of API calls) but it's still O(n) space in the worst case and probably not worth the extra code complexity as the algorithm still ultimately requires the memory/ disk space needed for the worst case.</p>\n</li>\n</ul>\n<br/>",
        "isOfficial": true,
        "scrapedAt": "2026-02-18T08:50:38.058Z"
    }
}