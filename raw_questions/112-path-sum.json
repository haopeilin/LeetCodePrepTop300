{
    "questionId": "112",
    "questionFrontendId": "112",
    "title": "Path Sum",
    "titleSlug": "path-sum",
    "content": "<p>Given the <code>root</code> of a binary tree and an integer <code>targetSum</code>, return <code>true</code> if the tree has a <strong>root-to-leaf</strong> path such that adding up all the values along the path equals <code>targetSum</code>.</p>\n\n<p>A <strong>leaf</strong> is a node with no children.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"images/112/pathsum1.jpg\" style=\"width: 500px; height: 356px;\" />\n<pre>\n<strong>Input:</strong> root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22\n<strong>Output:</strong> true\n<strong>Explanation:</strong> The root-to-leaf path with the target sum is shown.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"images/112/pathsum2.jpg\" />\n<pre>\n<strong>Input:</strong> root = [1,2,3], targetSum = 5\n<strong>Output:</strong> false\n<strong>Explanation:</strong> There are two root-to-leaf paths in the tree:\n(1 --&gt; 2): The sum is 3.\n(1 --&gt; 3): The sum is 4.\nThere is no root-to-leaf path with sum = 5.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [], targetSum = 0\n<strong>Output:</strong> false\n<strong>Explanation:</strong> Since the tree is empty, there are no root-to-leaf paths.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 5000]</code>.</li>\n\t<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n\t<li><code>-1000 &lt;= targetSum &lt;= 1000</code></li>\n</ul>\n",
    "difficulty": "Easy",
    "stats": "{\"totalAccepted\": \"2.1M\", \"totalSubmission\": \"3.8M\", \"totalAcceptedRaw\": 2066188, \"totalSubmissionRaw\": 3799964, \"acRate\": \"54.4%\"}",
    "hints": [],
    "similarQuestions": "[{\"title\": \"Path Sum II\", \"titleSlug\": \"path-sum-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Binary Tree Maximum Path Sum\", \"titleSlug\": \"binary-tree-maximum-path-sum\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Sum Root to Leaf Numbers\", \"titleSlug\": \"sum-root-to-leaf-numbers\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Path Sum III\", \"titleSlug\": \"path-sum-iii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Path Sum IV\", \"titleSlug\": \"path-sum-iv\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
    "topicTags": [
        {
            "name": "Tree",
            "slug": "tree"
        },
        {
            "name": "Depth-First Search",
            "slug": "depth-first-search"
        },
        {
            "name": "Breadth-First Search",
            "slug": "breadth-first-search"
        },
        {
            "name": "Binary Tree",
            "slug": "binary-tree"
        }
    ],
    "companyTags": null,
    "codeSnippets": [
        {
            "lang": "Java",
            "langSlug": "java",
            "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public boolean hasPathSum(TreeNode root, int targetSum) {\n        \n    }\n}"
        }
    ],
    "solution": {
        "content": "<h2><a href=\"#solution\"><svg><path></path></svg></a>Solution</h2>\n<hr/>\n<h3><a href=\"#binary-tree-definition\"><svg><path></path></svg></a>Binary tree definition</h3>\n<p>First of all, here is the definition of the <code>TreeNode</code> which we would use in the following implementation.</p>\n<pre><code>/* Definition for a binary tree node. */\npublic class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n​\n    TreeNode(int x) {\n        val = x;\n    }\n}</code></pre>\n<br/>\n<br/>\n<hr/>\n<h3><a href=\"#approach-1-recursion\"><svg><path></path></svg></a>Approach 1: Recursion</h3>\n<p>The most intuitive way is to use recursion here. One is going through the tree by considering at each step the node itself and its children. If node <em>is not</em> a leaf, one calls recursively <code>hasPathSum</code> method for its children with a sum decreased by the current node value. If node <em>is</em> a leaf, one check if the current sum is zero, <em>i.e.</em> if the initial sum was discovered.</p>\n<pre><code>class Solution {\npublic:\n    bool hasPathSum(TreeNode* root, int sum) {\n        if (!root) return false;\n        sum -= root-&gt;val;\n        if (!root-&gt;left &amp;&amp; !root-&gt;right)  // if reach a leaf\n            return sum == 0;\n        return hasPathSum(root-&gt;left, sum) || hasPathSum(root-&gt;right, sum);\n    }\n};</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time complexity : we visit each node exactly once, thus the time complexity is O(N), where N is the number of nodes.</li>\n<li>Space complexity : in the worst case, the tree is completely unbalanced, <em>e.g.</em> each node has only one child node, the recursion call would occur N times (the height of the tree), therefore the storage to keep the call stack would be O(N). But in the best case (the tree is completely balanced), the height of the tree would be log(N). Therefore, the space complexity in this case would be O(log(N)).\n<br/>\n</li>\n</ul>\n<br/>\n<hr/>\n<h3><a href=\"#approach-2-iterations\"><svg><path></path></svg></a>Approach 2: Iterations</h3>\n<p><strong>Algorithm</strong></p>\n<p>We could also convert the above recursion into iteration, with the help of stack. DFS would be better than BFS here since it works faster except in the worst case. In the worst case the path <code>root-&gt;leaf</code> with the given sum is the last considered one and in this case, DFS results in the same productivity as BFS.</p>\n<blockquote>\n<p>The idea is to visit each node with the DFS strategy while updating the remaining sum to cumulate at each visit.</p>\n</blockquote>\n<p>So we start from a stack that contains the root node and the corresponding remaining sum which is <code>sum - root.val</code>. Then we proceed to the iterations: pop the current node out of the stack and return <code>True</code> if the remaining sum is <code>0</code> and we're on the leaf node. If the remaining sum is not zero or we're not on the leaf yet then we push the child nodes and corresponding remaining sums into the stack.</p>\n<p></p>\n<pre><code>class Solution {\npublic:\n    bool hasPathSum(TreeNode* root, int sum) {\n        if (root == NULL) return false;\n        std::stack&lt;TreeNode*&gt; node_stack;\n        std::stack&lt;int&gt; sum_stack;\n        node_stack.push(root);\n        sum_stack.push(sum - root-&gt;val);\n        TreeNode* node;\n        int curr_sum;\n        while (!node_stack.empty()) {\n            node = node_stack.top();\n            node_stack.pop();\n            curr_sum = sum_stack.top();\n            sum_stack.pop();\n            if ((node-&gt;right == NULL) &amp;&amp; (node-&gt;left == NULL) &amp;&amp;\n                (curr_sum == 0))\n                return true;\n            if (node-&gt;right != NULL) {\n                node_stack.push(node-&gt;right);\n                sum_stack.push(curr_sum - node-&gt;right-&gt;val);\n            }\n            if (node-&gt;left != NULL) {\n                node_stack.push(node-&gt;left);\n                sum_stack.push(curr_sum - node-&gt;left-&gt;val);\n            }\n        }\n        return false;\n    }\n};</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time complexity: the same as the recursion approach O(N).</li>\n<li>Space complexity: O(N) since in the worst case, when the tree is completely unbalanced, <em>e.g.</em> each node has only one child node, we would keep all N nodes in the stack. But in the best case (the tree is balanced), the height of the tree would be log(N). Therefore, the space complexity in this case would be O(log(N)).</li>\n</ul>",
        "isOfficial": true,
        "scrapedAt": "2026-02-18T08:07:34.543Z"
    }
}