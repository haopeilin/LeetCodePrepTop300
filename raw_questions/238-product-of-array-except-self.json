{
  "questionId": "238",
  "questionFrontendId": "238",
  "title": "Product of Array Except Self",
  "titleSlug": "product-of-array-except-self",
  "content": "<p>Given an integer array <code>nums</code>, return <em>an array</em> <code>answer</code> <em>such that</em> <code>answer[i]</code> <em>is equal to the product of all the elements of</em> <code>nums</code> <em>except</em> <code>nums[i]</code>.</p>\n\n<p>The product of any prefix or suffix of <code>nums</code> is <strong>guaranteed</strong> to fit in a <strong>32-bit</strong> integer.</p>\n\n<p>You must write an algorithm that runs in&nbsp;<code>O(n)</code>&nbsp;time and without using the division operation.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> nums = [1,2,3,4]\n<strong>Output:</strong> [24,12,8,6]\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> nums = [-1,1,0,-3,3]\n<strong>Output:</strong> [0,0,9,0,0]\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-30 &lt;= nums[i] &lt;= 30</code></li>\n\t<li>The input is generated such that <code>answer[i]</code> is <strong>guaranteed</strong> to fit in a <strong>32-bit</strong> integer.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong>&nbsp;Can you solve the problem in <code>O(1)</code>&nbsp;extra&nbsp;space complexity? (The output array <strong>does not</strong> count as extra space for space complexity analysis.)</p>\n",
  "difficulty": "Medium",
  "stats": "{\"totalAccepted\": \"4.3M\", \"totalSubmission\": \"6.3M\", \"totalAcceptedRaw\": 4328454, \"totalSubmissionRaw\": 6312922, \"acRate\": \"68.6%\"}",
  "hints": [
    "Think how you can efficiently utilize prefix and suffix products to calculate the product of all elements except self for each index. Can you pre-compute the prefix and suffix products in linear time to avoid redundant calculations?",
    "Can you minimize additional space usage by reusing memory or modifying the input array to store intermediate results?"
  ],
  "similarQuestions": "[{\"title\": \"Trapping Rain Water\", \"titleSlug\": \"trapping-rain-water\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Maximum Product Subarray\", \"titleSlug\": \"maximum-product-subarray\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Paint House II\", \"titleSlug\": \"paint-house-ii\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Minimum Difference in Sums After Removal of Elements\", \"titleSlug\": \"minimum-difference-in-sums-after-removal-of-elements\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Construct Product Matrix\", \"titleSlug\": \"construct-product-matrix\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Find Sum of Array Product of Magical Sequences\", \"titleSlug\": \"find-sum-of-array-product-of-magical-sequences\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
  "topicTags": [
    {
      "name": "Array",
      "slug": "array"
    },
    {
      "name": "Prefix Sum",
      "slug": "prefix-sum"
    }
  ],
  "companyTags": null,
  "codeSnippets": [
    {
      "lang": "C++",
      "langSlug": "cpp",
      "code": "class Solution {\npublic:\n    vector<int> productExceptSelf(vector<int>& nums) {\n        \n    }\n};"
    },
    {
      "lang": "Java",
      "langSlug": "java",
      "code": "class Solution {\n    public int[] productExceptSelf(int[] nums) {\n        \n    }\n}"
    },
    {
      "lang": "Python3",
      "langSlug": "python3",
      "code": "class Solution:\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        "
    },
    {
      "lang": "Python",
      "langSlug": "python",
      "code": "class Solution(object):\n    def productExceptSelf(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        "
    },
    {
      "lang": "JavaScript",
      "langSlug": "javascript",
      "code": "/**\n * @param {number[]} nums\n * @return {number[]}\n */\nvar productExceptSelf = function(nums) {\n    \n};"
    },
    {
      "lang": "TypeScript",
      "langSlug": "typescript",
      "code": "function productExceptSelf(nums: number[]): number[] {\n    \n};"
    },
    {
      "lang": "C#",
      "langSlug": "csharp",
      "code": "public class Solution {\n    public int[] ProductExceptSelf(int[] nums) {\n        \n    }\n}"
    },
    {
      "lang": "C",
      "langSlug": "c",
      "code": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* productExceptSelf(int* nums, int numsSize, int* returnSize) {\n    \n}"
    },
    {
      "lang": "Go",
      "langSlug": "golang",
      "code": "func productExceptSelf(nums []int) []int {\n    \n}"
    },
    {
      "lang": "Kotlin",
      "langSlug": "kotlin",
      "code": "class Solution {\n    fun productExceptSelf(nums: IntArray): IntArray {\n        \n    }\n}"
    },
    {
      "lang": "Swift",
      "langSlug": "swift",
      "code": "class Solution {\n    func productExceptSelf(_ nums: [Int]) -> [Int] {\n        \n    }\n}"
    },
    {
      "lang": "Rust",
      "langSlug": "rust",
      "code": "impl Solution {\n    pub fn product_except_self(nums: Vec<i32>) -> Vec<i32> {\n        \n    }\n}"
    },
    {
      "lang": "Ruby",
      "langSlug": "ruby",
      "code": "# @param {Integer[]} nums\n# @return {Integer[]}\ndef product_except_self(nums)\n    \nend"
    },
    {
      "lang": "PHP",
      "langSlug": "php",
      "code": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer[]\n     */\n    function productExceptSelf($nums) {\n        \n    }\n}"
    },
    {
      "lang": "Dart",
      "langSlug": "dart",
      "code": "class Solution {\n  List<int> productExceptSelf(List<int> nums) {\n    \n  }\n}"
    },
    {
      "lang": "Scala",
      "langSlug": "scala",
      "code": "object Solution {\n    def productExceptSelf(nums: Array[Int]): Array[Int] = {\n        \n    }\n}"
    },
    {
      "lang": "Elixir",
      "langSlug": "elixir",
      "code": "defmodule Solution do\n  @spec product_except_self(nums :: [integer]) :: [integer]\n  def product_except_self(nums) do\n    \n  end\nend"
    },
    {
      "lang": "Erlang",
      "langSlug": "erlang",
      "code": "-spec product_except_self(Nums :: [integer()]) -> [integer()].\nproduct_except_self(Nums) ->\n  ."
    },
    {
      "lang": "Racket",
      "langSlug": "racket",
      "code": "(define/contract (product-except-self nums)\n  (-> (listof exact-integer?) (listof exact-integer?))\n  )"
    }
  ],
  "solution": {
    "content": "<div class=\"flex flex-col w-full\" style=\"position: relative;\"><div class=\"mYe_l WRmCx\">\n\n\n    \n\n\n<h2 id=\"solution\" level=\"2\" class=\"group/heading relative\"><a href=\"#solution\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" aria-hidden=\"true\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"link\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" role=\"img\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 640 512\" spacing=\"square\"><path fill=\"currentColor\" d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\"></path></svg></div></a>Solution</h2>\n<p>From the looks of it, this seems like a simple enough problem to solve in linear time and space. We can simply take the product of all the elements in the given array and then, for each of the elements <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.4306em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span></span> of the array, we can simply find <code>product of array except self</code> value by dividing the product by <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.4306em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span></span>.</p>\n<p>Doing this for each of the elements would solve the problem. However, there's a note in the problem which says that we are not allowed to use division operation. That makes solving this problem a bit harder.<br>\n<br><br>\n<br></p>\n<hr>\n<h3 id=\"approach-1-left-and-right-product-lists\" level=\"3\" class=\"group/heading relative\"><a href=\"#approach-1-left-and-right-product-lists\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" aria-hidden=\"true\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"link\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" role=\"img\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 640 512\" spacing=\"square\"><path fill=\"currentColor\" d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\"></path></svg></div></a>Approach 1: Left and Right product lists</h3>\n<p>It's much easier to build an intuition for solving this problem without division once you visualize how the different <code>products except self</code> look like for each of the elements. So, let's take a look at an example array and the different products.</p>\n\n<img alt=\"\" width=\"700\" src=\"../Figures/238/diag-1.png\">\n<p>Looking at the figure about we can figure another way of computing those different product values.</p>\n<blockquote>\n<p>Instead of dividing the product of all the numbers in the array by the number at a given index to get the corresponding product, we can make use of the product of all the numbers to the left and all the numbers to the right of the index. Multiplying these two individual products would give us the desired result as well.</p>\n</blockquote>\n<p>For every given index, <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span></span>, we will make use of the product of all the numbers to the left of it and multiply it by the product of all the numbers to the right. This will give us the product of all the numbers except the one at the given index <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span></span>. Let's look at a formal algorithm describing this idea more concretely.</p>\n<p><strong>Algorithm</strong></p>\n<ol>\n<li data-length=\"1\">Initialize two empty arrays, <code>L</code> and <code>R</code> where for a given index <code>i</code>, <code>L[i]</code> would contain the product of all the numbers to the left of <code>i</code> and <code>R[i]</code> would contain the product of all the numbers to the right of <code>i</code>.</li>\n<li data-length=\"1\">We would need two different loops to fill in values for the two arrays. For the array <code>L</code>, <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mopen\">[</span><span class=\"mord\">0</span><span class=\"mclose\">]</span></span></span></span></span> would be <code>1</code> since there are no elements to the left of the first element. For the rest of the elements, we simply use <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\">s</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span></span></span></span></span>. Remember that <code>L[i]</code> represents product of all the elements <em>to the left of element at index i</em>.</li>\n<li data-length=\"1\">For the other array, we do the same thing but in reverse i.e. we start with the initial value of <code>1</code> in <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.00773em;\">R</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right: 0.01968em;\">l</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\" style=\"margin-right: 0.03588em;\">g</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">h</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span></span></span></span></span> where <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.8889em; vertical-align: -0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.01968em;\">l</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\" style=\"margin-right: 0.03588em;\">g</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">h</span></span></span></span></span> is the number of elements in the array, and keep updating <code>R[i]</code> in reverse. Essentially, <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.00773em;\">R</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.00773em;\">R</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\">s</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span></span></span></span></span>. Remember that <code>R[i]</code> represents product of all the elements <em>to the right of element at index i</em>.</li>\n<li data-length=\"1\">Once we have the two arrays set up properly, we simply iterate over the input array one element at a time, and for each element at index <code>i</code>, we find the <code>product except self</code> as <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.00773em;\">R</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span></span></span></span></span>.</li>\n</ol>\n<p>Let's go over a simple run of the algorithm that clearly depicts the construction of the two intermediate arrays and finally the answer array.</p>\n<p></p>\n<p>For the given array <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">4</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right: 0.1667em;\"></span><span class=\"mord\">5</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right: 0.1667em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right: 0.1667em;\"></span><span class=\"mord\">8</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right: 0.1667em;\"></span><span class=\"mord\">2</span><span class=\"mclose\">]</span></span></span></span></span>, the <code>L</code> and <code>R</code> arrays would finally be:</p>\n\n<img alt=\"\" width=\"700\" src=\"../Figures/238/products.png\">\n<pre><code>class Solution {\npublic:\n    vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;& nums) {\n        // The length of the input array\n        int length = nums.size();\n​\n        // The left and right arrays as described in the algorithm\n        vector&lt;int&gt; L(length), R(length), answer(length);\n​\n        // L[i] contains the product of all the elements to the left\n        // Note: for the element at index '0', there are no elements to the\n        // left, so the L[0] would be 1\n        L[0] = 1;\n        for (int i = 1; i &lt; length; i++) {\n            // L[i - 1] already contains the product of elements to the left of\n            // 'i - 1' Simply multiplying it with nums[i - 1] would give the\n            // product of all elements to the left of index 'i'\n            L[i] = nums[i - 1] * L[i - 1];\n        }\n​\n        // R[i] contains the product of all the elements to the right\n        // Note: for the element at index 'length - 1', there are no elements to\n        // the right, so the R[length - 1] would be 1\n        R[length - 1] = 1;\n        for (int i = length - 2; i &gt;= 0; i--) {\n            // R[i + 1] already contains the product of elements to the right of\n            // 'i + 1' Simply multiplying it with nums[i + 1] would give the\n            // product of all elements to the right of index 'i'\n            R[i] = nums[i + 1] * R[i + 1];\n        }\n​\n        // Constructing the answer array\n        for (int i = 0; i &lt; length; i++) {\n            // For the first element, R[i] would be product except self\n            // For the last element of the array, product except self would be\n            // L[i] Else, multiple product of all elements to the left and to\n            // the right\n            answer[i] = L[i] * R[i];\n        }\n​\n        return answer;\n    }\n};</code></pre>\n<p><strong>Complexity analysis</strong></p>\n<ul>\n<li>Time complexity : <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span></span> where <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span></span></span></span></span> represents the number of elements in the input array. We use one iteration to construct the array <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord mathnormal\">L</span></span></span></span></span>, one to construct the array <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.00773em;\">R</span></span></span></span></span> and one last to construct the <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.4306em;\"></span><span class=\"mord mathnormal\">an</span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\" style=\"margin-right: 0.02691em;\">w</span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">er</span></span></span></span></span> array using <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord mathnormal\">L</span></span></span></span></span> and <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.00773em;\">R</span></span></span></span></span>.</li>\n<li>Space complexity : <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span></span> used up by the two intermediate arrays that we constructed to keep track of product of elements to the left and right.\n<br>\n</li>\n</ul>\n<br>\n<hr>\n<h3 id=\"approach-2-o1-space-approach\" level=\"3\" class=\"group/heading relative\"><a href=\"#approach-2-o1-space-approach\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" aria-hidden=\"true\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"link\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" role=\"img\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 640 512\" spacing=\"square\"><path fill=\"currentColor\" d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\"></path></svg></div></a>Approach 2: O(1) space approach</h3>\n<p>Although the above solution is good enough to solve the problem since we are not using division anymore, there's a follow-up component as well which asks us to solve this using constant space. Understandably so, the output array <em>does not</em> count towards the space complexity. This approach is essentially an extension of the approach above. Basically, we will be using the output array as one of <code>L</code> or <code>R</code> and we will be constructing the other one on the fly. Let's look at the algorithm based on this idea.</p>\n<p><strong>Algorithm</strong></p>\n<ol>\n<li data-length=\"1\">Initialize the empty <code>answer</code> array where for a given index <code>i</code>, <code>answer[i]</code> would contain the product of all the numbers to the left of <code>i</code>.</li>\n<li data-length=\"1\">We construct the <code>answer</code> array the same way we constructed the <code>L</code> array in the previous approach. These two algorithms are exactly the same except that we are trying to save up on space.</li>\n<li data-length=\"1\">The only change in this approach is that we don't explicitly build the <code>R</code> array from before. Instead, we simply use a variable to keep track of the running product of elements to the right and we keep updating the <code>answer</code> array by doing <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\">an</span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\" style=\"margin-right: 0.02691em;\">w</span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">er</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\">an</span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\" style=\"margin-right: 0.02691em;\">w</span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">er</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.00773em;\">R</span></span></span></span></span>. For a given index <code>i</code>, <code>answer[i]</code> contains the product of all the elements to the left and <code>R</code> would contain product of all the elements to the right. We then update <code>R</code> as <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\">s</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span></span></span></span></span></li>\n</ol>\n<pre><code>class Solution {\npublic:\n    vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;& nums) {\n        // The length of the input array\n        int length = nums.size();\n​\n        // The answer vector to be returned\n        vector&lt;int&gt; answer(length);\n​\n        // answer[i] contains the product of all the elements to the left\n        // Note: for the element at index '0', there are no elements to the\n        // left, so answer[0] would be 1\n        answer[0] = 1;\n        for (int i = 1; i &lt; length; i++) {\n            // answer[i - 1] already contains the product of elements to the\n            // left of 'i - 1' Simply multiplying it with nums[i - 1] would give\n            // the product of all elements to the left of index 'i'\n            answer[i] = nums[i - 1] * answer[i - 1];\n        }\n​\n        // R contains the product of all the elements to the right\n        // Note: for the element at index 'length - 1', there are no elements to\n        // the right, so R would be 1\n        int R = 1;\n        for (int i = length - 1; i &gt;= 0; i--) {\n            // For the index 'i', R would contain the\n            // product of all elements to the right. We update R accordingly\n            answer[i] = answer[i] * R;\n            R *= nums[i];\n        }\n​\n        return answer;\n    }\n};</code></pre>\n<p><strong>Complexity analysis</strong></p>\n<ul>\n<li>Time complexity : <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span></span> where <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span></span></span></span></span> represents the number of elements in the input array. We use one iteration to construct the array <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord mathnormal\">L</span></span></span></span></span>, one to update the array <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.4306em;\"></span><span class=\"mord mathnormal\">an</span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\" style=\"margin-right: 0.02691em;\">w</span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">er</span></span></span></span></span>.</li>\n<li>Space complexity : <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></span> since don't use any additional array for our computations. The problem statement mentions that using the <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.4306em;\"></span><span class=\"mord mathnormal\">an</span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\" style=\"margin-right: 0.02691em;\">w</span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">er</span></span></span></span></span> array doesn't add to the space complexity.</li>\n</ul>\n<br></div><span style=\"font-size: 0px; line-height: 0;\">&nbsp;</span></div>",
    "isOfficial": true,
    "scrapedAt": "2026-02-18T08:02:51.874Z"
  }
}