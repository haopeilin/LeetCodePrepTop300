{
    "questionId": "161",
    "questionFrontendId": "161",
    "title": "One Edit Distance",
    "titleSlug": "one-edit-distance",
    "content": "<p>Given two strings <code>s</code> and <code>t</code>, return <code>true</code> if they are both one edit distance apart, otherwise return <code>false</code>.</p>\n\n<p>A string <code>s</code> is said to be one distance apart from a string <code>t</code> if you can:</p>\n\n<ul>\n\t<li>Insert <strong>exactly one</strong> character into <code>s</code> to get <code>t</code>.</li>\n\t<li>Delete <strong>exactly one</strong> character from <code>s</code> to get <code>t</code>.</li>\n\t<li>Replace <strong>exactly one</strong> character of <code>s</code> with <strong>a different character</strong> to get <code>t</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;ab&quot;, t = &quot;acb&quot;\n<strong>Output:</strong> true\n<strong>Explanation:</strong> We can insert &#39;c&#39; into s&nbsp;to get&nbsp;t.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;&quot;, t = &quot;&quot;\n<strong>Output:</strong> false\n<strong>Explanation:</strong> We cannot get t from s by only one step.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= s.length, t.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>s</code> and <code>t</code> consist of lowercase letters, uppercase letters, and digits.</li>\n</ul>\n",
    "difficulty": "Medium",
    "stats": "{\"totalAccepted\": \"235K\", \"totalSubmission\": \"680.4K\", \"totalAcceptedRaw\": 235031, \"totalSubmissionRaw\": 680418, \"acRate\": \"34.5%\"}",
    "hints": [],
    "similarQuestions": "[{\"title\": \"Edit Distance\", \"titleSlug\": \"edit-distance\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
    "topicTags": [
        {
            "name": "Two Pointers",
            "slug": "two-pointers"
        },
        {
            "name": "String",
            "slug": "string"
        }
    ],
    "companyTags": null,
    "codeSnippets": [
        {
            "lang": "C++",
            "langSlug": "cpp",
            "code": "class Solution {\npublic:\n    bool isOneEditDistance(string s, string t) {\n        \n    }\n};"
        },
        {
            "lang": "Java",
            "langSlug": "java",
            "code": "class Solution {\n    public boolean isOneEditDistance(String s, String t) {\n        \n    }\n}"
        },
        {
            "lang": "Python3",
            "langSlug": "python3",
            "code": "class Solution:\n    def isOneEditDistance(self, s: str, t: str) -> bool:\n        "
        },
        {
            "lang": "Python",
            "langSlug": "python",
            "code": "class Solution(object):\n    def isOneEditDistance(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        "
        },
        {
            "lang": "JavaScript",
            "langSlug": "javascript",
            "code": "/**\n * @param {string} s\n * @param {string} t\n * @return {boolean}\n */\nvar isOneEditDistance = function(s, t) {\n    \n};"
        },
        {
            "lang": "TypeScript",
            "langSlug": "typescript",
            "code": "function isOneEditDistance(s: string, t: string): boolean {\n    \n};"
        },
        {
            "lang": "C#",
            "langSlug": "csharp",
            "code": "public class Solution {\n    public bool IsOneEditDistance(string s, string t) {\n        \n    }\n}"
        },
        {
            "lang": "C",
            "langSlug": "c",
            "code": "bool isOneEditDistance(char* s, char* t) {\n    \n}"
        },
        {
            "lang": "Go",
            "langSlug": "golang",
            "code": "func isOneEditDistance(s string, t string) bool {\n    \n}"
        },
        {
            "lang": "Kotlin",
            "langSlug": "kotlin",
            "code": "class Solution {\n    fun isOneEditDistance(s: String, t: String): Boolean {\n        \n    }\n}"
        },
        {
            "lang": "Swift",
            "langSlug": "swift",
            "code": "class Solution {\n    func isOneEditDistance(_ s: String, _ t: String) -> Bool {\n        \n    }\n}"
        },
        {
            "lang": "Rust",
            "langSlug": "rust",
            "code": "impl Solution {\n    pub fn is_one_edit_distance(s: String, t: String) -> bool {\n        \n    }\n}"
        },
        {
            "lang": "Ruby",
            "langSlug": "ruby",
            "code": "# @param {String} s\n# @param {String} t\n# @return {Boolean}\ndef is_one_edit_distance(s, t)\n    \nend"
        },
        {
            "lang": "PHP",
            "langSlug": "php",
            "code": "class Solution {\n\n    /**\n     * @param String $s\n     * @param String $t\n     * @return Boolean\n     */\n    function isOneEditDistance($s, $t) {\n        \n    }\n}"
        },
        {
            "lang": "Dart",
            "langSlug": "dart",
            "code": "class Solution {\n  bool isOneEditDistance(String s, String t) {\n    \n  }\n}"
        },
        {
            "lang": "Scala",
            "langSlug": "scala",
            "code": "object Solution {\n    def isOneEditDistance(s: String, t: String): Boolean = {\n        \n    }\n}"
        },
        {
            "lang": "Elixir",
            "langSlug": "elixir",
            "code": "defmodule Solution do\n  @spec is_one_edit_distance(s :: String.t, t :: String.t) :: boolean\n  def is_one_edit_distance(s, t) do\n    \n  end\nend"
        },
        {
            "lang": "Erlang",
            "langSlug": "erlang",
            "code": "-spec is_one_edit_distance(S :: unicode:unicode_binary(), T :: unicode:unicode_binary()) -> boolean().\nis_one_edit_distance(S, T) ->\n  ."
        },
        {
            "lang": "Racket",
            "langSlug": "racket",
            "code": "(define/contract (is-one-edit-distance s t)\n  (-> string? string? boolean?)\n  )"
        }
    ],
    "solution": {
        "content": "<h2><a href=\"#solution\"><svg><path></path></svg></a>Solution</h2>\n<hr/>\n<h3><a href=\"#approach-1-one-pass-algorithm\"><svg><path></path></svg></a>Approach 1: One pass algorithm</h3>\n<p><strong>Intuition</strong></p>\n<p>First of all, let's ensure that the string lengths are not too far from each other. If the length difference is 2 or more characters, then <code>s</code> and <code>t</code> couldn't be one edit away strings.</p>\n<p></p>\n<p>For the next let's assume that <code>s</code> is always shorter or the same length as <code>t</code>. If not, one could always call <code>isOneEditDistance(t, s)</code> to inverse the string order.</p>\n<p>Now it's time to pass along the strings and to look for the first different character.</p>\n<p>If there are no differences between the first <code>len(s)</code> characters, only two situations are possible :</p>\n<ul>\n<li>\n<p>The strings are equal.</p>\n</li>\n<li>\n<p>The strings are one edit away distance.</p>\n</li>\n</ul>\n<p></p>\n<p>Now what if there <em>is</em> a different character so that <code>s[i] != t[i]</code>?</p>\n<ul>\n<li>\n<p>If the strings are of the same length, <em>all</em> next characters should be equal to keep one edit away distance. To verify it, one has to compare the substrings of <code>s</code> and <code>t</code> both starting from the <code>i + 1</code>th character.</p>\n</li>\n<li>\n<p>If <code>t</code> is one character longer than <code>s</code>, the additional character <code>t[i]</code> should be the only difference between both strings. To verify it, one has to compare a substring of <code>s</code> starting from the <code>i</code>th character and a substring of <code>t</code> starting from the <code>i + 1</code>th character.</p>\n</li>\n</ul>\n<p></p>\n<p><strong>Implementation</strong></p>\n<pre><code>class Solution {\n    public boolean isOneEditDistance(String s, String t) {\n        int ns = s.length();\n        int nt = t.length();\n\n        // Ensure that s is shorter than t.\n        if (ns &gt; nt) return isOneEditDistance(t, s);\n\n        // The strings are NOT one edit away distance\n        // if the length diff is more than 1.\n        if (nt - ns &gt; 1) return false;\n\n        for (int i = 0; i &lt; ns; i++) {\n            if (s.charAt(i) != t.charAt(i)) {\n                // if strings have the same length\n                if (ns == nt) {\n                    return s.substring(i + 1).equals(t.substring(i + 1));\n                }\n                // If strings have different lengths\n                else {\n                    return s.substring(i).equals(t.substring(i + 1));\n                }\n            }\n        }\n\n        // If there are no diffs in ns distance\n        // The strings are one edit away only if\n        // t has one more character.\n        return (ns + 1 == nt);\n    }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity: O(N) in the worst case when string lengths are close enough <code>abs(ns - nt) &lt;= 1</code>, where <code>N</code> is a number of characters in the longest string. O(1) in the best case when <code>abs(ns - nt) &gt; 1</code>.</p>\n</li>\n<li>\n<p>Space complexity: O(N) because strings are immutable in Python and Java and create substring costs O(N) space.</p>\n</li>\n</ul>\n<p><strong>Problem generalization: Edit distance</strong></p>\n<p><a href=\"https://leetcode.com/articles/edit-distance/\">Given two words word1 and word2, find the minimum number of operations required to convert word1 to word2.</a></p>",
        "isOfficial": true,
        "scrapedAt": "2026-02-18T09:16:33.218Z"
    }
}