{
    "questionId": "196",
    "questionFrontendId": "196",
    "title": "Delete Duplicate Emails",
    "titleSlug": "delete-duplicate-emails",
    "content": "<p>Table: <code>Person</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| id          | int     |\n| email       | varchar |\n+-------------+---------+\nid is the primary key (column with unique values) for this table.\nEach row of this table contains an email. The emails will not contain uppercase letters.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to<strong> delete</strong> all duplicate emails, keeping only one unique email with the smallest <code>id</code>.</p>\n\n<p>For SQL users, please note that you are supposed to write a <code>DELETE</code> statement and not a <code>SELECT</code> one.</p>\n\n<p>For Pandas users, please note that you are supposed to modify <code>Person</code> in place.</p>\n\n<p>After running your script, the answer shown is the <code>Person</code> table. The driver will first compile and run your piece of code and then show the <code>Person</code> table. The final order of the <code>Person</code> table <strong>does not matter</strong>.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nPerson table:\n+----+------------------+\n| id | email            |\n+----+------------------+\n| 1  | john@example.com |\n| 2  | bob@example.com  |\n| 3  | john@example.com |\n+----+------------------+\n<strong>Output:</strong> \n+----+------------------+\n| id | email            |\n+----+------------------+\n| 1  | john@example.com |\n| 2  | bob@example.com  |\n+----+------------------+\n<strong>Explanation:</strong> john@example.com is repeated two times. We keep the row with the smallest Id = 1.\n</pre>\n",
    "difficulty": "Easy",
    "stats": "{\"totalAccepted\": \"917.1K\", \"totalSubmission\": \"1.4M\", \"totalAcceptedRaw\": 917094, \"totalSubmissionRaw\": 1399279, \"acRate\": \"65.5%\"}",
    "hints": [],
    "similarQuestions": "[]",
    "topicTags": [
        {
            "name": "Database",
            "slug": "database"
        }
    ],
    "companyTags": null,
    "codeSnippets": [],
    "solution": {
        "content": "<h1><a href=\"#solution\"><svg><path></path></svg></a>Solution</h1>\n<hr/>\n<h2><a href=\"#pandas\"><svg><path></path></svg></a>pandas</h2>\n<h3><a href=\"#approach-grouping\"><svg><path></path></svg></a>Approach: Grouping</h3>\n<h4>Algorithm</h4>\n<p>The requirement is to keep only the smallest <code>id</code> for each unique email. Naturally, we think of using the <code>groupby</code> method to achieve this. <code>person.groupby('email')</code> will group the <code>person</code> by the unique values in the <code>email</code> column. We divide <code>person</code> into multiple groups based on the unique values in the <code>email</code> column. This grouping allows us to group together rows with the same <code>email</code> so that we can operate on each group separately.</p>\n<p>We want to find the minimum <code>id</code> value within each group to retain the rows with the smallest <code>id</code>. To achieve this, we use the <code>transform('min')</code> method to generate a new series for each group, containing the minimum values from the <code>id</code> column within each respective group.</p>\n<pre><code>Map&lt;String, Integer&gt; minIdByEmail = new HashMap&lt;&gt;();\nfor (Person p : personList) {\n    minIdByEmail.merge(p.getEmail(), p.getId(), Math::min);\n}</code></pre><svg><path></path></svg>\n<p>This gives us a Series with the same length as the original DataFrame <code>person</code>, where each value represents the minimum <code>id</code> value within its corresponding group.</p>\n<pre><code>// Example mapping result:\n{\n    \"john@example.com\" = 1,\n    \"bob@example.com\" = 2\n}</code></pre><svg><path></path></svg>\n<br/>\n<p>Next, we can select the rows whose <code>id</code> is not the minimum <code>id</code> within their corresponding group:</p>\n<pre><code>List&lt;Person&gt; removedPerson = new ArrayList&lt;&gt;();\nfor (Person p : personList) {\n    if (p.getId() != minIdByEmail.get(p.getEmail())) {\n        removedPerson.add(p);\n    }\n}</code></pre><svg><path></path></svg>\n<p>We will have the following DataFrame <code>removed_person</code>:</p>\n<table><thead><tr><th>id</th><th>email</th></tr></thead><tbody><tr><td>3</td><td>john@example.com</td></tr></tbody></table>\n<br/>\n<p>Note that we are asked to modify <code>person</code> in-place. Therefore, we can remove all rows based on the elements provided by <code>removedPerson</code>. The complete code is as follows:</p>\n<h4>Implementation</h4>\n<pre><code>import java.util.*;\n\npublic class Solution {\n\n    public static void deleteDuplicateEmails(List&lt;Person&gt; personList) {\n        Map&lt;String, Integer&gt; minIdByEmail = new HashMap&lt;&gt;();\n        for (Person p : personList) {\n            minIdByEmail.merge(p.getEmail(), p.getId(), Math::min);\n        }\n\n        Iterator&lt;Person&gt; iterator = personList.iterator();\n        while (iterator.hasNext()) {\n            Person p = iterator.next();\n            if (p.getId() != minIdByEmail.get(p.getEmail())) {\n                iterator.remove();\n            }\n        }\n    }\n}</code></pre>\n<p>We can expect <code>person</code> to look like this.</p>\n<table><thead><tr><th>id</th><th>email</th></tr></thead><tbody><tr><td>1</td><td>john@example.com</td></tr><tr><td>2</td><td>bob@example.com</td></tr></tbody></table>\n<br/>\n<hr/>\n<h2><a href=\"#database\"><svg><path></path></svg></a>Database</h2>\n<h3><a href=\"#approach-using-delete-and-where-clause\"><svg><path></path></svg></a>Approach: Using <code>DELETE</code> and <code>WHERE</code> clause</h3>\n<h4>Algorithm</h4>\n<p>By joining this table with itself on the <em>Email</em> column, we can get the following code.</p>\n<pre><code>String query =\n    \"SELECT p1.* \" +\n    \"FROM person p1, person p2 \" +\n    \"WHERE p1.Email = p2.Email\";</code></pre><svg><path></path></svg>\n<p>Then we need to find the bigger id having same email address with other records. So we can add a new condition to the <code>WHERE</code> clause like this.</p>\n<pre><code>String query =\n    \"SELECT p1.* \" +\n    \"FROM person p1, person p2 \" +\n    \"WHERE p1.Email = p2.Email AND p1.Id &gt; p2.Id\";</code></pre><svg><path></path></svg>\n<p>As we already get the records to be deleted, we can alter this statement to <code>DELETE</code> in the end.</p>\n<h4>Implementation</h4>\n<pre><code>import java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.SQLException;\n\npublic class DatabaseSolution {\n\n    public static void deleteDuplicateEmails(Connection connection) throws SQLException {\n        String sql =\n            \"DELETE p1 FROM person p1, person p2 \" +\n            \"WHERE p1.Email = p2.Email AND p1.Id &gt; p2.Id\";\n\n        try (PreparedStatement stmt = connection.prepareStatement(sql)) {\n            stmt.executeUpdate();\n        }\n    }\n}</code></pre><svg><path></path></svg>",
        "isOfficial": true,
        "scrapedAt": "2026-02-18T07:31:37.231Z"
    }
}