{
    "questionId": "124",
    "questionFrontendId": "124",
    "title": "Binary Tree Maximum Path Sum",
    "titleSlug": "binary-tree-maximum-path-sum",
    "content": "<p>A <strong>path</strong> in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence <strong>at most once</strong>. Note that the path does not need to pass through the root.</p>\n\n<p>The <strong>path sum</strong> of a path is the sum of the node&#39;s values in the path.</p>\n\n<p>Given the <code>root</code> of a binary tree, return <em>the maximum <strong>path sum</strong> of any <strong>non-empty</strong> path</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"images/124/exx1.jpg\" style=\"width: 322px; height: 182px;\" />\n<pre>\n<strong>Input:</strong> root = [1,2,3]\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> The optimal path is 2 -&gt; 1 -&gt; 3 with a path sum of 2 + 1 + 3 = 6.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"images/124/exx2.jpg\" />\n<pre>\n<strong>Input:</strong> root = [-10,9,20,null,null,15,7]\n<strong>Output:</strong> 42\n<strong>Explanation:</strong> The optimal path is 15 -&gt; 20 -&gt; 7 with a path sum of 15 + 20 + 7 = 42.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[1, 3 * 10<sup>4</sup>]</code>.</li>\n\t<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n",
    "difficulty": "Hard",
    "stats": "{\"totalAccepted\": \"1.8M\", \"totalSubmission\": \"4.4M\", \"totalAcceptedRaw\": 1831226, \"totalSubmissionRaw\": 4361397, \"acRate\": \"42.0%\"}",
    "hints": [],
    "similarQuestions": "[{\"title\": \"Path Sum\", \"titleSlug\": \"path-sum\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Sum Root to Leaf Numbers\", \"titleSlug\": \"sum-root-to-leaf-numbers\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Path Sum IV\", \"titleSlug\": \"path-sum-iv\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Longest Univalue Path\", \"titleSlug\": \"longest-univalue-path\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Time Needed to Inform All Employees\", \"titleSlug\": \"time-needed-to-inform-all-employees\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Difference Between Maximum and Minimum Price Sum\", \"titleSlug\": \"difference-between-maximum-and-minimum-price-sum\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
    "topicTags": [
        {
            "name": "Dynamic Programming",
            "slug": "dynamic-programming"
        },
        {
            "name": "Tree",
            "slug": "tree"
        },
        {
            "name": "Depth-First Search",
            "slug": "depth-first-search"
        },
        {
            "name": "Binary Tree",
            "slug": "binary-tree"
        }
    ],
    "companyTags": null,
    "codeSnippets": [
        {
            "lang": "Java",
            "langSlug": "java",
            "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int maxPathSum(TreeNode root) {\n        \n    }\n}"
        }
    ],
    "solution": {
        "content": "<h2><a href=\"#solution\"><svg><path></path></svg></a>Solution</h2>\n<hr/>\n<h3><a href=\"#overview\"><svg><path></path></svg></a>Overview</h3>\n<p>In this problem, we are given the root of a binary tree. We want to find the maximum path sum of this tree.</p>\n<p>Before we delve into the solution, let's first understand a few terms. A <em>path</em> is a continuous sequence of nodes connected to each other. There will always be at least one node in a path. In a path, except for the starting and ending nodes, every node is connected to two other nodes in the sequence. These two nodes could either be the node's children, or one of them could be a child, and the other could be the parent node. In other words, no node can have more than two connections in this sequence. Each node contains a value, which could be negative, zero, or positive.</p>\n<p></p>\n<p></p>\n<p>A <em>path sum</em> is the sum of the values of all the nodes in a path. Because the values could be negative or positive, a path sum could also be negative or positive. Every combination of two nodes in a tree can form a path by using the sequence of all nodes between them. In fact, every node in itself can also be considered a path (a path needs at least one node). We can see that the number of paths could be pretty large, and there would be as many path sums as the number of paths. In this problem, we need to find the maximum path sum.</p>\n<p></p>\n<p>We must traverse the entire tree to find the maximum path sum. We are interested in a set of nodes that form a continuous sequence (path). When traversing trees, we prefer DFS over BFS because it can examine each path before moving on to the next.</p>\n<hr/>\n<h3><a href=\"#approach-post-order-dfs\"><svg><path></path></svg></a>Approach: Post Order DFS</h3>\n<h4>Intuition</h4>\n<p>One way to find the maximum path sum would be to look at all possible paths, calculate their path sums, and then find the maximum path sum. However, this would be a \"brute force\" approach. If there are n nodes in the tree, creating all the paths and computing their path sums would take O(n2) time. We can do better than this.</p>\n<p>Consider a scenario where the path with the highest sum passes through the tree's root.</p>\n<p>There could be four possibilities.</p>\n<ol>\n<li>The path starts at the root and goes down through the root's left child. We don't know how long the path is, but it could extend to the bottom of the left subtree.</li>\n<li>The path starts at the root and goes down through the root's right child. Very similar to the previous case, but the direction is toward the right.</li>\n<li>The path involves both the left and the right child.</li>\n<li>The path doesn't involve any child. The root itself is the only element of the path with maximum sum.</li>\n</ol>\n<p></p>\n<p>We know that the path contains the root. Therefore, in the beginning, we can assume that the path sum is the root node's value. To find the maximum path sum, we determine if there is a viable path leading down through the left or the right subtree. Please remember that a node can have negative or positive values. So a path sum contributed by a subtree could also be negative or positive. It would make sense to consider a path sum contributed by a subtree only if it is positive. If not, we can safely ignore it. In other words, the path goes down the left or the right subtree only if we see a gain in the path sum.</p>\n<p>This means we must first determine the gain in the path sum contributed by the left and the right subtree. Once we have both, we decide whether to include their contribution. We can see that we need to process the children before we process a node. This indicates that we need to perform a <strong>post-order traversal</strong> of the tree because, in post-order, children are processed before the parent.</p>\n<p>To implement post-order traversal, we implement a recursive function. This function takes the root of the subtree as the input. The function returns the path sum gain contributed by the subtree. To calculate the path sum gain, the function calls itself recursively on the subtree's left and right child.</p>\n<p>We have considered the scenario where the maximum sum path passes through the root. But what if it doesn't?</p>\n<p></p>\n<br/>\n<p>We slightly tweak our algorithm to include the case when the path sum doesn't pass through the root. Now, in addition to returning the path sum gain contributed by the subtree, the recursive function also keeps track of the maximum path sum. We update the maximum path sum whenever we find a new maximum.</p>\n<p>Let's put this formally now. Let's name our recursive function <code>gain_from_subtree</code>. It takes the root of a subtree as the input. The function has two responsibilities.</p>\n<ol>\n<li>\n<p>The function returns the path sum gain contributed by the subtree.</p>\n<p>The path sum gain contributed by the subtree can be derived from a path that includes at most one child of the root. You may wonder, why can't we include both children? If we include both children in the path, the path would have to make a fork at the root. The root is already connected to its parent. Now, if we include both children as well, with three connections, it wouldn't be a valid path anymore. Therefore, we can say that the path would consist of at most one child of the root.</p>\n<p>The recursive function compares <code>left_gain</code> and <code>right_gain</code> and adds the maximum of the two to the value of the root. The sum, <code>gain_from_subtree</code> is then returned to the caller.</p>\n<pre><code>int leftGain = Math.max(gainFromLeftSubtree, 0);\nint rightGain = Math.max(gainFromRightSubtree, 0);\nint gainFromSubtree = Math.max(leftGain, rightGain) + root.val;</code></pre><svg><path></path></svg>\n<p>We use <code>Math.max(gainFromLeftSubtree, 0)</code> because we want to consider the gain only if it is positive. If it is negative, we ignore it or consider it as zero.</p>\n</li>\n<li>\n<p>The function keeps track of the maximum path sum.</p>\n<p>Assuming that the maximum path sum passes through the root of the subtree, as explained earlier, we consider all four possibilities - (1) The path goes through the left subtree (2) The path goes through the right subtree (3) The path goes through both left and right subtrees (4) The path doesn't involve left or right subtrees. So we include the left and right gain if they are positive and the value of the root node. We compare this sum with the current maximum path sum and update it if necessary. The following code segment takes care of all four possibilities.</p>\n<pre><code>maxPathSum = Math.max(maxPathSum, leftGain + rightGain + root.val);</code></pre><svg><path></path></svg>\n</li>\n</ol>\n<h4>Algorithm</h4>\n<h5>Main function body</h5>\n<ol>\n<li>Initialize a global variable <code>max_sum</code> to <code>-Infinity</code>.</li>\n<li>Call the function <code>gain_from_subtree</code> on the tree's root.</li>\n<li>Return the value of <code>max_sum</code>.</li>\n</ol>\n<h5>Body of the recursive function <code>gain_from_subtree</code>. It accepts <code>root</code> of the subtree as the input.</h5>\n<ol>\n<li>If the root is <code>null</code>, return <code>0</code>. This is the base case. If a node doesn't have a left or right child, then the path sum contributed by the respective subtree is <code>0</code>.</li>\n<li>Call the function recursively on the left and right child of the root. Store the results in <code>gain_from_left</code> and <code>gain_from_right</code>, respectively.</li>\n<li>If either is negative, set it to <code>0</code>. This is because we don't want to include a path sum contributed by a subtree if it is negative.</li>\n<li>Update the maximum path sum (<code>max_sum</code>) seen so far. To do so, compare <code>max_sum</code> with the sum of the following, and update it if it is smaller.\n<ul>\n<li>The value of the root itself.</li>\n<li><code>gain_from_left</code> (<code>0</code> if negative)</li>\n<li><code>gain_from_right</code> (<code>0</code> if negative)</li>\n</ul>\n</li>\n<li>Return the path sum gain contributed by the subtree. This is the maximum of the following two values.\n<ul>\n<li>The value of the root plus <code>gain_from_left</code>.</li>\n<li>The value of the root plus <code>gain_from_right</code>.</li>\n</ul>\n</li>\n</ol>\n<h5>A note on the base case</h5>\n<p>Let's say our recursive algorithm reaches a node with no left child. Because there is no left child, our path cannot go toward the left subtree. In other words, the gain from the left subtree is 0. So, when the function is called on the non-existent child of the node, it returns 0. This would be true for a non-existent right child as well. Therefore, we can safely say that the base case is when the root is <code>null</code>.</p>\n<p></p>\n<br/>\n<h4>Implementation</h4>\n<pre><code>class Solution {\n\n    private int maxSum;\n\n    public int maxPathSum(TreeNode root) {\n        maxSum = Integer.MIN_VALUE;\n        gainFromSubtree(root);\n        return maxSum;\n    }\n\n    // post order traversal of subtree rooted at `root`\n    private int gainFromSubtree(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n\n        // add the path sum from left subtree. Note that if the path\n        // sum is negative, we can ignore it, or count it as 0.\n        // This is the reason we use Math.max here.\n        int gainFromLeft = Math.max(gainFromSubtree(root.left), 0);\n\n        // add the path sum from right subtree. 0 if negative\n        int gainFromRight = Math.max(gainFromSubtree(root.right), 0);\n\n        // if left or right path sum are negative, they are counted\n        // as 0, so this statement takes care of all four scenarios\n        maxSum = Math.max(maxSum, gainFromLeft + gainFromRight + root.val);\n\n        // return the max sum for a path starting at the root of subtree\n        return Math.max(gainFromLeft + root.val, gainFromRight + root.val);\n    }\n}</code></pre>\n<h4>Complexity Analysis</h4>\n<p>Let n be the number of nodes in the tree.</p>\n<ul>\n<li>\n<p>Time complexity: O(n)</p>\n<p>Each node in the tree is visited only once. During a visit, we perform constant time operations, including two recursive calls and calculating the max path sum for the current node. So the time complexity is O(n).</p>\n</li>\n<li>\n<p>Space complexity: O(n)</p>\n<p>We don't use any auxiliary data structure, but the recursive call stack can go as deep as the tree's height. In the worst case, the tree is a linked list, so the height is n. Therefore, the space complexity is O(n).</p>\n</li>\n</ul>",
        "isOfficial": true,
        "scrapedAt": "2026-02-18T08:08:14.796Z"
    }
}