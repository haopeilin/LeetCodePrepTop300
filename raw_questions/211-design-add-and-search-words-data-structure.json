{
  "questionId": "211",
  "questionFrontendId": "211",
  "title": "Design Add and Search Words Data Structure",
  "titleSlug": "design-add-and-search-words-data-structure",
  "content": "<p>Design a data structure that supports adding new words and finding if a string matches any previously added string.</p>\n\n<p>Implement the <code>WordDictionary</code> class:</p>\n\n<ul>\n\t<li><code>WordDictionary()</code>&nbsp;Initializes the object.</li>\n\t<li><code>void addWord(word)</code> Adds <code>word</code> to the data structure, it can be matched later.</li>\n\t<li><code>bool search(word)</code>&nbsp;Returns <code>true</code> if there is any string in the data structure that matches <code>word</code>&nbsp;or <code>false</code> otherwise. <code>word</code> may contain dots <code>&#39;.&#39;</code> where dots can be matched with any letter.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;WordDictionary&quot;,&quot;addWord&quot;,&quot;addWord&quot;,&quot;addWord&quot;,&quot;search&quot;,&quot;search&quot;,&quot;search&quot;,&quot;search&quot;]\n[[],[&quot;bad&quot;],[&quot;dad&quot;],[&quot;mad&quot;],[&quot;pad&quot;],[&quot;bad&quot;],[&quot;.ad&quot;],[&quot;b..&quot;]]\n<strong>Output</strong>\n[null,null,null,null,false,true,true,true]\n\n<strong>Explanation</strong>\nWordDictionary wordDictionary = new WordDictionary();\nwordDictionary.addWord(&quot;bad&quot;);\nwordDictionary.addWord(&quot;dad&quot;);\nwordDictionary.addWord(&quot;mad&quot;);\nwordDictionary.search(&quot;pad&quot;); // return False\nwordDictionary.search(&quot;bad&quot;); // return True\nwordDictionary.search(&quot;.ad&quot;); // return True\nwordDictionary.search(&quot;b..&quot;); // return True\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= word.length &lt;= 25</code></li>\n\t<li><code>word</code> in <code>addWord</code> consists of lowercase English letters.</li>\n\t<li><code>word</code> in <code>search</code> consist of <code>&#39;.&#39;</code> or lowercase English letters.</li>\n\t<li>There will be at most <code>2</code> dots in <code>word</code> for <code>search</code> queries.</li>\n\t<li>At most <code>10<sup>4</sup></code> calls will be made to <code>addWord</code> and <code>search</code>.</li>\n</ul>\n",
  "difficulty": "Medium",
  "stats": "{\"totalAccepted\": \"862.6K\", \"totalSubmission\": \"1.8M\", \"totalAcceptedRaw\": 862640, \"totalSubmissionRaw\": 1792794, \"acRate\": \"48.1%\"}",
  "hints": [
    "You should be familiar with how a Trie works. If not, please work on this problem: <a href=\"https://leetcode.com/problems/implement-trie-prefix-tree/\">Implement Trie (Prefix Tree)</a> first."
  ],
  "similarQuestions": "[{\"title\": \"Implement Trie (Prefix Tree)\", \"titleSlug\": \"implement-trie-prefix-tree\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Prefix and Suffix Search\", \"titleSlug\": \"prefix-and-suffix-search\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Match Substring After Replacement\", \"titleSlug\": \"match-substring-after-replacement\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Sum of Prefix Scores of Strings\", \"titleSlug\": \"sum-of-prefix-scores-of-strings\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Count Prefix and Suffix Pairs II\", \"titleSlug\": \"count-prefix-and-suffix-pairs-ii\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Count Prefix and Suffix Pairs I\", \"titleSlug\": \"count-prefix-and-suffix-pairs-i\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
  "topicTags": [
    {
      "name": "String",
      "slug": "string"
    },
    {
      "name": "Depth-First Search",
      "slug": "depth-first-search"
    },
    {
      "name": "Design",
      "slug": "design"
    },
    {
      "name": "Trie",
      "slug": "trie"
    }
  ],
  "companyTags": null,
  "codeSnippets": [
    {
      "lang": "C++",
      "langSlug": "cpp",
      "code": "class WordDictionary {\npublic:\n    WordDictionary() {\n        \n    }\n    \n    void addWord(string word) {\n        \n    }\n    \n    bool search(string word) {\n        \n    }\n};\n\n/**\n * Your WordDictionary object will be instantiated and called as such:\n * WordDictionary* obj = new WordDictionary();\n * obj->addWord(word);\n * bool param_2 = obj->search(word);\n */"
    },
    {
      "lang": "Java",
      "langSlug": "java",
      "code": "class WordDictionary {\n\n    public WordDictionary() {\n        \n    }\n    \n    public void addWord(String word) {\n        \n    }\n    \n    public boolean search(String word) {\n        \n    }\n}\n\n/**\n * Your WordDictionary object will be instantiated and called as such:\n * WordDictionary obj = new WordDictionary();\n * obj.addWord(word);\n * boolean param_2 = obj.search(word);\n */"
    },
    {
      "lang": "Python3",
      "langSlug": "python3",
      "code": "class WordDictionary:\n\n    def __init__(self):\n        \n\n    def addWord(self, word: str) -> None:\n        \n\n    def search(self, word: str) -> bool:\n        \n\n\n# Your WordDictionary object will be instantiated and called as such:\n# obj = WordDictionary()\n# obj.addWord(word)\n# param_2 = obj.search(word)"
    },
    {
      "lang": "Python",
      "langSlug": "python",
      "code": "class WordDictionary(object):\n\n    def __init__(self):\n        \n\n    def addWord(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: None\n        \"\"\"\n        \n\n    def search(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n\n\n# Your WordDictionary object will be instantiated and called as such:\n# obj = WordDictionary()\n# obj.addWord(word)\n# param_2 = obj.search(word)"
    },
    {
      "lang": "JavaScript",
      "langSlug": "javascript",
      "code": "\nvar WordDictionary = function() {\n    \n};\n\n/** \n * @param {string} word\n * @return {void}\n */\nWordDictionary.prototype.addWord = function(word) {\n    \n};\n\n/** \n * @param {string} word\n * @return {boolean}\n */\nWordDictionary.prototype.search = function(word) {\n    \n};\n\n/** \n * Your WordDictionary object will be instantiated and called as such:\n * var obj = new WordDictionary()\n * obj.addWord(word)\n * var param_2 = obj.search(word)\n */"
    },
    {
      "lang": "TypeScript",
      "langSlug": "typescript",
      "code": "class WordDictionary {\n    constructor() {\n        \n    }\n\n    addWord(word: string): void {\n        \n    }\n\n    search(word: string): boolean {\n        \n    }\n}\n\n/**\n * Your WordDictionary object will be instantiated and called as such:\n * var obj = new WordDictionary()\n * obj.addWord(word)\n * var param_2 = obj.search(word)\n */"
    },
    {
      "lang": "C#",
      "langSlug": "csharp",
      "code": "public class WordDictionary {\n\n    public WordDictionary() {\n        \n    }\n    \n    public void AddWord(string word) {\n        \n    }\n    \n    public bool Search(string word) {\n        \n    }\n}\n\n/**\n * Your WordDictionary object will be instantiated and called as such:\n * WordDictionary obj = new WordDictionary();\n * obj.AddWord(word);\n * bool param_2 = obj.Search(word);\n */"
    },
    {
      "lang": "C",
      "langSlug": "c",
      "code": "\n\n\ntypedef struct {\n    \n} WordDictionary;\n\n\nWordDictionary* wordDictionaryCreate() {\n    \n}\n\nvoid wordDictionaryAddWord(WordDictionary* obj, char* word) {\n    \n}\n\nbool wordDictionarySearch(WordDictionary* obj, char* word) {\n    \n}\n\nvoid wordDictionaryFree(WordDictionary* obj) {\n    \n}\n\n/**\n * Your WordDictionary struct will be instantiated and called as such:\n * WordDictionary* obj = wordDictionaryCreate();\n * wordDictionaryAddWord(obj, word);\n \n * bool param_2 = wordDictionarySearch(obj, word);\n \n * wordDictionaryFree(obj);\n*/"
    },
    {
      "lang": "Go",
      "langSlug": "golang",
      "code": "type WordDictionary struct {\n    \n}\n\n\nfunc Constructor() WordDictionary {\n    \n}\n\n\nfunc (this *WordDictionary) AddWord(word string)  {\n    \n}\n\n\nfunc (this *WordDictionary) Search(word string) bool {\n    \n}\n\n\n/**\n * Your WordDictionary object will be instantiated and called as such:\n * obj := Constructor();\n * obj.AddWord(word);\n * param_2 := obj.Search(word);\n */"
    },
    {
      "lang": "Kotlin",
      "langSlug": "kotlin",
      "code": "class WordDictionary() {\n\n    fun addWord(word: String) {\n        \n    }\n\n    fun search(word: String): Boolean {\n        \n    }\n\n}\n\n/**\n * Your WordDictionary object will be instantiated and called as such:\n * var obj = WordDictionary()\n * obj.addWord(word)\n * var param_2 = obj.search(word)\n */"
    },
    {
      "lang": "Swift",
      "langSlug": "swift",
      "code": "\nclass WordDictionary {\n\n    init() {\n        \n    }\n    \n    func addWord(_ word: String) {\n        \n    }\n    \n    func search(_ word: String) -> Bool {\n        \n    }\n}\n\n/**\n * Your WordDictionary object will be instantiated and called as such:\n * let obj = WordDictionary()\n * obj.addWord(word)\n * let ret_2: Bool = obj.search(word)\n */"
    },
    {
      "lang": "Rust",
      "langSlug": "rust",
      "code": "struct WordDictionary {\n\n}\n\n\n/** \n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl WordDictionary {\n\n    fn new() -> Self {\n        \n    }\n    \n    fn add_word(&self, word: String) {\n        \n    }\n    \n    fn search(&self, word: String) -> bool {\n        \n    }\n}\n\n/**\n * Your WordDictionary object will be instantiated and called as such:\n * let obj = WordDictionary::new();\n * obj.add_word(word);\n * let ret_2: bool = obj.search(word);\n */"
    },
    {
      "lang": "Ruby",
      "langSlug": "ruby",
      "code": "class WordDictionary\n    def initialize()\n        \n    end\n\n\n=begin\n    :type word: String\n    :rtype: Void\n=end\n    def add_word(word)\n        \n    end\n\n\n=begin\n    :type word: String\n    :rtype: Boolean\n=end\n    def search(word)\n        \n    end\n\n\nend\n\n# Your WordDictionary object will be instantiated and called as such:\n# obj = WordDictionary.new()\n# obj.add_word(word)\n# param_2 = obj.search(word)"
    },
    {
      "lang": "PHP",
      "langSlug": "php",
      "code": "class WordDictionary {\n    /**\n     */\n    function __construct() {\n        \n    }\n  \n    /**\n     * @param String $word\n     * @return NULL\n     */\n    function addWord($word) {\n        \n    }\n  \n    /**\n     * @param String $word\n     * @return Boolean\n     */\n    function search($word) {\n        \n    }\n}\n\n/**\n * Your WordDictionary object will be instantiated and called as such:\n * $obj = WordDictionary();\n * $obj->addWord($word);\n * $ret_2 = $obj->search($word);\n */"
    },
    {
      "lang": "Dart",
      "langSlug": "dart",
      "code": "class WordDictionary {\n\n  WordDictionary() {\n    \n  }\n  \n  void addWord(String word) {\n    \n  }\n  \n  bool search(String word) {\n    \n  }\n}\n\n/**\n * Your WordDictionary object will be instantiated and called as such:\n * WordDictionary obj = WordDictionary();\n * obj.addWord(word);\n * bool param2 = obj.search(word);\n */"
    },
    {
      "lang": "Scala",
      "langSlug": "scala",
      "code": "class WordDictionary() {\n\n    def addWord(word: String): Unit = {\n        \n    }\n\n    def search(word: String): Boolean = {\n        \n    }\n\n}\n\n/**\n * Your WordDictionary object will be instantiated and called as such:\n * val obj = new WordDictionary()\n * obj.addWord(word)\n * val param_2 = obj.search(word)\n */"
    },
    {
      "lang": "Elixir",
      "langSlug": "elixir",
      "code": "defmodule WordDictionary do\n  @spec init_() :: any\n  def init_() do\n    \n  end\n\n  @spec add_word(word :: String.t) :: any\n  def add_word(word) do\n    \n  end\n\n  @spec search(word :: String.t) :: boolean\n  def search(word) do\n    \n  end\nend\n\n# Your functions will be called as such:\n# WordDictionary.init_()\n# WordDictionary.add_word(word)\n# param_2 = WordDictionary.search(word)\n\n# WordDictionary.init_ will be called before every test case, in which you can do some necessary initializations."
    },
    {
      "lang": "Erlang",
      "langSlug": "erlang",
      "code": "-spec word_dictionary_init_() -> any().\nword_dictionary_init_() ->\n  .\n\n-spec word_dictionary_add_word(Word :: unicode:unicode_binary()) -> any().\nword_dictionary_add_word(Word) ->\n  .\n\n-spec word_dictionary_search(Word :: unicode:unicode_binary()) -> boolean().\nword_dictionary_search(Word) ->\n  .\n\n\n%% Your functions will be called as such:\n%% word_dictionary_init_(),\n%% word_dictionary_add_word(Word),\n%% Param_2 = word_dictionary_search(Word),\n\n%% word_dictionary_init_ will be called before every test case, in which you can do some necessary initializations."
    },
    {
      "lang": "Racket",
      "langSlug": "racket",
      "code": "(define word-dictionary%\n  (class object%\n    (super-new)\n    \n    (init-field)\n    \n    ; add-word : string? -> void?\n    (define/public (add-word word)\n      )\n    ; search : string? -> boolean?\n    (define/public (search word)\n      )))\n\n;; Your word-dictionary% object will be instantiated and called as such:\n;; (define obj (new word-dictionary%))\n;; (send obj add-word word)\n;; (define param_2 (send obj search word))"
    }
  ],
  "solution": {
    "content": "<div class=\"flex flex-col w-full\" style=\"position: relative;\"><div class=\"mYe_l WRmCx\"><h2 id=\"solution\" level=\"2\" class=\"group/heading relative\"><a href=\"#solution\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" aria-hidden=\"true\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"link\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" role=\"img\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 640 512\" spacing=\"square\"><path fill=\"currentColor\" d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\"></path></svg></div></a>Solution</h2>\n<hr>\n<h3 id=\"overview\" level=\"3\" class=\"group/heading relative\"><a href=\"#overview\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" aria-hidden=\"true\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"link\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" role=\"img\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 640 512\" spacing=\"square\"><path fill=\"currentColor\" d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\"></path></svg></div></a>Overview</h3>\n<h4 id=\"data-structure-trie\">Data Structure Trie</h4>\n<p>This article introduces the data structure <a href=\"https://en.wikipedia.org/wiki/Trie\" target=\"_blank\">trie</a>. It could be pronounced in two different ways: as \"tree\" or \"try\". Trie  which is also called a digital tree or a prefix tree is a kind of search-ordered tree data structure mostly used for the efficient dynamic add/search operations with the strings.</p>\n<p>Trie is widely used in real life: autocomplete search, spell checker, T9 predictive text, <a href=\"https://www.researchgate.net/figure/An-example-routing-table-and-the-corresponding-binary-trie-built-from-it_fig3_4236637\" target=\"_blank\">IP routing (longest prefix matching)</a>, <a href=\"https://gcc.gnu.org/onlinedocs/libstdc++/ext/pb_ds/trie_based_containers.html\" target=\"_blank\">some GCC containers</a>.</p>\n<p>Here is what it looks like</p>\n<p><img alt=\"fig\" src=\"../Figures/211/trie.png\"></p>\n<p><em>Figure 1. Data structure trie.</em></p>\n<p>There are two main types of trie interview questions:</p>\n<ul>\n<li>\n<p><a href=\"https://en.wikipedia.org/wiki/Trie\" target=\"_blank\">Standard Trie</a>. Design a structure to dynamically add and search strings, for example</p>\n<ul>\n<li>\n<p><a href=\"\" target=\"_blank\">Add and Search Word</a>.</p>\n</li>\n<li>\n<p><a href=\"https://leetcode.com/articles/word-search-ii\" target=\"_blank\">Word Search II</a>.</p>\n</li>\n<li>\n<p><a href=\"https://leetcode.com/articles/design-search-autocomplete-system/\" target=\"_blank\">Design Search Autocomplete System</a>.</p>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"https://en.wikipedia.org/wiki/Trie#Bitwise_tries\" target=\"_blank\">Bitwise Trie</a>. Design a structure to dynamically add <em>binary</em> strings and compute maximum/minimum XOR/AND/etc, for example</p>\n<ul>\n<li><a href=\"https://leetcode.com/articles/maximum-xor-of-two-numbers-in-an-array/\" target=\"_blank\">Maximum XOR of Two Number in an Array</a>.</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"why-trie-and-not-hashmap\">Why Trie and not HashMap</h4>\n<p>It's quite easy to write the solution using such data structures as hashmap or balanced tree.</p>\n<pre><code>class WordDictionary {\npublic:\n    unordered_map&lt;int, unordered_set&lt;string&gt;&gt; d;\n​\n    /** Initialize your data structure here. */\n    WordDictionary() {}\n​\n    /** Adds a word into the data structure. */\n    void addWord(string word) {\n        int m = word.size();\n        if (!d.count(m)) {\n            d[m] = unordered_set&lt;string&gt;();\n        }\n        d[m].insert(word);\n    }\n​\n    /** Returns if the word is in the data structure. A word could contain the\n     * dot character '.' to represent any one letter. */\n    bool search(string word) {\n        int m = word.size();\n        if (d.count(m)) {\n            for (auto w : d[m]) {\n                int i = 0;\n                while (i &lt; m && (w[i] == word[i] || word[i] == '.')) {\n                    i++;\n                }\n                if (i == m) return true;\n            }\n        }\n        return false;\n    }\n};</code></pre>\n<p>This solution passes all LeetCode test cases and formally has <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathcal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span></span> time complexity for the search, where <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">M</span></span></span></span></span> is the length of the word to find, and <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span></span></span></span></span> is the number of words. Although this solution is not efficient for the most important practical use cases:</p>\n<ul>\n<li>\n<p>Finding all keys with a common prefix.</p>\n</li>\n<li>\n<p>Enumerating a dataset of strings in lexicographical order.</p>\n</li>\n<li>\n<p>Scaling for the large datasets. Once the hash table increases in size, there are a lot of hash collisions and the search time complexity could degrade to <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1.0641em; vertical-align: -0.25em;\"></span><span class=\"mord mathcal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.8141em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">M</span><span class=\"mclose\">)</span></span></span></span></span>, where <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span></span></span></span></span> is the number of the inserted keys.</p>\n<p>Trie could use less space compared to hashmap when storing many keys with the same prefix. In this case, using trie has only <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathcal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span></span> time complexity, where <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">M</span></span></span></span></span> is the key length, and <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span></span></span></span></span> is the number of keys.</p>\n</li>\n</ul>\n<br>\n<br>\n<hr>\n<h3 id=\"approach-1-trie\" level=\"3\" class=\"group/heading relative\"><a href=\"#approach-1-trie\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" aria-hidden=\"true\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"link\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" role=\"img\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 640 512\" spacing=\"square\"><path fill=\"currentColor\" d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\"></path></svg></div></a>Approach 1: Trie</h3>\n<p><strong>How to Implement Trie: addWord function</strong></p>\n<p><img alt=\"fig\" src=\"../Figures/211/add_word.png\"></p>\n<p><em>Figure 2. Trie implementation.</em></p>\n<p>In trie, each path from the root to the \"word\" node represents one of the input words, for example, o -&gt; a -&gt; t -&gt; h is \"oath\".</p>\n<p>Trie implementation is pretty straightforward, it's basically nested hashmaps. At each step, one has to verify, if the child node to add is already present. If yes, just go one step down. If not, add it into the trie and then go one step down.</p>\n<p></p>\n<pre><code>struct TrieNode {\n    unordered_map&lt;char, TrieNode*&gt; children;\n    bool word = false;\n};\n​\nclass WordDictionary {\n    TrieNode* trie;\n​\npublic:\n    /** Initialize your data structure here. */\n    WordDictionary() { trie = new TrieNode(); }\n​\n    /** Adds a word into the data structure. */\n    void addWord(string word) {\n        TrieNode* node = trie;\n​\n        for (char ch : word) {\n            if (!node-&gt;children.count(ch)) {\n                node-&gt;children[ch] = new TrieNode();\n            }\n            node = node-&gt;children[ch];\n        }\n        node-&gt;word = true;\n    }\n};</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity: <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathcal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">M</span><span class=\"mclose\">)</span></span></span></span></span>, where <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">M</span></span></span></span></span> is the key length. At each step, we either examine or create a node in the trie. That takes only <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">M</span></span></span></span></span> operations.</p>\n</li>\n<li>\n<p>Space complexity: <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathcal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">M</span><span class=\"mclose\">)</span></span></span></span></span>. In the worst-case newly inserted key doesn't share a prefix with the keys already inserted in the trie. We have to add <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">M</span></span></span></span></span> new nodes, which takes <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathcal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">M</span><span class=\"mclose\">)</span></span></span></span></span> space.</p>\n</li>\n</ul>\n<p><strong>Search in Trie</strong></p>\n<p>In the absence of '.' characters, the search would be as simple as <code>addWord</code>. Each key is represented in the trie as a path from the root to the internal node or leaf. We start from the root and go down in trie, checking character by character.</p>\n<p><img alt=\"fig\" src=\"../Figures/211/search2.png\"></p>\n<p><em>Figure 3. Search in trie.</em></p>\n<p>The presence of '.' characters forces us to explore all possible paths at each <code>.</code> level.</p>\n<p><img alt=\"fig\" src=\"../Figures/211/search_dot.png\"></p>\n<p><em>Figure 4. Search in trie.</em></p>\n<pre><code>/** Returns if the word is in the node. */\nbool searchInNode(string word, TrieNode* node) {\n    for (int i = 0; i &lt; word.length(); ++i) {\n        char ch = word[i];\n        if (!node-&gt;children.count(ch)) {\n            // If the current character is '.'\n            // check all possible nodes at this level\n            if (ch == '.') {\n                for (auto x : node-&gt;children) {\n                    TrieNode* child = x.second;\n                    if (searchInNode(word.substr(i + 1), child)) {\n                        return true;\n                    }\n                }\n            }\n            // If no nodes lead to answer\n            // or the current character != '.'\n            return false;\n        } else {\n            // If the character is found\n            // go down to the next level in trie\n            node = node-&gt;children[ch];\n        }\n    }\n    return node-&gt;word;\n}\n​\n/** Returns if the word is in the data structure. A word could contain the dot\n * character '.' to represent any one letter. */\nbool search(string word) { return searchInNode(word, trie); }</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity: <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathcal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">M</span><span class=\"mclose\">)</span></span></span></span></span> for the \"well-defined\" words without dots, where <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">M</span></span></span></span></span> is the key length, and <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span></span></span></span></span> is a number of keys, and <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathcal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1.0913em; vertical-align: -0.25em;\"></span><span class=\"mord\">2</span><span class=\"mord\"><span class=\"mord\">6</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.8413em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right: 0.10903em;\">M</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span> for the \"undefined\" words. That corresponds to the worst-case situation of searching an undefined word <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1.4319em; vertical-align: -1.3263em;\"></span><span class=\"mord munder\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.1056em;\"><span style=\"top: -1.6737em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord text mtight\"><span class=\"mord mtight\">M&nbsp;times</span></span></span></span><span style=\"top: -3em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"mord munder\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.1056em;\"><span class=\"svg-align\" style=\"top: -2.352em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"stretchy\" style=\"height: 0.548em; min-width: 1.6em;\"><span class=\"brace-left\" style=\"height: 0.548em;\"><svg width=\"400em\" height=\"0.548em\" viewBox=\"0 0 400000 548\" preserveAspectRatio=\"xMinYMin slice\"><path d=\"M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13\n 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688\n 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7\n-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z\"></path></svg></span><span class=\"brace-center\" style=\"height: 0.548em;\"><svg width=\"400em\" height=\"0.548em\" viewBox=\"0 0 400000 548\" preserveAspectRatio=\"xMidYMin slice\"><path d=\"M199572 214\nc100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14\n 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3\n 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0\n-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z\"></path></svg></span><span class=\"brace-right\" style=\"height: 0.548em;\"><svg width=\"400em\" height=\"0.548em\" viewBox=\"0 0 400000 548\" preserveAspectRatio=\"xMaxYMin slice\"><path d=\"M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3\n 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237\n-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z\"></path></svg></span></span></span><span style=\"top: -3em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"mord\"><span class=\"mord\">.........</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.648em;\"><span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 1.3263em;\"><span></span></span></span></span></span></span></span></span></span> which is one character longer than all inserted keys.</p>\n</li>\n<li>\n<p>Space complexity: <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathcal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></span> for the search of \"well-defined\" words without dots, and up to <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathcal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">M</span><span class=\"mclose\">)</span></span></span></span></span> for the \"undefined\" words, to keep the recursion stack.</p>\n</li>\n</ul>\n<p><strong>Implementation</strong></p>\n<pre><code>struct TrieNode {\n    unordered_map&lt;char, TrieNode*&gt; children;\n    bool word = false;\n};\n​\nclass WordDictionary {\n    TrieNode* trie;\n​\npublic:\n    /** Initialize your data structure here. */\n    WordDictionary() { trie = new TrieNode(); }\n​\n    /** Adds a word into the data structure. */\n    void addWord(string word) {\n        TrieNode* node = trie;\n​\n        for (char ch : word) {\n            if (!node-&gt;children.count(ch)) {\n                node-&gt;children[ch] = new TrieNode();\n            }\n            node = node-&gt;children[ch];\n        }\n        node-&gt;word = true;\n    }\n​\n    /** Returns if the word is in the node. */\n    bool searchInNode(string word, TrieNode* node) {\n        for (int i = 0; i &lt; word.length(); ++i) {\n            char ch = word[i];\n            if (!node-&gt;children.count(ch)) {\n                // If the current character is '.'\n                // check all possible nodes at this level\n                if (ch == '.') {\n                    for (auto x : node-&gt;children) {\n                        TrieNode* child = x.second;\n                        if (searchInNode(word.substr(i + 1), child)) {\n                            return true;\n                        }\n                    }\n                }\n                // If no nodes lead to answer\n                // or the current character != '.'\n                return false;\n            } else {\n                // If the character is found\n                // go down to the next level in trie\n                node = node-&gt;children[ch];\n            }\n        }\n        return node-&gt;word;\n    }\n​\n    /** Returns if the word is in the data structure. A word could contain the\n     * dot character '.' to represent any one letter. */\n    bool search(string word) { return searchInNode(word, trie); }\n};</code></pre></div><span style=\"font-size: 0px; line-height: 0;\">&nbsp;</span></div>",
    "isOfficial": true,
    "scrapedAt": "2026-02-18T08:16:17.441Z"
  }
}