{
    "questionId": "271",
    "questionFrontendId": "271",
    "title": "Encode and Decode Strings",
    "titleSlug": "encode-and-decode-strings",
    "content": "<p>Design an algorithm to encode <b>a list of strings</b> to <b>a string</b>. The encoded string is then sent over the network and is decoded back to the original list of strings.</p>\n\n<p>Machine 1 (sender) has the function:</p>\n\n<pre>\nstring encode(vector&lt;string&gt; strs) {\n  // ... your code\n  return encoded_string;\n}</pre>\nMachine 2 (receiver) has the function:\n\n<pre>\nvector&lt;string&gt; decode(string s) {\n  //... your code\n  return strs;\n}\n</pre>\n\n<p>So Machine 1 does:</p>\n\n<pre>\nstring encoded_string = encode(strs);\n</pre>\n\n<p>and Machine 2 does:</p>\n\n<pre>\nvector&lt;string&gt; strs2 = decode(encoded_string);\n</pre>\n\n<p><code>strs2</code> in Machine 2 should be the same as <code>strs</code> in Machine 1.</p>\n\n<p>Implement the <code>encode</code> and <code>decode</code> methods.</p>\n\n<p>You are not allowed to&nbsp;solve the problem using any serialize methods (such as <code>eval</code>).</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> dummy_input = [&quot;Hello&quot;,&quot;World&quot;]\n<strong>Output:</strong> [&quot;Hello&quot;,&quot;World&quot;]\n<strong>Explanation:</strong>\nMachine 1:\nCodec encoder = new Codec();\nString msg = encoder.encode(strs);\nMachine 1 ---msg---&gt; Machine 2\n\nMachine 2:\nCodec decoder = new Codec();\nString[] strs = decoder.decode(msg);\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> dummy_input = [&quot;&quot;]\n<strong>Output:</strong> [&quot;&quot;]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= strs.length &lt;= 200</code></li>\n\t<li><code>0 &lt;= strs[i].length &lt;= 200</code></li>\n\t<li><code>strs[i]</code> contains any possible characters out of <code>256</code> valid ASCII characters.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up: </strong>Could you write a generalized algorithm to work on any possible set of characters?</p>\n",
    "difficulty": "Medium",
    "stats": "{\"totalAccepted\": \"297.2K\", \"totalSubmission\": \"580.9K\", \"totalAcceptedRaw\": 297234, \"totalSubmissionRaw\": 580914, \"acRate\": \"51.2%\"}",
    "hints": [],
    "similarQuestions": "[{\"title\": \"Count and Say\", \"titleSlug\": \"count-and-say\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Serialize and Deserialize Binary Tree\", \"titleSlug\": \"serialize-and-deserialize-binary-tree\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"String Compression\", \"titleSlug\": \"string-compression\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Count Binary Substrings\", \"titleSlug\": \"count-binary-substrings\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
    "topicTags": [
        {
            "name": "Array",
            "slug": "array"
        },
        {
            "name": "String",
            "slug": "string"
        },
        {
            "name": "Design",
            "slug": "design"
        }
    ],
    "companyTags": null,
    "codeSnippets": [
        {
            "lang": "C++",
            "langSlug": "cpp",
            "code": "class Codec {\npublic:\n\n    // Encodes a list of strings to a single string.\n    string encode(vector<string>& strs) {\n        \n    }\n\n    // Decodes a single string to a list of strings.\n    vector<string> decode(string s) {\n        \n    }\n};\n\n// Your Codec object will be instantiated and called as such:\n// Codec codec;\n// codec.decode(codec.encode(strs));"
        },
        {
            "lang": "Java",
            "langSlug": "java",
            "code": "public class Codec {\n\n    // Encodes a list of strings to a single string.\n    public String encode(List<String> strs) {\n        \n    }\n\n    // Decodes a single string to a list of strings.\n    public List<String> decode(String s) {\n        \n    }\n}\n\n// Your Codec object will be instantiated and called as such:\n// Codec codec = new Codec();\n// codec.decode(codec.encode(strs));"
        },
        {
            "lang": "Python3",
            "langSlug": "python3",
            "code": "class Codec:\n    def encode(self, strs: List[str]) -> str:\n        \"\"\"Encodes a list of strings to a single string.\n        \"\"\"\n        \n\n    def decode(self, s: str) -> List[str]:\n        \"\"\"Decodes a single string to a list of strings.\n        \"\"\"\n        \n\n\n# Your Codec object will be instantiated and called as such:\n# codec = Codec()\n# codec.decode(codec.encode(strs))"
        },
        {
            "lang": "Python",
            "langSlug": "python",
            "code": "class Codec:\n\n    def encode(self, strs):\n        \"\"\"Encodes a list of strings to a single string.\n        \n        :type strs: List[str]\n        :rtype: str\n        \"\"\"\n        \n\n    def decode(self, s):\n        \"\"\"Decodes a single string to a list of strings.\n        \n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        \n\n# Your Codec object will be instantiated and called as such:\n# codec = Codec()\n# codec.decode(codec.encode(strs))"
        },
        {
            "lang": "JavaScript",
            "langSlug": "javascript",
            "code": "/**\n * Encodes a list of strings to a single string.\n *\n * @param {string[]} strs\n * @return {string}\n */\nvar encode = function(strs) {\n    \n};\n\n/**\n * Decodes a single string to a list of strings.\n *\n * @param {string} s\n * @return {string[]}\n */\nvar decode = function(s) {\n    \n};\n\n/**\n * Your functions will be called as such:\n * decode(encode(strs));\n */"
        },
        {
            "lang": "TypeScript",
            "langSlug": "typescript",
            "code": "/**\n * Encodes a list of strings to a single string.\n */\nfunction encode(strs: string[]): string {\n\t\n};\n\n/**\n * Decodes a single string to a list of strings.\n */\nfunction decode(s: string): string[] {\n\t\n};\n\n/**\n * Your functions will be called as such:\n * decode(encode(strs));\n */"
        },
        {
            "lang": "C#",
            "langSlug": "csharp",
            "code": "public class Codec {\n\n    // Encodes a list of strings to a single string.\n    public string encode(IList<string> strs) {\n        \n    }\n\n    // Decodes a single string to a list of strings.\n    public IList<string> decode(string s) {\n        \n    }\n}\n\n// Your Codec object will be instantiated and called as such:\n// Codec codec = new Codec();\n// codec.decode(codec.encode(strs));"
        },
        {
            "lang": "C",
            "langSlug": "c",
            "code": "/** Encodes a list of strings to a single string */\nchar* encode(char** strs, int strsSize) {\n    \n}\n\n/**\n * Decodes a single string to a list of strings.\n *\n * Return an array of size *returnSize.\n * Note: The returned array must be malloced, assume caller calls free().\n */\nchar** decode(char* s, int* returnSize) {\n    \n}\n\n// Your functions will be called as such:\n// char* s = encode(strs, strsSize);\n// decode(s, &returnSize);"
        },
        {
            "lang": "Go",
            "langSlug": "golang",
            "code": "type Codec struct {\n    \n}\n\n// Encodes a list of strings to a single string.\nfunc (codec *Codec) Encode(strs []string) string {\n    \n}\n\n// Decodes a single string to a list of strings.\nfunc (codec *Codec) Decode(strs string) []string {\n    \n}\n\n// Your Codec object will be instantiated and called as such:\n// var codec Codec\n// codec.Decode(codec.Encode(strs));"
        },
        {
            "lang": "Kotlin",
            "langSlug": "kotlin",
            "code": "class Codec {\n    // Encodes a list of strings to a single string.\n    fun encode(strs: List<String>): String {\n        \n    }\n    \n    // Decodes a single string to a list of strings.\n    fun decode(s: String): List<String> {\n        \n    }\n}\n\n/**\n * Your Codec object will be instantiated and called as such:\n * var obj = Codec()\n * val s = obj.encode(strs)\n * val ans = obj.decode(s)\n */"
        },
        {
            "lang": "Swift",
            "langSlug": "swift",
            "code": "class Codec {\n    func encode(_ strs: [String]) -> String {\n        \n    }\n    \n    func decode(_ s: String) -> [String] {\n        \n    }\n}\n\n/**\n * Your Codec object will be instantiated and called as such:\n * let obj = Codec()\n * val s = obj.encode(strs)\n * let ans = obj.decode(s)\n*/"
        },
        {
            "lang": "Rust",
            "langSlug": "rust",
            "code": "struct Codec {\n\t\n}\n\n/** \n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl Codec {\n    fn new() -> Self {\n        \n    }\n\t\n    fn encode(&self, strs: Vec<String>) -> String {\n        \n    }\n\t\n    fn decode(&self, s: String) -> Vec<String> {\n        \n    }\n}\n\n/**\n * Your Codec object will be instantiated and called as such:\n * let obj = Codec::new();\n * let s: String = obj.encode(strs);\n * let ans: VecVec<String> = obj.decode(s);\n */"
        },
        {
            "lang": "Ruby",
            "langSlug": "ruby",
            "code": "# Encodes a list of strings to a single string.\n#\n# @param {string[]} strs\n# @return {string}\ndef encode(strs)\n    \nend\n\n# Decodes a single string to a list of strings.\n#\n# @param {string} s\n# @return {string[]}\ndef decode(s)\n    \nend\n\n\n# Your functions will be called as such:\n# decode(encode(strs))"
        },
        {
            "lang": "PHP",
            "langSlug": "php",
            "code": "class Codec {\n    /**\n     * @param String[] $strs\n     * @return String\n     */\n    function encode($strs) {\n        \n    }\n    \n    /**\n     * @param String $s\n     * @return String[]\n     */\n    function decode($s) {\n        \n    }\n}\n\n/**\n * Your Codec object will be instantiated and called as such:\n * $obj = Codec();\n * $s = $obj->encode($strs);\n * $ans = $obj->decode($s);\n */"
        },
        {
            "lang": "Scala",
            "langSlug": "scala",
            "code": "class Codec {\n    // Encodes a list of strings to a single string.\n    def encode(strs: List[String]): String = {\n        \n    }\n    \n    // Decodes a single string to a list of strings.\n    def decode(s: String): List[String] = {\n        \n    }\n}\n\n/**\n * Your Codec object will be instantiated and called as such:\n * var obj = new Codec()\n * val s = obj.encode(strs)\n * val ans = obj.decode(s)\n */"
        }
    ],
    "solution": {
        "content": "<h2><a href=\"#solution\"><svg><path></path></svg></a>Solution</h2>\n<hr/>\n<h3><a href=\"#approach-1-non-ascii-delimiter\"><svg><path></path></svg></a>Approach 1: Non-ASCII delimiter</h3>\n<h4>Intuition</h4>\n<p>Our problem is to encode and decode strings, which includes creating a single string from a list of strings and then reverting it back to the original list of strings. This can be a bit tricky since any string can contain any ASCII character.</p>\n<p>To accomplish this, we often use a <em>delimiter</em>, which is a special character or sequence of characters that we insert between each string when we combine them into one. The key thing about a delimiter is that it must be a character or sequence of characters that doesn't occur in the strings we're encoding. This allows us to correctly separate the strings when we decode them.</p>\n<p>In many cases, we might use a common ASCII character as the delimiter. <a href=\"https://en.wikipedia.org/wiki/ASCII\">ASCII (American Standard Code for Information Interchange)</a> is a character encoding standard that includes most of the characters you see on a standard keyboard, like letters, digits, punctuation marks, and some control characters. For example, it is common to use a delimiter like a comma to separate integers. However, if the strings we're encoding could contain any ASCII character, then we can't use an ASCII character as the delimiter, because we wouldn't know whether that character is part of a string or a delimiter.</p>\n<p>That's where the idea of a non-ASCII delimiter comes in. There are many more characters available than just the ones in the ASCII set. <a href=\"https://en.wikipedia.org/wiki/Unicode\">Unicode</a> is a character encoding standard that includes virtually every character from every writing system in the world, plus many symbols, control characters, and more. There are many Unicode characters that are not commonly used in text, and we can use one of these as our delimiter.</p>\n<p>For example, let's say we have a list of strings <code>[\"abc\", \"d,ef\"]</code> and we wanted to use a comma as a delimiter. We would end up with the string <code>\"abc,d,ef\"</code> which would be converted back as <code>[\"abc\", \"d\", \"ef\"]</code>, which is incorrect. We can't tell the difference between a comma being a delimiter or part of a string.</p>\n<p>In this approach, we could choose a Unicode character like <code>π</code>. We can use this character as our delimiter when we encode our list of strings, and then look for this character to find the boundaries between strings when we decode.</p>\n<p>This non-ASCII delimiter approach is simple and effective as long as we can be sure that the delimiter character won't appear in the strings we're encoding. However, it's worth noting that non-ASCII characters can sometimes be tricky to handle correctly, because not all systems or software handle non-ASCII characters in the same way.</p>\n<h4>Algorithm</h4>\n<h5>Encoding Process</h5>\n<ul>\n<li>Initialize an empty string (or a string builder/stream for efficiency) to hold the encoded string.</li>\n<li>Iterate over the strings in the list. For each string:\n<ul>\n<li>Add the string to the encoded string.</li>\n<li>After each string, add the non-ASCII delimiter <code>π</code> to the encoded string.</li>\n</ul>\n</li>\n<li>Once you've processed all the strings in the list, the resulting encoded string should be a concatenation of all the strings in the list, each followed by the non-ASCII delimiter.</li>\n</ul>\n<h5>Decoding Process</h5>\n<ul>\n<li>Initialize an empty list to hold the decoded strings.</li>\n<li>Split the encoded string by the non-ASCII delimiter <code>π</code>.</li>\n<li>The resulting list of strings is the decoded list.</li>\n</ul>\n<h4>Implementation</h4>\n<pre><code>public class Codec {\n    // Encodes a list of strings to a single string.\n    public String encode(List&lt;String&gt; strs) {\n        StringBuilder encodedString = new StringBuilder();\n        // Iterate through the list of strings\n        for (String s : strs) {\n            // Append each string to the StringBuilder followed by the delimiter\n            encodedString.append(s);\n            encodedString.append(\"π\");\n        }\n        // Return the entire encoded string\n        return encodedString.toString();\n    }\n​\n    // Decodes a single string to a list of strings.\n    public List&lt;String&gt; decode(String s) {\n        // Split the encoded string at each occurrence of the delimiter\n        // Note: We use -1 as the limit parameter to ensure trailing empty strings are included\n        String[] decodedStrings = s.split(\"π\", -1);\n        // Convert the array to a list and return it\n        // Note: We remove the last element because it's an empty string resulting from the final delimiter\n        return new ArrayList&lt;&gt;(Arrays.asList(decodedStrings).subList(0, decodedStrings.length - 1));\n    }\n}</code></pre>\n<h4>Complexity Analysis</h4>\n<p>Let n denote the total number of characters across all strings in the input list and k denote the number of strings.</p>\n<ul>\n<li>\n<p>Time Complexity: O(n).</p>\n<p>Both encoding and decoding processes iterate over every character in the input, thus they both have a linear time complexity of O(n).</p>\n</li>\n<li>\n<p>Space Complexity: O(k).</p>\n<p>We don't count the output as part of the space complexity, but for each word, we are using some space for the delimiter.</p>\n</li>\n</ul>\n<hr/>\n<h3><a href=\"#approach-2-escaping\"><svg><path></path></svg></a>Approach 2: Escaping</h3>\n<h4>Intuition</h4>\n<p>While the non-ASCII delimiter approach can work well for many applications, it assumes that the delimiter character will not appear in the strings to be encoded. However, in many practical situations, we cannot make this assumption. The strings might contain any possible character, including our chosen delimiter. Therefore, we need a different approach that can handle this situation.</p>\n<p>For our purpose, we select <code>/:</code> as the delimiter. This choice provides us with a unique pattern to signal the end of a string during the encoding and decoding process. However, there's still a potential issue: What happens if one of our strings naturally contains the sequence <code>/:</code>? Let's examine how we can resolve this situation.</p>\n<p><strong>Example 1: Simple approach works</strong></p>\n<p>Suppose we have the following list of strings: <code>[\"Hello\", \"World\", \"Nice\", \"To\", \"Meet\", \"You\"]</code>.</p>\n<p>If we use the simple approach to encode these strings, we just join them with our delimiter <code>/:</code> in between. This gives us: <code>Hello/:World/:Nice/:To/:Meet/:You/:</code>.</p>\n<p>When we decode this string, we split it at every <code>/:</code>, which gives us back our original list of strings: <code>[\"Hello\", \"World\", \"Nice\", \"To\", \"Meet\", \"You\"]</code>. So the simple approach works in this case.</p>\n<p><strong>Example 2: Simple approach does not work</strong></p>\n<p>Now suppose we have a different list of strings: <code>[\"Hello\", \"Wor/:ld\", \"Nice\", \"To\", \"Meet\", \"You\"]</code>.</p>\n<p>If we use the simple approach to encode these strings, we get: <code>Hello/:Wor/:ld/:Nice/:To/:Meet/:You/:</code>.</p>\n<p>However, when we decode this string by splitting it at every <code>/:</code>, we get: <code>[\"Hello\", \"Wor\", \"ld\", \"Nice\", \"To\", \"Meet\", \"You\"]</code>, which is not the same as our original list of strings.</p>\n<p>The string <code>Wor/:ld</code> has been incorrectly split into two strings: <code>Wor</code> and <code>ld</code>. The problem is that our delimiter <code>/:</code> appears in the original string <code>Wor/:ld</code>, which confuses our simple encoding and decoding approach.</p>\n<p>To handle this, we use a technique called <em>escaping</em>. This is a common concept in computer programming.</p>\n<p>So, what's the purpose of escaping? Let's say you have a character that has a special meaning in a certain context, like our delimiter <code>/:</code>. If this character sequence appears in our original strings, it might confuse our encoding and decoding process. We need a way to signal that in this particular instance, we don't want to treat <code>/:</code> as a delimiter but as a part of the original string.</p>\n<p>This is where escaping comes in. By choosing a specific character to act as an \"escape character\", we can denote that any special character following the escape character should be treated as a normal character instead of its special meaning. Here we choose the slash character <code>/</code> as our escape character.</p>\n<p>Let's illustrate with an example. Consider we have a string <code>Wor/:ld</code>. To avoid our delimiter <code>/:</code> being misinterpreted, we would \"escape\" the slash before the colon, making it <code>//:</code>. So, the string becomes <code>Wor//:ld</code>. Now, our encoding and decoding process will understand that <code>/:</code> in this context is not a delimiter, but a part of the original string.</p>\n<p>Let's consider another example using the escaping approach for the problem. In this case, our input list of strings is: <code>[\"Hello\", \"World/:\", \"How/are you?\"]</code>.</p>\n<p>We have one string <code>World/:</code> that contains our delimiter sequence <code>/:</code> and another string <code>How/are you?</code> that contains the slash character <code>/</code>.</p>\n<p>First, we'll encode the list of strings into a single string.</p>\n<p>We iterate over each string in the list, and for each string, we iterate over each character. If a character is a slash <code>/</code>, we add another slash to escape it, resulting in <code>//</code>. If a character is not a slash, we simply add it to the output string. After we've processed all the characters in a string, we append our delimiter <code>/:</code> to mark the end of that string.</p>\n<p>This gives us the following encoded string: <code>Hello/:World//:/:How//are you?/:</code>.</p>\n<p>Now, we'll decode the encoded string back into a list of strings.</p>\n<p>We initialize an empty list to hold the decoded strings and an empty string to build the current string. Then, we iterate over the characters in the encoded string.</p>\n<p>If a character is our escape character <code>/</code>, we check the next character. If the next character is also a slash (so we have <code>//</code>), it indicates that the original string had a <code>/</code> and we just escaped it. However, if the next character is a <code>:</code> (so we have <code>/:</code>), it is our delimiter.</p>\n<ol>\n<li>If we find two characters <code>//</code>, it indicates an escaped slash. We add <code>/</code> to the current string and move on.</li>\n<li>If we find two characters <code>/:</code>, it indicates our delimiter. We add the current string to the output, clear it, and move on.</li>\n</ol>\n<p>So, how does the algorithm detect when the delimiter <code>/:</code> is part of a string? In the encoded string, <code>/:</code> is converted to <code>//:</code>. As we iterate over the encoded string, we see <code>//</code> (case 1), add <code>/</code>, and then move on to the <code>:</code>. To summarize:</p>\n<ol>\n<li>If we see <code>//:</code>, it means <code>/:</code> was part of a string, not a delimiter. The first slash is the escape character and what comes after it is the contents of the string.</li>\n<li>If we see <code>/:</code>, it must be a delimiter, because if it wasn't then it would have been escaped to <code>//:</code>.</li>\n</ol>\n<p>After we've processed all the characters in the encoded string, we return the list of decoded strings.</p>\n<p>This gives us our original list of strings: <code>[\"Hello\", \"World/:\", \"How/are you?\"]</code>.</p>\n<p>When we decode the string, we would recognize the escape character and understand that the <code>/:</code> sequence that follows is not a delimiter but part of the original string.</p>\n<p>The concept of escaping in computing is widely used and has many real-world applications. Here are a few examples:</p>\n<ul>\n<li>\n<p><strong>HTML and XML</strong>: In these markup languages, the characters <code>&lt;</code>, <code>&gt;</code>, and <code>&amp;</code> have special meanings and are used to denote tags and entities. If you want to include these characters as text in a document, you need to use their escaped versions: <code>&amp;lt;</code>, <code>&amp;gt;</code>, and <code>&amp;amp;</code>.</p>\n</li>\n<li>\n<p><strong>SQL Queries</strong>: In SQL, single quotes are used to denote string literals. To include a single quote within the string itself, you need to escape it using two single quotes: <code>'It''s a sunny day'</code>.</p>\n</li>\n<li>\n<p><strong>Regular Expressions</strong>: In regex, many characters like <code>.</code>, <code>*</code>, <code>+</code>, <code>?</code>, <code>^</code>, <code>(</code>, <code>)</code>, <code>{</code>, <code>}</code>, <code>[</code>, <code>]</code>, <code>\\</code>, <code>|</code>, <code>/</code> have special meanings. If you want to match these characters literally, you need to escape them using a backslash.</p>\n</li>\n<li>\n<p><strong>Programming Languages</strong>: Almost all programming languages have some form of escape sequences to denote special characters. For example, in Python, Java, and C++, <code>\\\\n</code> denotes a newline, <code>\\\\t</code> denotes a tab, <code>\\\\\"</code> is used for a double quote within a string that is enclosed by double quotes, and <code>\\\\'</code> is used for a single quote within a string that is enclosed by single quotes.</p>\n</li>\n</ul>\n<p>These examples illustrate the escaping technique's importance in handling special characters across various domains in computing.</p>\n<h4>Algorithm</h4>\n<h5>Encoding Process</h5>\n<ul>\n<li>Initialize an empty string (or a string builder/stream for efficiency) to hold the encoded string.</li>\n<li>Iterate over each string in the input list. For each string:\n<ul>\n<li>Replace each occurrence of the slash character <code>/</code> with two slash characters <code>//</code>. This is our way of \"escaping\" the slash character.</li>\n<li>Add the escaped string and our chosen delimiter <code>/:</code> to the encoded string.</li>\n</ul>\n</li>\n<li>Return the encoded string after all strings in the input list have been processed.</li>\n</ul>\n<h5>Decoding Process</h5>\n<ul>\n<li>Initialize an empty list to hold the decoded strings.</li>\n<li>Initialize an empty string to build the current string being decoded.</li>\n<li>Iterate over the characters in the encoded string. For each character:\n<ul>\n<li>If the character and the next one form the delimiter <code>/:</code>, add the current string to the list of decoded strings and clear the current string for the next one. Skip the next character in the string.</li>\n<li>If the character and the next one form the escaped slash <code>//</code>, add a single slash to the current string. Skip the next character in the string.</li>\n<li>Otherwise, add the character to the current string.</li>\n</ul>\n</li>\n<li>Return the list of decoded strings after all characters in the encoded string have been processed.</li>\n</ul>\n<h4>Implementation</h4>\n<pre><code>class Codec {\npublic:\n    // Encodes a list of strings to a single string.\n    string encode(vector&lt;string&gt;&amp; strs) {\n        // Initialize a string to hold the encoded strings\n        string encodedString;\n​\n        // Iterate over each string in the input list\n        for (const auto&amp; s : strs) {\n            // For each string, iterate over each character\n            for (const char c : s) {\n                // If the character is a slash, append an additional slash to 'encodedString'\n                if (c == '/') {\n                    encodedString += \"//\";\n                }\n                // Otherwise, simply append the character to 'encodedString'\n                else {\n                    encodedString += c;\n                }\n            }\n            // After encoding each string, append the delimiter \"/:\"\n            encodedString += \"/:\";\n        }\n​\n        // Return the final encoded string\n        return encodedString;\n    }\n​\n    // Decodes a single string to a list of strings.\n    vector&lt;string&gt; decode(string s) {\n        // Initialize a vector to hold the decoded strings\n        vector&lt;string&gt; decodedStrings;\n​\n        // Initialize a string to hold the current string being decoded\n        string currentString;\n​\n        // Iterate over the characters in the input string\n        for (size_t i = 0; i &lt; s.size(); i++) {\n            // If we encounter the delimiter \"/:\"\n            if (i &lt; s.size()-1 &amp;&amp; s[i] == '/' &amp;&amp; s[i+1] == ':') {\n                // Add the current string to 'decodedStrings'\n                decodedStrings.push_back(currentString);\n​\n                // Clear 'currentString' for the next string\n                currentString.clear();\n​\n                // Move the index 1 step forward to skip the delimiter\n                i += 1;\n            }\n            // If we encounter an escaped slash \"//\"\n            else if (i &lt; s.size()-1 &amp;&amp; s[i] == '/' &amp;&amp; s[i+1] == '/') {\n                // Add a single slash to the 'currentString'\n                currentString += '/';\n​\n                // Move the index 1 step forward to skip the escaped slash\n                i += 1;\n            }\n            // Otherwise, just add the character to 'currentString'\n            else {\n                currentString += s[i];\n            }\n        }\n​\n        // Return the list of decoded strings\n        return decodedStrings;\n    }\n};</code></pre>\n<h4>Complexity Analysis</h4>\n<p>Let n denote the total number of characters across all strings in the input list and k denote the number of strings.</p>\n<ul>\n<li>\n<p>Time Complexity: O(n).</p>\n<p>Both encoding and decoding processes iterate over every character in the input, thus they both have a linear time complexity of O(n).</p>\n</li>\n<li>\n<p>Space Complexity: O(k).</p>\n<p>We don't count the output as part of the space complexity, but for each word, we are using some space for the escape character and delimiter.</p>\n</li>\n</ul>\n<hr/>\n<h3><a href=\"#approach-3-chunked-transfer-encoding\"><svg><path></path></svg></a>Approach 3: Chunked Transfer Encoding</h3>\n<h4>Intuition</h4>\n<p>Chunked transfer encoding is a method used in data communication protocols to send data in self-contained <em>chunks</em>, each of which is accompanied by its length or size. In the context of our problem, this technique can be very useful.</p>\n<p>In our encoding process, instead of just joining all the strings together with a delimiter, we would precede each string with its length, followed by a delimiter, and then the string itself. This way, even if our string contains the delimiter, we can correctly identify the string boundaries.</p>\n<p>When we decode our encoded string, we know that the first item before the delimiter is the length of the string.</p>\n<p>Consider an example for a list of strings using chunked transfer encoding.</p>\n<p>Suppose we have the following list of strings: <code>[\"Hello\", \"World\", \"/:Example/:\"]</code>. As you can see, our last string even contains the <code>/:</code> character sequence that we might choose as our delimiter.</p>\n<p>Let's see how we would encode and decode this using chunked transfer encoding.</p>\n<p><strong>Encoding:</strong></p>\n<p>For the encoding, we take each string's length, followed by a delimiter (we'll use <code>/:</code>), and then the string itself.</p>\n<p>For <code>\"Hello\"</code>, the length is 5. So we start our encoded string with <code>5/:Hello</code>.</p>\n<p>Next, for <code>\"World\"</code>, the length is 5 as well. So we add <code>5/:World</code> to our encoded string.</p>\n<p>Finally, for <code>\"/:Example/:\"</code>, the length is 11. We add <code>11/:/:Example/:</code> to our encoded string.</p>\n<p>After processing all strings, our encoded string becomes <code>5/:Hello5/:World11/:/:Example/:</code>.</p>\n<p><strong>Decoding:</strong></p>\n<p>For the decoding process, we start reading the encoded string.</p>\n<p>First, we read until we encounter <code>/:</code>, which gives us <code>5</code>. This tells us that the length of our first string is 5. So, we read the next 5 characters to get <code>\"Hello\"</code>.</p>\n<p>Next, we again read until <code>/:</code> to get <code>5</code>, indicating that our next string is of length 5. Reading the next 5 characters gives us <code>\"World\"</code>.</p>\n<p>Finally, reading until the next <code>/:</code> gives us 11. Reading the next 11 characters gives us <code>\"/:Example/:\"</code>.</p>\n<p>After processing the whole encoded string, we are left with the original list of strings: <code>[\"Hello\", \"World\", \"/:Example/:\"]</code>.</p>\n<p>Through this process, we have successfully encoded and decoded our list of strings using chunked transfer encoding. Even though our list contained a string with the delimiter sequence, we were still able to accurately encode and decode the list.</p>\n<p>The advantage of this method is that it doesn't matter what characters our string consists of. It could include the delimiter, or any other special or non-ASCII characters, and we would still correctly encode and decode the list of strings. This is because we always know where each string starts and ends, thanks to the length prefix.</p>\n<p>Numbers being in the string can't confuse the algorithm either since the number characters would be after the delimiter <code>/:</code>. For example, let's say we had <code>[\"Hello\", \"32World\", \"Example\"]</code>. It would encode to <code>\"5/:Hello7:/32World7:/Example\"</code>. We read the <code>7</code>, then stop upon seeing the delimiter, and the 32 being a number is irrelevant.</p>\n<h4>Algorithm</h4>\n<blockquote>\n<p>Note: we are using <code>/:</code> as a delimiter solely for continuity (as we used it in the previous approach). However, we could use any non-digit delimiter for this approach, like <code>#</code> for example.</p>\n</blockquote>\n<h5>Encoding Process</h5>\n<ul>\n<li>Initialize an empty string (or a string builder/stream for efficiency) to hold the encoded string.</li>\n<li>Iterate over the list of strings. For each string:\n<ul>\n<li>Calculate the length of the string.</li>\n<li>Append the string length to the encoded string, followed by the delimiter.</li>\n<li>Append the string itself to the encoded string.</li>\n</ul>\n</li>\n</ul>\n<p>This way, each string in our encoded string is prefixed by its length and a delimiter.</p>\n<h5>Decoding Process</h5>\n<ul>\n<li>Initialize an empty list to hold the decoded strings.</li>\n<li>Start reading the encoded string. Until you reach the end of the string:\n<ul>\n<li>First, read characters until you hit the delimiter. This part will be the string length (since we encoded it that way).</li>\n<li>Convert this part to an integer. Let's call it length.</li>\n<li>Read the next length characters (not including the delimiter). This part will be the original string.</li>\n<li>Add this string to our decoded strings list.</li>\n</ul>\n</li>\n</ul>\n<h4>Implementation</h4>\n<pre><code>class Codec {\npublic:\n    string encode(vector&lt;string&gt;&amp; strs) {\n        // Initialize an empty string to hold the encoded string.\n        string encodedString;\n        for (string &amp;s : strs) {\n            // Append the length, the delimiter, and the string itself.\n            encodedString += to_string(s.size()) + \"/:\" + s;\n        }\n        return encodedString;\n    }\n​\n    vector&lt;string&gt; decode(string s) {\n        // Initialize a list to hold the decoded strings.\n        vector&lt;string&gt; decodedStrings;\n        size_t i = 0;\n        while (i &lt; s.size()) {\n            // Find the delimiter.\n            size_t delim = s.find(\"/:\", i);\n            // Get the length, which is before the delimiter.\n            int length = stoi(s.substr(i, delim - i));\n            // Get the string, which is of 'length' length after the delimiter.\n            string str = s.substr(delim + 2, length);\n            // Add the string to the list.\n            decodedStrings.push_back(str);\n            // Move the index to the start of the next length.\n            i = delim + 2 + length;\n        }\n        return decodedStrings;\n    }\n};</code></pre>\n<h4>Complexity Analysis</h4>\n<p>Let n denote the total number of characters across all strings in the input list and k denote the number of strings.</p>\n<ul>\n<li>\n<p>Time Complexity: O(n).</p>\n<p>We are iterating through each string once.</p>\n</li>\n<li>\n<p>Space Complexity: O(k).</p>\n<p>We don't count the output as part of the space complexity, but for each word, we are using some space for the length and delimiter.</p>\n</li>\n</ul>",
        "isOfficial": true,
        "scrapedAt": "2026-02-18T08:57:55.671Z"
    }
}