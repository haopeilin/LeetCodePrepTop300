{
    "questionId": "260",
    "questionFrontendId": "260",
    "title": "Single Number III",
    "titleSlug": "single-number-iii",
    "content": "<p>Given an integer array <code>nums</code>, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once. You can return the answer in <strong>any order</strong>.</p>\n\n<p>You must write an&nbsp;algorithm that runs in linear runtime complexity and uses&nbsp;only constant extra space.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,1,3,2,5]\n<strong>Output:</strong> [3,5]\n<strong>Explanation: </strong> [5, 3] is also a valid answer.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [-1,0]\n<strong>Output:</strong> [-1,0]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [0,1]\n<strong>Output:</strong> [1,0]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li>Each integer in <code>nums</code> will appear twice, only two integers will appear once.</li>\n</ul>\n",
    "difficulty": "Medium",
    "stats": "{\"totalAccepted\": \"581.8K\", \"totalSubmission\": \"826.2K\", \"totalAcceptedRaw\": 581778, \"totalSubmissionRaw\": 826193, \"acRate\": \"70.4%\"}",
    "hints": [],
    "similarQuestions": "[{\"title\": \"Single Number\", \"titleSlug\": \"single-number\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Single Number II\", \"titleSlug\": \"single-number-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Find The Original Array of Prefix Xor\", \"titleSlug\": \"find-the-original-array-of-prefix-xor\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Find the XOR of Numbers Which Appear Twice\", \"titleSlug\": \"find-the-xor-of-numbers-which-appear-twice\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
    "topicTags": [
        {
            "name": "Array",
            "slug": "array"
        },
        {
            "name": "Bit Manipulation",
            "slug": "bit-manipulation"
        }
    ],
    "companyTags": null,
    "codeSnippets": [
        {
            "lang": "Java",
            "langSlug": "java",
            "code": "class Solution {\n    public int[] singleNumber(int[] nums) {\n        \n    }\n}"
        }
    ],
    "solution": {
        "content": "<h2><a href=\"#solution\"><svg><path></path></svg></a>Solution</h2>\n<hr/>\n<h3><a href=\"#overview\"><svg><path></path></svg></a>Overview</h3>\n<p>The problem could be solved in O(N) time and O(N) space by using a hashmap.</p>\n<p>Solving the problem in a constant space is a bit tricky but could be done with the help of two bitmasks.</p>\n<p><br/>\n<br/><br/>\n<br/></p>\n<hr/>\n<h3><a href=\"#approach-1-hashmap\"><svg><path></path></svg></a>Approach 1: Hashmap</h3>\n<p>Build a hashmap: element -&gt; its frequency. Return only the elements with the frequency equal to 1.</p>\n<p><strong>Implementation</strong></p>\n<pre><code>class Solution {\n \u00a0public int[] singleNumber(int[] nums) {\n \u00a0 \u00a0Map&lt;Integer, Integer&gt; hashmap = new HashMap();\n \u00a0 \u00a0for (int n : nums)\n \u00a0 \u00a0 \u00a0hashmap.put(n, hashmap.getOrDefault(n, 0) + 1);\n\u200b\n \u00a0 \u00a0int[] output = new int[2];\n \u00a0 \u00a0int idx = 0;\n \u00a0 \u00a0for (Map.Entry&lt;Integer, Integer&gt; item : hashmap.entrySet())\n \u00a0 \u00a0 \u00a0if (item.getValue() == 1) output[idx++] = item.getKey();\n\u200b\n \u00a0 \u00a0return output;\n  }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : O(N) to iterate over the input array.</p>\n</li>\n<li>\n<p>Space complexity : O(N) to keep the hashmap of N elements.</p>\n<br/>\n</li>\n</ul>\n<br/>\n<hr/>\n<h3><a href=\"#approach-2-two-bitmasks\"><svg><path></path></svg></a>Approach 2: Two bitmasks</h3>\n<p><strong>Prerequisites</strong></p>\n<p>This article will use two bitwise tricks, discussed in detail last week :</p>\n<ul>\n<li>If one builds an array bitmask with the help of the XOR operator, following <code>bitmask ^= x</code> strategy, the bitmask would keep only the bits that appear odd number of times. That was discussed in detail in the article <a href=\"https://leetcode.com/articles/single-number-ii/\">Single Number II</a>.</li>\n</ul>\n<p></p>\n<ul>\n<li><code>x &amp; (-x)</code> is a way to isolate the rightmost 1-bit, i.e. to keep the rightmost 1-bit and to set all the other bits to zero. Please refer to the article <a href=\"https://leetcode.com/articles/power-of-two/\">Power of Two</a> for a detailed explanation.</li>\n</ul>\n<p></p>\n<p><strong>Intuition</strong></p>\n<blockquote>\n<p>An interview tip. Imagine, you have a problem identifying an array element (or elements), which appears exactly a given number of times. Probably, the key is to build first an array bitmask using the XOR operator. Examples: <a href=\"leetcode.com/articles/single-number-ii/356460/Single-Number-II/324042\">In-Place Swap</a>, <a href=\"https://leetcode.com/articles/single-number/\">Single Number</a>, <a href=\"leetcode.com/articles/single-number-ii/356460/Single-Number-II/324042\">Single Number II</a>.</p>\n</blockquote>\n<p>So let's create an array bitmask: <code>bitmask ^= x</code>. This bitmask will <em>not</em> keep any number that appears twice because the XOR of two equal bits results in a zero bit <code>a^a = 0</code>.</p>\n<p>Instead, the bitmask would keep only the difference between two numbers (let's call them x and y) which appear just once. The difference here it's the bits that are different for x and y.</p>\n<p></p>\n<blockquote>\n<p>Could we extract x and y directly from this bitmask? No. However, we could use this bitmask as a marker to separate x and y.</p>\n</blockquote>\n<p>Let's do <code>bitmask &amp; (-bitmask)</code> to isolate the rightmost 1-bit, which is different between x and y. Let's say this is 1-bit for x and 0-bit for y.</p>\n<p></p>\n<p>Now let's use XOR as before, but for the new bitmask <code>x_bitmask</code>, which will contain only the numbers which have 1-bit in the position of <code>bitmask &amp; (-bitmask)</code>. This way, this new bitmask will contain only number x <code>x_bitmask = x</code>, because of two reasons:</p>\n<ul>\n<li>\n<p>y has 0-bit in the position <code>bitmask &amp; (-bitmask)</code> and hence will not enter this new bitmask.</p>\n</li>\n<li>\n<p>All numbers but x will not be visible in this new bitmask because they appear two times.</p>\n</li>\n</ul>\n<p></p>\n<p>Voila, x is identified. Now to identify y is simple: <code>y = bitmask^x</code>.</p>\n<p><strong>Implementation</strong></p>\n<pre><code>class Solution {\n \u00a0public int[] singleNumber(int[] nums) {\n \u00a0 \u00a0// difference between two numbers (x and y) which were seen only once\n \u00a0 \u00a0int bitmask = 0;\n \u00a0 \u00a0for (int num : nums) bitmask ^= num;\n\u200b\n \u00a0 \u00a0// rightmost 1-bit diff between x and y\n \u00a0 \u00a0int diff = bitmask &amp; (-bitmask);\n\u200b\n \u00a0 \u00a0int x = 0;\n \u00a0 \u00a0// bitmask which will contain only x\n \u00a0 \u00a0for (int num : nums) if ((num &amp; diff) != 0) x ^= num;\n\u200b\n \u00a0 \u00a0return new int[]{x, bitmask^x};\n  }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : O(N) to iterate over the input array.</p>\n</li>\n<li>\n<p>Space complexity : O(1), it's a constant space solution.</p>\n</li>\n</ul>",
        "isOfficial": true,
        "scrapedAt": "2026-02-18T07:45:57.454Z"
    }
}