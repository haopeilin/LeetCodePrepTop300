{
    "questionId": "181",
    "questionFrontendId": "181",
    "title": "Employees Earning More Than Their Managers",
    "titleSlug": "employees-earning-more-than-their-managers",
    "content": "<p>Table: <code>Employee</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| id          | int     |\n| name        | varchar |\n| salary      | int     |\n| managerId   | int     |\n+-------------+---------+\nid is the primary key (column with unique values) for this table.\nEach row of this table indicates the ID of an employee, their name, salary, and the ID of their manager.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution&nbsp;to find the employees who earn more than their managers.</p>\n\n<p>Return the result table in <strong>any order</strong>.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nEmployee table:\n+----+-------+--------+-----------+\n| id | name  | salary | managerId |\n+----+-------+--------+-----------+\n| 1  | Joe   | 70000  | 3         |\n| 2  | Henry | 80000  | 4         |\n| 3  | Sam   | 60000  | Null      |\n| 4  | Max   | 90000  | Null      |\n+----+-------+--------+-----------+\n<strong>Output:</strong> \n+----------+\n| Employee |\n+----------+\n| Joe      |\n+----------+\n<strong>Explanation:</strong> Joe is the only employee who earns more than his manager.\n</pre>\n",
    "difficulty": "Easy",
    "stats": "{\"totalAccepted\": \"1.1M\", \"totalSubmission\": \"1.5M\", \"totalAcceptedRaw\": 1083190, \"totalSubmissionRaw\": 1487852, \"acRate\": \"72.8%\"}",
    "hints": [],
    "similarQuestions": "[]",
    "topicTags": [
        {
            "name": "Database",
            "slug": "database"
        }
    ],
    "companyTags": null,
    "codeSnippets": [],
    "solution": {
        "content": "<h1><a href=\"#solution\"><svg><path></path></svg></a>Solution</h1>\n<hr/>\n<h2><a href=\"#pandas\"><svg><path></path></svg></a>pandas</h2>\n<h3><a href=\"#approach-1-self-merge-with-an-inner-join\"><svg><path></path></svg></a>Approach 1: Self-Merge with an Inner Join</h3>\n<h4>Algorithm</h4>\n<p>We first merge the <code>employee</code> table with itself to obtain the salary information of managers for each employee. Note that we set <code>how=inner</code> because we only need the rows where there is a match between the <code>managerId</code> and <code>id</code> columns. An inner join will return only the employees whose manager is not NULL.</p>\n<pre><code>// Perform a self-join on the employee list using Java streams\nList&lt;EmployeeJoin&gt; joined = employees.stream()\n    .filter(e -&gt; e.getManagerId() != null)\n    .flatMap(e -&gt; employees.stream()\n        .filter(m -&gt; m.getId().equals(e.getManagerId()))\n        .map(m -&gt; new EmployeeJoin(e, m)))\n    .collect(Collectors.toList());</code></pre><svg><path></path></svg>\n<blockquote>\n<p>Since there will be two columns with the same name after the merge operation, we need to assign suffixes to both tables. By default, the suffixes are <code>_x</code> and <code>_y</code>. In this problem, the left and right tables can be treated as information for employees and managers, respectively. Therefore, we use <code>_e</code> and <code>_m</code> for better understanding.</p>\n</blockquote>\n<table><thead><tr><th>id_e</th><th>name_e</th><th>salary_e</th><th>managerId_e</th><th>id_m</th><th>name_m</th><th>salary_m</th><th>managerId_m</th></tr></thead><tbody><tr><td>1</td><td>Joe</td><td>70000</td><td>3</td><td>3</td><td>Sam</td><td>60000</td><td>null</td></tr><tr><td>2</td><td>Henry</td><td>80000</td><td>4</td><td>4</td><td>Max</td><td>90000</td><td>null</td></tr></tbody></table>\n<br/>\n<p>Next, because we have the employee salary <code>salary_e</code> and their manager's salary <code>salary_m</code>, we can use a filter operation to select rows of interest. In addition, we only select one field, which is the name of the employee <code>name_e</code>.</p>\n<pre><code>// Filter employees whose salary is greater than their manager's salary\nList&lt;String&gt; result = joined.stream()\n    .filter(j -&gt; j.getEmployee().getSalary() &gt; j.getManager().getSalary())\n    .map(j -&gt; j.getEmployee().getName())\n    .collect(Collectors.toList());</code></pre><svg><path></path></svg>\n<table><thead><tr><th>name_e</th></tr></thead><tbody><tr><td>Joe</td></tr></tbody></table>\n<p>Finally, we rename the column to <code>Employee</code> and return the result.</p>\n<pre><code>// Wrap the result into the expected output structure\nList&lt;EmployeeResult&gt; output = result.stream()\n    .map(name -&gt; new EmployeeResult(name))\n    .collect(Collectors.toList());</code></pre><svg><path></path></svg>\n<h4>Implementation</h4>\n<pre><code>import java.util.*;\nimport java.util.stream.*;\n\npublic class Solution {\n\n    public static List&lt;EmployeeResult&gt; findEmployees(List&lt;Employee&gt; employees) {\n\n        List&lt;EmployeeJoin&gt; joined = employees.stream()\n            .filter(e -&gt; e.getManagerId() != null)\n            .flatMap(e -&gt; employees.stream()\n                .filter(m -&gt; m.getId().equals(e.getManagerId()))\n                .map(m -&gt; new EmployeeJoin(e, m)))\n            .collect(Collectors.toList());\n\n        return joined.stream()\n            .filter(j -&gt; j.getEmployee().getSalary() &gt; j.getManager().getSalary())\n            .map(j -&gt; new EmployeeResult(j.getEmployee().getName()))\n            .collect(Collectors.toList());\n    }\n}</code></pre>\n<hr/>\n<h2><a href=\"#database\"><svg><path></path></svg></a>Database</h2>\n<h3><a href=\"#approach-1-using-where-clause\"><svg><path></path></svg></a>Approach 1: Using <code>WHERE</code> clause</h3>\n<h4>Algorithm</h4>\n<p>As this table has the employee's manager information, we probably need to select information from it twice.</p>\n<pre><code>// Java representation of a Cartesian product using nested loops\nfor (Employee a : employees) {\n    for (Employee b : employees) {\n        // combine a and b\n    }\n}</code></pre><svg><path></path></svg>\n<blockquote>\n<p>Note: The keyword 'AS' is optional.</p>\n</blockquote>\n<table><thead><tr><th>Id</th><th>Name</th><th>Salary</th><th>ManagerId</th><th>Id</th><th>Name</th><th>Salary</th><th>ManagerId</th></tr></thead><tbody><tr><td>1</td><td>Joe</td><td>70000</td><td>3</td><td>1</td><td>Joe</td><td>70000</td><td>3</td></tr><tr><td>2</td><td>Henry</td><td>80000</td><td>4</td><td>1</td><td>Joe</td><td>70000</td><td>3</td></tr><tr><td>3</td><td>Sam</td><td>60000</td><td></td><td>1</td><td>Joe</td><td>70000</td><td>3</td></tr><tr><td>4</td><td>Max</td><td>90000</td><td></td><td>1</td><td>Joe</td><td>70000</td><td>3</td></tr><tr><td>1</td><td>Joe</td><td>70000</td><td>3</td><td>2</td><td>Henry</td><td>80000</td><td>4</td></tr><tr><td>2</td><td>Henry</td><td>80000</td><td>4</td><td>2</td><td>Henry</td><td>80000</td><td>4</td></tr><tr><td>3</td><td>Sam</td><td>60000</td><td></td><td>2</td><td>Henry</td><td>80000</td><td>4</td></tr><tr><td>4</td><td>Max</td><td>90000</td><td></td><td>2</td><td>Henry</td><td>80000</td><td>4</td></tr><tr><td>1</td><td>Joe</td><td>70000</td><td>3</td><td>3</td><td>Sam</td><td>60000</td><td></td></tr><tr><td>2</td><td>Henry</td><td>80000</td><td>4</td><td>3</td><td>Sam</td><td>60000</td><td></td></tr><tr><td>3</td><td>Sam</td><td>60000</td><td></td><td>3</td><td>Sam</td><td>60000</td><td></td></tr><tr><td>4</td><td>Max</td><td>90000</td><td></td><td>3</td><td>Sam</td><td>60000</td><td></td></tr><tr><td>1</td><td>Joe</td><td>70000</td><td>3</td><td>4</td><td>Max</td><td>90000</td><td></td></tr><tr><td>2</td><td>Henry</td><td>80000</td><td>4</td><td>4</td><td>Max</td><td>90000</td><td></td></tr><tr><td>3</td><td>Sam</td><td>60000</td><td></td><td>4</td><td>Max</td><td>90000</td><td></td></tr><tr><td>4</td><td>Max</td><td>90000</td><td></td><td>4</td><td>Max</td><td>90000</td><td></td></tr></tbody></table>\n<blockquote>\n<p>The first 3 columns are from a and the last 3 ones are from b.</p>\n</blockquote>\n<p>Select from two tables will get the <a href=\"https://en.wikipedia.org/wiki/Cartesian_product\">Cartesian product</a> of these two tables. In this case, the output will be 4*4 = 16 records. However, what we interest is the employee's salary higher than his/her manager. So we should add two conditions in a <code>WHERE</code> clause like below.</p>\n<pre><code>// Apply conditions equivalent to a WHERE clause\nfor (Employee a : employees) {\n    for (Employee b : employees) {\n        if (a.getManagerId() != null\n            &amp;&amp; a.getManagerId().equals(b.getId())\n            &amp;&amp; a.getSalary() &gt; b.getSalary()) {\n            // valid record\n        }\n    }\n}</code></pre><svg><path></path></svg>\n<table><thead><tr><th>Id</th><th>Name</th><th>Salary</th><th>ManagerId</th><th>Id</th><th>Name</th><th>Salary</th><th>ManagerId</th></tr></thead><tbody><tr><td>1</td><td>Joe</td><td>70000</td><td>3</td><td>3</td><td>Sam</td><td>60000</td><td></td></tr></tbody></table>\n<p>As we only need to output the employee's name, so we modify the above code a little to get a solution.</p>\n<h4>Implementation</h4>\n<pre><code>List&lt;String&gt; result = new ArrayList&lt;&gt;();\nfor (Employee a : employees) {\n    for (Employee b : employees) {\n        if (a.getManagerId() != null\n            &amp;&amp; a.getManagerId().equals(b.getId())\n            &amp;&amp; a.getSalary() &gt; b.getSalary()) {\n            result.add(a.getName());\n        }\n    }\n}</code></pre><svg><path></path></svg>\n<br/>\n<h3><a href=\"#approach-2-using-join-clause\"><svg><path></path></svg></a>Approach 2: Using <code>JOIN</code> clause</h3>\n<h4>Algorithm</h4>\n<p>Actually, <code>JOIN</code> is a more common and efficient way to link tables together, and we can use <code>ON</code> to specify some conditions.</p>\n<h4>Implementation</h4>\n<pre><code>// Java stream-based join equivalent\nList&lt;String&gt; result = employees.stream()\n    .filter(a -&gt; a.getManagerId() != null)\n    .flatMap(a -&gt; employees.stream()\n        .filter(b -&gt; a.getManagerId().equals(b.getId())\n            &amp;&amp; a.getSalary() &gt; b.getSalary())\n        .map(b -&gt; a.getName()))\n    .collect(Collectors.toList());</code></pre><svg><path></path></svg>",
        "isOfficial": true,
        "scrapedAt": "2026-02-18T07:27:27.088Z"
    }
}