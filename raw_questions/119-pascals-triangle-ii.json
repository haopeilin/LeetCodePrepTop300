{
    "questionId": "119",
    "questionFrontendId": "119",
    "title": "Pascal's Triangle II",
    "titleSlug": "pascals-triangle-ii",
    "content": "<p>Given an integer <code>rowIndex</code>, return the <code>rowIndex<sup>th</sup></code> (<strong>0-indexed</strong>) row of the <strong>Pascal&#39;s triangle</strong>.</p>\n\n<p>In <strong>Pascal&#39;s triangle</strong>, each number is the sum of the two numbers directly above it as shown:</p>\n<img alt=\"\" src=\"images/119/PascalTriangleAnimated2.gif\" style=\"height:240px; width:260px\" />\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> rowIndex = 3\n<strong>Output:</strong> [1,3,3,1]\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> rowIndex = 0\n<strong>Output:</strong> [1]\n</pre><p><strong class=\"example\">Example 3:</strong></p>\n<pre><strong>Input:</strong> rowIndex = 1\n<strong>Output:</strong> [1,1]\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= rowIndex &lt;= 33</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Could you optimize your algorithm to use only <code>O(rowIndex)</code> extra space?</p>\n",
    "difficulty": "Easy",
    "stats": "{\"totalAccepted\": \"1.2M\", \"totalSubmission\": \"1.8M\", \"totalAcceptedRaw\": 1186397, \"totalSubmissionRaw\": 1768819, \"acRate\": \"67.1%\"}",
    "hints": [],
    "similarQuestions": "[{\"title\": \"Pascal's Triangle\", \"titleSlug\": \"pascals-triangle\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Find Triangular Sum of an Array\", \"titleSlug\": \"find-triangular-sum-of-an-array\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
    "topicTags": [
        {
            "name": "Array",
            "slug": "array"
        },
        {
            "name": "Dynamic Programming",
            "slug": "dynamic-programming"
        }
    ],
    "companyTags": null,
    "codeSnippets": [
        {
            "lang": "Java",
            "langSlug": "java",
            "code": "class Solution {\n    public List<Integer> getRow(int rowIndex) {\n        \n    }\n}"
        }
    ],
    "solution": {
        "content": "<h2><a href=\"#solution\"><svg><path></path></svg></a>Solution</h2>\n<blockquote>\n<p>If you haven't attempted <a href=\"https://leetcode.com/problems/pascals-triangle/\">118. Pascal's Triangle</a>, I would strongly recommend that you try that first.</p>\n</blockquote>\n<hr/>\n<h3><a href=\"#approach-1-brute-force-recursion\"><svg><path></path></svg></a>Approach 1: Brute Force Recursion</h3>\n<p><strong>Intuition</strong></p>\n<p>We'll utilize a nice little property of Pascal's Triangle (given in the problem description):</p>\n<p></p>\n<blockquote>\n<p>In Pascal's triangle, each number is the sum of the two numbers directly above it.</p>\n</blockquote>\n<p><a href=\"#approach-4-math-specifically-combinatorics\">Approach 4</a> will expand more on why it is so.</p>\n<p><strong>Algorithm</strong></p>\n<p>Let's say we had a function <code>getNum(rowIndex, colIndex)</code>, which gave us the <code>colIndex</code><sup>th</sup> number in the <code>rowIndex</code><sup>th</sup> row, we could simply build the kth row by repeatedly calling <code>getNum(...)</code> for columns 0 to k.</p>\n<p>We can formulate our intuition into the following recursion:</p>\ngetNum(rowIndex,colIndex)​=getNum(rowIndex−1,colIndex−1)+getNum(rowIndex−1,colIndex)​\n<p>The recursion ends in some known base cases:</p>\n<ol>\n<li>\n<p>The first row is just a single 1, i.e. getNum(0, ...) = 1</p>\n</li>\n<li>\n<p>The first and last number of each row is 1, i.e. getNum(k, 0) = getNum(k, k) = 1</p>\n</li>\n</ol>\n<pre><code>class Solution {\n    int getNum(int row, int col) {\n        if (row == 0 || col == 0 || row == col) return 1;\n        return getNum(row - 1, col - 1) + getNum(row - 1, col);\n    }\n\n    public java.util.List&lt;Integer&gt; getRow(int rowIndex) {\n        java.util.List&lt;Integer&gt; ans = new java.util.ArrayList&lt;&gt;();\n        for (int i = 0; i &lt;= rowIndex; i++) {\n            ans.add(getNum(rowIndex, i));\n        }\n        return ans;\n    }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : O(2k). The time complexity recurrence is straightforward:</p>\n<p>T(k,i)=T(k−1,i)+T(k−1,i−1)+O(1)∋T(k,k)=T(k,0)=O(1)</p>\n<p>Thus, T(k, m) takes (mk​) units of constant time. <sup><a href=\"#user-content-fn-note-1\">1</a></sup></p>\n<p>For the kth row, total time required is:</p>\nT(k,0)+T(k,1)+...+T(k,k−1)+T(k,k)​=m=0∑k​T(k,m)≃m=0∑k​O((mk​))≃O(m=0∑k​(mk​))=O(2k)​\n</li>\n<li>\n<p>Space complexity : O(k)+O(k)≃O(k).</p>\n<ul>\n<li>We need O(k) space to store the output of the kth row.</li>\n<li>At worst, the recursive call stack has a maximum of k calls in memory, each call taking constant space. That's O(k) worst case recursive call stack space.</li>\n</ul>\n</li>\n</ul>\n<br/>\n<hr/>\n<h3><a href=\"#approach-2-dynamic-programming\"><svg><path></path></svg></a>Approach 2: Dynamic Programming</h3>\n<p><strong>Intuition</strong></p>\n<p>In the previous approach, we end up making the same recursive calls repeatedly.</p>\n<p></p>\n<p>For example, to calculate <code>getNum(5, 3)</code> and <code>getNum(5, 4)</code>, we end up calling <code>getNum(3, 2)</code> thrice. To generate, the entire fifth row (<code>0</code>-based row indexing), we'd have to call <code>getNum(3, 2)</code> four times.</p>\n<p>It makes sense to store the results of intermediate recursive calls for later use.</p>\n<p><strong>Algorithm</strong></p>\n<p>Simple memoization caches results of deep recursive calls and provides significant savings on runtime.</p>\n<pre><code>class Solution {\n    java.util.Map&lt;Long, Integer&gt; cache = new java.util.HashMap&lt;&gt;();\n\n    long key(int i, int j) {\n        return (((long) i) &lt;&lt; 32) | (j &amp; 0xffffffffL);\n    }\n\n    int getNum(int row, int col) {\n        long rowCol = key(row, col);\n        if (cache.containsKey(rowCol)) return cache.get(rowCol);\n        if (row == 0 || col == 0 || row == col) {\n            cache.put(rowCol, 1);\n            return 1;\n        }\n        int val = getNum(row - 1, col - 1) + getNum(row - 1, col);\n        cache.put(rowCol, val);\n        return val;\n    }\n\n    public java.util.List&lt;Integer&gt; getRow(int rowIndex) {\n        java.util.List&lt;Integer&gt; ans = new java.util.ArrayList&lt;&gt;();\n        for (int i = 0; i &lt;= rowIndex; i++) {\n            ans.add(getNum(rowIndex, i));\n        }\n        return ans;\n    }\n}</code></pre>\n<p>But, it is worth noting that generating a number for a particular row requires only two numbers from the previous row. Consequently, generating a row only requires numbers from the previous row.</p>\n<p>Thus, we could reduce our memory footprint by only keeping the latest row generated, and use that to generate a new row.</p>\n<pre><code>class Solution {\n    public java.util.List&lt;Integer&gt; getRow(int rowIndex) {\n        java.util.List&lt;Integer&gt; prev = new java.util.ArrayList&lt;&gt;();\n        prev.add(1);\n\n        for (int i = 1; i &lt;= rowIndex; i++) {\n            java.util.List&lt;Integer&gt; curr = new java.util.ArrayList&lt;&gt;(\n                java.util.Collections.nCopies(i + 1, 1)\n            );\n            for (int j = 1; j &lt; i; j++) {\n                curr.set(j, prev.get(j - 1) + prev.get(j));\n            }\n            prev = curr; // reference assignment is O(1)\n        }\n        return prev;\n    }\n}</code></pre>\n<blockquote>\n<p>In Java, assigning one list reference to another is an O(1) operation, since only the reference is copied and not the underlying elements. <sup><a href=\"#user-content-fn-note-2\">2</a></sup></p>\n</blockquote>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : O(k2).</p>\n<ul>\n<li>Simple memoization would make sure that a particular element in a row is only calculated once. Assuming that our memoization cache allows constant time lookup and updation (like a hash map), it takes constant time to calculate each element in Pascal's triangle.</li>\n<li>Since calculating a row requires calculating all the previous rows as well, we end up calculating 1+2+3+...+(k+1)=2(k+1)(k+2)​≃k2 elements for the kth row.</li>\n</ul>\n</li>\n<li>\n<p>Space complexity : O(k)+O(k)≃O(k).</p>\n<ul>\n<li>Simple memoization would need to hold all 1+2+3+...+(k+1)=2(k+1)(k+2)​ elements in the worst case. That would require O(k2) space.</li>\n<li>Saving space by keeping only the latest generated row, we need only O(k) extra space, other than the O(k) space required to store the output.</li>\n</ul>\n</li>\n</ul>\n<br/>\n<hr/>\n<h3><a href=\"#approach-3-memory-efficient-dynamic-programming\"><svg><path></path></svg></a>Approach 3: Memory-efficient Dynamic Programming</h3>\n<p><strong>Intuition</strong></p>\n<p>Notice that in the previous approach, we have maintained the previous row in memory on the premise that we need terms from it to build the current row. This is true, but not <em>wholly.</em></p>\n<p>What we actually need, to generate a term in the current row, is <em>just</em> the two terms above it (present in the previous row).</p>\n<p>Formally, in memory,</p>\n<pre><code>pascal[i][j] = pascal[i-1][j-1] + pascal[i-1][j]</code></pre><svg><path></path></svg>\n<p>where <code>pascal[i][j]</code> is the number in <em>i</em><sup>th</sup> row and <em>j</em><sup>th</sup> column of Pascal's triangle.</p>\n<p>So, trying to compute <code>pascal[i][j]</code>, only the memory regions of <code>pascal[i-1][j-1]</code> and <code>pascal[i-1][j]</code> are required to be accessed.</p>\n<p><strong>Algorithm</strong></p>\n<p>Let's take a step back and analyze the circumstances under which <code>pascal[i][j]</code> might be accessed. Given that we have already employed DP to save us valuable run-time, the access pattern for <code>pascal[i][j]</code> looks a bit like this:</p>\n<ul>\n<li><code>WRITE</code> <code>pascal[i][j]</code> (after generating it from <code>pascal[i-1][j-1]</code> and <code>pascal[i-1][j]</code>)</li>\n<li><code>READ</code> <code>pascal[i][j]</code> to generate <code>pascal[i+1][j]</code></li>\n<li><code>READ</code> <code>pascal[i][j]</code> to generate <code>pascal[i+1][j+1]</code></li>\n</ul>\n<p>That's it! Once we've written out <code>pascal[i][j]</code>:</p>\n<ol>\n<li>We don't ever need to modify it.</li>\n<li>It's only read a <em>fixed</em> number of times, i.e. <strong>twice</strong> (thanks to DP).</li>\n</ol>\n<p>Hypothetically, if we kept the the current row (in the process of being generated) and the previous row, in the same memory block, what kind of access patterns would we see (assume <code>pascal[j]</code> means the <em>j</em><sup>th</sup> number in a row)?</p>\n<ul>\n<li>\n<p><code>pascal[j]</code> was somehow generated in a previous instance. Currently, it holds the previous row value.</p>\n</li>\n<li>\n<p><code>pascal[j]</code> (which holds the <em>j</em><sup>th</sup> number of the previous row) must be read when writing out <code>pascal[j]</code> (the <em>j</em><sup>th</sup> number of the current row).</p>\n<ul>\n<li>Obviously they are the same memory location, so a conflict exists: the previous row value of <code>pascal[j]</code> will be lost after the write-out.</li>\n<li>Is that ok? If we don't need to read the previous row value of <code>pascal[j]</code> anymore, is there any harm in writing out the current row value in its place?</li>\n</ul>\n</li>\n<li>\n<p><code>pascal[j]</code> (which holds the <em>j</em><sup>th</sup> number of the previous row) must be read when writing out <code>pascal[j+1]</code> (the <em>j+1</em><sup>th</sup> number of the current row). These are two different memory locations, so there is no conflict.</p>\n</li>\n</ul>\n<p>If we managed to keep all read accesses on the previous row value of <code>pascal[j]</code>, <strong>before</strong> any write access to <code>pascal[j]</code> for the current row value, we should be good! That's possible by evaluating each row from the end, instead of the beginning. Thus, a new row value of <code>pascal[j+1]</code> must be generated <em>before</em> doing so for <code>pascal[j]</code>.</p>\n<p>The following animation demonstrates the above algorithm, used to generate the 4<sup>th</sup> row of Pascal's Triangle, from an existing 3<sup>rd</sup> row:</p>\n<p></p>\n<pre><code>class Solution {\n    public java.util.List&lt;Integer&gt; getRow(int rowIndex) {\n        java.util.List&lt;Integer&gt; ans = new java.util.ArrayList&lt;&gt;(\n            java.util.Collections.nCopies(rowIndex + 1, 1)\n        );\n\n        for (int i = 1; i &lt; rowIndex; i++) {\n            for (int j = i; j &gt; 0; j--) {\n                ans.set(j, ans.get(j) + ans.get(j - 1));\n            }\n        }\n        return ans;\n    }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : O(k2). Same as the previous dynamic programming approach.</p>\n</li>\n<li>\n<p>Space complexity : O(k). No extra space is used other than that required to hold the output.</p>\n</li>\n<li>\n<p>Although there is no savings in theoretical computational complexity, in practice there are some minor wins:</p>\n<ul>\n<li>We have one list/array instead of two. So memory consumption is roughly half.</li>\n<li>No time wasted in swapping references to lists for previous and current row.</li>\n<li>Locality of reference shines through here. Since every read is for consecutive memory locations in the list/array, we get a performance boost.</li>\n</ul>\n</li>\n</ul>\n<br/>\n<hr/>\n<h3><a href=\"#approach-4-math-specifically-combinatorics\"><svg><path></path></svg></a>Approach 4: Math! (specifically, Combinatorics)</h3>\n<p><strong>Intuition</strong></p>\n<p>Let's go back to the definition of a Pascal's Triangle:</p>\n<blockquote>\n<p>In mathematics, Pascal's triangle is a triangular array of the binomial coefficients.<br/>\n...<br/>\nThe entry in the <em>n</em><sup>th</sup> row and <em>r</em><sup>th</sup> column of Pascal's triangle is denoted (rn​).</p>\n</blockquote>\n<p>As a refresher, (rn​)=r!(n−r)!n!​.</p>\n<p>Binomial coefficients have an additive property, known as <a href=\"https://en.wikipedia.org/wiki/Pascal%27s_rule\">Pascal's rule</a>:</p>\n<p>(rn​)=(r−1n−1​)+(rn−1​)∀r,n∈N0, 0≤r≤n</p>\n<p>If you notice carefully, the terms (r−1n−1​) and (rn−1​), are the two numbers directly above the number (rn​) in Pascal's triangle. This recurrence is same as the intuition for <a href=\"#approach-1-brute-force-recursion\">Approach 1</a>.</p>\n<p><strong>Algorithm</strong></p>\n<p>While knowing Pascal's rule does not give us any benefits over previous approaches, knowing that the numbers in Pascal's triangle are just binomial coefficients will come in handy.</p>\n<p>Successive binomial coefficients (r−1n​) and (rn​) differ by a factor of:</p>\n<p>(r−1n​)(rn​)​=(r−1)!⋅(n−r+1)!n!​r!⋅(n−r)!n!​​=rn−r+1​</p>\n<p>Thus, we can derive the next term in a row in Pascal's triangle, from a preceding term. Running a loop should give us the required row.</p>\n<ul>\n<li>We know that each row starts with a 1, so we have a starting point.</li>\n<li>We also know that the kth row has exactly k+1 terms, so we know how long we need to run the loop.</li>\n</ul>\n<pre><code>class Solution {\n    public java.util.List&lt;Integer&gt; getRow(int n) {\n        java.util.List&lt;Integer&gt; ans = new java.util.ArrayList&lt;&gt;();\n        ans.add(1);\n\n        for (int k = 1; k &lt;= n; k++) {\n            ans.add((int) ((ans.get(ans.size() - 1) * (long) (n - k + 1)) / k));\n        }\n        return ans;\n    }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : O(k). Each term is calculated once, in constant time.</p>\n</li>\n<li>\n<p>Space complexity : O(k). No extra space required other than that required to hold the output.</p>\n</li>\n</ul>\n<hr/>\n<h3><a href=\"#further-thoughts\"><svg><path></path></svg></a>Further Thoughts</h3>\n<ul>\n<li>The symmetry of a row in Pascal's triangle allows us to get away with computing just half of each row.</li>\n</ul>\n<blockquote>\n<p>Pop Quiz: Are there any computational complexity benefits of doing this?</p>\n</blockquote>\n<blockquote>\n<p>Pop Quiz: Can you prove <em>why</em> these rows are symmetrical?</p>\n</blockquote>\n<hr/>\n<h2><a href=\"#user-content-footnote-label\"><svg><path></path></svg></a>Footnotes</h2>\n<ol>\n<li>\n<p>This <a href=\"https://stackoverflow.com/a/26229383/2844164\">Stack Overflow answer</a> has a good explanation. See the parallel between the time complexity recurrence and <a href=\"https://en.wikipedia.org/wiki/Pascal%27s_rule\">Pascal's rule</a>. <a href=\"#user-content-fnref-note-1\">↩</a></p>\n</li>\n<li>\n<p>In Java, object references (such as lists) can be reassigned efficiently since only the reference is copied and not the underlying data. This makes transferring ownership of a collection reference an O(1) operation. See this <a href=\"https://stackoverflow.com/a/12613436/2844164\">Stack Overflow answer</a> for more. <a href=\"#user-content-fnref-note-2\">↩</a></p>\n</li>\n</ol>",
        "isOfficial": true,
        "scrapedAt": "2026-02-18T08:12:24.345Z"
    }
}