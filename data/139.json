{"id":"139","title":"Word Break","difficulty":"Medium","content":"<p>Given a string <code>s</code> and a dictionary of strings <code>wordDict</code>, return <code>true</code> if <code>s</code> can be segmented into a space-separated sequence of one or more dictionary words.</p>\n\n<p><strong>Note</strong> that the same word in the dictionary may be reused multiple times in the segmentation.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;,&quot;code&quot;]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> Return true because &quot;leetcode&quot; can be segmented as &quot;leet code&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;,&quot;pen&quot;]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> Return true because &quot;applepenapple&quot; can be segmented as &quot;apple pen apple&quot;.\nNote that you are allowed to reuse a dictionary word.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;,&quot;dog&quot;,&quot;sand&quot;,&quot;and&quot;,&quot;cat&quot;]\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 300</code></li>\n\t<li><code>1 &lt;= wordDict.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= wordDict[i].length &lt;= 20</code></li>\n\t<li><code>s</code> and <code>wordDict[i]</code> consist of only lowercase English letters.</li>\n\t<li>All the strings of <code>wordDict</code> are <strong>unique</strong>.</li>\n</ul>\n","tags":["Array","Hash Table","String","Dynamic Programming","Trie","Memoization"],"java_snippet":"class Solution {\n    public boolean wordBreak(String s, List<String> wordDict) {\n        \n    }\n}","solution":"<h2><a href=\"#solution-article\"><svg><path></path></svg></a>Solution Article</h2>\n<hr/>\n<h3><a href=\"#approach-1-breadth-first-search\"><svg><path></path></svg></a>Approach 1: Breadth-First Search</h3>\n<p><strong>Intuition</strong></p>\n<p>Let's imagine the indices of <code>s</code> as a graph. Each index can be thought of as a node, which represents building <code>s</code> up to the index.</p>\n<p>Adding a word to an existing string is like an edge between nodes. For a node <code>start</code>, we can move to node <code>end</code> if the substring of <code>s</code> between <code>start, end</code> exists in <code>wordDict</code>.</p>\n<p>For example, let's say we have <code>s = \"leetcode\"</code> and <code>wordDict = [\"leet\", \"code\"]</code>. We are currently at node <code>4</code>, which implies that we have built <code>\"leet\"</code> (the first 4 characters of <code>s</code>). We can move to node <code>8</code>, because the substring of <code>s</code> with indices <code>[4, 8)</code> is <code>\"code\"</code>, which is in <code>wordDict</code>.</p>\n<p>We start at node <code>0</code>, which represents the empty string. We want to reach node <code>s.length</code>, which implies that we have built the entire string. We can run a BFS to accomplish this traversal. If you're not familiar with BFS, check out the relevant <a href=\"https://leetcode.com/explore/learn/card/graph/620/breadth-first-search-in-graph/\">Explore Card</a>.</p>\n<p>At each node <code>start</code>, we iterate over all the nodes <code>end</code> that come after <code>start</code>. For each <code>end</code>, we check if the substring between <code>start, end</code> is in <code>wordDict</code>. If it is, we can add <code>end</code> to the queue.</p>\n<p>We will first convert <code>wordDict</code> into a set so that we can perform the checks in constant time. We will also use a data structure <code>seen</code> to prevent us from visiting a node more than once.</p>\n<p><strong>Algorithm</strong></p>\n<ol>\n<li>Convert <code>wordDict</code> into a set <code>words</code>.</li>\n<li>Initialize a <code>queue</code> with <code>0</code> and a set <code>seen</code>.</li>\n<li>While the <code>queue</code> is not empty:\n<ul>\n<li>Remove the first element, <code>start</code>.</li>\n<li>If <code>start == s.length</code>, return <code>true</code>.</li>\n<li>Iterate <code>end</code> from <code>start + 1</code> up to and including <code>s.length</code>. For each <code>end</code>, if <code>end</code> has not been visited yet,\n<ul>\n<li>Check the substring starting at <code>start</code> and ending before <code>end</code>. If it is in <code>words</code>, add <code>end</code> to the queue and mark it in <code>seen</code>.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Return <code>false</code> if the BFS finishes without reaching the final node.</li>\n</ol>\n<p><strong>Implementation</strong></p>\n<pre><code>class Solution {\n    public boolean wordBreak(String s, List&lt;String&gt; wordDict) {\n        Set&lt;String&gt; words = new HashSet&lt;&gt;(wordDict);\n        Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();\n        boolean[] seen = new boolean[s.length() + 1];\n        queue.offer(0);\n\n        while (!queue.isEmpty()) {\n            int start = queue.poll();\n\n            if (start == s.length()) {\n                return true;\n            }\n\n            for (int end = start + 1; end &lt;= s.length(); end++) {\n                if (seen[end]) {\n                    continue;\n                }\n\n                if (words.contains(s.substring(start, end))) {\n                    queue.offer(end);\n                    seen[end] = true;\n                }\n            }\n        }\n\n        return false;\n    }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<p>Given n as the length of <code>s</code>, m as the length of <code>wordDict</code>, and k as the average length of the words in <code>wordDict</code>,</p>\n<ul>\n<li>\n<p>Time complexity: O(n3+m⋅k)</p>\n<p>There are O(n) nodes. Because of <code>seen</code>, we never visit a node more than once. At each node, we iterate over the nodes in front of the current node, of which there are O(n). For each node <code>end</code>, we create a substring, which also costs O(n).</p>\n<p>Therefore, handling a node costs O(n2), so the BFS could cost up to O(n3). Finally, we also spent O(m⋅k) to create the set <code>words</code>.</p>\n</li>\n<li>\n<p>Space complexity: O(n+m⋅k)</p>\n<p>We use O(n) space for <code>queue</code> and <code>seen</code>. We use O(m⋅k) space for the set <code>words</code>.</p>\n</li>\n</ul>\n<br/>\n<hr/>\n<h3><a href=\"#approach-2-top-down-dynamic-programming\"><svg><path></path></svg></a>Approach 2: Top-Down Dynamic Programming</h3>\n<p><strong>Intuition</strong></p>\n<blockquote>\n<p>If you're not familiar with dynamic programming, we recommend checking out the <a href=\"https://leetcode.com/explore/featured/card/dynamic-programming/\">Dynamic Programming explore card</a>. This problem is on the difficult side, so we will assume that readers are already familiar with the principles of DP.</p>\n</blockquote>\n<p>Let's have a function <code>dp</code> that returns a boolean indicating if it is possible to build <code>s</code> up to and including the index <code>i</code>.</p>\n<p>For example, given <code>s = \"leetcode\"</code> and <code>wordDict = [\"leet\", \"code\"]</code>, <code>dp(3)</code> would return <code>true</code>. <code>s</code> up to index <code>3</code> is <code>\"leet\"</code>, and we can build <code>\"leet\"</code> using the words in <code>wordDict</code>. The answer to the problem would be <code>dp(s.length - 1)</code>, which represents if we can build <code>s</code>.</p>\n<p>The base case of this function is when <code>i &lt; 0</code>. This would represent an empty string, and we can always build an empty string by doing nothing. Therefore, <code>dp(i) = true</code> for <code>i &lt; 0</code>.</p>\n<p>Given an index <code>i</code>, we need a recurrence relation to determine if <code>dp(i)</code> is <code>true</code> or <code>false</code>. For <code>dp(i)</code> to be <code>true</code>, there are two requirements:</p>\n<ol>\n<li>First, there needs to be a <code>word</code> from <code>wordDict</code> that <strong>ends</strong> at index <code>i</code>. Given a <code>word</code>, the substring of <code>s</code> from indices <code>i - word.length + 1</code> up to and including <code>i</code> should match <code>word</code>. We can check every <code>word</code> for this.</li>\n<li>If we manage to find a <code>word</code> that <strong>ends</strong> at index <code>i</code>, we would need to add it on top of another string (since we are building <code>s</code> by joining words together one by one). We need to make sure that the string we are adding onto is also buildable. If we find a <code>word</code> that passes the first check, it means <code>word</code> would start at index <code>i - word.length + 1</code>. The index before that is <code>i - word.length</code>. To check if the string ending at that index is buildable, we can refer to <code>dp(i - word.length)</code>.</li>\n</ol>\n<p>This gives us our recurrence relation:</p>\n<p>dp(i)=any(s[i - word.length + 1, i]==word &amp;&amp; dp(i - word.length))</p>\n<p>That is, there exists any <code>word</code> that satisfies both of the listed conditions.</p>\n<p>We can implement a recursive function <code>dp(i)</code> that implements the base cases and recurrence. We need to use memoization to avoid repeated computation.</p>\n<p></p>\n<p><strong>Algorithm</strong></p>\n<ol>\n<li>Declare a data structure <code>memo</code> that stores the values of <code>dp</code> for each index.</li>\n<li>Create a function <code>dp(i)</code>:\n<ul>\n<li>If <code>i &lt; 0</code>, return <code>true</code>.</li>\n<li>If we already calculated <code>i</code>, return the value stored in <code>memo</code>.</li>\n<li>Iterate over <code>wordDict</code>. For each <code>word</code>:\n<ul>\n<li>Check the substring of <code>s</code> ending at <code>i</code> with the same length as <code>word</code>. If the substring matches, and <code>dp(i - word.length)</code> is <code>true</code>, return <code>true</code>.</li>\n</ul>\n</li>\n<li>If no <code>word</code> satisfying the criteria was found, return <code>false</code>.</li>\n</ul>\n</li>\n<li>Return <code>dp(s.length - 1)</code>.</li>\n</ol>\n<p><strong>Implementation</strong></p>\n<blockquote>\n<p>In Java, we will use an array <code>memo</code> to save values. <code>memo[i] = -1</code> if we haven't calculated yet, <code>memo[i] = 0</code> if <code>dp(i) = false</code>, and <code>memo[i] = 1</code> if <code>dp(i) = true</code>.</p>\n</blockquote>\n<pre><code>class Solution {\n    int[] memo;\n    List&lt;String&gt; wordDict;\n    String s;\n\n    public boolean wordBreak(String s, List&lt;String&gt; wordDict) {\n        this.s = s;\n        this.wordDict = wordDict;\n        memo = new int[s.length()];\n        Arrays.fill(memo, -1);\n        return dp(s.length() - 1);\n    }\n\n    private boolean dp(int i) {\n        if (i &lt; 0) return true;\n\n        if (memo[i] != -1) {\n            return memo[i] == 1;\n        }\n\n        for (String word : wordDict) {\n            int currSize = word.length();\n            if (i - currSize + 1 &lt; 0) {\n                continue;\n            }\n\n            if (s.substring(i - currSize + 1, i + 1).equals(word) &amp;&amp;\n                dp(i - currSize)) {\n                memo[i] = 1;\n                return true;\n            }\n        }\n\n        memo[i] = 0;\n        return false;\n    }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<p>Given n as the length of <code>s</code>, m as the length of <code>wordDict</code>, and k as the average length of the words in <code>wordDict</code>,</p>\n<ul>\n<li>\n<p>Time complexity: O(n⋅m⋅k)</p>\n<p>There are n states of <code>dp(i)</code>. Because of memoization, we only calculate each state once. To calculate a state, we iterate over m words, and for each word perform some substring operations which costs O(k). Therefore, calculating a state costs O(m⋅k), and we need to calculate O(n) states.</p>\n</li>\n<li>\n<p>Space complexity: O(n)</p>\n<p>The data structure we use for memoization and the recursion call stack can use up to O(n) space.</p>\n</li>\n</ul>\n<br/>\n<hr/>\n<h3><a href=\"#approach-3-bottom-up-dynamic-programming\"><svg><path></path></svg></a>Approach 3: Bottom-Up Dynamic Programming</h3>\n<p><strong>Intuition</strong></p>\n<p>The same algorithm can be implemented iteratively. Instead of using a function <code>dp(i)</code>, we will use an array <code>dp</code> where <code>dp[i]</code> represents the same thing that <code>dp(i)</code> did. We can use the same recurrence relation:</p>\n<p>dp[i]=any(s[i - word.length + 1, i]==word &amp;&amp; dp[i - word.length])</p>\n<p>In top-down, we started at the top (<code>s.length - 1</code>) and work our way down to the base cases. In bottom-up, we start at the bottom <code>(i = 0)</code> and work our way up to the top.</p>\n<p>Before we check <code>dp[i - word.length]</code>, we should check if <code>i == word.length - 1</code>. This would mean that the current <code>word</code> we are placing to end at index <code>i</code> is the first word. <code>i - word.length</code> would be negative, so we need to separately check this case.</p>\n<p><strong>Algorithm</strong></p>\n<ol>\n<li>Initialize an array <code>dp</code> with the same length as <code>s</code> and all values initially set to <code>false</code>.</li>\n<li>Iterate <code>i</code> over the indices of <code>s</code>. At each <code>i</code>:\n<ul>\n<li>Iterate over each <code>word</code> in <code>wordDict</code>:\n<ul>\n<li>Check if <code>i == word.length - 1</code> or <code>dp[i - word.length] = true</code>.</li>\n<li>If so, and the substring of <code>s</code> ending at <code>i</code> with the same length as <code>word</code> matches, set <code>dp[i] = true</code> and <code>break</code>.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Return <code>dp[s.length - 1]</code>.</li>\n</ol>\n<p><strong>Implementation</strong></p>\n<pre><code>class Solution {\n    public boolean wordBreak(String s, List&lt;String&gt; wordDict) {\n        boolean[] dp = new boolean[s.length()];\n        for (int i = 0; i &lt; s.length(); i++) {\n            for (String word : wordDict) {\n                if (i &lt; word.length() - 1) {\n                    continue;\n                }\n\n                if (i == word.length() - 1 || dp[i - word.length()]) {\n                    if (s.substring(i - word.length() + 1, i + 1).equals(word)) {\n                        dp[i] = true;\n                        break;\n                    }\n                }\n            }\n        }\n\n        return dp[s.length() - 1];\n    }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<p>Given n as the length of <code>s</code>, m as the length of <code>wordDict</code>, and k as the average length of the words in <code>wordDict</code>,</p>\n<ul>\n<li>\n<p>Time complexity: O(n⋅m⋅k)</p>\n<p>The logic behind the time complexity is identical to the previous approach. It costs us O(m⋅k) to calculate each state, and we calculate O(n) states in total.</p>\n</li>\n<li>\n<p>Space complexity: O(n)</p>\n<p>We use an array <code>dp</code> of length n.</p>\n</li>\n</ul>\n<br/>\n<hr/>\n<h3><a href=\"#approach-4-trie-optimization\"><svg><path></path></svg></a>Approach 4: Trie Optimization</h3>\n<p><strong>Intuition</strong></p>\n<p>In the previous approach, we iterated over each state <code>i</code> and then calculated <code>dp[i]</code>. To calculate a given <code>dp[i]</code>, we did the following:</p>\n<ul>\n<li>Iterate over every <code>word</code> in <code>wordDict</code></li>\n<li>Check if each <code>word</code> ended at the current index</li>\n</ul>\n<p>This cost us O(m⋅k). In the problem constraints, we can see that the maximum value of m⋅k is <code>20,000</code>, so this is expensive. We can optimize the time it takes to calculate a given <code>dp[i]</code> by using a trie.</p>\n<p>A trie is a data structure that can be used to efficiently search for strings. If you are not familiar with tries, we highly recommend you read the official solution to <a href=\"https://leetcode.com/problems/implement-trie-prefix-tree/solution\">this problem</a> before proceeding with this approach.</p>\n<p>To summarize, a trie is a tree where each node is labeled. Here, we label each node with a character. The path from the root to any node represents the string that is built by the nodes on the path. The root represents the empty string.</p>\n<p> <br/></p>\n<p>We can start by building a trie from the words in <code>wordDict</code>. Each trie node will have an additional attribute <code>isWord</code> which indicates if the current node represents a word from <code>wordDict</code>. Then, we will calculate the same <code>dp</code> array as in the previous approach. We will calculate each state as follows:</p>\n<ul>\n<li>First, check if <code>i == 0</code> (placing first word) or <code>dp[i - 1]</code> (we could build the string up to this point). If neither are true, move on to the next state <code>i + 1</code>.</li>\n<li>Otherwise, we see if <code>dp[i]</code> can be <code>true</code>. Initialize a node <code>curr</code> at the <code>root</code> of the trie.</li>\n<li>Start iterating with a variable <code>j</code> from index <code>i</code>. For each character <code>s[j]</code>, check if we can traverse the trie.</li>\n<li>If we can't traverse the trie, it means no words exist starting at index <code>i</code> and ending at index <code>j</code> or beyond. We can break from the loop and move on to the next state <code>i + 1</code>.</li>\n<li>If we can traverse the trie, we move to the child node. We check the child's <code>isWord</code> attribute. If it is <code>true</code>, it means there is a word in <code>wordDict</code> starting at index <code>i</code> and ending at index <code>j</code>. We set <code>dp[j] = true</code>.</li>\n<li>We continue traversing the trie until we reach a dead end or <code>j</code> reaches the end of the string.</li>\n</ul>\n<p>This allows us to handle each state in O(n) instead of O(m⋅k), which is a big improvement since n≤300.</p>\n<p><strong>Algorithm</strong></p>\n<ol>\n<li>Build a trie from <code>wordDict</code>. Each node should also have an <code>isWord</code> attribute. Store the root of the trie in <code>root</code>.</li>\n<li>Initialize an array <code>dp</code> with the same length as <code>s</code> and all values initially set to <code>false</code>.</li>\n<li>Iterate <code>i</code> over the indices of <code>s</code>. At each <code>i</code>:\n<ul>\n<li>Check if <code>i == 0</code> or <code>dp[i - 1] = true</code>. If not, continue to the next <code>i</code>.</li>\n<li>Set <code>curr = root</code>. Iterate <code>j</code> over the indices of <code>s</code>, starting from <code>i</code>. At each <code>j</code>,\n<ul>\n<li>Get the character at index <code>j</code> as <code>c = s[j]</code>.</li>\n<li>If <code>c</code> is not in the children of <code>curr</code>, we can <code>break</code> from the loop.</li>\n<li>Otherwise, move <code>curr</code> to the child labeled <code>c</code>.</li>\n<li>If <code>curr.isWord</code>, set <code>dp[j] = true</code>.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Return <code>dp[s.length - 1]</code>.</li>\n</ol>\n<p><strong>Implementation</strong></p>\n<pre><code>class TrieNode {\n    boolean isWord;\n    Map&lt;Character, TrieNode&gt; children = new HashMap&lt;&gt;();\n}\n\nclass Solution {\n    public boolean wordBreak(String s, List&lt;String&gt; wordDict) {\n        TrieNode root = new TrieNode();\n        for (String word : wordDict) {\n            TrieNode curr = root;\n            for (char c : word.toCharArray()) {\n                curr.children.putIfAbsent(c, new TrieNode());\n                curr = curr.children.get(c);\n            }\n            curr.isWord = true;\n        }\n\n        boolean[] dp = new boolean[s.length()];\n        for (int i = 0; i &lt; s.length(); i++) {\n            if (i == 0 || dp[i - 1]) {\n                TrieNode curr = root;\n                for (int j = i; j &lt; s.length(); j++) {\n                    char c = s.charAt(j);\n                    if (!curr.children.containsKey(c)) {\n                        break;\n                    }\n                    curr = curr.children.get(c);\n                    if (curr.isWord) {\n                        dp[j] = true;\n                    }\n                }\n            }\n        }\n\n        return dp[s.length() - 1];\n    }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<p>Given n as the length of <code>s</code>, m as the length of <code>wordDict</code>, and k as the average length of the words in <code>wordDict</code>,</p>\n<ul>\n<li>\n<p>Time complexity: O(n2+m⋅k)</p>\n<p>Building the trie involves iterating over all characters of all words. This costs O(m⋅k).</p>\n<p>Once we build the trie, we calculate <code>dp</code>. For each <code>i</code>, we iterate over all the indices after <code>i</code>. We have a basic nested for loop which costs O(n2) to handle all <code>dp[i]</code>.</p>\n</li>\n<li>\n<p>Space complexity: O(n+m⋅k)</p>\n<p>The <code>dp</code> array takes O(n) space. The trie can have up to m⋅k nodes in it.</p>\n</li>\n</ul>\n<br/>\n<hr/>\n<h3><a href=\"#approach-5-a-different-dp\"><svg><path></path></svg></a>Approach 5: A Different DP</h3>\n<p><strong>Intuition</strong></p>\n<blockquote>\n<p>In this approach, we will take a look at another way to implement the DP algorithm. Note that this approach is the one covered in the video.</p>\n</blockquote>\n<p>Here, we let <code>dp[i]</code> hold the answer to the question: \"is it possible to form <code>s</code> up to a length of <code>i</code>? To find the answer for each index, instead of iterating over the words in <code>wordDict</code> and checking if a <code>word</code> ends at the current index <code>i</code>, we will instead iterate over <strong>all substrings that end before index <code>i</code></strong>. If we find one of these substrings is in <code>wordDict</code> <strong>and</strong> we can form the string prior to the substring, then <code>dp[i] = true</code>.</p>\n<p>The reason we are checking for <strong>before</strong> index <code>i</code> is because we have slightly changed our <code>dp</code> definition here. In the previous problem, <code>i</code> represented the index of the last character. Here, <code>i</code> represents the length, so we are offset by one.</p>\n<p>Before starting the DP, we first convert <code>wordsDict</code> to a set so that we can perform the checks in O(1). The rest of the algorithm follows similarly to the previous approaches.</p>\n<p><strong>Algorithm</strong></p>\n<ol>\n<li>Convert <code>wordsDict</code> to a set <code>words</code>.</li>\n<li>Initialize an array <code>dp</code> of length <code>n + 1</code> with all values set to <code>false</code>.</li>\n<li>Iterate <code>i</code> from <code>1</code> until and including <code>n</code>. Here, <code>i</code> represents the length of the string starting from the beginning.\n<ul>\n<li>Iterate <code>j</code> from <code>0</code> until <code>i</code>. Here, <code>j</code> represents the first index of the substring we are checking.</li>\n<li>If <code>dp[j]</code> is true AND the substring <code>s[j:i]</code> is in <code>words</code>, set <code>dp[i] = true</code> and break. Note that <code>s[j:i]</code> represents the substring starting at <code>j</code> and ending at <code>i - 1</code>.</li>\n</ul>\n</li>\n<li>Return <code>dp[n]</code>.</li>\n</ol>\n<p><strong>Implementation</strong></p>\n<pre><code>class Solution {\n    public boolean wordBreak(String s, List&lt;String&gt; wordDict) {\n        Set&lt;String&gt; words = new HashSet&lt;&gt;(wordDict);\n        boolean[] dp = new boolean[s.length() + 1];\n        dp[0] = true;\n\n        for (int i = 1; i &lt;= s.length(); i++) {\n            for (int j = 0; j &lt; i; j++) {\n                if (dp[j] &amp;&amp; words.contains(s.substring(j, i))) {\n                    dp[i] = true;\n                    break;\n                }\n            }\n        }\n\n        return dp[s.length()];\n    }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<p>Given n as the length of <code>s</code>, m as the length of <code>wordDict</code>, and k as the average length of the words in <code>wordDict</code>,</p>\n<ul>\n<li>\n<p>Time complexity: O(n3+m⋅k)</p>\n<p>First, we spend O(m⋅k) to convert <code>wordDict</code> into a set. Then we have a nested loop over <code>n</code>, which iterates O(n2) times. For each iteration, we have a substring operation which could cost up to O(n). Thus this nested loop costs O(n3).</p>\n</li>\n<li>\n<p>Space complexity: O(n+m⋅k)</p>\n<p>The <code>dp</code> array takes O(n) space. The set <code>words</code> takes up O(m⋅k) space.</p>\n</li>\n</ul>\n<br/>\n<hr/>"}