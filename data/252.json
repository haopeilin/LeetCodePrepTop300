{"id":"252","title":"Meeting Rooms","difficulty":"Easy","content":"<p>Given an array of meeting time <code>intervals</code>&nbsp;where <code>intervals[i] = [start<sub>i</sub>, end<sub>i</sub>]</code>, determine if a person could attend all meetings.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> intervals = [[0,30],[5,10],[15,20]]\n<strong>Output:</strong> false\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> intervals = [[7,10],[2,4]]\n<strong>Output:</strong> true\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= intervals.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>intervals[i].length == 2</code></li>\n\t<li><code>0 &lt;= start<sub>i</sub> &lt;&nbsp;end<sub>i</sub> &lt;= 10<sup>6</sup></code></li>\n</ul>\n","tags":["Array","Sorting"],"java_snippet":"class Solution {\n    public boolean canAttendMeetings(int[][] intervals) {\n        \n    }\n}","solution":"<h2><a href=\"#solution-article\"><svg><path></path></svg></a>Solution Article</h2>\n<hr/>\n<h3><a href=\"#approach-1-brute-force\"><svg><path></path></svg></a>Approach 1: Brute Force</h3>\n<p>The straight-forward solution is to compare every two meetings in the array, and see if they conflict with each other (i.e. if they overlap). Two meetings overlap if one of them starts while the other is still taking place.</p>\n<pre><code>class Solution {\npublic:\n    bool overlap(vector&lt;int&gt;&amp; interval1, vector&lt;int&gt;&amp; interval2) {\n        return interval1[0] &gt;= interval2[0] and interval1[0] &lt; interval2[1]\n               or interval2[0] &gt;= interval1[0] and interval2[0] &lt; interval1[1];\n    }\n    \n    bool canAttendMeetings(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) {\n        for (size_t i = 0; i &lt; intervals.size(); i++) {\n            for (size_t j = i + 1; j &lt; intervals.size(); j++) {\n                if (overlap(intervals[i], intervals[j])) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n};</code></pre>\n<p><strong>Overlap Condition</strong></p>\n<p>The overlap condition in the code above can be written in a more concise way. Consider two non-overlapping meetings. The earlier meeting ends before the later meeting begins. Therefore, the <em>minimum</em> end time of the two meetings (which is the end time of the earlier meeting) is smaller than or equal the <em>maximum</em> start time of the two meetings (which is the start time of the later meeting).</p>\n<p></p>\n<p><em>Figure 1. Two non-overlapping intervals.</em></p>\n<p></p>\n<p><em>Figure 2. Two overlapping intervals.</em></p>\n<p>So the condition can be rewritten as follows.</p>\n<pre><code>public static boolean overlap(int[] interval1, int[] interval2) {\n    return (Math.min(interval1[1], interval2[1]) &gt;\n            Math.max(interval1[0], interval2[0]));\n}</code></pre>\n<h4>Complexity Analysis</h4>\n<p>Because we have to check every meeting against every other meeting, the total run time is O(n2). No additional space is used, so the space complexity is O(1).</p>\n<hr/>\n<h3><a href=\"#approach-2-sorting\"><svg><path></path></svg></a>Approach 2: Sorting</h3>\n<p>The idea here is to sort the meetings by starting time. Then, go through the meetings one by one and make sure that each meeting ends before the next one starts.</p>\n<pre><code>class Solution {\npublic:\n    bool canAttendMeetings(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) {\n        if (intervals.empty()) {\n            return true;\n        }\n​\n        // Note: C++ sort function automatically sorts a vector first\n        // by the 1st element, then by the 2nd element and so on.\n        sort(intervals.begin(), intervals.end());\n        for (size_t i = 0; i &lt; intervals.size() - 1; i++) {\n            if (intervals[i][1] &gt; intervals[i + 1][0]) {\n                return false;\n            }\n        }\n        return true;\n    }\n};</code></pre>\n<h4>Complexity Analysis</h4>\n<ul>\n<li>\n<p>Time complexity: O(nlogn).</p>\n<p>The time complexity is dominated by the sorting step. Once the array has been sorted, only O(n) time is required to go through the array and determine if there is any overlap.</p>\n</li>\n<li>\n<p>Space complexity: O(logn) or O(n)</p>\n<p>Note that some extra space is used when we sort an array in place. The space complexity of the sorting algorithm depends on the programming language.</p>\n<ul>\n<li>In Python, the <code>sort</code> method sorts a list using the Tim Sort algorithm which is a combination of Merge Sort and Insertion Sort and has O(n) additional space. Additionally, Tim Sort is designed to be a stable algorithm.</li>\n<li>In Java, Arrays.sort() is implemented using a variant of the Quick Sort algorithm which has a space complexity of O(logn) for sorting an array.</li>\n</ul>\n</li>\n</ul>\n<hr/>"}