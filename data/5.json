{"id":"5","title":"Longest Palindromic Substring","difficulty":"Medium","content":"<p>Given a string <code>s</code>, return <em>the longest</em> <span data-keyword=\"palindromic-string\"><em>palindromic</em></span> <span data-keyword=\"substring-nonempty\"><em>substring</em></span> in <code>s</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;babad&quot;\n<strong>Output:</strong> &quot;bab&quot;\n<strong>Explanation:</strong> &quot;aba&quot; is also a valid answer.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;cbbd&quot;\n<strong>Output:</strong> &quot;bb&quot;\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>s</code> consist of only digits and English letters.</li>\n</ul>\n","tags":["Two Pointers","String","Dynamic Programming"],"java_snippet":"class Solution {\n    public String longestPalindrome(String s) {\n        \n    }\n}","solution":"<div class=\"flex flex-col w-full\" style=\"position: relative;\"><div class=\"mYe_l WRmCx\">\n<h2 class=\"group/heading relative\" id=\"solution\" level=\"2\"><a aria-hidden=\"true\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" href=\"#solution\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" data-icon=\"link\" data-prefix=\"fas\" focusable=\"false\" role=\"img\" spacing=\"square\" viewbox=\"0 0 640 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\" fill=\"currentColor\"></path></svg></div></a>Solution</h2>\n<hr/>\n<h3 class=\"group/heading relative\" id=\"approach-1-check-all-substrings\" level=\"3\"><a aria-hidden=\"true\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" href=\"#approach-1-check-all-substrings\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" data-icon=\"link\" data-prefix=\"fas\" focusable=\"false\" role=\"img\" spacing=\"square\" viewbox=\"0 0 640 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\" fill=\"currentColor\"></path></svg></div></a>Approach 1: Check All Substrings</h3>\n<p><strong>Intuition</strong></p>\n<p>We can start with a brute-force approach. We will simply check if each substring is a palindrome, and take the longest one that is.</p>\n<p>First, let's talk about how we can check if a given string is a palindrome. This is a classic problem and we can do it using two pointers. If a string is a palindrome, the first character is equal to the last character. The second character is equal to the second last character, and so on.</p>\n<p></p>\n<p>We initialize two pointers: one at the start of the string and another at the end of it. We check if the characters at the pointers are equal - if they aren't, we know the string cannot be a palindrome. If they are equal, we move to the next pair of characters by moving the pointers toward each other. We continue until we either find a mismatch or the pointers meet. If the pointers meet, then we have checked all pairs and we know the string is a palindrome.</p>\n<p>One bonus to using this algorithm is that we frequently exit early on strings that are not palindromes. If you had a string of length <code>1000</code> and the third and third last characters did not match, we would exit the algorithm after only 3 iterations.</p>\n<p>There's another optimization that we can do. Because the problem wants the longest palindrome, we can start by checking the longest-length substrings and iterate toward the shorter-length substrings. This way, the first time we find a substring that is a palindrome, we can immediately return it as the answer.</p>\n<p><strong>Algorithm</strong></p>\n<ol>\n<li data-length=\"1\">Create a helper method <code>check(i, j)</code> to determine if a substring is a palindrome.\n<ul>\n<li>To save space, we will not pass the substring itself. Instead, we will pass two indices that represent the substring in question. The first character will be <code>s[i]</code> and the last character will be <code>s[j - 1]</code>.</li>\n<li>In this function, declare two pointers <code>left = i</code> and <code>right = j - 1</code>.</li>\n<li>While <code>left &lt; right</code>, do the following steps:</li>\n<li>If <code>s[left] != s[right]</code>, return <code>false</code>.</li>\n<li>Otherwise, increment <code>left</code> and decrement <code>right</code>.</li>\n<li>If we get through the while loop, return <code>true</code>.</li>\n</ul>\n</li>\n<li data-length=\"1\">Use a for loop to iterate a variable <code>length</code> starting from <code>s.length</code> until <code>1</code>. This variable represents the length of the substrings we are currently considering.</li>\n<li data-length=\"1\">Use a for loop to iterate a variable <code>start</code> starting from <code>0</code> until and including <code>s.length - length</code>. This variable represents the starting point of the substring we are currently considering.</li>\n<li data-length=\"1\">In each inner loop iteration, we are considering the substring starting at <code>start</code> until <code>start + length</code>. Pass these values into <code>check</code> to see if this substring is a palindrome. If it is, return the substring.</li>\n</ol>\n<p><strong>Implementation</strong></p>\n<pre><code>class Solution {\npublic:\n    string longestPalindrome(string s) {\n        for (int length = s.size(); length &gt; 0; length--) {\n            for (int start = 0; start &lt;= s.size() - length; start++) {\n                if (check(s, start, start + length)) {\n                    return s.substr(start, length);\n                }\n            }\n        }\n​\n        return \"\";\n    }\n​\nprivate:\n    bool check(string s, int i, int j) {\n        int left = i;\n        int right = j - 1;\n​\n        while (left &lt; right) {\n            if (s[left] != s[right]) {\n                return false;\n            }\n​\n            left++;\n            right--;\n        }\n​\n        return true;\n    }\n};</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<p>Given <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></span> as the length of <code>s</code>,</p>\n<ul>\n<li>\n<p>Time complexity: <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1.0641em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.8141em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p>The two nested for loops iterate <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1.0641em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.8141em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span> times. We check one substring of length <code>n</code>, two substrings of length <code>n - 1</code>, three substrings of length <code>n - 2</code>, and so on.</p>\n<p>There are <code>n</code> substrings of length 1, but we don't check them all since any substring of length 1 is a palindrome, and we will return immediately.</p>\n<p>Therefore, the number of substrings that we check in the worst case is <code>1 + 2 + 3 + ... + n - 1</code>. This is the partial sum of <a href=\"https://en.wikipedia.org/wiki/1_%2B_2_%2B_3_%2B_4_%2B_%E2%8B%AF#Partial_sums\" target=\"_blank\">this series</a> for <code>n - 1</code>, which is equal to <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1.355em; vertical-align: -0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 1.01em;\"><span style=\"top: -2.655em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span><span style=\"top: -3.23em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width: 0.04em;\"></span></span><span style=\"top: -3.485em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">⋅</span><span class=\"mopen mtight\">(</span><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span><span class=\"mclose mtight\">)</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1.0641em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.8141em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n<p>In each iteration of the while loop, we perform a palindrome check. The cost of this check is linear with <code>n</code> as well, giving us a time complexity of <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1.0641em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.8141em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n<p>Note that this time complexity is in the worst case and has a significant constant divisor that is dropped by big O. Due to the optimizations of checking the longer length substrings first and exiting the palindrome check early if we determine that a substring cannot be a palindrome, the practical runtime of this algorithm is not too bad.</p>\n</li>\n<li>\n<p>Space complexity: <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p>We don't count the answer as part of the space complexity. Thus, all we use are a few integer variables.</p>\n</li>\n</ul>\n<br/>\n<hr/>\n<h3 class=\"group/heading relative\" id=\"approach-2-dynamic-programming\" level=\"3\"><a aria-hidden=\"true\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" href=\"#approach-2-dynamic-programming\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" data-icon=\"link\" data-prefix=\"fas\" focusable=\"false\" role=\"img\" spacing=\"square\" viewbox=\"0 0 640 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\" fill=\"currentColor\"></path></svg></div></a>Approach 2: Dynamic Programming</h3>\n<p><strong>Intuition</strong></p>\n<p>Let's say that we knew the substring with inclusive bounds <code>i, j</code> was a palindrome. If <code>s[i - 1] == s[j + 1]</code>, then we know the substring with inclusive bounds <code>i - 1, j + 1</code> must also be a palindrome, and this check can be done in constant time.</p>\n<p>We can flip the direction of this logic as well - if <code>s[i] == s[j]</code> and the substring <code>i + 1, j - 1</code> is a palindrome, then the substring <code>i, j</code> must also be a palindrome.</p>\n<p></p>\n<p>We know that all substrings of length 1 are palindromes. From this, we can check if each substring of length 3 is a palindrome using the above fact. We just need to check every <code>i, j</code> pair where <code>j - i = 2</code>. Once we know all palindromes of length 3, we can use that information to find all palindromes of length 5, and then 7, and so on.</p>\n<p>What about even-length palindromes? A substring of length 2 is a palindrome if both characters are equal. That is, <code>i, i + 1</code> is a palindrome if <code>s[i] == s[i + 1]</code>. From this, we can use the earlier logic to find all palindromes of length 4, then 6, and so on.</p>\n<p>Let's use a table <code>dp</code> with dimensions of <code>n * n</code>. <code>dp[i][j]</code> is a boolean representing if the substring with inclusive bounds <code>i, j</code> is a palindrome. We initialize <code>dp[i][i] = true</code> for the substrings of length 1, and then <code>dp[i][i + 1] = (s[i] == s[i + 1])</code> for the substrings of length 2.</p>\n<p>Now, we need to populate the table. We iterate over all <code>i, j</code> pairs, starting with pairs that have a difference of 2 (representing substrings of length 3), then pairs with a difference of 3, then 4, and so on. For each <code>i, j</code> pair, we check the condition from earlier:</p>\n<p><code>s[i] == s[j] &amp;&amp; dp[i + 1][j - 1]</code></p>\n<p>If this condition is true, then the substring with inclusive bounds <code>i, j</code> must be a palindrome. We set <code>dp[i][j] = true</code>.</p>\n<p>Because we are starting with the shortest substrings and iterating toward the longest substrings, every time we find a new palindrome, it must be the longest one we have seen so far. We can use this fact to keep track of the answer on the fly.</p>\n<p><strong>Algorithm</strong></p>\n<ol>\n<li data-length=\"1\">\n<p>Initialize <code>n = s.length</code> and a boolean table <code>dp</code> with size <code>n * n</code>, and all values to <code>false</code>.</p>\n</li>\n<li data-length=\"1\">\n<p>Initialize <code>ans = [0, 0]</code>. This will hold the inclusive bounds of the answer.</p>\n</li>\n<li data-length=\"1\">\n<p>Set all <code>dp[i][i] = true</code>.</p>\n</li>\n<li data-length=\"1\">\n<p>Iterate over all pairs <code>i, i + 1</code>. For each one, if <code>s[i] == s[i + 1]</code>, then set <code>dp[i][i + 1] = true</code> and update <code>ans = [i, i + 1]</code>.</p>\n</li>\n<li data-length=\"1\">\n<p>Now, we populate the <code>dp</code> table. Iterate over <code>diff</code> from <code>2</code> until <code>n</code>. This variable represents the difference <code>j - i</code>.</p>\n</li>\n<li data-length=\"1\">\n<p>In a nested for loop, iterate over <code>i</code> from <code>0</code> until <code>n - diff</code>.</p>\n<ul>\n<li>Set <code>j = i + diff</code>.</li>\n<li>Check the condition: if <code>s[i] == s[j] &amp;&amp; dp[i + 1][j - 1]</code>, we found a palindrome.</li>\n<li>In that case, set <code>dp[i][j] = true</code> and <code>ans = [i, j]</code></li>\n</ul>\n</li>\n<li data-length=\"1\">\n<p>Retrieve the answer bounds from <code>ans</code> as <code>i, j</code>. Return the substring of <code>s</code> starting at index <code>i</code> and ending with index <code>j</code>.</p>\n</li>\n</ol>\n<p><strong>Implementation</strong></p>\n<pre><code>class Solution {\npublic:\n    string longestPalindrome(string s) {\n        int n = s.size();\n        vector&lt;vector&lt;bool&gt;&gt; dp(n, vector&lt;bool&gt;(n));\n        array&lt;int, 2&gt; ans = {0, 0};\n​\n        for (int i = 0; i &lt; n; ++i) {\n            dp[i][i] = true;\n        }\n​\n        for (int i = 0; i &lt; n - 1; ++i) {\n            if (s[i] == s[i + 1]) {\n                dp[i][i + 1] = true;\n                ans = {i, i + 1};\n            }\n        }\n​\n        for (int diff = 2; diff &lt; n; ++diff) {\n            for (int i = 0; i &lt; n - diff; ++i) {\n                int j = i + diff;\n                if (s[i] == s[j] &amp;&amp; dp[i + 1][j - 1]) {\n                    dp[i][j] = true;\n                    ans = {i, j};\n                }\n            }\n        }\n​\n        int i = ans[0];\n        int j = ans[1];\n        return s.substr(i, j - i + 1);\n    }\n};</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<p>Given <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></span> as the length of <code>s</code>,</p>\n<ul>\n<li>\n<p>Time complexity: <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1.0641em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.8141em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p>We declare an <code>n * n</code> table <code>dp</code>, which takes <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1.0641em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.8141em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span> time. We then populate <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1.0641em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.8141em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span> states <code>i, j</code> - each state takes <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></span> time to compute.</p>\n</li>\n<li>\n<p>Space complexity: <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1.0641em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.8141em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p>The table <code>dp</code> takes <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1.0641em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.8141em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span> space.</p>\n</li>\n</ul>\n<br/>\n<hr/>\n<h3 class=\"group/heading relative\" id=\"approach-3-expand-from-centers\" level=\"3\"><a aria-hidden=\"true\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" href=\"#approach-3-expand-from-centers\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" data-icon=\"link\" data-prefix=\"fas\" focusable=\"false\" role=\"img\" spacing=\"square\" viewbox=\"0 0 640 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\" fill=\"currentColor\"></path></svg></div></a>Approach 3: Expand From Centers</h3>\n<p><strong>Intuition</strong></p>\n<p>In the first approach, the palindrome check cost <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span>. In the second approach, the palindrome check cost <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></span>. This allowed us to improve the time complexity from <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1.0641em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.8141em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span> to <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1.0641em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.8141em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n<p>The problem with the second approach is that we <strong>always</strong> iterated over <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1.0641em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.8141em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span> states of <code>i, j</code>. Can we optimize further to minimize the number of iterations required?</p>\n<p>In the first approach, we implemented a palindrome check using two pointers. We started by checking the first and last characters, then the second and second last characters, and so on.</p>\n<p>Instead of starting the pointers at the edges and moving inwards, the same logic can be applied when starting the pointers at the center and moving outwards. A palindrome mirrors around its center. Let's say you had <code>s = \"racecar\"</code>. If we start both pointers at the middle (<code>\"e\"</code>) and move them away from each other, we can see that at every iteration, the characters match: <code>e -&gt; c -&gt; a -&gt; r</code>.</p>\n<p>The previous two approaches focused on the bounds of a substring - <code>i, j</code>. There are <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1.0641em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.8141em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span> bounds, but only <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span> centers. For each index <code>i</code>, we can consider odd-length palindromes by starting the pointers at <code>i, i</code>. To consider the even length palindromes, we can start the pointers at <code>i, i + 1</code>. There are <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></span> starting points for the odd-length palindromes and <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6667em; vertical-align: -0.0833em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.6444em;\"></span><span class=\"mord\">1</span></span></span></span></span> starting points for the even-length palindromes - that's <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.7278em; vertical-align: -0.0833em;\"></span><span class=\"mord\">2</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.6444em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span> starting points in total.</p>\n<p>This is very promising - we can lower the minimum iterations required if we focus on the centers instead of on the bounds. Let's use a helper method <code>expand(i, j)</code> that starts two pointers <code>left = i</code> and <code>right = j</code>. In this method, we will consider <code>i, j</code> as a center. When <code>i == j</code>, we are considering odd-length palindromes. When <code>i != j</code>, we are considering even-length palindromes. We will expand from the center as far as we can to find the longest palindrome, and then return the length of this palindrome.</p>\n<p>Let's say that we have a center <code>i, i</code>. We call <code>expand</code> and find a length of <code>length</code>. What are the bounds of the palindrome? Because we are centered at <code>i, i</code>, it means <code>length</code> must be odd. If we perform floor division of <code>length</code> by 2, we will get the number of characters <code>dist</code> on each side of the palindrome. For example, given <code>s = \"racecar\"</code>, we have <code>length = 7</code> and <code>dist = 7 / 2 = 3</code>. There are 3 characters on each side - <code>\"rac\"</code> on the left and <code>\"car\"</code> on the right. Therefore, we can determine that the bounds of the palindrome are <code>i - dist, i + dist</code>.</p>\n<p>What about a center at <code>i, i + 1</code>? <code>length</code> must be even now. If we have a palindrome with length <code>2</code>, then <code>length / 2 = 1</code>, but there are zero characters on each side of the center. We can see that <code>dist</code> is too large by 1. Therefore, we will calculate <code>dist</code> as <code>(length / 2) - 1</code> instead. Now, <code>dist</code> correctly represents the number of characters on each side. The bounds of the palindrome are <code>i - dist, i + 1 + dist</code>.</p>\n<p><strong>Algorithm</strong></p>\n<ol>\n<li data-length=\"1\">Create a helper method <code>expand(i, j)</code> to find the length of the longest palindrome centered at <code>i, j</code>.\n<ul>\n<li>Set <code>left = i</code> and <code>right = j</code>.</li>\n<li>While <code>left</code> and <code>right</code> are both in bounds and <code>s[left] == s[right]</code>, move the pointers away from each other.</li>\n<li>The formula for the length of a substring starting at <code>left</code> and ending at <code>right</code> is <code>right - left + 1</code>.</li>\n<li>However, when the while loop ends, it implies <code>s[left] != s[right]</code>. Therefore, we need to subtract <code>2</code>. Return <code>right - left - 1</code>.</li>\n</ul>\n</li>\n<li data-length=\"1\">Initialize <code>ans = [0, 0]</code>. This will hold the inclusive bounds of the answer.</li>\n<li data-length=\"1\">Iterate <code>i</code> over all indices of <code>s</code>.\n<ul>\n<li>Find the length of the longest odd-length palindrome centered at <code>i</code>: <code>oddLength = expand(i, i)</code>.</li>\n<li>If <code>oddLength</code> is the greatest length we have seen so far, i.e. <code>oddLength &gt; ans[1] - ans[0] + 1</code>, update <code>ans</code>.</li>\n<li>Find the length of the longest even-length palindrome centered at <code>i</code>: <code>evenLength = expand(i, i + 1)</code>.</li>\n<li>If <code>evenLength</code> is the greatest length we have seen so far, update <code>ans</code>.</li>\n</ul>\n</li>\n<li data-length=\"1\">Retrieve the answer bounds from <code>ans</code> as <code>i, j</code>. Return the substring of <code>s</code> starting at index <code>i</code> and ending with index <code>j</code>.</li>\n</ol>\n<p><strong>Implementation</strong></p>\n<pre><code>class Solution {\npublic:\n    string expand(int i, int j, string s) {\n        int left = i;\n        int right = j;\n​\n        while (left &gt;= 0 &amp;&amp; right &lt; s.size() &amp;&amp; s[left] == s[right]) {\n            left--;\n            right++;\n        }\n​\n        return s.substr(left + 1, right - left - 1);\n    }\n​\n    string longestPalindrome(string s) {\n        string ans = \"\";\n​\n        for (int i = 0; i &lt; s.size(); i++) {\n            string odd = expand(i, i, s);\n            if (odd.size() &gt; ans.size()) {\n                ans = odd;\n            }\n​\n            string even = expand(i, i + 1, s);\n            if (even.size() &gt; ans.size()) {\n                ans = even;\n            }\n        }\n​\n        return ans;\n    }\n};</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<p>Given <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></span> as the length of <code>s</code>,</p>\n<ul>\n<li>\n<p>Time complexity: <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1.0641em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.8141em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p>There are <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.7278em; vertical-align: -0.0833em;\"></span><span class=\"mord\">2</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.6444em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span> centers. For each center, we call <code>expand</code>, which costs up to <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n<p>Although the time complexity is the same as in the DP approach, the average/practical runtime of the algorithm is much faster. This is because most centers will not produce long palindromes, so most of the <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span> calls to <code>expand</code> will cost far less than <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></span> iterations.</p>\n<p>The worst case scenario is when every character in the string is the same.</p>\n</li>\n<li>\n<p>Space complexity: <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p>We don't use any extra space other than a few integers. This is a big improvement on the DP approach.</p>\n</li>\n</ul>\n<br/>\n<hr/>\n<h3 class=\"group/heading relative\" id=\"approach-4-manachers-algorithm\" level=\"3\"><a aria-hidden=\"true\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" href=\"#approach-4-manachers-algorithm\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" data-icon=\"link\" data-prefix=\"fas\" focusable=\"false\" role=\"img\" spacing=\"square\" viewbox=\"0 0 640 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\" fill=\"currentColor\"></path></svg></div></a>Approach 4: Manacher's Algorithm</h3>\n<p>Believe it or not, this problem can be solved in linear time.</p>\n<p><a href=\"https://en.wikipedia.org/wiki/Longest_palindromic_substring#Manacher's_algorithm\" target=\"_blank\">Manacher's algorithm</a> finds the longest palindromic substring in <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span> time and space.</p>\n<p>Note: this algorithm is completely out of scope for coding interviews. Because of this, we will not be talking about the algorithm in detail. This approach has been included for the sake of completeness and for those who are curious about algorithms beyond the scope of interviews.</p>\n<p>If you wish to learn more about Manacher's algorithm, please reference the above link.</p>\n<p><strong>Implementation</strong></p>\n<pre><code>class Solution {\npublic:\n    string longestPalindrome(string s) {\n        string s_prime = \"#\";\n        for (char c : s) {\n            s_prime += c;\n            s_prime += \"#\";\n        }\n​\n        int n = s_prime.length();\n        vector&lt;int&gt; palindrome_radii(n, 0);\n        int center = 0;\n        int radius = 0;\n​\n        for (int i = 0; i &lt; n; i++) {\n            int mirror = 2 * center - i;\n​\n            if (i &lt; radius) {\n                palindrome_radii[i] = min(radius - i, palindrome_radii[mirror]);\n            }\n​\n            while (i + 1 + palindrome_radii[i] &lt; n &amp;&amp;\n                   i - 1 - palindrome_radii[i] &gt;= 0 &amp;&amp;\n                   s_prime[i + 1 + palindrome_radii[i]] ==\n                       s_prime[i - 1 - palindrome_radii[i]]) {\n                palindrome_radii[i]++;\n            }\n​\n            if (i + palindrome_radii[i] &gt; radius) {\n                center = i;\n                radius = i + palindrome_radii[i];\n            }\n        }\n​\n        int max_length = 0;\n        int center_index = 0;\n        for (int i = 0; i &lt; n; i++) {\n            if (palindrome_radii[i] &gt; max_length) {\n                max_length = palindrome_radii[i];\n                center_index = i;\n            }\n        }\n​\n        int start_index = (center_index - max_length) / 2;\n        string longest_palindrome = s.substr(start_index, max_length);\n​\n        return longest_palindrome;\n    }\n};</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<p>Given <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></span> as the length of <code>s</code>,</p>\n<ul>\n<li>\n<p>Time complexity: <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p>From Wikipedia (the implementation they describe is slightly different from the above code, but it's the same algorithm):</p>\n<blockquote>\n<p>The algorithm runs in linear time. This can be seen by noting that Center strictly increases after each outer loop and the sum Center + Radius is non-decreasing. Moreover, the number of operations in the first inner loop is linear in the increase of the sum Center + Radius while the number of operations in the second inner loop is linear in the increase of Center. Since Center <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.7719em; vertical-align: -0.136em;\"></span><span class=\"mrel\">≤</span></span></span></span></span> 2n+1 and Radius <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.7719em; vertical-align: -0.136em;\"></span><span class=\"mrel\">≤</span></span></span></span></span> n, the total number of operations in the first and second inner loops is <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span> and the total number of operations in the outer loop, other than those in the inner loops, is also <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span>. The overall running time is therefore <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n</blockquote>\n</li>\n<li>\n<p>Space complexity: <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p>We use <code>sPrime</code> and <code>palindromeRadii</code>, both of length <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n</li>\n</ul>\n<br/>\n<hr/></div><span style=\"font-size: 0px; line-height: 0;\"> </span></div>"}