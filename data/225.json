{"id":"225","title":"Implement Stack using Queues","difficulty":"Easy","content":"<p>Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (<code>push</code>, <code>top</code>, <code>pop</code>, and <code>empty</code>).</p>\n\n<p>Implement the <code>MyStack</code> class:</p>\n\n<ul>\n\t<li><code>void push(int x)</code> Pushes element x to the top of the stack.</li>\n\t<li><code>int pop()</code> Removes the element on the top of the stack and returns it.</li>\n\t<li><code>int top()</code> Returns the element on the top of the stack.</li>\n\t<li><code>boolean empty()</code> Returns <code>true</code> if the stack is empty, <code>false</code> otherwise.</li>\n</ul>\n\n<p><b>Notes:</b></p>\n\n<ul>\n\t<li>You must use <strong>only</strong> standard operations of a queue, which means that only <code>push to back</code>, <code>peek/pop from front</code>, <code>size</code> and <code>is empty</code> operations are valid.</li>\n\t<li>Depending on your language, the queue may not be supported natively. You may simulate a queue using a list or deque (double-ended queue) as long as you use only a queue&#39;s standard operations.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;MyStack&quot;, &quot;push&quot;, &quot;push&quot;, &quot;top&quot;, &quot;pop&quot;, &quot;empty&quot;]\n[[], [1], [2], [], [], []]\n<strong>Output</strong>\n[null, null, null, 2, 2, false]\n\n<strong>Explanation</strong>\nMyStack myStack = new MyStack();\nmyStack.push(1);\nmyStack.push(2);\nmyStack.top(); // return 2\nmyStack.pop(); // return 2\nmyStack.empty(); // return False\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= x &lt;= 9</code></li>\n\t<li>At most <code>100</code> calls will be made to <code>push</code>, <code>pop</code>, <code>top</code>, and <code>empty</code>.</li>\n\t<li>All the calls to <code>pop</code> and <code>top</code> are valid.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow-up:</strong> Can you implement the stack using only one queue?</p>\n","tags":["Stack","Design","Queue"],"java_snippet":"class MyStack {\n\n    public MyStack() {\n        \n    }\n    \n    public void push(int x) {\n        \n    }\n    \n    public int pop() {\n        \n    }\n    \n    public int top() {\n        \n    }\n    \n    public boolean empty() {\n        \n    }\n}\n\n/**\n * Your MyStack object will be instantiated and called as such:\n * MyStack obj = new MyStack();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.top();\n * boolean param_4 = obj.empty();\n */","solution":"<h2><a href=\"#summary\"><svg><path></path></svg></a>Summary</h2>\n<p>This article is for beginners. It introduces the following ideas:<br/>\nStack, Queue.</p>\n<h2><a href=\"#solution\"><svg><path></path></svg></a>Solution</h2>\n<hr/>\n<h3><a href=\"#approach-1-two-queues-push---o1-pop-on-\"><svg><path></path></svg></a>Approach #1 (Two Queues, push - O(1), pop O(n) )</h3>\n<p><strong>Intuition</strong></p>\n<p>Stack is <strong>LIFO</strong> (last in - first out) data structure, in which elements are added and removed from the same end, called <code>top</code>.<br/>\nIn general stack is implemented using array or linked list, but in the current article we will review a different approach for implementing stack using queues. In contrast queue is <strong>FIFO</strong> (first in - first out) data structure, in which elements are added only from the one side - <code>rear</code> and removed from the other - <code>front</code>. In order to implement stack using queues, we need to maintain two queues <code>q1</code> and <code>q2</code>. Also we will keep top stack element in a constant memory.</p>\n<p><strong>Algorithm</strong></p>\n<p><strong>Push</strong></p>\n<p>The new element is always added to the rear of queue <code>q1</code> and it is kept as <code>top</code> stack element</p>\n<p></p>\n<p><em>Figure 1. Push an element in stack</em></p>\n<pre><code>private Queue&lt;Integer&gt; q1 = new LinkedList&lt;&gt;();\nprivate Queue&lt;Integer&gt; q2 = new LinkedList&lt;&gt;();\nprivate int top;\n​\n// Push element x onto stack.\npublic void push(int x) {\n    q1.add(x);\n    top = x;\n}</code></pre>\n**Complexity Analysis**\n<ul>\n<li>\n<p>Time complexity : O(1). Queue is implemented as linked list and <code>add</code> operation has O(1) time complexity.</p>\n</li>\n<li>\n<p>Space complexity : O(1)</p>\n</li>\n</ul>\n<p><strong>Pop</strong></p>\n<p>We need to remove the element from the top of the stack. This is the last inserted element in <code>q1</code>.<br/>\nBecause queue is FIFO (first in - first out) data structure, the last inserted element could be removed only after all elements, except it, have been removed. For this reason we need to maintain additional queue <code>q2</code>, which will serve as a temporary storage to enqueue the removed elements from q1. The last inserted element in <code>q2</code> is kept as top. Then the algorithm removes the last element in <code>q1</code>. We swap <code>q1</code> with <code>q2</code> to avoid copying all elements from <code>q2</code> to <code>q1</code>.</p>\n<p></p>\n<p><em>Figure 2. Pop an element from stack</em></p>\n<pre><code>// Removes the element on top of the stack.\npublic void pop() {\n    while (q1.size() &gt; 1) {\n        top = q1.remove();\n        q2.add(top);\n    }\n    q1.remove();\n    Queue&lt;Integer&gt; temp = q1;\n    q1 = q2;\n    q2 = temp;\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time complexity : O(n). The algorithm  dequeues n elements from <code>q1</code> and enqueues n−1 elements to <code>q2</code>, where n is the stack size. This gives 2n−1 operations.</li>\n<li>Space complexity : O(1).</li>\n</ul>\n<hr/>\n<h3><a href=\"#approach-2-two-queues-push---on-pop-o1-\"><svg><path></path></svg></a>Approach #2 (Two Queues, push - O(n), pop O(1) )</h3>\n<p><strong>Algorithm</strong></p>\n<p><strong>Push</strong></p>\n<p>The algorithm inserts each new element to queue <code>q2</code> and keep it as the <code>top</code> element. In case queue <code>q1</code> is not empty (there are elements in the stack), we remove all elements from <code>q1</code> and add them to <code>q2</code>. In this way the new inserted element (<code>top</code> element in the stack) will be always positioned at the front of <code>q2</code>. We swap <code>q1</code> with <code>q2</code> to avoid copying all elements from <code>q2</code> to <code>q1</code>.</p>\n<p></p>\n<p><em>Figure 3. Push an element in stack</em></p>\n<pre><code>public void push(int x) {\n    q2.add(x);\n    top = x;\n    while (!q1.isEmpty()) {                \n        q2.add(q1.remove());\n    }\n    Queue&lt;Integer&gt; temp = q1;\n    q1 = q2;\n    q2 = temp;\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : O(n). The algorithm  removes n elements from <code>q1</code> and inserts n+1 elements to <code>q2</code>, where n is the stack size. This gives 2n+1 operations. The operations <code>add</code> and <code>remove</code> in linked lists has O(1) complexity.</p>\n</li>\n<li>\n<p>Space complexity : O(1).</p>\n</li>\n</ul>\n<p><strong>Pop</strong></p>\n<p>The algorithm dequeues an element from  queue <code>q1</code> and keeps front element of <code>q1</code> as <code>top</code>.</p>\n<p></p>\n<p><em>Figure 4. Pop an element from stack</em></p>\n<pre><code>// Removes the element on top of the stack.\npublic void pop() {\n    q1.remove();\n    if (!q1.isEmpty()) {\n        top = q1.peek();\n    }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time complexity : O(1).</li>\n<li>Space complexity : O(1).</li>\n</ul>\n<p>In both approaches <code>empty</code> and <code>top</code> operations have the same implementation.</p>\n<p><strong>Empty</strong></p>\n<p>Queue <code>q1</code> always contains all stack elements, so the algorithm checks <code>q1</code> size to return if the stack is empty.</p>\n<pre><code>// Return whether the stack is empty.\npublic boolean empty() {\n    return q1.isEmpty();\n}</code></pre>\n<p>Time complexity : O(1).</p>\n<p>Space complexity : O(1).</p>\n<p><strong>Top</strong></p>\n<p>The <code>top</code> element is kept in constant memory and is modified each time when we push or pop an element.</p>\n<pre><code>// Get the top element.\npublic int top() {\n    return top;\n}</code></pre>\n<p>Time complexity : O(1).<br/>\nThe <code>top</code> element has been calculated in advance and only returned in <code>top</code> operation.</p>\n<p>Space complexity : O(1).</p>\n<hr/>\n<h3><a href=\"#approach-3-one-queue-push---on-pop-o1-\"><svg><path></path></svg></a>Approach #3 (One Queue, push - O(n), pop O(1) )</h3>\n<p>The mentioned above two approaches have one weakness, they use two queues. This could be optimized as we use only one queue, instead of two.</p>\n<p><strong>Algorithm</strong></p>\n<p><strong>Push</strong></p>\n<p>When we push an element into a queue, it will be stored at back of the queue due to queue's properties.<br/>\nBut we need to implement a stack, where last inserted element should be in the front of the queue, not at the back. To achieve this we can invert the order of queue elements when pushing a new element.</p>\n<p></p>\n<p><em>Figure 5. Push an element in stack</em></p>\n<pre><code>private LinkedList&lt;Integer&gt; q1 = new LinkedList&lt;&gt;();\n​\n// Push element x onto stack.\npublic void push(int x) {\n    q1.add(x);\n    int sz = q1.size();\n    while (sz &gt; 1) {\n        q1.add(q1.remove());\n        sz--;\n    }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : O(n). The algorithm  removes n elements and inserts n+1 elements to <code>q1</code> , where n is the stack size. This gives 2n+1 operations. The operations <code>add</code> and <code>remove</code> in linked lists has O(1) complexity.</p>\n</li>\n<li>\n<p>Space complexity : O(1).</p>\n</li>\n</ul>\n<p><strong>Pop</strong></p>\n<p>The last inserted element is always stored at the front of <code>q1</code> and we can pop it for constant time.</p>\n<pre><code>// Removes the element on top of the stack.\npublic void pop() {\n    q1.remove();\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time complexity : O(1).</li>\n<li>Space complexity : O(1).</li>\n</ul>\n<p><strong>Empty</strong></p>\n<p>Queue <code>q1</code> contains all stack elements, so the algorithm checks if <code>q1</code> is empty.</p>\n<pre><code>// Return whether the stack is empty.\npublic boolean empty() {\n    return q1.isEmpty();\n}</code></pre>\n<p>Time complexity : O(1).<br/>\nSpace complexity : O(1).</p>\n<p><strong>Top</strong></p>\n<p>The <code>top</code> element is always positioned at the front of <code>q1</code>. Algorithm return it.</p>\n<pre><code>// Get the top element.\npublic int top() {\n    return q1.peek();\n}</code></pre>\n<p>Time complexity : O(1).<br/>\nSpace complexity : O(1).</p>\n<p>Analysis written by: @elmirap.</p>"}