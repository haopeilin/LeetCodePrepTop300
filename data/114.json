{"id":"114","title":"Flatten Binary Tree to Linked List","difficulty":"Medium","content":"<p>Given the <code>root</code> of a binary tree, flatten the tree into a &quot;linked list&quot;:</p>\n\n<ul>\n\t<li>The &quot;linked list&quot; should use the same <code>TreeNode</code> class where the <code>right</code> child pointer points to the next node in the list and the <code>left</code> child pointer is always <code>null</code>.</li>\n\t<li>The &quot;linked list&quot; should be in the same order as a <a href=\"https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR\" target=\"_blank\"><strong>pre-order</strong><strong> traversal</strong></a> of the binary tree.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/14/flaten.jpg\" style=\"width: 500px; height: 226px;\" />\n<pre>\n<strong>Input:</strong> root = [1,2,5,3,4,null,6]\n<strong>Output:</strong> [1,null,2,null,3,null,4,null,5,null,6]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = []\n<strong>Output:</strong> []\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [0]\n<strong>Output:</strong> [0]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 2000]</code>.</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> Can you flatten the tree in-place (with <code>O(1)</code> extra space)?","tags":["Linked List","Stack","Tree","Depth-First Search","Binary Tree"],"java_snippet":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public void flatten(TreeNode root) {\n        \n    }\n}","solution":"<h2><a href=\"#solution\"><svg><path></path></svg></a>Solution</h2>\n<h3><a href=\"#approach-1-recursion\"><svg><path></path></svg></a>Approach 1: Recursion</h3>\n<p><strong>Intuition</strong></p>\n<p>A common strategy for tree modification problems is recursion. A tree is a recursive structure. Every node gets to be a root node of some tree and that tree further has a bunch of smaller subtrees each with their own root nodes. So, when it comes to problems where the structure of the tree has to be modified or we have to traverse the tree in general, recursion is one of the top approaches that comes to mind simply because it's easy enough to code up and also is very intuitive to understand. Let's quickly look at a binary tree structure and then we will talk about how we can solve this problem using a recursive strategy.</p>\n<p>We haven't drawn the entire tree in the above image so as to build that intuition for that recursive solution. The main idea behind a recursive solution is that we use the solutions for subproblems to solve an uber level problem. In the case of a tree, the subtrees are essentially our subproblems. So, a recursive solution for this problem is essentially based on the idea that assuming we have already transformed the left and the right halves of a given root node, how do we establish or modify the necessary connections so that we get a right skewed tree overall. Let's look at what this means diagrammatically to have a better understanding.</p>\n<p>In the above figure, we simply showcase the root node of a tree and its left and right subtrees. A great way to think about recursion here is that we \"suppose\" that recursion does all the hard work for us and flattens out the left and the right subtrees as shown in the figure. What is it that we have to do then to get our final result? We need a right skewed tree, right? Well, we simply have to shuffle around some pointers to get our final result as shown below.</p>\n<p>Let's dive a bit deeper and take a look at an exact tree now to see what exact connections we'll need to establish exactly for this work.</p>\n<p>The figure shown below essentially highlights the exact set of nodes that are required for re-wiring the tree to our final right skewed tree. We've marked them \"L\" for left, \"R\" for right, and LT for \"left tail\". We'll get to the reason as to why we call that third node \"left tail\", later.</p>\n<p>And finally, let's see how our tree looks like once we rewire the \"L\" and the \"R\" nodes properly as well.</p>\n<p>Yeah, we haven't exactly explained what this <code>left tail</code> means. So, if you go back a few figures to the point where we had the left and the right subtrees all flattened out and we hadn't done any pointer manipulation yet, you'll notice that each subtree actually looks like a <code>Linked List</code>. Every linked list has a head node and in this case, we also need the <code>tail</code> node. Once recursion does the hard work for us and flattens out the subtrees, we will essentially get two linked lists and we need the tail end of the left one to attach it to the right one. Let's see what all information we will need in our recursive function at a given node.</p>\n<ul>\n<li><em>_node_</em> = The current node</li>\n<li><em>_leftChild_</em> = the left child of our current node</li>\n<li><em>_rightChild_</em> = the right child of our current node</li>\n<li><em>_leftTail_</em> = The tail node of the flattened out left subtree</li>\n<li><em>_rightTail_</em> = The tail node of the fully formed tree rooted at <em>_node_</em>. This information is needed by the parent recursive calls since the tree rooted at the current node can be some other's node's left subtree or right subtree.</li>\n</ul>\n<p>We have all the information available with us except the tail nodes. That's something that our recursion function will have to return. So, a recursion call for a given <code>node</code> will return the tail node of the flattened out tree. In our example, we will return the node <code>11</code> as the tail end of our final flattened out tree.</p>\n<p><strong>Algorithm</strong></p>\n<ol>\n<li>\n<p>We'll have a separate function for flattening out the tree since the main function provided in the problem isn't supposed to return anything and our algorithm will return the <code>tail</code> node of the flattened out tree.</p>\n</li>\n<li>\n<p>For a given <code>node</code>, we will recursively flatten out the left and the right subtrees and store their corresponding tail nodes in <code>leftTail</code> and <code>rightTail</code> respectively.</p>\n</li>\n<li>\n<p>Next, we will make the following connections (only if there is a left child for the current node, else the leftTail would be null)</p>\n\n</li>\n<li>\n<p>Next we have to return the tail of the final, flattened out tree rooted at <code>node</code>. So, if the <code>node</code> has a right child, then we will return the <code>rightTail</code>, else, we'll return the <code>leftTail</code>.</p>\n</li>\n</ol>\n<pre><code>/*\n * Definition for a binary tree node.\n * class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int x) { val = x; }\n *     TreeNode(int x, TreeNode left, TreeNode right) {\n *         val = x;\n *         this.left = left;\n *         this.right = right;\n *     }\n * };\n */\nclass Solution {\n    public TreeNode flattenTree(TreeNode node) {\n        // Handle the null scenario\n        if (node == null) {\n            return null;\n        }\n        // For a leaf node, we simply return the\n        // node as is.\n        if (node.left == null &amp;&amp; node.right == null) {\n            return node;\n        }\n        // Recursively flatten the left subtree\n        TreeNode leftTail = flattenTree(node.left);\n        // Recursively flatten the right subtree\n        TreeNode rightTail = flattenTree(node.right);\n        // If there was a left subtree, we shuffle the connections\n        // around so that there is nothing on the left side\n        // anymore.\n        if (leftTail != null) {\n            leftTail.right = node.right;\n            node.right = node.left;\n            node.left = null;\n        }\n        // We need to return the \"rightmost\" node after we are\n        // done wiring the new connections.\n        return rightTail == null ? leftTail : rightTail;\n    }\n\n    public void flatten(TreeNode root) {\n        flattenTree(root);\n    }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time Complexity: O(N) since we process each node of the tree exactly once.</li>\n<li>Space Complexity: O(N) which is occupied by the recursion stack. The problem statement doesn't mention anything about the tree being balanced or not and hence, the tree could be e.g. left skewed and in that case the longest branch (and hence the number of nodes in the recursion stack) would be N.\n<br/>\n</li>\n</ul>\n<br/>\n<hr/>\n<h3><a href=\"#approach-2-iterative-solution-using-stack\"><svg><path></path></svg></a>Approach 2: Iterative Solution using Stack</h3>\n<p><strong>Intuition</strong></p>\n<p>This approach is exactly the same as the previous one except the implementation. In the previous approach we rely on the system stack for our recursion's space requirements. However, as we all know, that stack is limited and for extremely long trees, it might not be feasible to use the system stack. So, we need to use our own stack that will be allocated memory on the heap and will be able to handle much larger sized trees easily.</p>\n<p><strong>Algorithm</strong></p>\n<ol>\n<li>\n<p>So the implementation for this algorithm using a custom stack is a tad bit tricky because now, we have to go one step further and understand how the different states of recursion will unfold and more importantly, we'll have to see how and when to add different nodes to our stack and when to pop them out for good. The basic idea however still follows along the same lines as the previous approach.</p>\n</li>\n<li>\n<p>We will initialize a <code>stack</code> which will contain a tuple. The first entry in the tuple will represent our node. The second entry will represent the recursion state that the node is in. We have two different recursion states namely <code>START</code> and <code>END</code>.</p>\n<ul>\n<li>START basically means that we haven't started processing the node yet and so, we will try and process its left side if one exists. If not, we will process its right side.</li>\n<li>When the node is in an END state, that implies we are done processing one side (subtree) of it. If we did process the left subtree of the node, then we need to re-wire the connections so as to make this a right skewed tree. Also, in the END state, we add the right child of the current node to the stack.</li>\n</ul>\n<p>It's important to understand the different cases around these recursion states based on different kinds of (sub)trees.</p>\n<p><code>Case 1: START recursion state, node has a left child</code></p>\n<p><code>Case 2: START recursion state, node has NO left child</code></p>\n<p><code>Case 3: END recursion state, node has a right child</code></p>\n</li>\n<li>\n<p>If the recursion state of a popped node is <code>START</code>, we will check if the node has a left child or not. If it does, we will add the node back to the stack with the <code>END</code> recursion state and also add the left child with the <code>START</code> recursion state. If there is no left child, then we add the right child <code>only</code> with the <code>START</code> state.</p>\n</li>\n<li>\n<p>If a node popped from the stack is in the <code>END</code> state, that implies it must have had a left child and that means we have a valid <code>tailNode</code> set up for re-wiring the connections as shown in the previous figure. Once we are done re-wiring the connections, we push the right child into the stack with the <code>START</code> recursion state.</p>\n</li>\n<li>\n<p>Finally, for a popped node that is a leaf node, we will set our <code>tailNode</code>.</p>\n</li>\n</ol>\n<pre><code>import java.util.Stack;\n\nclass Solution {\n    public void flatten(TreeNode root) {\n        // Handle the null scenario\n        if (root == null) {\n            return;\n        }\n\n        final int START = 1, END = 2;\n        TreeNode tailNode = null;\n\n        Stack<object[]> stk = new Stack&lt;&gt;();\n        stk.push(new Object[]{root, START});\n\n        while (!stk.isEmpty()) {\n            Object[] nodeData = stk.pop();\n            TreeNode currentNode = (TreeNode) nodeData[0];\n            int recursionState = (int) nodeData[1];\n\n            // We reached a leaf node. Record this as a tail\n            // node and move on.\n            if (currentNode.left == null &amp;&amp; currentNode.right == null) {\n                tailNode = currentNode;\n                continue;\n            }\n\n            // If the node is in the START state, it means we still\n            // haven't processed its left child yet.\n            if (recursionState == START) {\n                if (currentNode.left != null) {\n                    stk.push(new Object[]{currentNode, END});\n                    stk.push(new Object[]{currentNode.left, START});\n                } else if (currentNode.right != null) {\n                    stk.push(new Object[]{currentNode.right, START});\n                }\n            } else {\n                // END recursion state\n                TreeNode rightNode = currentNode.right;\n                if (tailNode != null) {\n                    // Establish the proper connections.\n                    tailNode.right = currentNode.right;\n                    currentNode.right = currentNode.left;\n                    currentNode.left = null;\n                    rightNode = tailNode.right;\n                }\n                if (rightNode != null) {\n                    stk.push(new Object[]{rightNode, START});\n                }\n            }\n        }\n    }\n}</object[]></code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time Complexity: O(N) since we process each node of the tree exactly once.</li>\n<li>Space Complexity: O(N) which is occupied by the stack. The problem statement doesn't mention anything about the tree being balanced or not and hence, the tree could be e.g. left skewed and in that case the longest branch (and hence the number of nodes in the recursion stack) would be N.\n<br/>\n</li>\n</ul>\n<br/>\n<hr/>\n<h3><a href=\"#approach-3-o1-iterative-solution\"><svg><path></path></svg></a>Approach 3: O(1) Iterative Solution</h3>\n<p><strong>Intuition</strong></p>\n<p>We'll get to the intuition for this approach in a bit, but first let's talk about the motivation. For any kind of tree traversal, we always have the easiest of solutions which is based on recursion. Next, we have a custom stack based iterative version of the same solution. Finally, we want a tree traversal that doesn't use any kind of additional space at all. There is a well known tree traversal out there that doesn't use any additional space at all. It's known as <code>Morris Traversal</code>. Our solution is based off of the same ideology, but Morris Traversal is not a pre-requisite here.</p>\n<p>To understand what's difference between the nodes processing of this approach and basic recursion, let's look at a sample tree.</p>\n<p>With recursion, we only re-wire the connections for the \"current node\" once we are already done processing the left and the right subtrees <em>completely</em>. Let's see what that looks like in a figure.</p>\n<p>However, the <code>postponing</code> of rewiring of connections on the current node until the left subtree is done, is basically what recursion is. Recursion is all about postponing decisions until something else is completed. In order for us to be able to postpone stuff, we need to use the stack. However, in our current approach we want to get rid of the stack altogether. So, we will have to come up with a <code>greedy</code> way that will be costlier in terms of time, but will be space efficient in achieving the same results.</p>\n<blockquote>\n<p>For a current node, we will check if it has a left child or not. If it does, we will find the last node in the rightmost branch of the subtree rooted at this left child. Once we find this \"rightmost\" node, we will hook it up with the right child of the current node.</p>\n</blockquote>\n<p>Let's look at this idea on our current sample tree.</p>\n<p>This might not make a lot of sense just yet. But, bear with me and read on. Let's see what connections we need to establish or shuffle once we find that \"rightmost node\". We are highlighting \"rightmost\" here because technically, even without knowing this approach, the node <code>23</code> would have made much more sense here, right? Instead, we are doing some vodoo with the node <code>6</code>. God knows why!</p>\n<p>As mentioned in the previous paragraph, this figure would make much more sense if we had just found out the node <code>23</code>, and set its right child to <code>1</code> instead of doing all this with <code>6</code>. Why did we do that you might ask? Well, it's an optimization of sorts. To find the actual \"rightmost\" node of subtree, we might have to potentially traverse most of that subtree. Like in our example. To actually get to the node <code>23</code>, we would have had to traverse all of the nodes: <code>2, 6, 44, 23</code>. Instead, we simply stop at the node 6. We'll see why that also achieves our final purpose. For now, let's move on.</p>\n<p>By doing the following operation for every node, we are simply trying to move stuff to the right-hand side one step at a time. The reason we used the node <code>6</code> in the above example and not <code>23</code> is the very reason we called this approach somewhat <code>greedy</code>.</p>\n<p>Processing of the node <code>2</code> is simple since it doesn't have a left child at all. So we have nothing to do here. Let's come over to the node <code>6</code> since this is where things get interesting and start to make sense. We'll again use the same logic as before.</p>\n<blockquote>\n<p>For a current node, we will check if it has a left child or not. If it does, we will find the last node in the rightmost branch of the subtree rooted at this left child. Once we find this \"rightmost\" node, we will hook it up with the right child of the current node.</p>\n</blockquote>\n<p>As we can clearly see from the previous figures, the rightmost node here would be <code>23</code>. So, let's look at the tree after we are done rewiring the connections.</p>\n<p>Now this looks just like the tree after the recursion would have completed on the left subtree and we rewired the connections, right? Exactly!. The reason we stopped at the <code>first rightmost node with no right child</code> was because we would eventually end up <code>rightyfying</code> all the subtrees through that connection. Even though before we didn't hook up the node <code>23</code>, we were able to do it when we arrived at the node <code>6</code> here.</p>\n<p><strong>Algorithm</strong></p>\n<ol>\n<li>\n<p>So basically, this is going to be a super short algorithm and a short-er implementation :)</p>\n</li>\n<li>\n<p>We use a pointer for traversing the nodes of our tree starting from the root. We have a loop that keeps going until the node pointer becomes null which is when we would be done processing the entire tree.</p>\n</li>\n<li>\n<p>For every node we check if it has a left child or not. If it doesn't we simply move on to the right hand side i.e.</p>\n\n</li>\n<li>\n<p>If the node does have a left child, we find the first node on the rightmost branch of the left subtree which doesn't have a right child i.e. the almost rightmost node.</p>\n\n</li>\n<li>\n<p>Once we find this rightmost node, we rewire the connections as explained in the intuition section.</p>\n\n</li>\n<li>\n<p>And we move on to the right node to continue processing of our tree.</p>\n</li>\n</ol>\n<pre><code>class Solution {\n    public void flatten(TreeNode root) {\n        // Handle the null scenario\n        if (root == null) {\n            return;\n        }\n\n        TreeNode node = root;\n        while (node != null) {\n            // If the node has a left child\n            if (node.left != null) {\n                // Find the rightmost node\n                TreeNode rightmost = node.left;\n                while (rightmost.right != null) {\n                    rightmost = rightmost.right;\n                }\n                // Rewire the connections\n                rightmost.right = node.right;\n                node.right = node.left;\n                node.left = null;\n            }\n            // Move on to the right side of the tree\n            node = node.right;\n        }\n    }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time Complexity: O(N) since we process each node of the tree at most twice. If you think about it, we process the nodes once when we actually run our algorithm on them as the <code>currentNode</code>. The second time when we <code>come across</code> the nodes is when we are trying to find our <code>rightmost node</code>. Sure, this algorithm is <code>slower</code> than the previous two approaches but it doesn't use any additional space which is a big win.</li>\n<li>Space Complexity: O(1) boom!.\n<br/>\n</li>\n</ul>\n<br/>"}