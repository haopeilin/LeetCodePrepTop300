{"id":"99","title":"Recover Binary Search Tree","difficulty":"Medium","content":"<p>You are given the <code>root</code> of a binary search tree (BST), where the values of <strong>exactly</strong> two nodes of the tree were swapped by mistake. <em>Recover the tree without changing its structure</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/28/recover1.jpg\" style=\"width: 422px; height: 302px;\" />\n<pre>\n<strong>Input:</strong> root = [1,3,null,null,2]\n<strong>Output:</strong> [3,1,null,null,2]\n<strong>Explanation:</strong> 3 cannot be a left child of 1 because 3 &gt; 1. Swapping 1 and 3 makes the BST valid.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/28/recover2.jpg\" style=\"width: 581px; height: 302px;\" />\n<pre>\n<strong>Input:</strong> root = [3,1,4,null,null,2]\n<strong>Output:</strong> [2,1,4,null,null,3]\n<strong>Explanation:</strong> 2 cannot be in the right subtree of 3 because 2 &lt; 3. Swapping 2 and 3 makes the BST valid.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[2, 1000]</code>.</li>\n\t<li><code>-2<sup>31</sup> &lt;= Node.val &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> A solution using <code>O(n)</code> space is pretty straight-forward. Could you devise a constant <code>O(1)</code> space solution?","tags":["Tree","Depth-First Search","Binary Search Tree","Binary Tree"],"java_snippet":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public void recoverTree(TreeNode root) {\n        \n    }\n}","solution":"<h2><a href=\"#solution\"><svg><path></path></svg></a>Solution</h2>\n<hr/>\n<h3><a href=\"#approach-1-sort-an-almost-sorted-array-where-two-elements-are-swapped\"><svg><path></path></svg></a>Approach 1: Sort an Almost Sorted Array Where Two Elements Are Swapped</h3>\n<p><strong>Intuition</strong></p>\n<p>Let's start from straightforward but not optimal solution with a linear time and space complexity. This solution serves to identify and discuss all subproblems.</p>\n<p>It's known that <a href=\"https://leetcode.com/articles/delete-node-in-a-bst/\">inorder traversal of BST is an array sorted in the ascending order</a>. Here is how one could compute an inorder traversal</p>\n<pre><code>public void inorder(TreeNode root, List&lt;Integer&gt; nums) {\n    if (root == null) return;\n    inorder(root.left, nums);\n    nums.add(root.val);\n    inorder(root.right, nums);\n}</code></pre>\n<p>Here two nodes are swapped, and hence inorder traversal is an almost sorted array where only two elements are swapped. To identify two swapped elements in a sorted array is a classical problem that could be solved in linear time. Here is a solution code</p>\n<pre><code>public int[] findTwoSwapped(List&lt;Integer&gt; nums) {\n    int n = nums.size();\n    int x = -1, y = -1;\n    boolean swapped_first_occurrence = false;\n​\n    for (int i = 0; i &lt; n - 1; ++i) {\n        if (nums.get(i + 1) &lt; nums.get(i)) {\n            y = nums.get(i + 1);\n            if (!swapped_first_occurrence) {\n                // The first swap occurrence\n                x = nums.get(i);\n                swapped_first_occurrence = true;\n            } else {\n                // The second swap occurrence\n                break;\n            }\n        }\n    }\n    return new int[] { x, y };\n}</code></pre>\n<p>When swapped nodes are known, one could traverse the tree again and swap their values.</p>\n<p><strong>Algorithm</strong></p>\n<p>Here is the algorithm:</p>\n<ol>\n<li>\n<p>Construct inorder traversal of the tree. It should be an almost sorted list where only two elements are swapped.</p>\n</li>\n<li>\n<p>Identify two swapped elements x and y in an almost sorted array in linear time.</p>\n</li>\n<li>\n<p>Traverse the tree again. Change value x to y and value y to x.</p>\n</li>\n</ol>\n<p><strong>Implementation</strong></p>\n<pre><code>class Solution {\npublic:\n    void inorder(TreeNode* root, vector&lt;int&gt;&amp; nums) {\n        if (root == nullptr) return;\n        inorder(root-&gt;left, nums);\n        nums.push_back(root-&gt;val);\n        inorder(root-&gt;right, nums);\n    }\n    vector&lt;int&gt; findTwoSwapped(vector&lt;int&gt; nums) {\n        int n = nums.size();\n        int x = -1, y = -1;\n        bool swapped_first_occurrence = false;\n        for (int i = 0; i &lt; n - 1; ++i) {\n            if (nums[i + 1] &lt; nums[i]) {\n                y = nums[i + 1];\n                if (!swapped_first_occurrence) {\n                    // The first swap occurrence\n                    x = nums[i];\n                    swapped_first_occurrence = true;\n                } else {\n                    // The second swap occurrence\n                    break;\n                }\n            }\n        }\n        return vector&lt;int&gt;{x, y};\n    }\n    void recover(TreeNode* r, int count, int x, int y) {\n        if (r != nullptr) {\n            if (r-&gt;val == x || r-&gt;val == y) {\n                r-&gt;val = r-&gt;val == x ? y : x;\n                if (--count == 0) return;\n            }\n            recover(r-&gt;left, count, x, y);\n            recover(r-&gt;right, count, x, y);\n        }\n    }\n    void recoverTree(TreeNode* root) {\n        vector&lt;int&gt; nums;\n        inorder(root, nums);\n        vector&lt;int&gt; swapped = findTwoSwapped(nums);\n        recover(root, 2, swapped[0], swapped[1]);\n    }\n};</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity: O(N). To compute inorder traversal takes O(N) time, to identify and to swap back swapped nodes O(N) in the worst case.</p>\n</li>\n<li>\n<p>Space complexity: O(N) since we keep inorder traversal <code>nums</code> with N elements.</p>\n</li>\n</ul>\n<hr/>\n<h3><a href=\"#what-is-coming-next\"><svg><path></path></svg></a>What Is Coming Next</h3>\n<p>In approach 1 we discussed three easy subproblems of this hard problem:</p>\n<ol>\n<li>\n<p>Construct inorder traversal.</p>\n</li>\n<li>\n<p>Find swapped elements in an almost sorted array where only two elements are swapped.</p>\n</li>\n<li>\n<p>Swap values of two nodes.</p>\n</li>\n</ol>\n<p>Now we will discuss three more approaches, and basically they are all the same :</p>\n<ul>\n<li>\n<p>Merge steps 1 and 2, i.e. identify swapped nodes during the inorder traversal.</p>\n</li>\n<li>\n<p>Swap node values.</p>\n</li>\n</ul>\n<p>The difference in-between the following approaches is in a chosen method to implement inorder traversal :</p>\n<ul>\n<li>\n<p>Approach 2 : Iterative.</p>\n</li>\n<li>\n<p>Approach 3 : Recursive.</p>\n</li>\n<li>\n<p>Approach 4 : Morris.</p>\n</li>\n</ul>\n<p>Iterative and recursive approaches here do less than <em>one pass</em>, and they both need up to O(H) space to keep stack, where H is a tree height.</p>\n<p>Morris approach is <em>two pass</em> approach, but it's a constant-space one.</p>\n<hr/>\n<h3><a href=\"#approach-2-iterative-inorder-traversal\"><svg><path></path></svg></a>Approach 2: Iterative Inorder Traversal</h3>\n<p><strong>Intuition</strong></p>\n<p>Here we construct inorder traversal by iterations and identify swapped nodes at the same time, in one pass.</p>\n<blockquote>\n<p>Iterative inorder traversal is simple: go left as far as you can, then one step right. Repeat till the end of nodes in the tree.</p>\n</blockquote>\n<p>To identify swapped nodes, track the last node <code>pred</code> in the inorder traversal (i.e. the <em>predecessor</em> of the current node) and compare it with current node value. If the current node value is smaller than its predecessor <code>pred</code> value, the swapped node is here.</p>\n<p>There are only two swapped nodes here, and hence one could break after having the second node identified.</p>\n<p>Doing so, one could get directly nodes (and not only their values), and hence swap node values in O(1) time, drastically reducing the time needed for step 3.</p>\n<p></p>\n<p><strong>Implementation</strong></p>\n<p><a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/Stack.html\">Don't use Stack in Java, use ArrayDeque instead</a>.</p>\n<pre><code>class Solution {\npublic:\n    void recoverTree(TreeNode* root) {\n        stack&lt;TreeNode*&gt; stack;\n        TreeNode *x = NULL, *y = NULL, *pred = NULL;\n        while (!stack.empty() || root != NULL) {\n            while (root != NULL) {\n                stack.push(root);\n                root = root-&gt;left;\n            }\n            root = stack.top();\n            stack.pop();\n            if (pred != NULL &amp;&amp; root-&gt;val &lt; pred-&gt;val) {\n                y = root;\n                if (x == NULL)\n                    x = pred;\n                else\n                    break;\n            }\n            pred = root;\n            root = root-&gt;right;\n        }\n        swap(x-&gt;val, y-&gt;val);\n    }\n};</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity: O(N) in the worst case when one of the swapped nodes is a rightmost leaf.</p>\n</li>\n<li>\n<p>Space complexity : up to O(N) to keep the stack in the worst case when the tree is completely lean.</p>\n</li>\n</ul>\n<hr/>\n<h3><a href=\"#approach-3-recursive-inorder-traversal\"><svg><path></path></svg></a>Approach 3: Recursive Inorder Traversal</h3>\n<p>Iterative approach 2 could be converted into recursive one.</p>\n<p>Recursive inorder traversal is extremely simple: follow <code>Left-&gt;Node-&gt;Right</code> direction, i.e. do the recursive call for the <em>left</em> child, then do all the business with the node (= if the node is the swapped one or not), and then do the recursive call for the <em>right</em> child.</p>\n<p>On the following figure the nodes are numerated in the order you visit them, please follow <code>1-2-3-4-5</code> to compare different DFS strategies.</p>\n<p><strong>Implementation</strong></p>\n<pre><code>class Solution {\npublic:\n    TreeNode* x = nullptr;     // first node\n    TreeNode* y = nullptr;     // second node\n    TreeNode* pred = nullptr;  // predecessor node\n    void findTwoSwapped(TreeNode* root) {\n        if (root == nullptr) return;\n        findTwoSwapped(root-&gt;left);\n        if (pred != nullptr &amp;&amp; root-&gt;val &lt; pred-&gt;val) {\n            y = root;\n            if (x == nullptr)\n                x = pred;\n            else\n                return;\n        }\n        pred = root;\n        findTwoSwapped(root-&gt;right);\n    }\n    void recoverTree(TreeNode* root) {\n        findTwoSwapped(root);\n        swap(x-&gt;val, y-&gt;val);  // C++ standard swap function\n    }\n};</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity: O(N) in the worst case when one of the swapped nodes is a rightmost leaf.</p>\n</li>\n<li>\n<p>Space complexity : up to O(N) to keep the stack in the worst case when the tree is completely lean.</p>\n</li>\n</ul>\n<hr/>\n<h3><a href=\"#approach-4-morris-inorder-traversal\"><svg><path></path></svg></a>Approach 4: Morris Inorder Traversal</h3>\n<p>We discussed already iterative and recursive inorder traversals, which both have great time complexity though use up to O(N) to keep stack. We could trade in performance to save space.</p>\n<p>The idea of Morris inorder traversal is simple: to use no space but to traverse the tree.</p>\n<blockquote>\n<p>How that could be even possible? At each node one has to decide where to go: left or right, traverse left subtree or traverse right subtree. How one could know that the left subtree is already done if no additional memory is allowed?</p>\n</blockquote>\n<p>The idea of <a href=\"https://www.sciencedirect.com/science/article/pii/0020019079900681\">Morris</a> algorithm is to set the <em>temporary link</em> between the node and its<br/>\n<a href=\"https://leetcode.com/articles/delete-node-in-a-bst/\">predecessor</a>: <code>predecessor.right = root</code>. So one starts from the node, computes its predecessor and verifies if the link is present.</p>\n<ul>\n<li>\n<p>There is no link? Set it and go to the left subtree.</p>\n</li>\n<li>\n<p>There is a link? Break it and go to the right subtree.</p>\n</li>\n</ul>\n<p>There is one small issue to deal with : what if there is no left child, i.e. there is no left subtree? Then go straightforward to the right subtree.</p>\n<p></p>\n<p><strong>Implementation</strong></p>\n<pre><code>class Solution {\npublic:\n    void swap(TreeNode* a, TreeNode* b) {\n        int tmp = a-&gt;val;\n        a-&gt;val = b-&gt;val;\n        b-&gt;val = tmp;\n    }\n    void recoverTree(TreeNode* root) {\n        // predecessor is a Morris predecessor.\n        // In the 'loop' cases it could be equal to the node itself predecessor\n        // == root. pred is a 'true' predecessor, the previous node in the\n        // inorder traversal.\n        TreeNode *x = nullptr, *y = nullptr, *pred = nullptr,\n                 *predecessor = nullptr;\n        while (root != nullptr) {\n            // If there is a left child\n            // then compute the predecessor.\n            // If there is no link predecessor-&gt;right = root --&gt; set it.\n            // If there is a link predecessor-&gt;right = root --&gt; break it.\n            if (root-&gt;left != nullptr) {\n                // Predecessor node is one step left\n                // and then right till you can.\n                predecessor = root-&gt;left;\n                while (predecessor-&gt;right != nullptr &amp;&amp;\n                       predecessor-&gt;right != root)\n                    predecessor = predecessor-&gt;right;\n                // Set the link predecessor-&gt;right = root\n                // and go to explore left subtree\n                if (predecessor-&gt;right == nullptr) {\n                    predecessor-&gt;right = root;\n                    root = root-&gt;left;\n                }\n                // Break the link predecessor-&gt;right = root\n                // link is broken : time to change subtree and go right\n                else {\n                    // Check for the swapped nodes\n                    if (pred != nullptr &amp;&amp; root-&gt;val &lt; pred-&gt;val) {\n                        y = root;\n                        if (x == nullptr) x = pred;\n                    }\n                    pred = root;\n                    predecessor-&gt;right = nullptr;\n                    root = root-&gt;right;\n                }\n            }\n            // If there is no left child\n            // then just go right.\n            else {\n                // Check for the swapped nodes\n                if (pred != nullptr &amp;&amp; root-&gt;val &lt; pred-&gt;val) {\n                    y = root;\n                    if (x == nullptr) x = pred;\n                }\n                pred = root;\n                root = root-&gt;right;\n            }\n        }\n        swap(x, y);\n    }\n};</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : O(N) since we visit each node up to two times.</p>\n</li>\n<li>\n<p>Space complexity : O(1).</p>\n</li>\n</ul>"}