{"id":"291","title":"Word Pattern II","difficulty":"Medium","content":"<p>Given a <code>pattern</code> and a string <code>s</code>, return <code>true</code><em> if </em><code>s</code><em> <strong>matches</strong> the </em><code>pattern</code><em>.</em></p>\n\n<p>A string <code>s</code> <b>matches</b> a <code>pattern</code> if there is some <strong>bijective mapping</strong> of single characters to <strong>non-empty</strong> strings such that if each character in <code>pattern</code> is replaced by the string it maps to, then the resulting string is <code>s</code>. A <strong>bijective mapping</strong> means that no two characters map to the same string, and no character maps to two different strings.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> pattern = &quot;abab&quot;, s = &quot;redblueredblue&quot;\n<strong>Output:</strong> true\n<strong>Explanation:</strong> One possible mapping is as follows:\n&#39;a&#39; -&gt; &quot;red&quot;\n&#39;b&#39; -&gt; &quot;blue&quot;</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> pattern = &quot;aaaa&quot;, s = &quot;asdasdasdasd&quot;\n<strong>Output:</strong> true\n<strong>Explanation:</strong> One possible mapping is as follows:\n&#39;a&#39; -&gt; &quot;asd&quot;\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> pattern = &quot;aabb&quot;, s = &quot;xyzabcxzyabc&quot;\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= pattern.length, s.length &lt;= 20</code></li>\n\t<li><code>pattern</code> and <code>s</code> consist of only lowercase English letters.</li>\n</ul>\n","tags":["Hash Table","String","Backtracking"],"java_snippet":"class Solution {\n    public boolean wordPatternMatch(String pattern, String s) {\n        \n    }\n}","solution":"<div class=\"flex flex-col w-full\" style=\"position: relative;\"><div class=\"mYe_l WRmCx\"><h2 class=\"group/heading relative\" id=\"solution\" level=\"2\"><a aria-hidden=\"true\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" href=\"#solution\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" data-icon=\"link\" data-prefix=\"fas\" focusable=\"false\" role=\"img\" spacing=\"square\" viewbox=\"0 0 640 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\" fill=\"currentColor\"></path></svg></div></a>Solution</h2>\n<hr/>\n<h3 class=\"group/heading relative\" id=\"overview\" level=\"3\"><a aria-hidden=\"true\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" href=\"#overview\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" data-icon=\"link\" data-prefix=\"fas\" focusable=\"false\" role=\"img\" spacing=\"square\" viewbox=\"0 0 640 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\" fill=\"currentColor\"></path></svg></div></a>Overview</h3>\n<p>Our objective is to return <code>true</code> if <code>s</code> matches the <code>pattern</code>.</p>\n<p>We can think of the pattern as a code, where each character in the <code>pattern</code> is a symbol that corresponds to a substring of <code>s</code>.</p>\n<blockquote>\n<p><strong>Input:</strong> pattern = \"abab\", s = \"redblueredblue\"</p>\n</blockquote>\n<table><thead><tr><th style=\"text-align: center;\">Symbol</th><th style=\"text-align: center;\">Value</th></tr></thead><tbody><tr><td style=\"text-align: center;\"><code>'a'</code></td><td style=\"text-align: center;\">\"red\"</td></tr><tr><td style=\"text-align: center;\"><code>'b'</code></td><td style=\"text-align: center;\">\"blue\"</td></tr></tbody></table>\n<p>If we can build <code>s</code> using the code, then <code>s</code> matches the <code>pattern</code>.</p>\n<p>Understanding test cases that fail can help us better understand the problem.</p>\n<blockquote>\n<p><strong>Input:</strong> pattern = \"ab\", s = \"aa\"<br/>\n<strong>Output:</strong> false</p>\n</blockquote>\n<table><thead><tr><th style=\"text-align: center;\">Symbol</th><th style=\"text-align: center;\">Value 1</th><th style=\"text-align: center;\">Value 2</th></tr></thead><tbody><tr><td style=\"text-align: center;\"><code>'a'</code></td><td style=\"text-align: center;\">\"a\"</td><td style=\"text-align: center;\">\"aa\"</td></tr><tr><td style=\"text-align: center;\"><code>'b'</code></td><td style=\"text-align: center;\">\"a\"</td><td style=\"text-align: center;\">\"\"</td></tr></tbody></table>\n<p>Neither of the value columns in the above table are valid mappings because each symbol must be mapped to a <strong>unique non-empty</strong> substring of <code>s</code>.</p>\n<p>One challenge of this problem is that we are unsure of the number of characters in <code>s</code> that correspond to each symbol in the <code>pattern</code>. We may need to explore many possibilities before finding a valid mapping or determining that none exists.</p>\n<hr/>\n<h3 class=\"group/heading relative\" id=\"approach-1-hash-table-and-backtracking\" level=\"3\"><a aria-hidden=\"true\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" href=\"#approach-1-hash-table-and-backtracking\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" data-icon=\"link\" data-prefix=\"fas\" focusable=\"false\" role=\"img\" spacing=\"square\" viewbox=\"0 0 640 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\" fill=\"currentColor\"></path></svg></div></a>Approach 1: Hash Table and Backtracking</h3>\n<h4 id=\"intuition\">Intuition</h4>\n<p>The code table in the overview looks like a hash table. We can utilize a hash map to store <code>(symbol, word)</code> mappings, where a character from <code>pattern</code> is the key and a substring of <code>s</code> is the value.</p>\n<p>Each symbol must be mapped to a unique <code>word</code>, so we will also use a hash set to track the <code>word</code> values we have stored already.</p>\n<p>The brute force method of solving the problem is to generate all of the possible mappings and then test each one to see if it is valid. This approach would be inefficient, leading to an exponential time complexity.</p>\n<p>How can we reduce the search space?</p>\n<p>Let's say we have created the following mapping for the below example:</p>\n<blockquote>\n<p><strong>Input:</strong> pattern = \"abab\", s = \"redblueredblue\"</p>\n</blockquote>\n<table><thead><tr><th style=\"text-align: center;\">Key</th><th style=\"text-align: center;\">Value</th></tr></thead><tbody><tr><td style=\"text-align: center;\"><code>'a'</code></td><td style=\"text-align: center;\">\"re\"</td></tr><tr><td style=\"text-align: center;\"><code>'b'</code></td><td style=\"text-align: center;\">\"db\"</td></tr></tbody></table>\n<p>When we reach the next character, <code>\"l\"</code>, in <code>s</code>, the current symbol is <code>'a'</code>. Since <code>'a'</code> maps to <code>\"re\"</code> according to our mapping, we expect to see <code>\"re\"</code> in <code>s</code> at that position. However, we find <code>\"l\"</code> instead. This mismatch indicates that our current mapping isn't valid for the entire string <code>s</code>, and thus, we do not need to check the rest of the string.</p>\n<p>Now, we could abandon the current mapping and start over, or we could backtrack to the last point where the mapping was valid to explore other possibilities.</p>\n<blockquote>\n<p>If you are not familiar with backtracking, we recommend you read our <strong><a href=\"https://leetcode.com/explore/learn/card/recursion-ii/472/backtracking/2654/\" target=\"_blank\">Backtracking Explore Card</a></strong>.</p>\n</blockquote>\n<p>We will create a recursive function, <code>isMatch</code>, that uses backtracking to determine whether <code>s</code> matches the <code>pattern</code>. The function uses a pointer, <code>pIndex</code> to traverse the <code>pattern</code> and a pointer <code>sIndex</code> to track the current index of <code>s</code>.</p>\n<p>The base case is when we have processed the whole pattern. If we have also processed the entirety of <code>s</code>, the <code>pattern</code> matches <code>s</code>, so we return <code>true</code>. Otherwise, there are extra characters of <code>s</code>, so we return <code>false</code>.</p>\n<p>For the recursive case, we start by saving the current character in the pattern as <code>symbol</code>.</p>\n<p>If we have encountered the <code>symbol</code> before, we check whether the corresponding <code>word</code> matches with the next characters in <code>s</code>. If so, we move on to the next character in the <code>pattern</code> with a recursive call to <code>isMatch</code>.</p>\n<p>If the <code>symbol</code> is the first occurrence in <code>pattern</code>, we need to generate the possible mappings from <code>symbol</code> to different substrings of <code>s</code>.</p>\n<blockquote>\n<p><strong>Input:</strong> pattern = \"abac\", s = \"aabbaac\"</p>\n</blockquote>\n<p>State: <code>pIndex = 1</code> and <code>sIndex = 2</code></p>\n<p>The current <code>symbol</code> is <code>b</code>, which is its first occurrence. The possible mappings are:</p>\n<div class=\"font-menlo mb-6 rounded-lg px-3 py-2.5 text-sm bg-fill-3 dark:bg-dark-fill-3\"><div class=\"group relative\" translate=\"no\"><pre style=\"color: black; font-size: 13px; text-shadow: none; font-family: Menlo, Monaco, Consolas; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 4; hyphens: none; padding: 0px; margin: 0px; overflow: auto; background: transparent; overflow-wrap: normal;\"><code class=\"language-javascript\" style=\"white-space: pre; text-shadow: none;\"><span><span>s</span><span class=\"token\" style=\"color: rgb(153, 153, 153);\">[</span><span class=\"token\" style=\"color: rgb(153, 0, 85);\">2</span><span class=\"token\" style=\"color: rgb(153, 153, 153);\">]</span><span> </span><span class=\"token\" style=\"color: rgb(154, 110, 58);\">=</span><span> </span><span class=\"token\" style=\"color: rgb(102, 153, 0);\">\"b\"</span><span>\n</span></span><span><span>s</span><span class=\"token\" style=\"color: rgb(153, 153, 153);\">[</span><span class=\"token\" style=\"color: rgb(153, 0, 85);\">2</span><span class=\"token\" style=\"color: rgb(154, 110, 58);\">:</span><span class=\"token\" style=\"color: rgb(153, 0, 85);\">3</span><span class=\"token\" style=\"color: rgb(153, 153, 153);\">]</span><span> </span><span class=\"token\" style=\"color: rgb(154, 110, 58);\">=</span><span> </span><span class=\"token\" style=\"color: rgb(102, 153, 0);\">\"bb\"</span><span>\n</span></span><span><span>s</span><span class=\"token\" style=\"color: rgb(153, 153, 153);\">[</span><span class=\"token\" style=\"color: rgb(153, 0, 85);\">2</span><span class=\"token\" style=\"color: rgb(154, 110, 58);\">:</span><span class=\"token\" style=\"color: rgb(153, 0, 85);\">4</span><span class=\"token\" style=\"color: rgb(153, 153, 153);\">]</span><span> </span><span class=\"token\" style=\"color: rgb(154, 110, 58);\">=</span><span> </span><span class=\"token\" style=\"color: rgb(102, 153, 0);\">\"bba\"</span><span>\n</span></span><span><span>s</span><span class=\"token\" style=\"color: rgb(153, 153, 153);\">[</span><span class=\"token\" style=\"color: rgb(153, 0, 85);\">2</span><span class=\"token\" style=\"color: rgb(154, 110, 58);\">:</span><span class=\"token\" style=\"color: rgb(153, 0, 85);\">5</span><span class=\"token\" style=\"color: rgb(153, 153, 153);\">]</span><span> </span><span class=\"token\" style=\"color: rgb(154, 110, 58);\">=</span><span> </span><span class=\"token\" style=\"color: rgb(102, 153, 0);\">\"bbaa\"</span><span>\n</span></span><span><span>s</span><span class=\"token\" style=\"color: rgb(153, 153, 153);\">[</span><span class=\"token\" style=\"color: rgb(153, 0, 85);\">2</span><span class=\"token\" style=\"color: rgb(154, 110, 58);\">:</span><span class=\"token\" style=\"color: rgb(153, 0, 85);\">6</span><span class=\"token\" style=\"color: rgb(153, 153, 153);\">]</span><span> </span><span class=\"token\" style=\"color: rgb(154, 110, 58);\">=</span><span> </span><span class=\"token\" style=\"color: rgb(102, 153, 0);\">\"bbacc\"</span></span></code></pre><div class=\"absolute -right-1.5 -top-0.5 flex gap-2\"><div class=\"z-base-1 hidden rounded border group-hover:block border-border-quaternary dark:border-border-quaternary bg-layer-02 dark:bg-layer-02\"><div class=\"relative cursor-pointer flex h-[22px] w-[22px] items-center justify-center bg-layer-02 dark:bg-layer-02 hover:bg-fill-tertiary dark:hover:bg-fill-tertiary rounded-[4px]\" data-state=\"closed\"><div><div data-state=\"closed\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3 h-3.5 w-3.5 text-text-primary dark:text-text-primary\"><svg aria-hidden=\"true\" class=\"svg-inline--fa fa-clone absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" data-icon=\"clone\" data-prefix=\"far\" focusable=\"false\" role=\"img\" viewbox=\"0 0 512 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M64 464H288c8.8 0 16-7.2 16-16V384h48v64c0 35.3-28.7 64-64 64H64c-35.3 0-64-28.7-64-64V224c0-35.3 28.7-64 64-64h64v48H64c-8.8 0-16 7.2-16 16V448c0 8.8 7.2 16 16 16zM224 304H448c8.8 0 16-7.2 16-16V64c0-8.8-7.2-16-16-16H224c-8.8 0-16 7.2-16 16V288c0 8.8 7.2 16 16 16zm-64-16V64c0-35.3 28.7-64 64-64H448c35.3 0 64 28.7 64 64V288c0 35.3-28.7 64-64 64H224c-35.3 0-64-28.7-64-64z\" fill=\"currentColor\"></path></svg></div></div></div></div></div></div></div></div>\n<p>The possible <code>word</code> mappings for the <code>symbol</code> are the set of substrings that start at <code>sIndex</code> and end anywhere between <code>sIndex</code> and the last index of <code>s</code>. Let such a substring be termed <code>newWord</code>. If we find that we have encountered <code>newWord</code> before, we continue with the next iteration because each <code>symbol</code> to <code>word</code> mapping must be unique. Otherwise, we add <code>newWord</code> to the hash map and hash set. Then, we call <code>isMatch</code> with the next character in the <code>pattern</code>. Finally, we backtrack by removing <code>newWord</code> from the hash map and hash set to explore other possible mappings.</p>\n<h4 id=\"algorithm\">Algorithm</h4>\n<ol>\n<li data-length=\"1\">Create a hash map <code>symbolMap</code> that maps the key, a character from <code>pattern</code>, to the value, a substring of <code>s</code>.</li>\n<li data-length=\"1\">Create a hash set <code>wordSet</code> that stores the unique substrings of <code>s</code> that have been mapped to a <code>symbol</code>.</li>\n<li data-length=\"1\">Define a recursive function <code>isMatch</code> that takes an index in <code>s</code>, <code>sIndex</code>, and an index in <code>pattern</code>, <code>pIndex</code> as parameters. The function determines whether <code>s</code> matches a given <code>pattern</code>. Pass <code>s</code> and <code>pattern</code> as parameters to the function if needed because of scoping.\n<ul>\n<li>Base case: <code>pIndex</code> equals the length of <code>pattern</code>. Return <code>true</code> if <code>sIndex</code> equals the length of <code>s</code>; <code>s</code> matches the pattern. Otherwise, return <code>false</code>.</li>\n<li>Set <code>symbol</code> to <code>pattern[pIndex]</code>, the next character in the pattern.</li>\n<li>If <code>symbol</code> is associated with a substring of <code>s</code>, save the substring as <code>word</code>, and check if the next characters in <code>s</code> match <code>word</code>.\n<ul>\n<li>If the characters don't match, return <code>false</code>.</li>\n<li>If they do match, call <code>isMatch</code> for the next character in <code>pattern</code>.</li>\n</ul>\n</li>\n<li>Otherwise, <code>symbol</code> is a new <code>pattern</code> character. Try mapping <code>symbol</code> to new substrings of <code>s</code>, starting with the substring consisting of <code>s[sIndex]</code> and extending until the substring reaches the end of <code>s</code>.\n<ul>\n<li>Save the current substring as <code>newWord</code>.</li>\n<li>If <code>newWord</code> already exists in <code>wordSet</code>, continue.</li>\n<li>Otherwise, add <code>newWord</code> to <code>wordSet</code> and to <code>symbolMap</code> with the <code>symbol</code>.</li>\n<li>Call <code>isMatch</code> for the next character in <code>pattern</code>. If the result is <code>true</code>, return <code>true</code>.</li>\n<li>Remove <code>newWord</code> from the <code>wordSet</code> and the <code>symbolMap</code>.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li data-length=\"1\">Call <code>isMatch</code> with <code>sIndex</code> and <code>pIndex</code> as <code>0</code> and return the result.</li>\n</ol>\n<h4 id=\"implementation\">Implementation</h4>\n<pre><code>class Solution {\npublic:\n    bool wordPatternMatch(string pattern, string s) {\n        unordered_map&lt;char, string&gt; symbolMap;\n        unordered_set&lt;string&gt; wordSet;\n​\n        return isMatch(s, 0, pattern, 0, symbolMap, wordSet);\n    }\n​\nprivate:\n    bool isMatch(string&amp; s, int sIndex, string&amp; pattern, int pIndex,\n                 unordered_map&lt;char, string&gt;&amp; symbolMap,\n                 unordered_set&lt;string&gt;&amp; wordSet) {\n        // Base case: reached end of pattern\n        if (pIndex == pattern.length()) {\n            return sIndex == s.length(); // True iff also reached end of s\n        }\n​\n        // Get current pattern character\n        char symbol = pattern[pIndex];\n​\n        // This symbol already has an associated word\n        if (symbolMap.find(symbol) != symbolMap.end()) {\n            string word = symbolMap[symbol];\n            // Check if it matches s[sIndex...sIndex + word.length()]\n            if (s.compare(sIndex, word.length(), word)) {\n                return false;\n            }\n            // If it matches continue to match the rest\n            return isMatch(s, sIndex + word.length(), pattern, pIndex + 1,\n                           symbolMap, wordSet);\n        }\n​\n        // This symbol does not exist in the map\n        for (int k = sIndex + 1; k &lt;= s.length(); k++) {\n            string newWord = s.substr(sIndex, k - sIndex);\n            if (wordSet.find(newWord) != wordSet.end()) {\n                continue;\n            }\n            // Create or update it\n            symbolMap[symbol] = newWord;\n            wordSet.insert(newWord);\n            // Continue to match the rest\n            if (isMatch(s, k, pattern, pIndex + 1, symbolMap, wordSet)) {\n                return true;\n            }\n            // Backtracking\n            symbolMap.erase(symbol);\n            wordSet.erase(newWord);\n        }\n        // No mappings were valid\n        return false;\n    }\n};</code></pre>\n<h4 id=\"complexity-analysis\">Complexity Analysis</h4>\n<p>Let <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></span> be the length of <code>s</code> and <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.625em; vertical-align: -0.1944em;\"></span><span class=\"mord mathnormal\">p</span></span></span></span></span> be the length of <code>pattern</code>.</p>\n<ul>\n<li>\n<p>Time complexity: <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">p</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1.0641em; vertical-align: -0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.8141em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p>The <code>isMatch</code> function is called for each character in <code>pattern</code> for each <code>word</code> that can be formed from substrings of <code>s</code>.</p>\n<p>Looking up a <code>symbol</code> in the hash map or <code>word</code> in the hash set takes <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></span> in the average case.</p>\n<p>We generate <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></span> substrings of length <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6444em;\"></span><span class=\"mord\">1</span></span></span></span></span>, <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6667em; vertical-align: -0.0833em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.6444em;\"></span><span class=\"mord\">1</span></span></span></span></span> substrings of length <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6444em;\"></span><span class=\"mord\">2</span></span></span></span></span>, <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6667em; vertical-align: -0.0833em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.6444em;\"></span><span class=\"mord\">2</span></span></span></span></span> substrings of length <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6444em;\"></span><span class=\"mord\">3</span></span></span></span></span>, and so on. We can represent the number of substrings mathematically as <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6667em; vertical-align: -0.0833em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord\">2</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.6667em; vertical-align: -0.0833em;\"></span><span class=\"minner\">⋯</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">))</span></span></span></span></span>. This sum can be calculated by the formula <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1.355em; vertical-align: -0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 1.01em;\"><span style=\"top: -2.655em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span><span style=\"top: -3.23em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width: 0.04em;\"></span></span><span style=\"top: -3.485em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mopen mtight\">(</span><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span><span class=\"mclose mtight\">)</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span></span>, which is a quadratic complexity, <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1.0641em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.8141em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n<p>The function will be called <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6389em; vertical-align: -0.1944em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1.355em; vertical-align: -0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 1.01em;\"><span style=\"top: -2.655em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span><span style=\"top: -3.23em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width: 0.04em;\"></span></span><span style=\"top: -3.485em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mopen mtight\">(</span><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span><span class=\"mclose mtight\">)</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span></span> times. Splicing each substring takes <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span> time, so the overall time complexity is <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">p</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1.0641em; vertical-align: -0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.8141em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n</li>\n<li>\n<p>Space complexity: <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">p</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p><code>symbolMap</code> can store a <code>(symbol, word)</code> mapping for each unique <code>symbol</code> in <code>pattern</code>. The set of symbols is the English alphabet, which contains <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6444em;\"></span><span class=\"mord\">26</span></span></span></span></span> letters. The length of the substrings of <code>s</code> combined is <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></span>, so it can use up to <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">26</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span> space, which can be simplified to <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n<p><code>wordSet</code> stores a <code>word</code> for each unique <code>symbol</code> in the <code>symbolMap</code>. It will use the same amount of space as <code>symbolMap</code>, <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n<blockquote>\n<p>Note: The number of letters in the alphabet is considered constant, but for this problem, it is not trivial because <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.625em; vertical-align: -0.1944em;\"></span><span class=\"mord mathnormal\">p</span></span></span></span></span> and <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></span> are constrained to <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6444em;\"></span><span class=\"mord\">20</span></span></span></span></span>. For inputs where <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.7335em; vertical-align: -0.1944em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.6444em;\"></span><span class=\"mord\">26</span></span></span></span></span>, when every character of <code>pattern</code> is unique, we can represent the space required by the hash map and hash set as <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">p</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n</blockquote>\n<p>We recursively check each character in <code>pattern</code>, so the depth of the recursive call stack can grow up to <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.625em; vertical-align: -0.1944em;\"></span><span class=\"mord mathnormal\">p</span></span></span></span></span>, requiring <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">p</span><span class=\"mclose\">)</span></span></span></span></span> space.</p>\n<p>Therefore, the overall space complexity is <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">p</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord\">2</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span>, which we can simplify to <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">p</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span></p>\n</li>\n</ul>\n<hr/>\n<h3 class=\"group/heading relative\" id=\"approach-2-optimized-backtracking\" level=\"3\"><a aria-hidden=\"true\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" href=\"#approach-2-optimized-backtracking\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" data-icon=\"link\" data-prefix=\"fas\" focusable=\"false\" role=\"img\" spacing=\"square\" viewbox=\"0 0 640 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\" fill=\"currentColor\"></path></svg></div></a>Approach 2: Optimized Backtracking</h3>\n<h4 id=\"intuition-1\">Intuition</h4>\n<p>An alternative to using a map is an array, which provides constant time complexity for both insertion and retrieval operations. This is faster than the worst-case time complexity of hashmap operations. However, this advantage comes with a trade-off: arrays are only suitable when the range of values is relatively small and can be mapped directly to array indices. Since the set of symbols are the letters in the English alphabet, we can utilize an array.</p>\n<p>Assuming that <code>s</code> matches the <code>pattern</code>, then there are the same number of substrings in <code>s</code> as there are characters in <code>pattern</code>. We can leverage this observation to further narrow the search space.</p>\n<p>The above approach assumes that for any character <code>symbol</code> of the <code>pattern</code>, the possible set of corresponding substrings includes all substrings that start with <code>sIndex</code> and stop at any point until the end of <code>s</code>. We can reason that if the <code>symbol</code> is not the last character in the <code>pattern</code>, then the corresponding substring must end before the last index of <code>s</code> because the remaining characters in the <code>pattern</code> also need to be mapped to substrings of <code>s</code>.</p>\n<p>The basic idea of this optimization is to peek ahead and check if the <code>pattern</code> has additional characters. If so, we count how many characters at the end of <code>s</code> the remaining characters in <code>pattern</code> must use, and we only explore the new possible substrings for the <code>symbol</code> that leave room in <code>s</code> for the remaining characters in <code>pattern</code>.</p>\n<p>The following example demonstrates this idea.</p>\n<blockquote>\n<p><strong>Input:</strong> pattern = \"abac\", s = \"aabbaac\"</p>\n</blockquote>\n<p>State: <code>pIndex = 1</code> and <code>sIndex = 2</code></p>\n<p><code>symbols</code>:</p>\n<table><thead><tr><th style=\"text-align: center;\">Index</th><th style=\"text-align: center;\">0</th><th style=\"text-align: center;\">1</th><th style=\"text-align: center;\">2</th><th style=\"text-align: center;\">...</th><th style=\"text-align: center;\">25</th></tr></thead><tbody><tr><td style=\"text-align: center;\">Letter</td><td style=\"text-align: center;\">'a'</td><td style=\"text-align: center;\">'b'</td><td style=\"text-align: center;\">'c'</td><td style=\"text-align: center;\">...</td><td style=\"text-align: center;\">'z'</td></tr><tr><td style=\"text-align: center;\">Word</td><td style=\"text-align: center;\">\"aa\"</td><td style=\"text-align: center;\">\"\"</td><td style=\"text-align: center;\">\"\"</td><td style=\"text-align: center;\">...</td><td style=\"text-align: center;\">\"\"</td></tr></tbody></table>\n<p>The second character of the <code>pattern</code>, <code>'b'</code>, is a new <code>symbol</code>. How many indices at the end of <code>s</code> will be used by the remaining characters in the <code>pattern</code>?</p>\n<ul>\n<li><code>'a'</code> is the next symbol in the <code>pattern</code>. It maps to <code>\"aa\"</code>, so it will take <code>2</code> spots.</li>\n<li><code>'c'</code> is the last symbol in the <code>pattern</code>. We don't know what <code>word</code> it maps to, but it will require at least <code>1</code> spot.</li>\n</ul>\n<p>There are <code>5</code> more indices left in <code>s</code> total and the remaining characters in <code>pattern</code> will fill at least <code>1 + 2 = 3</code> spots. <code>5 - 3 = 2</code> is the maximum length of the new word.</p>\n<p>So, the <code>word</code> substrings we test for symbol <code>'b'</code> are:</p>\n<div class=\"font-menlo mb-6 rounded-lg px-3 py-2.5 text-sm bg-fill-3 dark:bg-dark-fill-3\"><div class=\"group relative\" translate=\"no\"><pre style=\"color: black; font-size: 13px; text-shadow: none; font-family: Menlo, Monaco, Consolas; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 4; hyphens: none; padding: 0px; margin: 0px; overflow: auto; background: transparent; overflow-wrap: normal;\"><code class=\"language-javascript\" style=\"white-space: pre; text-shadow: none;\"><span><span>s</span><span class=\"token\" style=\"color: rgb(153, 153, 153);\">[</span><span class=\"token\" style=\"color: rgb(153, 0, 85);\">2</span><span class=\"token\" style=\"color: rgb(153, 153, 153);\">]</span><span> </span><span class=\"token\" style=\"color: rgb(154, 110, 58);\">=</span><span> </span><span class=\"token\" style=\"color: rgb(102, 153, 0);\">\"b\"</span><span>\n</span></span><span><span>s</span><span class=\"token\" style=\"color: rgb(153, 153, 153);\">[</span><span class=\"token\" style=\"color: rgb(153, 0, 85);\">2</span><span class=\"token\" style=\"color: rgb(154, 110, 58);\">:</span><span class=\"token\" style=\"color: rgb(153, 0, 85);\">3</span><span class=\"token\" style=\"color: rgb(153, 153, 153);\">]</span><span> </span><span class=\"token\" style=\"color: rgb(154, 110, 58);\">=</span><span> </span><span class=\"token\" style=\"color: rgb(102, 153, 0);\">\"bb\"</span></span></code></pre><div class=\"absolute -right-1.5 -top-0.5 flex gap-2\"><div class=\"z-base-1 hidden rounded border group-hover:block border-border-quaternary dark:border-border-quaternary bg-layer-02 dark:bg-layer-02\"><div class=\"relative cursor-pointer flex h-[22px] w-[22px] items-center justify-center bg-layer-02 dark:bg-layer-02 hover:bg-fill-tertiary dark:hover:bg-fill-tertiary rounded-[4px]\" data-state=\"closed\"><div><div data-state=\"closed\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3 h-3.5 w-3.5 text-text-primary dark:text-text-primary\"><svg aria-hidden=\"true\" class=\"svg-inline--fa fa-clone absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" data-icon=\"clone\" data-prefix=\"far\" focusable=\"false\" role=\"img\" viewbox=\"0 0 512 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M64 464H288c8.8 0 16-7.2 16-16V384h48v64c0 35.3-28.7 64-64 64H64c-35.3 0-64-28.7-64-64V224c0-35.3 28.7-64 64-64h64v48H64c-8.8 0-16 7.2-16 16V448c0 8.8 7.2 16 16 16zM224 304H448c8.8 0 16-7.2 16-16V64c0-8.8-7.2-16-16-16H224c-8.8 0-16 7.2-16 16V288c0 8.8 7.2 16 16 16zm-64-16V64c0-35.3 28.7-64 64-64H448c35.3 0 64 28.7 64 64V288c0 35.3-28.7 64-64 64H224c-35.3 0-64-28.7-64-64z\" fill=\"currentColor\"></path></svg></div></div></div></div></div></div></div></div>\n<p>We can visualize <code>s</code> as <code>\"aa_aax\"</code>, where <code>\"aa\"</code> represents the known mapping of <code>'a'</code>, <code>x</code> represents a spot for the unknown mapping of <code>'c'</code>, and the empty space represents the <code>word</code> that corresponds to symbol <code>'b'</code>.</p>\n<p>When we encounter a new <code>symbol</code>, before generating the new words, we count how many indices of <code>s</code> must be filled by the remaining characters in the <code>pattern</code>, which we store in <code>filledSpots</code>.</p>\n<p>We compute <code>filledSpots</code> by iterating through the symbols from the next to the last index of <code>pattern</code> and adding the length of the corresponding <code>word</code> for each of the characters remaining in <code>pattern</code>. If the symbol is new, we add <code>1</code>, because the <code>word</code> will consist of at least one index of <code>s</code>.</p>\n<p>Then, we can identify the last possible ending index in <code>s</code> of a new word that could correspond to a given <code>symbol</code> as <code>s.length() - filledSpots</code>, which we use to narrow the search space when we generate new words.</p>\n<h4 id=\"algorithm-1\">Algorithm</h4>\n<ol>\n<li data-length=\"1\">Create an array <code>symbols</code> of size <code>26</code> that maps a character from <code>pattern</code> to a substring of <code>s</code>. Each index corresponds to a letter of the alphabet.</li>\n<li data-length=\"1\">Create a hash set <code>wordSet</code> that stores the unique substrings of <code>s</code> that have been mapped to a symbol.</li>\n<li data-length=\"1\">Define a recursive function <code>isMatch</code> that takes an index in <code>s</code>, <code>sIndex</code>, and an index in <code>pattern</code>, <code>pIndex</code> as parameters. The function determines whether <code>s</code> matches a given <code>pattern</code>.\n<ul>\n<li>Base case: <code>pIndex</code> equals the length of <code>pattern</code>. Return <code>true</code> if <code>sIndex</code> equals the length of <code>s</code>; <code>s</code> matches the pattern. Otherwise, return <code>false</code>.</li>\n<li>Set <code>symbol</code> to <code>pattern[pIndex]</code>, the next character in <code>pattern</code>.</li>\n<li>If <code>symbol</code> is associated with a substring of <code>s</code>, save the substring as <code>word</code>, and check if the next characters in <code>s</code> match <code>word</code>.\n<ul>\n<li>If the characters don't match, return <code>false</code>.</li>\n<li>If they do match, call <code>isMatch</code> for the next character in <code>pattern</code>.</li>\n</ul>\n</li>\n<li>Otherwise, <code>symbol</code> is a new <code>pattern</code> character. Find the last possible end index in <code>s</code> of a new word that could correspond to <code>sybmol</code>.\n<ul>\n<li>Set a variable <code>filledSpots</code> to <code>0</code>.</li>\n<li>Iterate from <code>pIndex + 1</code> to the last character of <code>pattern</code>. If the symbol <code>p</code> is associated with a <code>word</code>, add the length of the <code>word</code> to <code>filledSpots</code>. Otherwise, add <code>1</code> to <code>filledSpots</code>.</li>\n</ul>\n</li>\n<li>Try mapping <code>symbol</code> to new substrings of <code>s</code>, starting with the substring consisting of <code>s[sIndex]</code> and extending until the substring reaches the last possible end index of the new word, which is <code>s.length() - filledSpots</code>.\n<ul>\n<li>Save the current substring as <code>newWord</code>.</li>\n<li>If <code>newWord</code> already exists in <code>wordSet</code>, continue.</li>\n<li>Otherwise, add <code>newWord</code> to <code>wordSet</code> and <code>symbols</code> with <code>symbol</code>.</li>\n<li>Call <code>isMatch</code> for the next character in <code>pattern</code>. If the result is <code>true</code>, return <code>true</code>.</li>\n<li>Remove <code>newWord</code> from the <code>wordSet</code> and the <code>symbols</code> array.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li data-length=\"1\">Call <code>isMatch</code> with the starting indices in <code>s</code> and the <code>pattern</code> as <code>0</code> and return the result.</li>\n</ol>\n<h4 id=\"implementation-1\">Implementation</h4>\n<pre><code>class Solution {\npublic:\n    bool wordPatternMatch(string pattern, string s) {\n        vector&lt;string&gt; symbols(26, \"\");\n        unordered_set&lt;string&gt; wordSet;\n​\n        return isMatch(s, 0, pattern, 0, symbols, wordSet);\n    }\n​\nprivate:\n    bool isMatch(string&amp; s, int sIndex, string&amp; pattern, int pIndex,\n                 vector&lt;string&gt;&amp; symbols, unordered_set&lt;string&gt;&amp; wordSet) {\n        // Base case: reached end of pattern\n        if (pIndex == pattern.length()) {\n            return sIndex == s.length(); // True if and only if also reached end of s\n        }\n​\n        // Get current pattern character\n        char symbol = pattern[pIndex];\n​\n        // This symbol already has an associated word\n        if (!symbols[symbol - 'a'].empty()) {\n            string word = symbols[symbol - 'a'];\n            // Check if it matches s[sIndex...sIndex + word.length()]\n            if (s.compare(sIndex, word.length(), word)) {\n                return false;\n            }\n            // If it matches continue to match the rest\n            return isMatch(s, sIndex + word.length(), pattern, pIndex + 1,\n                           symbols, wordSet);\n        }\n​\n        // Count the number of spots the remaining symbols in the pattern take\n        int filledSpots = 0;\n        for (int i = pIndex + 1; i &lt; pattern.length(); i++) {\n            char p = pattern[i];\n            filledSpots += symbols[p - 'a'].empty() ? 1 : symbols[p - 'a'].length();\n        }\n​\n        // This symbol does not have an associated word\n        for (int k = sIndex + 1; k &lt;= s.length() - filledSpots; k++) {\n            string newWord = s.substr(sIndex, k - sIndex);\n            if (wordSet.find(newWord) != wordSet.end())\n                continue;\n            // Create or update it\n            symbols[symbol - 'a'] = newWord;\n            wordSet.insert(newWord);\n            // Continue to match the rest\n            if (isMatch(s, k, pattern, pIndex + 1, symbols, wordSet)) {\n                return true;\n            }\n            // Backtracking\n            symbols[symbol - 'a'] = \"\";\n            wordSet.erase(newWord);\n        }\n        // No mappings were valid\n        return false;\n    }\n};</code></pre>\n<h4 id=\"complexity-analysis-1\">Complexity Analysis</h4>\n<p>Let <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></span> be the length of <code>s</code> and <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.625em; vertical-align: -0.1944em;\"></span><span class=\"mord mathnormal\">p</span></span></span></span></span> be the length of <code>pattern</code>.</p>\n<ul>\n<li>\n<p>Time complexity: <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">p</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.4445em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1.0641em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.8141em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p>The <code>isMatch</code> function is called for each character in <code>pattern</code> for each <code>word</code> that can be formed from substrings of <code>s</code>.</p>\n<p>We only generate substrings that leave space for the rest of the characters in <code>pattern</code>. We generate <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.7778em; vertical-align: -0.1944em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.6444em;\"></span><span class=\"mord\">1</span></span></span></span></span> substrings of length <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6444em;\"></span><span class=\"mord\">1</span></span></span></span></span>, <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.7778em; vertical-align: -0.1944em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></span> substrings of length <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6444em;\"></span><span class=\"mord\">2</span></span></span></span></span>, <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.7778em; vertical-align: -0.1944em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.6444em;\"></span><span class=\"mord\">1</span></span></span></span></span> substrings of length <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6444em;\"></span><span class=\"mord\">3</span></span></span></span></span>, and so on. We can calculate the number of substrings we generate as <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1.355em; vertical-align: -0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 1.01em;\"><span style=\"top: -2.655em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span><span style=\"top: -3.23em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width: 0.04em;\"></span></span><span style=\"top: -3.485em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mopen mtight\">(</span><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">−</span><span class=\"mord mathnormal mtight\">p</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span><span class=\"mclose mtight\">)</span><span class=\"mopen mtight\">((</span><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">−</span><span class=\"mord mathnormal mtight\">p</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span><span class=\"mclose mtight\">)</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span><span class=\"mclose mtight\">)</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.7778em; vertical-align: -0.1944em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></span>, which has a quadratic complexity of <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">((</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1.0641em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.8141em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n<p>The <code>isMatch</code> function will be called <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6389em; vertical-align: -0.1944em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1.0641em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.8141em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span></span> times. Splicing each substring takes <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span>, so the overall time complexity is <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">p</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.4445em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1.0641em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.8141em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n</li>\n<li>\n<p>Space complexity: <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">p</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p>The <code>symbols</code> array can store a substring for each letter in the English alphabet. It stores up to <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6444em;\"></span><span class=\"mord\">26</span></span></span></span></span> substrings with a combined length of <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></span>, so it requires <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">26</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span> space, which can be simplified to <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n<p>The <code>wordSet</code> can store a <code>word</code> for each unique symbol in <code>pattern</code>. The combined length of the substrings is <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></span>, so it can use up to <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">26</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span> space, which is simplified to <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n<blockquote>\n<p>Note: The number of letters in the alphabet is considered constant, but for this problem, it is not trivial because <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.625em; vertical-align: -0.1944em;\"></span><span class=\"mord mathnormal\">p</span></span></span></span></span> and <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></span> are constrained to <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6444em;\"></span><span class=\"mord\">20</span></span></span></span></span>. For inputs where <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.7335em; vertical-align: -0.1944em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.6444em;\"></span><span class=\"mord\">26</span></span></span></span></span>, when every character of <code>pattern</code> is unique, we can represent the space required by the hash set as <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">p</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n</blockquote>\n<p>We recursively check each character in the <code>pattern</code> so the depth of the recursive call stack can grow up to <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.625em; vertical-align: -0.1944em;\"></span><span class=\"mord mathnormal\">p</span></span></span></span></span>, requiring <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">p</span><span class=\"mclose\">)</span></span></span></span></span> space.</p>\n<p>Therefore, the overall space complexity is <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">p</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord\">2</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span>, which we can simplify to <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">p</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n</li>\n</ul>\n<hr/></div><span style=\"font-size: 0px; line-height: 0;\"> </span></div>"}