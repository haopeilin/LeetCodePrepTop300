{"id":"222","title":"Count Complete Tree Nodes","difficulty":"Easy","content":"<p>Given the <code>root</code> of a <strong>complete</strong> binary tree, return the number of the nodes in the tree.</p>\n\n<p>According to <strong><a href=\"http://en.wikipedia.org/wiki/Binary_tree#Types_of_binary_trees\" target=\"_blank\">Wikipedia</a></strong>, every level, except possibly the last, is completely filled in a complete binary tree, and all nodes in the last level are as far left as possible. It can have between <code>1</code> and <code>2<sup>h</sup></code> nodes inclusive at the last level <code>h</code>.</p>\n\n<p>Design an algorithm that runs in less than&nbsp;<code data-stringify-type=\"code\">O(n)</code>&nbsp;time complexity.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/14/complete.jpg\" style=\"width: 372px; height: 302px;\" />\n<pre>\n<strong>Input:</strong> root = [1,2,3,4,5,6]\n<strong>Output:</strong> 6\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = []\n<strong>Output:</strong> 0\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [1]\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 5 * 10<sup>4</sup>]</code>.</li>\n\t<li><code>0 &lt;= Node.val &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li>The tree is guaranteed to be <strong>complete</strong>.</li>\n</ul>\n","tags":["Binary Search","Bit Manipulation","Tree","Binary Tree"],"java_snippet":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int countNodes(TreeNode root) {\n        \n    }\n}","solution":"<h2><a href=\"#solution\"><svg><path></path></svg></a>Solution</h2>\n<hr/>\n<h3><a href=\"#approach-1-linear-time\"><svg><path></path></svg></a>Approach 1: Linear Time</h3>\n<p><strong>Intuition</strong></p>\n<p>This problem is quite popular at Google during the last year.<br/>\nThe naive solution here is a linear time one-liner which counts nodes<br/>\nrecursively one by one.</p>\n<p><strong>Implementation</strong></p>\n<pre><code>class Solution {\n  public int countNodes(TreeNode root) {\n    return root != null ? 1 + countNodes(root.right) + countNodes(root.left) : 0;\n  }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time complexity : O(N).</li>\n<li>Space complexity : O(d)=O(logN) to keep<br/>\nthe recursion stack, where d is a tree depth.\n<br/>\n</li>\n</ul>\n<br/>\n<hr/>\n<h3><a href=\"#approach-2-binary-search\"><svg><path></path></svg></a>Approach 2: Binary search</h3>\n<p><strong>Intuition</strong></p>\n<p>Approach 1 doesn't profit from the fact that the tree is a complete one.</p>\n<blockquote>\n<p>In a complete binary tree every level,<br/>\nexcept possibly the last, is completely filled,<br/>\nand all nodes in the last level are as far left as possible.</p>\n</blockquote>\n<p>That means that complete tree has 2k nodes in the kth level<br/>\nif the kth level is not the last one.<br/>\nThe last level may be not filled completely,<br/>\nand hence in the last level the number of nodes<br/>\ncould vary from 1 to 2d, where d is a tree<br/>\ndepth.</p>\n<p></p>\n<p>Now one could compute the number of nodes in all levels<br/>\nbut the last one: ∑k=0k=d−1​2k=2d−1.<br/>\nThat reduces the problem to the simple check of how many nodes<br/>\nthe tree has in the last level.</p>\n<p></p>\n<p>Now there are two questions:</p>\n<ol>\n<li>\n<p>How many nodes in the last level have to be checked?</p>\n</li>\n<li>\n<p>What is the best time performance for such a check?</p>\n</li>\n</ol>\n<p>Let's start from the first question. It's a complete tree, and hence<br/>\nall nodes in the last level are <em>as far left as possible</em>.<br/>\nThat means that instead of checking the existence of all<br/>\n2d possible leafs, one could use binary search and check<br/>\nlog(2d)=d leafs only.</p>\n<p></p>\n<p>Let's move to the second question, and enumerate potential nodes<br/>\nin the last level from 0 to 2d−1.<br/>\nHow to check if the node number idx exists?<br/>\nLet's use binary search again to reconstruct the sequence of moves<br/>\nfrom root to idx node. For example, idx = 4. idx is in the<br/>\nsecond half of nodes <code>0,1,2,3,4,5,6,7</code> and hence the first move is to the<br/>\nright. Then idx is in the first half of nodes <code>4,5,6,7</code> and hence<br/>\nthe second move is to the left. The idx is in the first half of nodes<br/>\n<code>4,5</code> and hence the next move is to the left. The time complexity<br/>\nfor one check is O(d).</p>\n<p></p>\n<p>1 and 2 together result in O(d) checks, each check at<br/>\na price of O(d). That means that the overall time complexity<br/>\nwould be O(d2).</p>\n<p><strong>Algorithm</strong></p>\n<ul>\n<li>\n<p>Return 0 if the tree is empty.</p>\n</li>\n<li>\n<p>Compute the tree depth <code>d</code>.</p>\n</li>\n<li>\n<p>Return 1 if <code>d == 0</code>.</p>\n</li>\n<li>\n<p>The number of nodes in all levels but the last one is 2d−1.<br/>\nThe number of nodes in the last level could vary from 1 to 2d.<br/>\nEnumerate potential nodes from 0 to 2d−1<br/>\nand perform the binary search by the node index to check how many<br/>\nnodes are in the last level. Use the function <code>exists(idx, d, root)</code> to<br/>\ncheck if the node with index idx exists.</p>\n</li>\n<li>\n<p>Use binary search to implement <code>exists(idx, d, root)</code> as well.</p>\n</li>\n<li>\n<p>Return 2d−1 + the number of nodes in the last level.</p>\n</li>\n</ul>\n<p><strong>Implementation</strong></p>\n<pre><code>class Solution {\n  // Return tree depth in O(d) time.\n  public int computeDepth(TreeNode node) {\n    int d = 0;\n    while (node.left != null) {\n      node = node.left;\n      ++d;\n    }\n    return d;\n  }\n​\n  // Last level nodes are enumerated from 0 to 2**d - 1 (left -&gt; right).\n  // Return True if last level node idx exists. \n  // Binary search with O(d) complexity.\n  public boolean exists(int idx, int d, TreeNode node) {\n    int left = 0, right = (int)Math.pow(2, d) - 1;\n    int pivot;\n    for(int i = 0; i &lt; d; ++i) {\n      pivot = left + (right - left) / 2;\n      if (idx &lt;= pivot) {\n        node = node.left;\n        right = pivot;\n      }\n      else {\n        node = node.right;\n        left = pivot + 1;\n      }\n    }\n    return node != null;\n  }\n​\n  public int countNodes(TreeNode root) {\n    // if the tree is empty\n    if (root == null) return 0;\n​\n    int d = computeDepth(root);\n    // if the tree contains 1 node\n    if (d == 0) return 1;\n​\n    // Last level nodes are enumerated from 0 to 2**d - 1 (left -&gt; right).\n    // Perform binary search to check how many nodes exist.\n    int left = 1, right = (int)Math.pow(2, d) - 1;\n    int pivot;\n    while (left &lt;= right) {\n      pivot = left + (right - left) / 2;\n      if (exists(pivot, d, root)) left = pivot + 1;\n      else right = pivot - 1;\n    }\n​\n    // The tree contains 2**d - 1 nodes on the first (d - 1) levels\n    // and left nodes on the last level.\n    return (int)Math.pow(2, d) - 1 + left;\n  }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time complexity : O(d2)=O(log2N),<br/>\nwhere d is a tree depth.</li>\n<li>Space complexity : O(1).</li>\n</ul>"}