{"id":"79","title":"Word Search","difficulty":"Medium","content":"<p>Given an <code>m x n</code> grid of characters <code>board</code> and a string <code>word</code>, return <code>true</code> <em>if</em> <code>word</code> <em>exists in the grid</em>.</p>\n\n<p>The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/04/word2.jpg\" style=\"width: 322px; height: 242px;\" />\n<pre>\n<strong>Input:</strong> board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;ABCCED&quot;\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/04/word-1.jpg\" style=\"width: 322px; height: 242px;\" />\n<pre>\n<strong>Input:</strong> board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;SEE&quot;\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/15/word3.jpg\" style=\"width: 322px; height: 242px;\" />\n<pre>\n<strong>Input:</strong> board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;ABCB&quot;\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == board.length</code></li>\n\t<li><code>n = board[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 6</code></li>\n\t<li><code>1 &lt;= word.length &lt;= 15</code></li>\n\t<li><code>board</code> and <code>word</code> consists of only lowercase and uppercase English letters.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Could you use search pruning to make your solution faster with a larger <code>board</code>?</p>\n","tags":["Array","String","Backtracking","Depth-First Search","Matrix"],"java_snippet":"class Solution {\n    public boolean exist(char[][] board, String word) {\n        \n    }\n}","solution":"<div class=\"flex flex-col w-full\" style=\"position: relative;\"><div class=\"mYe_l WRmCx\"><h2 class=\"group/heading relative\" id=\"solution\" level=\"2\"><a aria-hidden=\"true\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" href=\"#solution\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" data-icon=\"link\" data-prefix=\"fas\" focusable=\"false\" role=\"img\" spacing=\"square\" viewbox=\"0 0 640 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\" fill=\"currentColor\"></path></svg></div></a>Solution</h2>\n<hr/>\n<h3 class=\"group/heading relative\" id=\"approach-1-backtracking\" level=\"3\"><a aria-hidden=\"true\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" href=\"#approach-1-backtracking\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" data-icon=\"link\" data-prefix=\"fas\" focusable=\"false\" role=\"img\" spacing=\"square\" viewbox=\"0 0 640 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\" fill=\"currentColor\"></path></svg></div></a>Approach 1: Backtracking</h3>\n<h4 id=\"intuition\">Intuition</h4>\n<p>This problem is yet another 2D grid traversal problem, which is similar with another problem called <a href=\"https://leetcode.com/articles/robot-room-cleaner/\" target=\"_blank\">489. Robot Room Cleaner</a>.</p>\n<p>Many people in the <a href=\"https://leetcode.com/problems/word-search/discuss/\" target=\"_blank\">discussion forum</a> claimed that the solution is of <em><strong>DFS</strong></em> (Depth-First Search). Although it is true that we would explore the 2D grid with the DFS strategy for this problem, it does not capture the entire nature of the solution.</p>\n<blockquote>\n<p>We argue that a more accurate term to summarize the solution would be <em><strong>backtracking</strong></em>, which is a methodology where we mark the current path of exploration, if the path does not lead to a solution, we then revert the change (<em>i.e.</em> backtracking) and try another path.</p>\n</blockquote>\n<p>As the general idea for the solution, we would walk around the 2D grid, and at each step, we <em>mark</em> our choice before jumping into the next step. And at the end of each step, we would also revert our mark so that we will have a <em>clean slate</em> to try another <em>direction</em>. In addition, the exploration is done via the <em>DFS</em> strategy, where we go as far as possible before we try the next direction.</p>\n<p></p>\n<h4 id=\"algorithm\">Algorithm</h4>\n<p>There is a certain code pattern for all the algorithms of backtracking. For example, one can find one template in our <a href=\"https://leetcode.com/explore/learn/card/recursion-ii/472/backtracking/2793/\" target=\"_blank\">Explore card of Recursion II</a>.</p>\n<p>The skeleton of the algorithm is a loop that iterates through each cell in the grid. For each cell, we invoke the <em>backtracking</em> function (<em>i.e.</em> <code>backtrack()</code>) to check if we would obtain a solution, starting from this very cell.</p>\n<p>For the backtracking function <code>backtrack(row, col, suffix)</code>, as a DFS algorithm, it is often implemented as a <em>recursive</em> function. The function can be broke down into the following four steps:</p>\n<ul>\n<li>\n<p>Step 1). At the beginning, first we check if we reach the bottom case of the recursion, where the word to be matched is empty, <em>i.e.</em> we have already found the match for each prefix of the word.</p>\n</li>\n<li>\n<p>Step 2). We then check if the current state is invalid, either the position of the cell is out of the boundary of the board or the letter in the current cell does not match with the first letter of the word.</p>\n</li>\n<li>\n<p>Step 3). If the current step is valid, we then start the exploration of backtracking with the strategy of DFS. First, we mark the current cell as <em>visited</em>, <em>e.g.</em> any non-alphabetic letter will do. Then we iterate through the four possible directions, namely <em>up</em>, <em>right</em>, <em>down</em> and <em>left</em>. The order of the directions can be altered, to one's preference.</p>\n</li>\n<li>\n<p>Step 4). At the end of the exploration, we revert the cell back to its original state. Finally we return the result of the exploration.</p>\n</li>\n</ul>\n<p>We demonstrate how it works with an example in the following animation.</p>\n<p></p>\n<h4 id=\"implementation\">Implementation</h4>\n<pre><code>class Solution {\nprivate:\n    vector&lt;vector&lt;char&gt;&gt; board;\n    int ROWS;\n    int COLS;\n​\npublic:\n    bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) {\n        this-&gt;board = board;\n        ROWS = board.size();\n        COLS = board[0].size();\n        for (int row = 0; row &lt; ROWS; ++row)\n            for (int col = 0; col &lt; COLS; ++col)\n                if (backtrack(row, col, word, 0)) return true;\n        return false;\n    }\n​\nprotected:\n    bool backtrack(int row, int col, const string&amp; word, int index) {\n        /* Step 1). check the bottom case. */\n        if (index &gt;= word.length()) return true;\n        /* Step 2). Check the boundaries. */\n        if (row &lt; 0 || row == ROWS || col &lt; 0 || col == COLS ||\n            board[row][col] != word[index])\n            return false;\n        /* Step 3). explore the neighbors in DFS */\n        bool ret = false;\n        // mark the path before the next exploration\n        board[row][col] = '#';\n        int rowOffsets[4] = {0, 1, 0, -1};\n        int colOffsets[4] = {1, 0, -1, 0};\n        for (int d = 0; d &lt; 4; ++d) {\n            ret = backtrack(row + rowOffsets[d], col + colOffsets[d], word,\n                            index + 1);\n            if (ret) break;\n        }\n        /* Step 4). clean up and return the result. */\n        board[row][col] = word[index];\n        return ret;\n    }\n};</code></pre>\n<p><strong>Notes</strong></p>\n<p>There are a few choices that we made for our backtracking algorithm, here we elaborate some thoughts that are behind those choices.</p>\n<blockquote>\n<p>Instead of returning directly once we find a match, we simply <em>break</em> out of the loop and do the cleanup before returning.</p>\n</blockquote>\n<p>Here is what the alternative solution might look like.</p>\n<pre><code>class Solution {\nprivate:\n    vector&lt;vector&lt;char&gt;&gt; board;\n    int ROWS;\n    int COLS;\n​\npublic:\n    bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) {\n        this-&gt;board = board;\n        ROWS = board.size();\n        COLS = board[0].size();\n        for (int row = 0; row &lt; ROWS; ++row)\n            for (int col = 0; col &lt; COLS; ++col)\n                if (backtrack(row, col, word, 0)) return true;\n        return false;\n    }\n​\nprotected:\n    bool backtrack(int row, int col, const string&amp; word, int index) {\n        /* Step 1). check the bottom case. */\n        if (index &gt;= word.size()) return true;\n        /* Step 2). Check the boundaries. */\n        if (row &lt; 0 || row == ROWS || col &lt; 0 || col == COLS ||\n            board[row][col] != word[index])\n            return false;\n        /* Step 3). explore the neighbors in DFS */\n        // mark the path before the next exploration\n        char temp = board[row][col];\n        board[row][col] = '#';\n        int rowOffsets[4] = {0, 1, 0, -1};\n        int colOffsets[4] = {1, 0, -1, 0};\n        for (int d = 0; d &lt; 4; ++d) {\n            if (backtrack(row + rowOffsets[d], col + colOffsets[d], word,\n                          index + 1)) {\n                // return without cleanup\n                return true;\n            }\n        }\n        /* Step 4). clean up and return the result. */\n        board[row][col] = temp;\n        return false;\n    }\n};</code></pre>\n<p>As one may notice, we simply <code>return True</code> if the result of the recursive call to <code>backtrack()</code> is positive. Though this minor modification would have no impact on the time or space complexity, it would however leave with a \"side-effect,\" <em>i.e.</em> the matched letters in the original board would be altered to <code>#</code>.</p>\n<blockquote>\n<p>Instead of doing the boundary checks before the recursive call on the <code>backtrack()</code> function, we do it within the function.</p>\n</blockquote>\n<p>This is an important choice though. Doing the boundary check within the function would allow us to reach the bottom case, for the test case where the board contains only a single cell, since either of neighbor indices would not be valid.</p>\n<h4 id=\"complexity-analysis\">Complexity Analysis</h4>\n<ul>\n<li>\n<p>Time Complexity: <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathcal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1.0913em; vertical-align: -0.25em;\"></span><span class=\"mord\"><span class=\"mord\">3</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.8413em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">L</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span> where <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span></span></span></span></span> is the number of cells in the board and <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord mathnormal\">L</span></span></span></span></span> is the length of the word to be matched.</p>\n<ul>\n<li>\n<p>For the backtracking function, initially we could have at most 4 directions to explore, but further the choices are reduced into 3 (since we won't go back to where we come from).<br/>\nAs a result, the execution trace after the first step could be visualized as a 3-nary tree, each of the branches represent a potential exploration in the corresponding direction. Therefore, in the worst case, the total number of invocation would be the number of nodes in a full 3-nary tree, which is about <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.8413em;\"></span><span class=\"mord\"><span class=\"mord\">3</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.8413em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">L</span></span></span></span></span></span></span></span></span></span></span></span>.</p>\n</li>\n<li>\n<p>We iterate through the board for backtracking, <em>i.e.</em> there could be <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span></span></span></span></span> times invocation for the backtracking function in the worst case.</p>\n</li>\n<li>\n<p>As a result, overall the time complexity of the algorithm would be <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathcal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1.0913em; vertical-align: -0.25em;\"></span><span class=\"mord\"><span class=\"mord\">3</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.8413em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">L</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n</li>\n</ul>\n</li>\n<li>\n<p>Space Complexity: <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathcal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">L</span><span class=\"mclose\">)</span></span></span></span></span> where <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord mathnormal\">L</span></span></span></span></span> is the length of the word to be matched.</p>\n<ul>\n<li>The main consumption of the memory lies in the recursion call of the backtracking function. The maximum length of the call stack would be the length of the word. Therefore, the space complexity of the algorithm is <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathcal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">L</span><span class=\"mclose\">)</span></span></span></span></span>.\n<br/>\n</li>\n</ul>\n</li>\n</ul>\n<br/></div><span style=\"font-size: 0px; line-height: 0;\"> </span></div>"}