{"id":"219","title":"Contains Duplicate II","difficulty":"Easy","content":"<p>Given an integer array <code>nums</code> and an integer <code>k</code>, return <code>true</code> <em>if there are two <strong>distinct indices</strong> </em><code>i</code><em> and </em><code>j</code><em> in the array such that </em><code>nums[i] == nums[j]</code><em> and </em><code>abs(i - j) &lt;= k</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,1], k = 3\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,0,1,1], k = 1\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,1,2,3], k = 2\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= k &lt;= 10<sup>5</sup></code></li>\n</ul>\n","tags":["Array","Hash Table","Sliding Window"],"java_snippet":"class Solution {\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\n        \n    }\n}","solution":"<h2><a href=\"#summary\"><svg><path></path></svg></a>Summary</h2>\n<p>This article is for beginners. It introduces the following ideas:<br/>\nLinear Search, Binary Search Tree and Hash Table.</p>\n<h2><a href=\"#solution\"><svg><path></path></svg></a>Solution</h2>\n<hr/>\n<h3><a href=\"#approach-1-naive-linear-search\"><svg><path></path></svg></a>Approach #1: Naive Linear Search</h3>\n<p><strong>Intuition</strong></p>\n<p>Look for duplicate element in the previous k elements.</p>\n<p><strong>Algorithm</strong></p>\n<p>This algorithm is the same as <a href=\"https://leetcode.com/articles/contains-duplicate/#approach-1-naive-linear-search-time-limit-exceeded\">Approach #1 in Contains Duplicate solution</a>, except that it looks at previous k elements instead of all its previous elements.</p>\n<p>Another perspective of this algorithm is to keep a virtual sliding window of the previous k elements. We scan for the duplicate in this window.</p>\n<pre><code>public boolean containsNearbyDuplicate(int[] nums, int k) {\n    for (int i = 0; i &lt; nums.length; ++i) {\n        for (int j = Math.max(i - k, 0); j &lt; i; ++j) {\n            if (nums[i] == nums[j]) return true;\n        }\n    }\n    return false;\n}\n// Time Limit Exceeded.</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : O(nmin(k,n)).<br/>\nIt costs O(min(k,n)) time for each linear search. Apparently we do at most n comparisons in one search even if k can be larger than n.</p>\n</li>\n<li>\n<p>Space complexity : O(1).</p>\n</li>\n</ul>\n<hr/>\n<h3><a href=\"#approach-2-binary-search-tree\"><svg><path></path></svg></a>Approach #2: Binary Search Tree</h3>\n<p><strong>Intuition</strong></p>\n<p>Keep a sliding window of k elements using self-balancing Binary Search Tree (BST).</p>\n<p><strong>Algorithm</strong></p>\n<p>The key to improve upon <a href=\"#approach-1-naive-linear-search-time-limit-exceeded\">Approach #1</a> above is to reduce the search time of the previous k elements. Can we use an auxiliary data structure to maintain a sliding window of k elements with more efficient <code>search</code>, <code>delete</code>, and <code>insert</code> operations? Since elements in the sliding window are strictly First-In-First-Out (FIFO), queue is a natural data structure. A queue using a linked list implementation supports constant time <code>delete</code> and <code>insert</code> operations, however the <code>search</code> costs linear time, which is <em>no better</em> than <a href=\"#approach-1-naive-linear-search-time-limit-exceeded\">Approach #1</a>.</p>\n<p>A better option is to use a self-balancing BST. A BST supports <code>search</code>, <code>delete</code> and <code>insert</code> operations all in O(logk) time, where k is the number of elements in the BST. In most interviews you are not required to implement a self-balancing BST, so you may think of it as a black box. Most programming languages provide implementations of this useful data structure in its standard library. In Java, you may use a <code>TreeSet</code> or a <code>TreeMap</code>. In C++ STL, you may use a <code>std::set</code> or a <code>std::map</code>.</p>\n<p>If you already have such a data structure available, the pseudocode is:</p>\n<ul>\n<li>Loop through the array, for each element do\n<ul>\n<li>Search current element in the BST, return <code>true</code> if found</li>\n<li>Put current element in the BST</li>\n<li>If the size of the BST is larger than k, remove the oldest item.</li>\n</ul>\n</li>\n<li>Return <code>false</code></li>\n</ul>\n<pre><code>public boolean containsNearbyDuplicate(int[] nums, int k) {\n    Set&lt;Integer&gt; set = new TreeSet&lt;&gt;();\n    for (int i = 0; i &lt; nums.length; ++i) {\n        if (set.contains(nums[i])) return true;\n        set.add(nums[i]);\n        if (set.size() &gt; k) {\n            set.remove(nums[i - k]);\n        }\n    }\n    return false;\n}\n// Time Limit Exceeded.</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : O(nlog(min(k,n))). We do n operations of <code>search</code>, <code>delete</code> and <code>insert</code>. Each operation costs logarithmic time complexity in the sliding window which size is min(k,n). Note that even if k can be greater than n, the window size can never exceed n.</p>\n</li>\n<li>\n<p>Space complexity : O(min(n,k)).<br/>\nSpace is the size of the sliding window which should not exceed n or k.</p>\n</li>\n</ul>\n<p><strong>Note</strong></p>\n<p>The algorithm still gets Time Limit Exceeded for large n and k.</p>\n<hr/>\n<h3><a href=\"#approach-3-hash-table\"><svg><path></path></svg></a>Approach #3: Hash Table</h3>\n<p><strong>Intuition</strong></p>\n<p>Keep a sliding window of k elements using Hash Table.</p>\n<p><strong>Algorithm</strong></p>\n<p>From the previous approaches, we know that even logarithmic performance in <code>search</code> is not enough.<br/>\nIn this case, we need a data structure supporting constant time <code>search</code>, <code>delete</code> and <code>insert</code> operations.<br/>\nHash Table is the answer. The algorithm and implementation are almost identical to <a href=\"#approach-2-binary-search-tree-time-limit-exceeded\">Approach #2</a>.</p>\n<ul>\n<li>Loop through the array, for each element do\n<ul>\n<li>Search current element in the HashTable, return <code>true</code> if found</li>\n<li>Put current element in the HashTable</li>\n<li>If the size of the HashTable is larger than k, remove the oldest item.</li>\n</ul>\n</li>\n<li>Return <code>false</code></li>\n</ul>\n<pre><code>public boolean containsNearbyDuplicate(int[] nums, int k) {\n    Set&lt;Integer&gt; set = new HashSet&lt;&gt;();\n    for (int i = 0; i &lt; nums.length; ++i) {\n        if (set.contains(nums[i])) return true;\n        set.add(nums[i]);\n        if (set.size() &gt; k) {\n            set.remove(nums[i - k]);\n        }\n    }\n    return false;\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : O(n).<br/>\nWe do n operations of <code>search</code>, <code>delete</code> and <code>insert</code>, each with constant time complexity.</p>\n</li>\n<li>\n<p>Space complexity : O(min(n,k)).<br/>\nThe extra space required depends on the number of items stored in the hash table, which is the size of the sliding window, min(n,k).</p>\n</li>\n</ul>\n<h2><a href=\"#see-also\"><svg><path></path></svg></a>See Also</h2>\n<ul>\n<li><a href=\"https://leetcode.com/articles/contains-duplicate/\">Problem 217 Contains Duplicate</a></li>\n<li><a href=\"https://leetcode.com/articles/contains-duplicate-iii/\">Problem 220 Contains Duplicate III</a></li>\n</ul>"}