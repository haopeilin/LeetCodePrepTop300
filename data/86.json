{"id":"86","title":"Partition List","difficulty":"Medium","content":"<p>Given the <code>head</code> of a linked list and a value <code>x</code>, partition it such that all nodes <strong>less than</strong> <code>x</code> come before nodes <strong>greater than or equal</strong> to <code>x</code>.</p>\n\n<p>You should <strong>preserve</strong> the original relative order of the nodes in each of the two partitions.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/04/partition.jpg\" style=\"width: 662px; height: 222px;\" />\n<pre>\n<strong>Input:</strong> head = [1,4,3,2,5,2], x = 3\n<strong>Output:</strong> [1,2,2,4,3,5]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> head = [2,1], x = 2\n<strong>Output:</strong> [1,2]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the list is in the range <code>[0, 200]</code>.</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n\t<li><code>-200 &lt;= x &lt;= 200</code></li>\n</ul>\n","tags":["Linked List","Two Pointers"],"java_snippet":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode partition(ListNode head, int x) {\n        \n    }\n}","solution":"<div class=\"flex flex-col w-full\" style=\"position: relative;\"><div class=\"mYe_l WRmCx\"><h2 class=\"group/heading relative\" id=\"solution\" level=\"2\"><a aria-hidden=\"true\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" href=\"#solution\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" data-icon=\"link\" data-prefix=\"fas\" focusable=\"false\" role=\"img\" spacing=\"square\" viewbox=\"0 0 640 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\" fill=\"currentColor\"></path></svg></div></a>Solution</h2>\n<p>The problem wants us to reform the linked list structure, such that the<br/>\nelements lesser that a certain value <code>x</code>, come before the elements greater or<br/>\nequal to <code>x</code>. This essentially means in this reformed list, there would be a<br/>\npoint in the linked list <code>before</code> which all the elements would be smaller than<br/>\n<code>x</code> and <code>after</code> which all the elements would be greater or equal to <code>x</code>.<br/>\nLet's call this point as the <code>JOINT</code>.</p>\n\n<p>Reverse engineering the question tells us that if we break the reformed list<br/>\nat the <code>JOINT</code>, we will get two smaller linked lists, one with lesser elements<br/>\nand the other with elements greater or equal to <code>x</code>. In the solution, our main aim<br/>\nis to create these two linked lists and join them.</p>\n<h3 class=\"group/heading relative\" id=\"approach-1-two-pointer-approach\" level=\"3\"><a aria-hidden=\"true\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" href=\"#approach-1-two-pointer-approach\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" data-icon=\"link\" data-prefix=\"fas\" focusable=\"false\" role=\"img\" spacing=\"square\" viewbox=\"0 0 640 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\" fill=\"currentColor\"></path></svg></div></a>Approach 1: Two Pointer Approach</h3>\n<p><strong>Intuition</strong></p>\n<p>We can take two pointers <code>before</code> and <code>after</code> to keep track of the two linked<br/>\nlists as described above. These two pointers could be<br/>\nused two create two separate lists and then these lists could be combined to<br/>\nform the desired reformed list.</p>\n<p><strong>Algorithm</strong></p>\n<ol>\n<li data-length=\"1\">\n<p>Initialize two pointers <code>before</code> and <code>after</code>. In the implementation we have<br/>\ninitialized these two with a dummy <code>ListNode</code>. This helps to reduce the number<br/>\nof conditional checks we would need otherwise. You can try an implementation<br/>\nwhere you don't initialize with a dummy node and see it yourself!</p>\n\n \n Dummy Node Initialization<br/>\n</li>\n<li data-length=\"1\">\n<p>Iterate the original linked list, using the <code>head</code> pointer.</p>\n</li>\n<li data-length=\"1\">\n<p>If the node's value pointed by <code>head</code> is <em>lesser</em> than <code>x</code>, the node should<br/>\nbe part of the <code>before</code> list. So we move it to <code>before</code> list.</p>\n\n</li>\n<li data-length=\"1\">\n<p>Else, the node should be part of <code>after</code> list. So we move it to <code>after</code> list.</p>\n\n</li>\n<li data-length=\"1\">\n<p>Once we are done with all the nodes in the original linked list, we would<br/>\nhave two list <code>before</code> and <code>after</code>. The original list nodes are either part of<br/>\n<code>before</code> list or <code>after</code> list, depending on its value.</p>\n\n<p><em><code>Note:</code> Since we traverse the original linked list from left to right,<br/>\nat no point would the order of nodes change relatively in the two lists. Another important thing to note here is that we show the original linked list intact in the above diagrams. However, in the implementation, we remove the nodes from the original linked list and attach them in the before or after list. We don't utilize any additional space. We simply move the nodes from the original list around.</em></p>\n</li>\n<li data-length=\"1\">\n<p>Now, these two lists <code>before</code> and <code>after</code> can be combined to form the reformed list.</p>\n\n</li>\n</ol>\n<p>We did a dummy node initialization at the start to make implementation<br/>\neasier, you don't want that to be part of the returned list, hence just<br/>\nmove ahead one node in both the lists while combining the two list. Since both<br/>\nbefore and after have an extra node at the front.</p>\n<pre><code>class Solution {\npublic:\n    ListNode* partition(ListNode* head, int x) {\n        ListNode* before_head = new ListNode(0);\n        ListNode* before = before_head;\n        ListNode* after_head = new ListNode(0);\n        ListNode* after = after_head;\n        while (head != NULL) {\n            if (head-&gt;val &lt; x) {\n                before-&gt;next = head;\n                before = before-&gt;next;\n            } else {\n                after-&gt;next = head;\n                after = after-&gt;next;\n            }\n            head = head-&gt;next;\n        }\n        after-&gt;next = NULL;\n        before-&gt;next = after_head-&gt;next;\n        return before_head-&gt;next;\n    }\n};</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time Complexity: <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span></span>, where <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span></span></span></span></span> is the number of nodes in the original<br/>\nlinked list and we iterate the original list.</li>\n<li>Space Complexity: <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></span>, we have not utilized any extra space, the point to<br/>\nnote is that we are reforming the original list, by moving the original nodes, we<br/>\nhave not used any extra space as such.</li>\n</ul></div><span style=\"font-size: 0px; line-height: 0;\"> </span></div>"}