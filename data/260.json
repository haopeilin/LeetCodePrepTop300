{"id":"260","title":"Single Number III","difficulty":"Medium","content":"<p>Given an integer array <code>nums</code>, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once. You can return the answer in <strong>any order</strong>.</p>\n\n<p>You must write an&nbsp;algorithm that runs in linear runtime complexity and uses&nbsp;only constant extra space.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,1,3,2,5]\n<strong>Output:</strong> [3,5]\n<strong>Explanation: </strong> [5, 3] is also a valid answer.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [-1,0]\n<strong>Output:</strong> [-1,0]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [0,1]\n<strong>Output:</strong> [1,0]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li>Each integer in <code>nums</code> will appear twice, only two integers will appear once.</li>\n</ul>\n","tags":["Array","Bit Manipulation"],"java_snippet":"class Solution {\n    public int[] singleNumber(int[] nums) {\n        \n    }\n}","solution":"<h2><a href=\"#solution\"><svg><path></path></svg></a>Solution</h2>\n<hr/>\n<h3><a href=\"#overview\"><svg><path></path></svg></a>Overview</h3>\n<p>The problem could be solved in O(N) time and O(N) space by using a hashmap.</p>\n<p>Solving the problem in a constant space is a bit tricky but could be done with the help of two bitmasks.</p>\n<p><br/>\n<br/><br/>\n<br/></p>\n<hr/>\n<h3><a href=\"#approach-1-hashmap\"><svg><path></path></svg></a>Approach 1: Hashmap</h3>\n<p>Build a hashmap: element -&gt; its frequency. Return only the elements with the frequency equal to 1.</p>\n<p><strong>Implementation</strong></p>\n<pre><code>class Solution {\n  public int[] singleNumber(int[] nums) {\n    Map&lt;Integer, Integer&gt; hashmap = new HashMap();\n    for (int n : nums)\n      hashmap.put(n, hashmap.getOrDefault(n, 0) + 1);\n​\n    int[] output = new int[2];\n    int idx = 0;\n    for (Map.Entry&lt;Integer, Integer&gt; item : hashmap.entrySet())\n      if (item.getValue() == 1) output[idx++] = item.getKey();\n​\n    return output;\n  }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : O(N) to iterate over the input array.</p>\n</li>\n<li>\n<p>Space complexity : O(N) to keep the hashmap of N elements.</p>\n<br/>\n</li>\n</ul>\n<br/>\n<hr/>\n<h3><a href=\"#approach-2-two-bitmasks\"><svg><path></path></svg></a>Approach 2: Two bitmasks</h3>\n<p><strong>Prerequisites</strong></p>\n<p>This article will use two bitwise tricks, discussed in detail last week :</p>\n<ul>\n<li>If one builds an array bitmask with the help of the XOR operator, following <code>bitmask ^= x</code> strategy, the bitmask would keep only the bits that appear odd number of times. That was discussed in detail in the article <a href=\"https://leetcode.com/articles/single-number-ii/\">Single Number II</a>.</li>\n</ul>\n<p></p>\n<ul>\n<li><code>x &amp; (-x)</code> is a way to isolate the rightmost 1-bit, i.e. to keep the rightmost 1-bit and to set all the other bits to zero. Please refer to the article <a href=\"https://leetcode.com/articles/power-of-two/\">Power of Two</a> for a detailed explanation.</li>\n</ul>\n<p></p>\n<p><strong>Intuition</strong></p>\n<blockquote>\n<p>An interview tip. Imagine, you have a problem identifying an array element (or elements), which appears exactly a given number of times. Probably, the key is to build first an array bitmask using the XOR operator. Examples: <a href=\"leetcode.com/articles/single-number-ii/356460/Single-Number-II/324042\">In-Place Swap</a>, <a href=\"https://leetcode.com/articles/single-number/\">Single Number</a>, <a href=\"leetcode.com/articles/single-number-ii/356460/Single-Number-II/324042\">Single Number II</a>.</p>\n</blockquote>\n<p>So let's create an array bitmask: <code>bitmask ^= x</code>. This bitmask will <em>not</em> keep any number that appears twice because the XOR of two equal bits results in a zero bit <code>a^a = 0</code>.</p>\n<p>Instead, the bitmask would keep only the difference between two numbers (let's call them x and y) which appear just once. The difference here it's the bits that are different for x and y.</p>\n<p></p>\n<blockquote>\n<p>Could we extract x and y directly from this bitmask? No. However, we could use this bitmask as a marker to separate x and y.</p>\n</blockquote>\n<p>Let's do <code>bitmask &amp; (-bitmask)</code> to isolate the rightmost 1-bit, which is different between x and y. Let's say this is 1-bit for x and 0-bit for y.</p>\n<p></p>\n<p>Now let's use XOR as before, but for the new bitmask <code>x_bitmask</code>, which will contain only the numbers which have 1-bit in the position of <code>bitmask &amp; (-bitmask)</code>. This way, this new bitmask will contain only number x <code>x_bitmask = x</code>, because of two reasons:</p>\n<ul>\n<li>\n<p>y has 0-bit in the position <code>bitmask &amp; (-bitmask)</code> and hence will not enter this new bitmask.</p>\n</li>\n<li>\n<p>All numbers but x will not be visible in this new bitmask because they appear two times.</p>\n</li>\n</ul>\n<p></p>\n<p>Voila, x is identified. Now to identify y is simple: <code>y = bitmask^x</code>.</p>\n<p><strong>Implementation</strong></p>\n<pre><code>class Solution {\n  public int[] singleNumber(int[] nums) {\n    // difference between two numbers (x and y) which were seen only once\n    int bitmask = 0;\n    for (int num : nums) bitmask ^= num;\n​\n    // rightmost 1-bit diff between x and y\n    int diff = bitmask &amp; (-bitmask);\n​\n    int x = 0;\n    // bitmask which will contain only x\n    for (int num : nums) if ((num &amp; diff) != 0) x ^= num;\n​\n    return new int[]{x, bitmask^x};\n  }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : O(N) to iterate over the input array.</p>\n</li>\n<li>\n<p>Space complexity : O(1), it's a constant space solution.</p>\n</li>\n</ul>"}