{"id":"57","title":"Insert Interval","difficulty":"Medium","content":"<p>You are given an array of non-overlapping intervals <code>intervals</code> where <code>intervals[i] = [start<sub>i</sub>, end<sub>i</sub>]</code> represent the start and the end of the <code>i<sup>th</sup></code> interval and <code>intervals</code> is sorted in ascending order by <code>start<sub>i</sub></code>. You are also given an interval <code>newInterval = [start, end]</code> that represents the start and end of another interval.</p>\n\n<p>Insert <code>newInterval</code> into <code>intervals</code> such that <code>intervals</code> is still sorted in ascending order by <code>start<sub>i</sub></code> and <code>intervals</code> still does not have any overlapping intervals (merge overlapping intervals if necessary).</p>\n\n<p>Return <code>intervals</code><em> after the insertion</em>.</p>\n\n<p><strong>Note</strong> that you don&#39;t need to modify <code>intervals</code> in-place. You can make a new array and return it.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> intervals = [[1,3],[6,9]], newInterval = [2,5]\n<strong>Output:</strong> [[1,5],[6,9]]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]\n<strong>Output:</strong> [[1,2],[3,10],[12,16]]\n<strong>Explanation:</strong> Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= intervals.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>intervals[i].length == 2</code></li>\n\t<li><code>0 &lt;= start<sub>i</sub> &lt;= end<sub>i</sub> &lt;= 10<sup>5</sup></code></li>\n\t<li><code>intervals</code> is sorted by <code>start<sub>i</sub></code> in <strong>ascending</strong> order.</li>\n\t<li><code>newInterval.length == 2</code></li>\n\t<li><code>0 &lt;= start &lt;= end &lt;= 10<sup>5</sup></code></li>\n</ul>\n","tags":["Array"],"java_snippet":"class Solution {\n    public int[][] insert(int[][] intervals, int[] newInterval) {\n        \n    }\n}","solution":"<div class=\"flex flex-col w-full\" style=\"position: relative;\"><div class=\"mYe_l WRmCx\"><h2 class=\"group/heading relative\" id=\"solution\" level=\"2\"><a aria-hidden=\"true\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" href=\"#solution\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" data-icon=\"link\" data-prefix=\"fas\" focusable=\"false\" role=\"img\" spacing=\"square\" viewbox=\"0 0 640 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\" fill=\"currentColor\"></path></svg></div></a>Solution</h2>\n<hr/>\n<h3 class=\"group/heading relative\" id=\"overview\" level=\"3\"><a aria-hidden=\"true\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" href=\"#overview\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" data-icon=\"link\" data-prefix=\"fas\" focusable=\"false\" role=\"img\" spacing=\"square\" viewbox=\"0 0 640 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\" fill=\"currentColor\"></path></svg></div></a>Overview</h3>\n<p>We are given a sorted list of non-overlapping <code>intervals</code> and a <code>newInterval</code>. The task is to insert the <code>newInterval</code> into the <code>intervals</code> while maintaining sorted order and ensuring no overlapping intervals. If there is any overlap, the overlapping intervals should be merged. In the end, return the intervals list with the addition of the new intervals.</p>\n<p>Two key observations are crucial for this problem:</p>\n<ol>\n<li data-length=\"1\">The given intervals are already sorted in ascending order based on the start values.</li>\n<li data-length=\"1\">Initially, the intervals are non-overlapping, but inserting a new interval might lead to overlaps that need resolution by merging while maintaining sorted order.</li>\n</ol>\n<p>To solve this problem, we break it into three cases when comparing the current interval with the new interval:<br/>\nCase 1. The current interval ends before the new interval starts.<br/>\nCase 2. There is an overlap, and the intervals need merging.<br/>\nCase 3. The current interval starts after the new interval ends.</p>\n<p>A visual representation below illustrates all three scenarios:</p>\n<p></p>\n<p>Now let us consider the given problem description example with <code>intervals</code> and a <code>newInterval</code>:</p>\n<div class=\"font-menlo mb-6 rounded-lg px-3 py-2.5 text-sm bg-fill-3 dark:bg-dark-fill-3\"><div class=\"group relative\" translate=\"no\"><pre style=\"color: black; font-size: 13px; text-shadow: none; font-family: Menlo, Monaco, Consolas; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 4; hyphens: none; padding: 0px; margin: 0px; overflow: auto; background: transparent; overflow-wrap: normal;\"><code style=\"white-space: pre; text-shadow: none;\"><span><span>intervals = [[1, 3], [6, 9]]\n</span></span><span>newInterval = [2, 5]</span></code></pre><div class=\"absolute -right-1.5 -top-0.5 flex gap-2\"><div class=\"z-base-1 hidden rounded border group-hover:block border-border-quaternary dark:border-border-quaternary bg-layer-02 dark:bg-layer-02\"><div class=\"relative cursor-pointer flex h-[22px] w-[22px] items-center justify-center bg-layer-02 dark:bg-layer-02 hover:bg-fill-tertiary dark:hover:bg-fill-tertiary rounded-[4px]\" data-state=\"closed\"><div><div data-state=\"closed\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3 h-3.5 w-3.5 text-text-primary dark:text-text-primary\"><svg aria-hidden=\"true\" class=\"svg-inline--fa fa-clone absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" data-icon=\"clone\" data-prefix=\"far\" focusable=\"false\" role=\"img\" viewbox=\"0 0 512 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M64 464H288c8.8 0 16-7.2 16-16V384h48v64c0 35.3-28.7 64-64 64H64c-35.3 0-64-28.7-64-64V224c0-35.3 28.7-64 64-64h64v48H64c-8.8 0-16 7.2-16 16V448c0 8.8 7.2 16 16 16zM224 304H448c8.8 0 16-7.2 16-16V64c0-8.8-7.2-16-16-16H224c-8.8 0-16 7.2-16 16V288c0 8.8 7.2 16 16 16zm-64-16V64c0-35.3 28.7-64 64-64H448c35.3 0 64 28.7 64 64V288c0 35.3-28.7 64-64 64H224c-35.3 0-64-28.7-64-64z\" fill=\"currentColor\"></path></svg></div></div></div></div></div></div></div></div>\n<p>The first interval starts at 1 and ends at 3, while the second interval starts at 6 and ends at 9. The goal is to insert the <code>newInterval</code> into the existing list of <code>intervals</code>, maintaining sorted order.</p>\n<p>Upon analysis, we observe that the <code>newInterval</code> [2, 5] overlaps with the first interval [1, 3] because 2 is less than 3. Now, since we know the intervals need to be merged, we must ensure the merged interval covers the entire overlapping region.</p>\n<p>To achieve this, we take the maximum of the end of the first interval and the end of the new interval, as well as the minimum of the start of the first interval and the start of the new interval. Therefore, the merged interval becomes <code>[min(1, 2), max(3, 5)] = [1, 5]</code>.</p>\n<p>Moving on to the second interval [6, 9], its starting point (6) comes after the new interval's ending point (5). There is no overlap between them. Therefore, the second interval remains unchanged.</p>\n<table><thead><tr><th>Original Intervals</th><th>New Interval</th><th>Action</th><th>Resulting Intervals</th></tr></thead><tbody><tr><td>[1,3]</td><td>[2,5]</td><td>New interval overlaps with the first interval [1,3]. Merge intervals by taking [min(1, 2), max(3, 5)] = [1, 5].</td><td>[1,5]</td></tr><tr><td>[6,9]</td><td></td><td>No overlap with the new interval [2,5]. Interval remains unchanged.</td><td>[6,9]</td></tr></tbody></table>\n<p>In conclusion, the final result is [[1, 5], [6, 9]], representing the intervals after inserting and merging the new interval [2, 5].</p>\n<p>In a concrete business context, this problem may be presented as follows: Suppose we have an array representing video watch times, where each segment consists of the start and stop times of a user watching a video. The task is to calculate the total number of unique minutes watched across all the video segments. This is fundamentally the same question.</p>\n<blockquote>\n<p>We recommend solving <a href=\"https://leetcode.com/problems/merge-intervals/\" target=\"_blank\">Merge Intervals</a> problem before attempting this question, as it provides valuable insights into pattern recognition. This question is an extension of the Merge Intervals concept, building upon the same principles.</p>\n</blockquote>\n<hr/>\n<h3 class=\"group/heading relative\" id=\"approach-1-linear-search\" level=\"3\"><a aria-hidden=\"true\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" href=\"#approach-1-linear-search\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" data-icon=\"link\" data-prefix=\"fas\" focusable=\"false\" role=\"img\" spacing=\"square\" viewbox=\"0 0 640 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\" fill=\"currentColor\"></path></svg></div></a>Approach 1: Linear Search</h3>\n<h4 id=\"intuition\">Intuition</h4>\n<p>We can do a linear search by iterating through all the intervals and checking which one of the three conditions the intervals fall under:</p>\n<ol>\n<li data-length=\"1\">\n<p><strong>No Overlaps before Merging:</strong></p>\n<ul>\n<li>This occurs when the current interval ends before the new interval starts.</li>\n</ul>\n</li>\n<li data-length=\"1\">\n<p><strong>Overlapping and Merging:</strong></p>\n<ul>\n<li>This occurs when the starting point of the current interval is less than or equal to the ending point of the new interval (<code>newInterval[1]</code>), indicating an overlap. We can merge the current interval with the new interval by updating the start and end values of the new interval.</li>\n</ul>\n</li>\n<li data-length=\"1\">\n<p><strong>No Overlapping after Merging:</strong></p>\n<ul>\n<li>This occurs when the current interval starts after the new interval ends.</li>\n</ul>\n</li>\n</ol>\n<h5 id=\"1-identifying-non-overlapping-intervals-before-merging\">1. Identifying Non-Overlapping Intervals Before Merging:</h5>\n<p>We iterate through all intervals, checking whether the endpoint of the current interval (<code>intervals[i][1]</code>) is less than the starting point of the new interval (<code>newInterval[0]</code>). If this condition holds true, it indicates there is no overlap before merging, and we add the current interval to the result.</p>\n<h5 id=\"2-identifying-and-merging-overlapping-intervals\">2. Identifying and Merging Overlapping Intervals:</h5>\n<p>During the iteration, we identify overlap by comparing the endpoint of the new interval (<code>newInterval[1]</code>) with the starting point of the current interval (<code>intervals[i][0]</code>). When an overlap is detected, we merge the intervals by updating the start and end values of the new interval. The index (<code>i</code>) is then incremented to move to the next interval. After merging, the new interval is added to the result.</p>\n<h5 id=\"3-identifying-non-overlapping-intervals-after-merging\">3. Identifying Non-Overlapping Intervals After Merging:</h5>\n<p>As we have already added the non-overlapping intervals before <code>newInterval</code> and merged overlapping ones, the remaining intervals after are guaranteed not to overlap with the newly merged interval. We simply add these remaining intervals to the result.</p>\n<p>The following slideshow illustrates how the linear search algorithm is employed:</p>\n<p></p>\n<h4 id=\"algorithm\">Algorithm</h4>\n<ul>\n<li>Initialize variables <code>n</code> and <code>i</code> to store the size of intervals and the current index, respectively, and an empty array <code>res</code> to store the result.</li>\n<li>Case 1: No Overlap Before Insertion:\n<ul>\n<li>Loop through intervals while <code>i</code> is less than <code>n</code> and the current interval's endpoint (<code>intervals[i][1]</code>) is less than the new interval's start point (<code>newInterval[0]</code>).</li>\n<li>Add the current interval from intervals to the <code>res</code> array.</li>\n<li>Increment <code>i</code> to move to the next interval.</li>\n</ul>\n</li>\n<li>Case 2: Overlap and Merge:\n<ul>\n<li>Loop through intervals while <code>i</code> is less than <code>n</code> and the new interval's endpoint (<code>newInterval[1]</code>) is greater than or equal to the current interval's start point (<code>intervals[i][0]</code>).</li>\n<li>Update the newInterval's start point to the minimum of its current start and the current interval's start.</li>\n<li>Update the newInterval's endpoint to the maximum of its current end and the current interval's end.</li>\n<li>This essentially merges overlapping intervals into a single larger interval.</li>\n<li>Increment <code>i</code> to move to the next interval.</li>\n</ul>\n</li>\n<li>Add the updated <code>newInterval</code> to the <code>res</code> array, representing the merged interval.</li>\n<li>Case 3: No overlap after insertion:\n<ul>\n<li>Loop through the remaining intervals (from index <code>i</code>) and add them to the <code>res</code> array.\n<ul>\n<li>This includes intervals that occur after the new interval and those that don't overlap, as they have already been correctly inserted in the previous iterations (previous two cases).</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Return the <code>res</code> array containing all intervals with the new interval inserted correctly.</li>\n</ul>\n<h4 id=\"implementation\">Implementation</h4>\n<pre><code>class Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; insert(vector&lt;vector&lt;int&gt;&gt;&amp; intervals,\n                               vector&lt;int&gt;&amp; newInterval) {\n        int n = intervals.size(), i = 0;\n        vector&lt;vector&lt;int&gt;&gt; res;\n​\n        // Case 1: no overlapping case before the merge intervals\n        // Compare ending point of intervals to starting point of newInterval\n        while (i &lt; n &amp;&amp; intervals[i][1] &lt; newInterval[0]) {\n            res.push_back(intervals[i]);\n            i++;\n        }\n​\n        // Case 2: overlapping case and merging of intervals\n        while (i &lt; n &amp;&amp; newInterval[1] &gt;= intervals[i][0]) {\n            newInterval[0] = min(newInterval[0], intervals[i][0]);\n            newInterval[1] = max(newInterval[1], intervals[i][1]);\n            i++;\n        }\n        res.push_back(newInterval);\n​\n        // Case 3: no overlapping of intervals after newinterval being merged\n        while (i &lt; n) {\n            res.push_back(intervals[i]);\n            i++;\n        }\n        return res;\n    }\n};</code></pre>\n<h4 id=\"complexity-analysis\">Complexity Analysis</h4>\n<p>Let <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span></span></span></span></span> be the number of intervals.</p>\n<ul>\n<li>\n<p>Time complexity: <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p>We iterate through the intervals once, and each interval is considered and processed only once.</p>\n</li>\n<li>\n<p>Space complexity: <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p>We only use the result (<code>res</code>) array to store output, so this could be considered <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n</li>\n</ul>\n<hr/>\n<h3 class=\"group/heading relative\" id=\"approach-2-binary-search\" level=\"3\"><a aria-hidden=\"true\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" href=\"#approach-2-binary-search\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" data-icon=\"link\" data-prefix=\"fas\" focusable=\"false\" role=\"img\" spacing=\"square\" viewbox=\"0 0 640 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\" fill=\"currentColor\"></path></svg></div></a>Approach 2: Binary Search</h3>\n<h4 id=\"intuition-1\">Intuition</h4>\n<p>To apply binary search to a problem, a crucial requirement is that the input should have a monotonically increasing or decreasing nature. In our given scenario, it is explicitly stated that the input is already sorted with respect to the start value, indicating a monotonically increasing order. Therefore, we can confidently consider applying binary search.</p>\n<h5 id=\"1-finding-the-insertion-position\">1. Finding the Insertion Position</h5>\n<p>As the intervals are sorted by start value, we perform a binary search comparing the starting point of the current interval (<code>intervals[mid][0]</code>) with the starting point of the new interval (<code>target</code>). If <code>intervals[mid][0]</code> is less than the target, it indicates that the insertion point should be to the right of the current position. Consequently, we update <code>left</code> to <code>mid + 1</code>. If it's greater, the insertion point should be to the left, so we update <code>right</code> to <code>mid - 1</code>. This process continues until <code>left</code> becomes greater than <code>right</code>, revealing the correct insertion position.</p>\n<h5 id=\"2-handling-merging\">2. Handling Merging</h5>\n<ol>\n<li data-length=\"1\">If <code>res</code> is empty or the end of the last interval in <code>res</code> is less than the starting point of the current interval, it indicates there is no overlap before merging. The current interval is directly added to <code>res</code> in such cases.</li>\n<li data-length=\"1\">If an overlap is detected, signifying the need for merging, the current interval is merged with the last interval in <code>res</code>. The end of the last interval in <code>res</code> is updated to the maximum of its current end and the end of the current interval.</li>\n</ol>\n<p>The following slideshow illustrates how the binary search algorithm is employed:</p>\n<p></p>\n<h4 id=\"algorithm-1\">Algorithm</h4>\n<ul>\n<li>If <code>intervals</code> is empty, it means there are no existing intervals, so we can simply return a array containing the <code>newInterval</code>.</li>\n<li>Perform a binary search to find the correct position to insert the new interval in the <code>intervals</code> array. It updates the values of <code>left</code> and <code>right</code> based on the comparison of the target value with the first element of the interval at the middle index.\n<ul>\n<li>Initialize the variables <code>target</code> with the starting point of <code>newInterval</code> (i.e., <code>newInterval[0]</code>), <code>left</code> with 0, and <code>right</code> with <code>n - 1</code> to define the search space in the <code>intervals</code> array.</li>\n<li>Perform a binary search by repeatedly dividing the search space in half until <code>left</code> is greater than <code>right</code>.</li>\n<li>Calculate the middle index <code>mid</code> as the average of <code>left</code> and <code>right</code>.</li>\n<li>If the start of the interval at index <code>mid</code> is less than the target value, update <code>left</code> to <code>mid + 1</code> to search the right half of the search space. Otherwise, update <code>right</code> to <code>mid - 1</code> to search the left half of the search space.</li>\n<li>The search updates <code>left</code> and <code>right</code> until they converge to the correct position. Repeat until <code>left</code> is greater than <code>right</code>.</li>\n</ul>\n</li>\n<li>Use <code>intervals.insert(intervals.begin() + left, newInterval)</code> to insert the <code>newInterval</code> at the correct position.</li>\n<li>Initialize an empty array <code>res</code> to store the result.</li>\n<li>Iterate through the sorted intervals.\n<ul>\n<li>Check if <code>res</code> is empty or if the end of the last interval in <code>res</code> is less than the start of the current interval. If either condition is true, add the current interval to <code>res</code>.</li>\n<li>If there is an overlap, update the endpoint of the last interval in <code>res</code> to cover the current interval. This step ensures that non-overlapping intervals are added directly, and overlapping intervals are merged.</li>\n</ul>\n</li>\n<li>The final merged and inserted intervals are stored in the <code>res</code> array, which is then returned.</li>\n</ul>\n<h4 id=\"implementation-1\">Implementation</h4>\n<pre><code>class Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; insert(vector&lt;vector&lt;int&gt;&gt;&amp; intervals,\n                               vector&lt;int&gt;&amp; newInterval) {\n        // If the intervals vector is empty, return a vector containing the\n        // newInterval\n        if (intervals.empty()) {\n            return {newInterval};\n        }\n​\n        int n = intervals.size();\n        int target = newInterval[0];\n        int left = 0, right = n - 1;\n​\n        // Binary search to find the position to insert newInterval\n        while (left &lt;= right) {\n            int mid = (left + right) / 2;\n            if (intervals[mid][0] &lt; target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n​\n        // Insert newInterval at the found position\n        intervals.insert(intervals.begin() + left, newInterval);\n​\n        // Merge overlapping intervals\n        vector&lt;vector&lt;int&gt;&gt; res;\n        for (const auto&amp; interval : intervals) {\n            // If res is empty or there is no overlap, add the interval to the\n            // result\n            if (res.empty() || res.back()[1] &lt; interval[0]) {\n                res.push_back(interval);\n                // If there is an overlap, merge the intervals by updating the\n                // end of the last interval in res\n            } else {\n                res.back()[1] = max(res.back()[1], interval[1]);\n            }\n        }\n​\n        return res;\n    }\n};</code></pre>\n<h4 id=\"complexity-analysis-1\">Complexity Analysis</h4>\n<p>Let <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span></span></span></span></span> be the number of intervals.</p>\n<ul>\n<li>\n<p>Time complexity: <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p>The binary search for finding the position to insert the <code>newInterval</code> has a time complexity of <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mop\">lo<span style=\"margin-right: 0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right: 0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span></span>. However, the insertion of the <code>newInterval</code> into the list may take <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span></span> time in the worst case, as it could involve shifting elements within the list. Consequently, the overall time complexity is <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mop\">lo<span style=\"margin-right: 0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right: 0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span></span>, which simplifies to <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n</li>\n<li>\n<p>Space complexity: <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p>We use the additional space to store the result (<code>res</code>) and perform calculations using <code>res,</code> so it does count towards the space complexity. In the worst case, the size of <code>res</code> will be proportional to the number of intervals in the input list.</p>\n</li>\n</ul></div><span style=\"font-size: 0px; line-height: 0;\"> </span></div>"}