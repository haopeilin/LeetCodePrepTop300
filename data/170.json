{"id":"170","title":"Two Sum III - Data structure design","difficulty":"Easy","content":"<p>Design a data structure that accepts a stream of integers and checks if it has a pair of integers that sum up to a particular value.</p>\n\n<p>Implement the <code>TwoSum</code> class:</p>\n\n<ul>\n\t<li><code>TwoSum()</code> Initializes the <code>TwoSum</code> object, with an empty array initially.</li>\n\t<li><code>void add(int number)</code> Adds <code>number</code> to the data structure.</li>\n\t<li><code>boolean find(int value)</code> Returns <code>true</code> if there exists any pair of numbers whose sum is equal to <code>value</code>, otherwise, it returns <code>false</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;TwoSum&quot;, &quot;add&quot;, &quot;add&quot;, &quot;add&quot;, &quot;find&quot;, &quot;find&quot;]\n[[], [1], [3], [5], [4], [7]]\n<strong>Output</strong>\n[null, null, null, null, true, false]\n\n<strong>Explanation</strong>\nTwoSum twoSum = new TwoSum();\ntwoSum.add(1);   // [] --&gt; [1]\ntwoSum.add(3);   // [1] --&gt; [1,3]\ntwoSum.add(5);   // [1,3] --&gt; [1,3,5]\ntwoSum.find(4);  // 1 + 3 = 4, return true\ntwoSum.find(7);  // No two integers sum up to 7, return false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>-10<sup>5</sup> &lt;= number &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-2<sup>31</sup> &lt;= value &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li>At most <code>10<sup>4</sup></code> calls will be made to <code>add</code> and <code>find</code>.</li>\n</ul>\n","tags":["Array","Hash Table","Two Pointers","Design","Data Stream"],"java_snippet":"class TwoSum {\n\n    public TwoSum() {\n        \n    }\n    \n    public void add(int number) {\n        \n    }\n    \n    public boolean find(int value) {\n        \n    }\n}\n\n/**\n * Your TwoSum object will be instantiated and called as such:\n * TwoSum obj = new TwoSum();\n * obj.add(number);\n * boolean param_2 = obj.find(value);\n */","solution":"<h2><a href=\"#solution\"><svg><path></path></svg></a>Solution</h2>\n<hr/>\n<h3><a href=\"#approach-1-sorted-list\"><svg><path></path></svg></a>Approach 1: Sorted List</h3>\n<p><strong>Intuition</strong></p>\n<p>First of all, the problem description is not terribly clear on the requirements of <em>time</em> and <em>space</em> complexity. But let us consider this as part of the challenge or a freedom of design. We could figure out the desired complexity for each function, by trial and error.</p>\n<p>This is one of the followup problems to the first programming problem on LeetCode called <a href=\"https://leetcode.com/problems/two-sum/\">Two Sum</a>, where one is asked to return the indice of two numbers from a <strong><em>list</em></strong> that could sum up to a given value.</p>\n<blockquote>\n<p>Let us take the inspiration from the origin problem, by keeping all the incoming numbers in a <em>list</em>.</p>\n</blockquote>\n<p>Given a list, one of the solutions to the Two Sum problem is called <strong><em>Two-Pointers Iteration</em></strong> where we iterate through the list from two directions with <em>two pointers</em> approaching each other.</p>\n<p></p>\n<blockquote>\n<p>However, one of the preconditions for the Two-Pointers Iteration solution is that the input list should be <em><strong>sorted</strong></em>.</p>\n</blockquote>\n<p>So now, here are the questions:</p>\n<ul>\n<li>\n<p>Should we keep the list in order while inserting new numbers in the function <code>add(number)</code> ?</p>\n</li>\n<li>\n<p>Or should we do the sorting on demand, <em>i.e.</em> at the invocation of <code>find(value)</code> ?</p>\n</li>\n</ul>\n<p>We will address the above two questions later in the Algorithm section.</p>\n<p><strong>Algorithm</strong></p>\n<p>Let us first give the algorithm of Two-Pointers Iteration to find the two-sum solution from a <em>sorted</em> list:</p>\n<ul>\n<li>\n<p>We initialize <strong>two pointers</strong> <code>low</code> and <code>high</code> which point to the head and the tail elements of the list respectively.</p>\n</li>\n<li>\n<p>With the two pointers, we start a <strong>loop</strong> to iterate the list. The loop would terminate either we find the two-sum solution or the two pointers meet each other.</p>\n</li>\n<li>\n<p>Within the loop, at each step, we would move either of the pointers, according to different conditions:</p>\n<ul>\n<li>\n<p>If the sum of the elements pointed by the current pointers is <em><strong>less than</strong></em> the desired value, then we should try to increase the sum to meet the desired value, <em>i.e.</em> we should move the <code>low</code> pointer forwards to have a larger value.</p>\n</li>\n<li>\n<p>Similarly if the sum of the elements pointed by the current pointers is <em><strong>greater than</strong></em> the desired value, we then should try to reduce the sum by moving the <code>high</code> pointer towards the <code>low</code> pointer.</p>\n</li>\n<li>\n<p>If the sum happen to the desired value, then we could simply do an <strong>early return</strong> of the function.</p>\n</li>\n</ul>\n</li>\n<li>\n<p>If the loop is terminated at the case where the two pointers meet each other, then we can be sure that there is no solution to the desired value.</p>\n</li>\n</ul>\n<pre><code>class TwoSum {\n    private List&lt;Integer&gt; nums;\n    private boolean isSorted;\n\n    public TwoSum() {\n        this.nums = new ArrayList&lt;&gt;();\n        this.isSorted = false;\n    }\n\n    public void add(int number) {\n        nums.add(number);\n        isSorted = false;\n    }\n\n    public boolean find(int value) {\n        if (!isSorted) {\n            Collections.sort(nums);\n            isSorted = true;\n        }\n\n        int low = 0;\n        int high = nums.size() - 1;\n\n        while (low &lt; high) {\n            int sum = nums.get(low) + nums.get(high);\n\n            if (sum &lt; value) {\n                low++;\n            } else if (sum &gt; value) {\n                high--;\n            } else {\n                return true;\n            }\n        }\n\n        return false;\n    }\n}</code></pre>\n<blockquote>\n<p>The problem statement does not specify how often each operation will be called, so in theory any pattern is possible. In practice though, the online judge tends to issue many <code>add(number)</code> calls before a <code>find(value)</code> call. Because of this input structure, it is more efficient to keep insertions inexpensive and postpone sorting until it is actually needed. Sorting only when the list has been modified allows the sorting cost to be amortized over many insertions, which results in significantly better performance on the judge’s test cases.</p>\n</blockquote>\n<p>The usage pattern implies that we should try to minimize the cost of <code>add(number)</code> function. As a result, we sort the list within the <code>find(value)</code> function instead of the <code>add(number)</code> function.</p>\n<p><em>So to the above questions about where to place the sort operation, actually both options are valid and correct.</em> Due to the usage pattern of the two functions though, it is <strong>less optimal</strong> to sort the list at each <em>add</em> operation.</p>\n<p>On the other hand, we do not do sorting at each occasion of <code>find(value)</code> neither. But rather, we sort on demand, <em>i.e.</em> only when the list is updated. As a result, we <strong><em>amortize</em></strong> the cost of the sorting over the time. And this is the optimization trick for the solution to pass the online judge.</p>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity:</p>\n<ul>\n<li>\n<p>For the <code>add(number)</code> function: O(1), since we simply append the element into the list.</p>\n</li>\n<li>\n<p>For the <code>find(value)</code> function: O(N⋅log(N)). In the worst case, we would need to sort the list first, which is of O(N⋅log(N)) time complexity normally. And later, again in the worst case we need to iterate through the entire list, which is of O(N) time complexity. As a result, the overall time complexity of the function lies on O(N⋅log(N)) of the sorting operation, which dominates over the later iteration part.</p>\n</li>\n</ul>\n</li>\n<li>\n<p>Space Complexity: the overall space complexity of the data structure is O(N) where N is the total number of <em>numbers</em> that have been added.</p>\n<br/>\n</li>\n</ul>\n<br/>\n<hr/>\n<h3><a href=\"#approach-2-hashtable\"><svg><path></path></svg></a>Approach 2: HashTable</h3>\n<p><strong>Intuition</strong></p>\n<p>As an alternative solution to the original <a href=\"https://leetcode.com/problems/two-sum/\">Two Sum</a> problem, one could employ the <em>HashTable</em> to index each number.</p>\n<blockquote>\n<p>Given a desired sum value <code>S</code>, for each number <code>a</code>, we just need to verify if there exists a complement number (<code>S-a</code>) in the table.</p>\n</blockquote>\n<p>As we know, the data structure of hashtable could offer us a quick <em>lookup</em> as well as <em>insertion</em> operations, which fits well with the above requirements.</p>\n<p><strong>Algorithm</strong></p>\n<ul>\n<li>\n<p>First, we initialize a <em>hashtable</em> container in our data structure.</p>\n</li>\n<li>\n<p>For the <code>add(number)</code> function, we build a frequency hashtable with the <em>number</em> as key and the frequency of the <em>number</em> as the value in the table.</p>\n</li>\n<li>\n<p>For the <code>find(value)</code> function, we then iterate through the hashtable over the keys. For each key (<code>number</code>), we check if there exists a complement (<code>value - number</code>) in the table. If so, we could terminate the loop and return the result.</p>\n</li>\n<li>\n<p>In a particular case, where the number and its complement are equal, we then need to check if there exists <em>at least</em> <strong>two copies</strong> of the <em>number</em> in the table.</p>\n</li>\n</ul>\n<p>We illustrate the algorithm in the following figure:</p>\n<p></p>\n<pre><code>class TwoSum {\n    private Map&lt;Long, Integer&gt; numCounts;\n\n    /** Initialize your data structure here. */\n    public TwoSum() {\n        this.numCounts = new HashMap&lt;&gt;();\n    }\n\n    /** Add the number to an internal data structure. */\n    public void add(int number) {\n        long key = number;\n        numCounts.put(key, numCounts.getOrDefault(key, 0) + 1);\n    }\n\n    /** Find if there exists any pair of numbers which sum is equal to the\n     * value. */\n    public boolean find(int value) {\n        for (Map.Entry&lt;Long, Integer&gt; entry : numCounts.entrySet()) {\n            long number = entry.getKey();\n            long complement = (long) value - number;\n\n            if (complement != number) {\n                if (numCounts.containsKey(complement)) {\n                    return true;\n                }\n            } else {\n                if (entry.getValue() &gt; 1) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity:</p>\n<ul>\n<li>\n<p>For the <code>add(number)</code> function: O(1), since it takes a constant time to update an entry in hashtable.</p>\n</li>\n<li>\n<p>For the <code>find(value)</code> function: O(N), where N is the total number of <strong>unique</strong> <em>numbers</em>. In the worst case, we would iterate through the entire table.</p>\n</li>\n</ul>\n</li>\n<li>\n<p>Space Complexity: O(N), where N is the total number of <strong>unique</strong> <em>numbers</em> that we will see during the usage of the data structure.</p>\n</li>\n</ul>"}