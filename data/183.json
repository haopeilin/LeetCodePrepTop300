{"id":"183","title":"Customers Who Never Order","difficulty":"Easy","content":"<p>Table: <code>Customers</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| id          | int     |\n| name        | varchar |\n+-------------+---------+\nid is the primary key (column with unique values) for this table.\nEach row of this table indicates the ID and name of a customer.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Table: <code>Orders</code></p>\n\n<pre>\n+-------------+------+\n| Column Name | Type |\n+-------------+------+\n| id          | int  |\n| customerId  | int  |\n+-------------+------+\nid is the primary key (column with unique values) for this table.\ncustomerId is a foreign key (reference columns) of the ID from the Customers table.\nEach row of this table indicates the ID of an order and the ID of the customer who ordered it.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to find all customers who never order anything.</p>\n\n<p>Return the result table in <strong>any order</strong>.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nCustomers table:\n+----+-------+\n| id | name  |\n+----+-------+\n| 1  | Joe   |\n| 2  | Henry |\n| 3  | Sam   |\n| 4  | Max   |\n+----+-------+\nOrders table:\n+----+------------+\n| id | customerId |\n+----+------------+\n| 1  | 3          |\n| 2  | 1          |\n+----+------------+\n<strong>Output:</strong> \n+-----------+\n| Customers |\n+-----------+\n| Henry     |\n| Max       |\n+-----------+\n</pre>\n","tags":["Database"],"java_snippet":"","solution":"<h1><a href=\"#solution\"><svg><path></path></svg></a>Solution</h1>\n<hr/>\n<h2><a href=\"#pandas\"><svg><path></path></svg></a>Java</h2>\n<h3><a href=\"#approach-1-filtering-data-with-exclusion-criteria\"><svg><path></path></svg></a>Approach 1: Filtering Data with Exclusion Criteria</h3>\n<h4>Algorithm</h4>\n<p>The criterion for determining whether a customer ever orders is: if a customer ID does not appear in the <code>orders</code> table, it means they have never placed an order.</p>\n<p>Therefore, we can use row filtering to remove customer IDs that do not meet the criteria.</p>\n<blockquote>\n<p>In Java:</p>\n<ul>\n<li>We can collect all <code>customerId</code> values from orders into a set.</li>\n<li>We then filter customers whose <code>id</code> is NOT present in that set.</li>\n</ul>\n<p>Therefore, selecting customers whose IDs are not contained in the set identifies those who never ordered.</p>\n</blockquote>\n<pre><code>// Collect all customerIds from orders\nSet&lt;Integer&gt; orderedCustomerIds = orders.stream()\n        .map(Order::getCustomerId)\n        .collect(Collectors.toSet());\n\n// Select customers whose id is not present in orderedCustomerIds\nList&lt;Customer&gt; result = customers.stream()\n        .filter(c -&gt; !orderedCustomerIds.contains(c.getId()))\n        .collect(Collectors.toList());</code></pre><svg><path></path></svg>\n<p>We can obtain the following table:</p>\n<table><tbody><tr><th>id</th><th>name</th></tr><tr><td>2</td><td>Henry</td></tr><tr><td>4</td><td>Max</td></tr></tbody></table>\n<br/>\n<p>Note that the requirement is to only return the names that meet the criteria, and the column <code>name</code> should be renamed as <code>Customers</code>, therefore.</p>\n<pre><code>// Extract only the customer names and rename the output column conceptually as \"Customers\"\nList&lt;String&gt; customersResult = result.stream()\n        .map(Customer::getName)\n        .collect(Collectors.toList());</code></pre><svg><path></path></svg>\n<p>Here is the resulting table:</p>\n<table><tbody><tr><th>Customers</th></tr><tr><td>Henry</td></tr><tr><td>Max</td></tr></tbody></table>\n<br/>\n<h4>Implementation</h4>\n<pre><code>import java.util.*;\nimport java.util.stream.Collectors;\n\npublic class Solution {\n\n    public static List&lt;String&gt; findCustomers(List&lt;Customer&gt; customers, List&lt;Order&gt; orders) {\n        Set&lt;Integer&gt; orderedCustomerIds = orders.stream()\n                .map(Order::getCustomerId)\n                .collect(Collectors.toSet());\n\n        return customers.stream()\n                .filter(c -&gt; !orderedCustomerIds.contains(c.getId()))\n                .map(Customer::getName)\n                .collect(Collectors.toList());\n    }\n}</code></pre><svg><path></path></svg>\n<br/>\n<hr/>\n<h3><a href=\"#approach-2-left-join-on-customers\"><svg><path></path></svg></a>Approach 2: Left Join on <code>customers</code></h3>\n<h4>Algorithm</h4>\n<p>The idea is to join the table <code>customers</code> with the table <code>orders</code> based on the common customer ID (the column <code>id</code> in <code>customers</code> and the column <code>customerId</code> in <code>orders</code>).</p>\n<p>By performing a left join and selecting the records where the <code>customerId</code> is <code>null</code>, we can identify customers who do not make an order.</p>\n<blockquote>\n<p>We use a left join on <code>customers</code> because we want to include all customers from it, regardless of whether they place an order or not.<br/>\nTherefore, by using left join logic in Java, we can preserve all customers and attempt to match them with corresponding orders.</p>\n</blockquote>\n<pre><code>// Build a map from customerId to orders\nMap&lt;Integer, List&lt;Order&gt;&gt; orderMap = orders.stream()\n        .collect(Collectors.groupingBy(Order::getCustomerId));\n\n// Simulate a left join by iterating over customers\nList&lt;Customer&gt; joinedResult = customers.stream()\n        .filter(c -&gt; !orderMap.containsKey(c.getId()))\n        .collect(Collectors.toList());</code></pre><svg><path></path></svg>\n<p>The table appears as follows:</p>\n<table><tbody><tr><th>id</th><th>name</th><th>id</th><th>customerId</th></tr><tr><td>1</td><td>Joe</td><td>2</td><td>1</td></tr><tr><td>2</td><td>Henry</td><td>null</td><td>null</td></tr><tr><td>3</td><td>Sam</td><td>1</td><td>3</td></tr><tr><td>4</td><td>Max</td><td>null</td><td>null</td></tr></tbody></table>\n<br/>\n<p>The next step is filtering the joined table by selecting the rows where the <code>customerId</code> is null, which will give us the customers who do not have any orders.</p>\n<pre><code>// Customers without matching orders already represent customerId == null\nList&lt;Customer&gt; noOrderCustomers = joinedResult;</code></pre><svg><path></path></svg>\n<p>The table appears as follows:</p>\n<table><tbody><tr><th>id</th><th>name</th><th>id</th><th>customerId</th></tr><tr><td>2</td><td>Henry</td><td>null</td><td>null</td></tr><tr><td>4</td><td>Max</td><td>null</td><td>null</td></tr></tbody></table>\n<br/>\n<p>Similarly, we only return the names of the rows that meet the criteria, and rename the column <code>name</code> as <code>Customers</code>.</p>\n<pre><code>List&lt;String&gt; customersResult = noOrderCustomers.stream()\n        .map(Customer::getName)\n        .collect(Collectors.toList());</code></pre><svg><path></path></svg>\n<p>Here is the resulting table:</p>\n<table><tbody><tr><th>Customers</th></tr><tr><td>Henry</td></tr><tr><td>Max</td></tr></tbody></table>\n<br/>\n<p>In summary, the complete answer is as follows:</p>\n<h4>Implementation</h4>\n<pre><code>import java.util.*;\nimport java.util.stream.Collectors;\n\npublic class Solution {\n\n    public static List&lt;String&gt; customersWhoNeverOrder(List&lt;Customer&gt; customers, List&lt;Order&gt; orders) {\n        Map&lt;Integer, List&lt;Order&gt;&gt; orderMap = orders.stream()\n                .collect(Collectors.groupingBy(Order::getCustomerId));\n\n        return customers.stream()\n                .filter(c -&gt; !orderMap.containsKey(c.getId()))\n                .map(Customer::getName)\n                .collect(Collectors.toList());\n    }\n}</code></pre>\n<h2><a href=\"#database\"><svg><path></path></svg></a>Database</h2>\n<h3><a href=\"#approach-1-filtering-data-with-exclusion-criteria-1\"><svg><path></path></svg></a>Approach 1: Filtering Data with Exclusion Criteria</h3>\n<h4>Algorithm</h4>\n<p>The criterion for determining whether a customer ever orders is: if a customer ID does not appear in the <code>orders</code> table, it means they have never placed an order.</p>\n<p>Therefore, we can use row filtering to remove customer IDs that do not meet the criteria using a <code>NOT IN</code> clause.</p>\n<pre><code>String sql = \n    \"SELECT * \" +\n    \"FROM customers \" +\n    \"WHERE customers.id NOT IN (\" +\n    \"    SELECT customerid FROM orders\" +\n    \")\";</code></pre><svg><path></path></svg>\n<p>We can obtain the following table:</p>\n<table><tbody><tr><th>id</th><th>name</th></tr><tr><td>2</td><td>Henry</td></tr><tr><td>4</td><td>Max</td></tr></tbody></table>\n<br/>\n<p>Note that the requirement is to only return the names that meet the criteria, and the column <code>name</code> should be renamed as <code>Customers</code>, therefore, the complete answer is as follows:</p>\n<h4>Implementation</h4>\n<pre><code>String sql =\n    \"SELECT customers.name AS Customers \" +\n    \"FROM customers \" +\n    \"WHERE customers.id NOT IN (\" +\n    \"    SELECT customerid FROM orders\" +\n    \")\";</code></pre><svg><path></path></svg>\n<br/>\n<h3><a href=\"#approach-2-left-join-on-customers-1\"><svg><path></path></svg></a>Approach 2: Left Join on <code>customers</code></h3>\n<h4>Algorithm</h4>\n<p>The idea is to join the table <code>customers</code> with the table <code>orders</code> based on the common customer ID (the column <code>id</code> in <code>customers</code> and the column <code>customerId</code> in <code>orders</code>).</p>\n<p>By performing a left join and selecting the records where the <code>customerId</code> is <code>null</code>, we can identify customers who do not make an order.</p>\n<blockquote>\n<p>We use a left join on <code>customers</code> because we want to include all customers from it, regardless of whether they place an order or not.<br/>\nTherefore, by using a left join in SQL executed via Java, we can preserve all the rows from the left table.</p>\n</blockquote>\n<pre><code>String sql =\n    \"SELECT * \" +\n    \"FROM Customers c \" +\n    \"LEFT JOIN Orders o \" +\n    \"ON c.Id = o.CustomerId\";</code></pre><svg><path></path></svg>\n<p>The table appears as follows:</p>\n<table><tbody><tr><th>id</th><th>name</th><th>id</th><th>customerId</th></tr><tr><td>1</td><td>Joe</td><td>2</td><td>1</td></tr><tr><td>2</td><td>Henry</td><td>null</td><td>null</td></tr><tr><td>3</td><td>Sam</td><td>1</td><td>3</td></tr><tr><td>4</td><td>Max</td><td>null</td><td>null</td></tr></tbody></table>\n<br/>\n<p>The next step is filtering the joined table by selecting the rows where the <code>customerId</code> is null, which will give us the customers who do not have any orders.</p>\n<pre><code>String sql =\n    \"SELECT * \" +\n    \"FROM Customers \" +\n    \"LEFT JOIN Orders ON Customers.Id = Orders.CustomerId \" +\n    \"WHERE Orders.CustomerId IS NULL\";</code></pre><svg><path></path></svg>\n<p>The table appears as follows:</p>\n<table><tbody><tr><th>id</th><th>name</th><th>id</th><th>customerId</th></tr><tr><td>2</td><td>Henry</td><td>null</td><td>null</td></tr><tr><td>4</td><td>Max</td><td>null</td><td>null</td></tr></tbody></table>\n<br/>\n<p>Similarly, we only return the names of the rows that meet the criteria, and rename the column <code>name</code> as <code>Customers</code>. The complete answer is as follows:</p>\n<h4>Implementation</h4>\n<pre><code>String sql =\n    \"SELECT name AS Customers \" +\n    \"FROM Customers \" +\n    \"LEFT JOIN Orders ON Customers.Id = Orders.CustomerId \" +\n    \"WHERE Orders.CustomerId IS NULL\";</code></pre><svg><path></path></svg>"}