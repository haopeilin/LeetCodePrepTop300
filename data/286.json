{"id":"286","title":"Walls and Gates","difficulty":"Medium","content":"<p>You are given an <code>m x n</code> grid <code>rooms</code>&nbsp;initialized with these three possible values.</p>\n\n<ul>\n\t<li><code>-1</code>&nbsp;A wall or an obstacle.</li>\n\t<li><code>0</code> A gate.</li>\n\t<li><code>INF</code> Infinity means an empty room. We use the value <code>2<sup>31</sup> - 1 = 2147483647</code> to represent <code>INF</code> as you may assume that the distance to a gate is less than <code>2147483647</code>.</li>\n</ul>\n\n<p>Fill each empty room with the distance to <em>its nearest gate</em>. If it is impossible to reach a gate, it should be filled with <code>INF</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/03/grid.jpg\" style=\"width: 500px; height: 223px;\" />\n<pre>\n<strong>Input:</strong> rooms = [[2147483647,-1,0,2147483647],[2147483647,2147483647,2147483647,-1],[2147483647,-1,2147483647,-1],[0,-1,2147483647,2147483647]]\n<strong>Output:</strong> [[3,-1,0,1],[2,2,1,-1],[1,-1,2,-1],[0,-1,3,4]]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> rooms = [[-1]]\n<strong>Output:</strong> [[-1]]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == rooms.length</code></li>\n\t<li><code>n == rooms[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 250</code></li>\n\t<li><code>rooms[i][j]</code> is <code>-1</code>, <code>0</code>, or <code>2<sup>31</sup> - 1</code>.</li>\n</ul>\n","tags":["Array","Breadth-First Search","Matrix"],"java_snippet":"class Solution {\n    public void wallsAndGates(int[][] rooms) {\n        \n    }\n}","solution":"<h2><a href=\"#solution\"><svg><path></path></svg></a>Solution</h2>\n<hr/>\n<h3><a href=\"#approach-1-brute-force-time-limit-exceeded\"><svg><path></path></svg></a>Approach #1 (Brute Force) [Time Limit Exceeded]</h3>\n<p>The brute force approach is simple, we just implement a breadth-first search from each empty room to its nearest gate.</p>\n<p>While we are doing the search, we use a 2D array called <code>distance</code> to keep track of the distance from the starting point. It also implicitly tell us whether a position had been visited so it won't be inserted into the queue again.</p>\n<pre><code>private static final int EMPTY = Integer.MAX_VALUE;\nprivate static final int GATE = 0;\nprivate static final int WALL = -1;\nprivate static final List&lt;int[]&gt; DIRECTIONS = Arrays.asList(\n        new int[] { 1,  0},\n        new int[] {-1,  0},\n        new int[] { 0,  1},\n        new int[] { 0, -1}\n);\n​\npublic void wallsAndGates(int[][] rooms) {\n    if (rooms.length == 0) return;\n    for (int row = 0; row &lt; rooms.length; row++) {\n        for (int col = 0; col &lt; rooms[0].length; col++) {\n            if (rooms[row][col] == EMPTY) {\n                rooms[row][col] = distanceToNearestGate(rooms, row, col);\n            }\n        }\n    }\n}\n​\nprivate int distanceToNearestGate(int[][] rooms, int startRow, int startCol) {\n    int m = rooms.length;\n    int n = rooms[0].length;\n    int[][] distance = new int[m][n];\n    Queue&lt;int[]&gt; q = new LinkedList&lt;&gt;();\n    q.add(new int[] { startRow, startCol });\n    while (!q.isEmpty()) {\n        int[] point = q.poll();\n        int row = point[0];\n        int col = point[1];\n        for (int[] direction : DIRECTIONS) {\n            int r = row + direction[0];\n            int c = col + direction[1];\n            if (r &lt; 0 || c &lt; 0 || r &gt;= m || c &gt;= n || rooms[r][c] == WALL\n                    || distance[r][c] != 0) {\n                continue;\n            }\n            distance[r][c] = distance[row][col] + 1;\n            if (rooms[r][c] == GATE) {\n                return distance[r][c];\n            }\n            q.add(new int[] { r, c });\n        }\n    }\n    return Integer.MAX_VALUE;\n}</code></pre>\n<p><strong>Complexity analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : O(m2n2).<br/>\nFor each point in the m×n size grid, the gate could be at most m×n steps away.</p>\n</li>\n<li>\n<p>Space complexity : O(mn).<br/>\nThe space complexity depends on the queue's size. Since we won't insert points that have been visited before into the queue, we insert at most m×n points into the queue.</p>\n</li>\n</ul>\n<hr/>\n<h3><a href=\"#approach-2-breadth-first-search-accepted\"><svg><path></path></svg></a>Approach #2 (Breadth-first Search) [Accepted]</h3>\n<p>Instead of searching from an empty room to the gates, how about searching the other way round? In other words, we initiate breadth-first search (BFS) from all gates at the same time. Since BFS guarantees that we search all rooms of distance <em>d</em> before searching rooms of distance <em>d</em> + 1, the distance to an empty room must be the shortest.</p>\n<pre><code>private static final int EMPTY = Integer.MAX_VALUE;\nprivate static final int GATE = 0;\nprivate static final List&lt;int[]&gt; DIRECTIONS = Arrays.asList(\n        new int[] { 1,  0},\n        new int[] {-1,  0},\n        new int[] { 0,  1},\n        new int[] { 0, -1}\n);\n​\npublic void wallsAndGates(int[][] rooms) {\n    int m = rooms.length;\n    if (m == 0) return;\n    int n = rooms[0].length;\n    Queue&lt;int[]&gt; q = new LinkedList&lt;&gt;();\n    for (int row = 0; row &lt; m; row++) {\n        for (int col = 0; col &lt; n; col++) {\n            if (rooms[row][col] == GATE) {\n                q.add(new int[] { row, col });\n            }\n        }\n    }\n    while (!q.isEmpty()) {\n        int[] point = q.poll();\n        int row = point[0];\n        int col = point[1];\n        for (int[] direction : DIRECTIONS) {\n            int r = row + direction[0];\n            int c = col + direction[1];\n            if (r &lt; 0 || c &lt; 0 || r &gt;= m || c &gt;= n || rooms[r][c] != EMPTY) {\n                continue;\n            }\n            rooms[r][c] = rooms[row][col] + 1;\n            q.add(new int[] { r, c });\n        }\n    }\n}</code></pre>\n<p><strong>Complexity analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : O(mn).</p>\n<p>If you are having difficulty to derive the time complexity, start simple.</p>\n<p>Let us start with the case with only one gate. The breadth-first search takes at most m×n steps to reach all rooms, therefore the time complexity is O(mn). But what if you are doing breadth-first search from k gates?</p>\n<p>Once we set a room's distance, we are basically marking it as visited, which means each room is visited at most once. Therefore, the time complexity does not depend on the number of gates and is O(mn).</p>\n</li>\n<li>\n<p>Space complexity : O(mn).<br/>\nThe space complexity depends on the queue's size. We insert at most m×n points into the queue.</p>\n</li>\n</ul>"}