{"id":"65","title":"Valid Number","difficulty":"Hard","content":"<p>Given a string <code>s</code>, return whether <code>s</code> is a <strong>valid number</strong>.<br />\n<br />\nFor example, all the following are valid numbers: <code>&quot;2&quot;, &quot;0089&quot;, &quot;-0.1&quot;, &quot;+3.14&quot;, &quot;4.&quot;, &quot;-.9&quot;, &quot;2e10&quot;, &quot;-90E3&quot;, &quot;3e+7&quot;, &quot;+6e-1&quot;, &quot;53.5e93&quot;, &quot;-123.456e789&quot;</code>, while the following are not valid numbers: <code>&quot;abc&quot;, &quot;1a&quot;, &quot;1e&quot;, &quot;e3&quot;, &quot;99e2.5&quot;, &quot;--6&quot;, &quot;-+3&quot;, &quot;95a54e53&quot;</code>.</p>\n\n<p>Formally, a&nbsp;<strong>valid number</strong> is defined using one of the following definitions:</p>\n\n<ol>\n\t<li>An <strong>integer number</strong> followed by an <strong>optional exponent</strong>.</li>\n\t<li>A <strong>decimal number</strong> followed by an <strong>optional exponent</strong>.</li>\n</ol>\n\n<p>An <strong>integer number</strong> is defined with an <strong>optional sign</strong> <code>&#39;-&#39;</code> or <code>&#39;+&#39;</code> followed by <strong>digits</strong>.</p>\n\n<p>A <strong>decimal number</strong> is defined with an <strong>optional sign</strong> <code>&#39;-&#39;</code> or <code>&#39;+&#39;</code> followed by one of the following definitions:</p>\n\n<ol>\n\t<li><strong>Digits</strong> followed by a <strong>dot</strong> <code>&#39;.&#39;</code>.</li>\n\t<li><strong>Digits</strong> followed by a <strong>dot</strong> <code>&#39;.&#39;</code> followed by <strong>digits</strong>.</li>\n\t<li>A <strong>dot</strong> <code>&#39;.&#39;</code> followed by <strong>digits</strong>.</li>\n</ol>\n\n<p>An <strong>exponent</strong> is defined with an <strong>exponent notation</strong> <code>&#39;e&#39;</code> or <code>&#39;E&#39;</code> followed by an <strong>integer number</strong>.</p>\n\n<p>The <strong>digits</strong> are defined as one or more digits.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">s = &quot;0&quot;</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">true</span></p>\n</div>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">s = &quot;e&quot;</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">false</span></p>\n</div>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">s = &quot;.&quot;</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">false</span></p>\n</div>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 20</code></li>\n\t<li><code>s</code> consists of only English letters (both uppercase and lowercase), digits (<code>0-9</code>), plus <code>&#39;+&#39;</code>, minus <code>&#39;-&#39;</code>, or dot <code>&#39;.&#39;</code>.</li>\n</ul>\n","tags":["String"],"java_snippet":"class Solution {\n    public boolean isNumber(String s) {\n        \n    }\n}","solution":"<div class=\"flex flex-col w-full\" style=\"position: relative;\"><div class=\"mYe_l WRmCx\"><h2 class=\"group/heading relative\" id=\"solution\" level=\"2\"><a aria-hidden=\"true\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" href=\"#solution\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" data-icon=\"link\" data-prefix=\"fas\" focusable=\"false\" role=\"img\" spacing=\"square\" viewbox=\"0 0 640 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\" fill=\"currentColor\"></path></svg></div></a>Solution</h2>\n<hr/>\n<h3 class=\"group/heading relative\" id=\"overview\" level=\"3\"><a aria-hidden=\"true\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" href=\"#overview\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" data-icon=\"link\" data-prefix=\"fas\" focusable=\"false\" role=\"img\" spacing=\"square\" viewbox=\"0 0 640 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\" fill=\"currentColor\"></path></svg></div></a>Overview</h3>\n<p>You're browsing through LeetCode's problems and notice a problem marked as hard with a 16% acceptance rate, the lowest you've ever seen. What could it be? 4D Dynamic Programming + binary search? An esoteric graph algorithm with a name you can't pronounce?</p>\n<p>Actually, it's \"determine if a string is a number\". What gives? In my opinion, the reason this problem is so \"difficult\" isn't necessarily because it is <strong>super</strong> hard. I think it's just really hard to approach the problem in a way that covers <em>all</em> possible edge cases - something this problem definitely does not lack. Additionally, this is not your typical LeetCode problem, but a problem that is highly representative of a \"real world\" problem - a seemingly simple task that is frustratingly full of edge cases.</p>\n<p>Don't feel discouraged if you're struggling with this problem. When we solve a lot of problems, we discover common patterns, algorithms, and neat tricks that stick with us. We can then apply this knowledge to solve similar problems in the future. The issue with this problem is that there isn't really any other problem on LeetCode that prepares you for it. The key to solving this problem is to carefully read the problem statement, think about edge cases, and keep your code <em><strong>simple</strong></em>.</p>\n<blockquote>\n<p><strong>Interview Tip:</strong> Asked a question like this in an interview? Be sure to communicate thoroughly with your interviewer to make sure you're covering all cases.</p>\n</blockquote>\n<br/>\n<hr/>\n<h3 class=\"group/heading relative\" id=\"approach-1-follow-the-rules\" level=\"3\"><a aria-hidden=\"true\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" href=\"#approach-1-follow-the-rules\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" data-icon=\"link\" data-prefix=\"fas\" focusable=\"false\" role=\"img\" spacing=\"square\" viewbox=\"0 0 640 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\" fill=\"currentColor\"></path></svg></div></a>Approach 1: Follow The Rules!</h3>\n<p><strong>Intuition</strong></p>\n<p>The problem statement outlines a very specific set of rules. Let's put all possible characters into groups, and then create a set of rules for each group. Then, we can iterate through the input and evaluate if the characters are following the rules or not.</p>\n<p>What are all of the possible character groups, and what can we say about them? Reading through the problem statement <strong>very carefully</strong>, we can ascertain:</p>\n<ol>\n<li data-length=\"1\">\n<p>Digits (one of <code>[\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]</code>)</p>\n<ul>\n<li>Both <strong>decimal numbers</strong> and <strong>integers</strong> must contain at least one digit.</li>\n</ul>\n</li>\n<li data-length=\"1\">\n<p>A sign (<code>\"+\"</code> or <code>\"-\"</code>)</p>\n<ul>\n<li>Sign characters are optional for both <strong>decimal numbers</strong> and <strong>integers</strong>, but if one is present, it will always be the first character. Note, this means that a sign character can also appear immediately after an exponent.</li>\n</ul>\n</li>\n<li data-length=\"1\">\n<p>An exponent (<code>\"e\"</code> or <code>\"E\"</code>)</p>\n<ul>\n<li>Exponents are also optional, but if the string contains one then it must be after a <strong>decimal number</strong> or an <strong>integer</strong>.</li>\n<li>An <strong>integer</strong> must follow the exponent.</li>\n</ul>\n</li>\n<li data-length=\"1\">\n<p>A dot (<code>\".\"</code>)</p>\n<ul>\n<li>A <strong>decimal number</strong> should only contain one dot. <strong>Integers</strong> cannot contain dots.</li>\n</ul>\n</li>\n<li data-length=\"1\">\n<p>Anything else</p>\n<ul>\n<li>There will never be anything else in a <em>valid number</em>.</li>\n</ul>\n</li>\n</ol>\n<p>From these facts, we can logically determine a set of rules to follow in our algorithm.</p>\n<p><strong>Rules</strong></p>\n<ol>\n<li data-length=\"1\">\n<p>Digits</p>\n<ul>\n<li>First of all, there must always be at least one digit in the input for it to form a valid number. Let's use a variable <code>seenDigit</code> to indicate whether we have seen a digit yet.</li>\n</ul>\n</li>\n<li data-length=\"1\">\n<p>Signs</p>\n<ul>\n<li>If a sign is present, it must be the first character in a <strong>decimal number</strong> or <strong>integer</strong>. In a valid number, there are two possible locations for these signs - at the front of the number, or right after an exponent (<code>\"e\"</code> or <code>\"E\"</code>) e.g., <code>-63e+7</code>. Therefore, if we see a sign, and it is not the first character of the input, and does not come immediately after an exponent (<code>\"e\"</code> or <code>\"E\"</code>), then we know the number is not valid.</li>\n</ul>\n</li>\n<li data-length=\"1\">\n<p>Exponents (<code>\"e\"</code> or <code>\"E\"</code>)</p>\n<ul>\n<li>There cannot be more than one exponent in a <em>valid number</em>, so we will use a variable <code>seenExponent</code> to indicate whether we have already seen an exponent.</li>\n<li>An exponent must appear after a <strong>decimal number</strong> or an <strong>integer</strong>. This means if we see an exponent, we must have already seen a digit.</li>\n</ul>\n</li>\n<li data-length=\"1\">\n<p>Dots</p>\n<ul>\n<li>There cannot be more than one dot in a <em>valid number</em>, since only <strong>integers</strong> are allowed after an exponent, so there cannot be more than one <strong>decimal number</strong>. We will use a variable <code>seenDot</code> to indicate whether we have seen a dot.</li>\n<li>If we see a dot appear after an exponent, the number is not valid, because <strong>integers</strong> cannot have dots.</li>\n</ul>\n</li>\n<li data-length=\"1\">\n<p>Anything else</p>\n<ul>\n<li>Seeing anything else instantly invalidates the input.</li>\n</ul>\n</li>\n</ol>\n<p><strong>Algorithm</strong></p>\n<p>Now that we have laid out the rules, let's iterate over the input. For each character, determine what group it belongs to, and verify that it follows the rules.</p>\n<ol>\n<li data-length=\"1\">\n<p>Declare 3 variables <code>seenDigit</code>, <code>seenExponent</code>, and <code>seenDot</code>. Set all of them to <code>false</code>.</p>\n</li>\n<li data-length=\"1\">\n<p>Iterate over the input.</p>\n</li>\n<li data-length=\"1\">\n<p>If the character is a digit, set <code>seenDigit = true</code>.</p>\n</li>\n<li data-length=\"1\">\n<p>If the character is a sign, check if it is either the first character of the input, or if the character before it is an exponent. If not, <code>return false</code>.</p>\n</li>\n<li data-length=\"1\">\n<p>If the character is an exponent, first check if we have already seen an exponent <strong>or</strong> if we have not yet seen a digit. If either is true, then <code>return false</code>. Otherwise, set <code>seenExponent = true</code>, and <code>seenDigit = false</code>. We need to reset <code>seenDigit</code> because after an exponent, we must construct a new <strong>integer</strong>.</p>\n</li>\n<li data-length=\"1\">\n<p>If the character is a dot, first check if we have already seen either a dot or an exponent. If so, <code>return false</code>. Otherwise, set <code>seenDot = true</code>.</p>\n</li>\n<li data-length=\"1\">\n<p>If the character is anything else, <code>return false</code>.</p>\n</li>\n<li data-length=\"1\">\n<p>At the end, return <code>seenDigit</code>. This is one reason why we have to reset <code>seenDigit</code> after seeing an exponent - otherwise an input like <code>\"21e\"</code> would be incorrectly judged as valid.</p>\n</li>\n</ol>\n<p><strong>Implementation</strong></p>\n<pre><code>class Solution {\npublic:\n    bool isNumber(string s) {\n        bool seenDigit = false;\n        bool seenExponent = false;\n        bool seenDot = false;\n        for (int i = 0; i &lt; s.length(); i++) {\n            char curr = s[i];\n            if (curr &gt;= '0' &amp;&amp; curr &lt;= '9') {\n                seenDigit = true;\n            } else if (curr == '+' || curr == '-') {\n                if (i &gt; 0 &amp;&amp; s[i - 1] != 'e' &amp;&amp; s[i - 1] != 'E') {\n                    return false;\n                }\n            } else if (curr == 'e' || curr == 'E') {\n                if (seenExponent || !seenDigit) {\n                    return false;\n                }\n                seenExponent = true;\n                seenDigit = false;\n            } else if (curr == '.') {\n                if (seenDot || seenExponent) {\n                    return false;\n                }\n                seenDot = true;\n            } else {\n                return false;\n            }\n        }\n        return seenDigit;\n    }\n};</code></pre>\n<p><em>\"One day I will find the right words, and they will be simple.\"</em> - Jack Kerouac</p>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity: <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span></span>, where <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span></span></span></span></span> is the length of <code>s</code>.</p>\n<p>We simply iterate over the input once. The number of operations we perform for each character in the input is <em>independent</em> of the length of the string, and therefore only requires constant time. This results in <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n</li>\n<li>\n<p>Space complexity: <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n<p>Regardless of the input size, we only store 3 variables, <code>seenDigit</code>, <code>seenExponent</code>, and <code>seenDot</code>.</p>\n</li>\n</ul>\n<br/>\n<hr/>\n<h3 class=\"group/heading relative\" id=\"approach-2-deterministic-finite-automaton-dfa\" level=\"3\"><a aria-hidden=\"true\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" href=\"#approach-2-deterministic-finite-automaton-dfa\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" data-icon=\"link\" data-prefix=\"fas\" focusable=\"false\" role=\"img\" spacing=\"square\" viewbox=\"0 0 640 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\" fill=\"currentColor\"></path></svg></div></a>Approach 2: Deterministic Finite Automaton (DFA)</h3>\n<p><strong>Intuition</strong></p>\n<p>Let's now view Approach 1 from a different angle. There were 3 boolean variables, and they can be either <code>true</code> or <code>false</code>. Each time we read a character in the string, we either stayed in the current state (boolean variables stayed the same) or we <strong>transitioned</strong> into a new state (boolean variables changed).<br/>\nWhat we've described above is a lot like a  <a href=\"https://en.wikipedia.org/wiki/Deterministic_finite_automaton\" target=\"_blank\">deterministic finite automaton</a>. A DFA is a finite number of states with transition rules to move between them. However, keep in mind that the state depends on more than just those 3 boolean variables; it also depends on whether we have encountered a <code>+</code> or <code>-</code>. We will discuss this in more detail later.</p>\n<blockquote>\n<p><strong>Never heard of a DFA before?</strong></p>\n<p>DFA's are useful for solving many problems, including advanced dynamic programming problems such as <a href=\"https://leetcode.com/problems/number-of-ways-to-paint-n-3-grid/\" target=\"_blank\">1411. Number of Ways to Paint N X 3 Grid</a>. So if you're not yet familiar with them, we recommend that you read up on them. It will be worth it!</p>\n<p>DFAs share a lot of similarities with the trie data structure. Recall that a <a href=\"https://leetcode.com/explore/learn/card/trie/\" target=\"_blank\">trie</a> is used to represent a dictionary of words, in a space-efficient manner.  To check whether or not a word is in the dictionary, we would simultaneously traverse through the word and the trie. If we end at a node that is marked as a valid end-point, then we would return true. Otherwise, if we get \"stuck\", or end at a node that is not an end-point, we would return false. It's the same for a DFA: we start at a \"root\" node, and then check each character one by one, checking whether or not there is a valid transition we can make.</p>\n<p>There are a few key differences between DFA's and tries, so keep these in mind while reading through the remainder of this section.</p>\n<ol>\n<li data-length=\"1\">While a trie can only represent a <em>finite</em> number of strings (the given dictionary), a DFA can represent an <em>infinite</em> number of different strings.</li>\n<li data-length=\"1\">While a trie can only move down the implicit tree, a DFA can essentially \"loopback\" to a higher level, or stay on the same level, or even the same node.</li>\n<li data-length=\"1\">A trie is a type of tree, and a DFA is a type of directed graph.</li>\n</ol>\n<p>Other than that, you can lean on your existing knowledge of tries to wrap your head around this new data structure.</p>\n</blockquote>\n<p><strong>Algorithm</strong></p>\n<p>The first step is to design our DFA. Picture the DFA as a directed graph, where each node is a state, and each edge is a transition labeled with a character group (digit, exponent, sign, or dot). There are two key steps to designing it.</p>\n<ol>\n<li data-length=\"1\">Identify all valid combinations that the aforementioned boolean variables can be in. Each combination is a <strong>state</strong>. Draw a circle for each state, and label what it means.</li>\n<li data-length=\"1\">For each <strong>state</strong>, consider what a character from each group would mean in the context of that state. Each group will either cause a <strong>transition</strong> into another state, or it will signify that the string is invalid. For each valid transition, draw a directed arrow between the two states and write the group next to the arrow.</li>\n</ol>\n<blockquote>\n<p><strong>Try this on your own before reading any further!</strong> Take a few minutes and try to design the DFA. Keep in mind that a state can point to itself. For example, with the input <code>\"12345\"</code>, if we were to use the first approach, after the first character, none of the boolean variables change, so the state should not change. Therefore, the node should have an edge that points to itself, labeled by \"digit\". Another hint: the start node should have 3 outgoing edges labeled \"digit\", \"sign\", and \"dot\".</p>\n</blockquote>\n<br/>\n\n<p><br/><br/></p>\n<p>With our constructed DFA, our algorithm will be:</p>\n<ol>\n<li data-length=\"1\">\n<p>Initialize the DFA as an array of hash tables. Each hash table's keys will be a character group, and the values will be the state it should transition to. We can use the indexes of the array to handle state transitions. Set the <code>currentState = 0</code>.</p>\n</li>\n<li data-length=\"1\">\n<p>Iterate through the input. For each character, first determine what group it belongs to. Then, check if that group exists in the current state's hash table. If it does, transition to the next state. Otherwise, return <code>false</code>.</p>\n</li>\n<li data-length=\"1\">\n<p>At the end, check if we are currently in a valid end state: 1, 4, or 7.</p>\n</li>\n</ol>\n<p>If you're having trouble with your implementation, try to go through your DFA with a complicated case such as <code>-123.456E+789</code>. Follow along with your designed DFA, and if there is a bug, check which edge case went wrong and adjust the graph accordingly. Once your DFA is correctly designed, the coding part will be less challenging.</p>\n<p><strong>Implementation</strong></p>\n<pre><code>class Solution {\npublic:\n    bool isNumber(string s) {\n        // This is the DFA we have designed above\n        map&lt;string, int&gt; dfa[8] = {{{\"digit\", 1}, {\"sign\", 2}, {\"dot\", 3}},\n                                   {{\"digit\", 1}, {\"dot\", 4}, {\"exponent\", 5}},\n                                   {{\"digit\", 1}, {\"dot\", 3}},\n                                   {{\"digit\", 4}},\n                                   {{\"digit\", 4}, {\"exponent\", 5}},\n                                   {{\"sign\", 6}, {\"digit\", 7}},\n                                   {{\"digit\", 7}},\n                                   {{\"digit\", 7}}};\n        int current_state = 0;\n        string group;\n        for (char c : s) {\n            if (isdigit(c)) {\n                group = \"digit\";\n            } else if (c == '+' || c == '-') {\n                group = \"sign\";\n            } else if (c == 'e' || c == 'E') {\n                group = \"exponent\";\n            } else if (c == '.') {\n                group = \"dot\";\n            } else {\n                return false;\n            }\n            if (dfa[current_state].find(group) == dfa[current_state].end()) {\n                return false;\n            }\n            current_state = dfa[current_state][group];\n        }\n        return current_state == 1 || current_state == 4 || current_state == 7;\n    }\n};</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity: <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span></span>, where <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span></span></span></span></span> is the length of <code>s</code>.</p>\n<p>We simply iterate through the input once. The number of operations we perform for each character in the input is <em>independent</em> of the length of the string, and therefore each operation requires constant time. So we get <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n</li>\n<li>\n<p>Space complexity: <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n<p>We will construct the same DFA regardless of the input size.</p>\n</li>\n</ul>\n<br/>\n<hr/></div><span style=\"font-size: 0px; line-height: 0;\"> </span></div>"}