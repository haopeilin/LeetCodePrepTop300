{"id":"10","title":"Regular Expression Matching","difficulty":"Hard","content":"<p>Given an input string <code>s</code>&nbsp;and a pattern <code>p</code>, implement regular expression matching with support for <code>&#39;.&#39;</code> and <code>&#39;*&#39;</code> where:</p>\n\n<ul>\n\t<li><code>&#39;.&#39;</code> Matches any single character.​​​​</li>\n\t<li><code>&#39;*&#39;</code> Matches zero or more of the preceding element.</li>\n</ul>\n\n<p>The matching should cover the <strong>entire</strong> input string (not partial).</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;aa&quot;, p = &quot;a&quot;\n<strong>Output:</strong> false\n<strong>Explanation:</strong> &quot;a&quot; does not match the entire string &quot;aa&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;aa&quot;, p = &quot;a*&quot;\n<strong>Output:</strong> true\n<strong>Explanation:</strong> &#39;*&#39; means zero or more of the preceding element, &#39;a&#39;. Therefore, by repeating &#39;a&#39; once, it becomes &quot;aa&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;ab&quot;, p = &quot;.*&quot;\n<strong>Output:</strong> true\n<strong>Explanation:</strong> &quot;.*&quot; means &quot;zero or more (*) of any character (.)&quot;.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length&nbsp;&lt;= 20</code></li>\n\t<li><code>1 &lt;= p.length&nbsp;&lt;= 20</code></li>\n\t<li><code>s</code> contains only lowercase English letters.</li>\n\t<li><code>p</code> contains only lowercase English letters, <code>&#39;.&#39;</code>, and&nbsp;<code>&#39;*&#39;</code>.</li>\n\t<li>It is guaranteed for each appearance of the character <code>&#39;*&#39;</code>, there will be a previous valid character to match.</li>\n</ul>\n","tags":["String","Dynamic Programming","Recursion"],"java_snippet":"class Solution {\n    public boolean isMatch(String s, String p) {\n        \n    }\n}","solution":"<h2><a href=\"#solution\"><svg><path></path></svg></a>Solution</h2>\n<hr/>\n<h3><a href=\"#approach-1-recursion\"><svg><path></path></svg></a>Approach 1: Recursion</h3>\n<p><strong>Intuition</strong></p>\n<p>If there were no Kleene stars (the <code>*</code> wildcard character for regular expressions), the problem would be easier - we simply check from left to right if each character of the text matches the pattern.</p>\n<p>When a star is present, we may need to check many different suffixes of the text and see if they match the rest of the pattern.  A recursive solution is a straightforward way to represent this relationship.</p>\n<p><strong>Algorithm</strong></p>\n<p>Without a Kleene star, our solution would look like this:</p>\n<p>If a star is present in the pattern, it will be in the second position pattern[1].  Then, we may ignore this part of the pattern, or delete a matching character in the text.  If we have a match on the remaining strings after any of these operations, then the initial inputs matched.</p>\n<pre><code>class Solution {\n    public boolean isMatch(String text, String pattern) {\n        if (pattern.isEmpty()) return text.isEmpty();\n        boolean first_match =\n            (!text.isEmpty() &amp;&amp;\n                (pattern.charAt(0) == text.charAt(0) ||\n                    pattern.charAt(0) == '.'));\n​\n        if (pattern.length() &gt;= 2 &amp;&amp; pattern.charAt(1) == '*') {\n            return (\n                isMatch(text, pattern.substring(2)) ||\n                (first_match &amp;&amp; isMatch(text.substring(1), pattern))\n            );\n        } else {\n            return (\n                first_match &amp;&amp; isMatch(text.substring(1), pattern.substring(1))\n            );\n        }\n    }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: Let T,P be the lengths of the text and the pattern respectively.  In the worst case, a call to <code>match(text[i:], pattern[2j:])</code> will be made (ii+j​) times, and strings of the order O(T−i) and O(P−2∗j) will be made.  Thus, the complexity has the order ∑i=0T​∑j=0P/2​(ii+j​)O(T+P−i−2j).  With some effort outside the scope of this article, we can show this is bounded by O((T+P)2T+2P​).</p>\n</li>\n<li>\n<p>Space Complexity:  For every call to <code>match</code>, we will create those strings as described above, possibly creating duplicates.  If memory is not freed, this will also take a total of O((T+P)2T+2P​) space, even though there are only order O(T2+P2) unique suffixes of P and  T that are actually required.</p>\n<br/>\n</li>\n</ul>\n<br/>\n<hr/>\n<h3><a href=\"#approach-2-dynamic-programming\"><svg><path></path></svg></a>Approach 2: Dynamic Programming</h3>\n<p><strong>Intuition</strong></p>\n<p>As the problem has an <strong>optimal substructure</strong>, it is natural to cache intermediate results.  We ask the question dp(i, j): does text[i:] and pattern[j:] match?  We can describe our answer in terms of answers to questions involving smaller strings.</p>\n<p><strong>Algorithm</strong></p>\n<p>We proceed with the same recursion as in <a href=\"#approach-1-recursion\">Approach 1</a>, except because calls will only ever be made to <code>match(text[i:], pattern[j:])</code>, we use dp(i, j) to handle those calls instead, saving us expensive string-building operations and allowing us to cache the intermediate results.</p>\n<p><em>Top-Down Variation</em></p>\n<pre><code>enum Result {\n    TRUE,\n    FALSE,\n}\n​\nclass Solution {\n    Result[][] memo;\n​\n    public boolean isMatch(String text, String pattern) {\n        memo = new Result[text.length() + 1][pattern.length() + 1];\n        return dp(0, 0, text, pattern);\n    }\n​\n    public boolean dp(int i, int j, String text, String pattern) {\n        if (memo[i][j] != null) {\n            return memo[i][j] == Result.TRUE;\n        }\n        boolean ans;\n        if (j == pattern.length()) {\n            ans = i == text.length();\n        } else {\n            boolean first_match =\n                (i &lt; text.length() &amp;&amp;\n                    (pattern.charAt(j) == text.charAt(i) ||\n                        pattern.charAt(j) == '.'));\n​\n            if (j + 1 &lt; pattern.length() &amp;&amp; pattern.charAt(j + 1) == '*') {\n                ans = (dp(i, j + 2, text, pattern) ||\n                    (first_match &amp;&amp; dp(i + 1, j, text, pattern)));\n            } else {\n                ans = first_match &amp;&amp; dp(i + 1, j + 1, text, pattern);\n            }\n        }\n        memo[i][j] = ans ? Result.TRUE : Result.FALSE;\n        return ans;\n    }\n}</code></pre>\n<p><em>Bottom-Up Variation</em></p>\n<pre><code>class Solution {\n    public boolean isMatch(String text, String pattern) {\n        boolean[][] dp = new boolean[text.length() + 1][pattern.length() + 1];\n        dp[text.length()][pattern.length()] = true;\n​\n        for (int i = text.length(); i &gt;= 0; i--) {\n            for (int j = pattern.length() - 1; j &gt;= 0; j--) {\n                boolean first_match =\n                    (i &lt; text.length() &amp;&amp;\n                        (pattern.charAt(j) == text.charAt(i) ||\n                            pattern.charAt(j) == '.'));\n                if (j + 1 &lt; pattern.length() &amp;&amp; pattern.charAt(j + 1) == '*') {\n                    dp[i][j] = dp[i][j + 2] || (first_match &amp;&amp; dp[i + 1][j]);\n                } else {\n                    dp[i][j] = first_match &amp;&amp; dp[i + 1][j + 1];\n                }\n            }\n        }\n        return dp[0][0];\n    }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: Let T,P be the lengths of the text and the pattern respectively.  The work for every call to <code>dp(i, j)</code> for i=0,...,T; j=0,...,P is done once, and it is O(1) work.  Hence, the time complexity is O(TP).</p>\n</li>\n<li>\n<p>Space Complexity:  The only memory we use is the O(TP) boolean entries in our cache.  Hence, the space complexity is O(TP).</p>\n</li>\n</ul>"}