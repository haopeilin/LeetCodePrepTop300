{"id":"199","title":"Binary Tree Right Side View","difficulty":"Medium","content":"<p>Given the <code>root</code> of a binary tree, imagine yourself standing on the <strong>right side</strong> of it, return <em>the values of the nodes you can see ordered from top to bottom</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">root = [1,2,3,null,5,null,4]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">[1,3,4]</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2024/11/24/tmpd5jn43fs-1.png\" style=\"width: 400px; height: 207px;\" /></p>\n</div>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">root = [1,2,3,4,null,null,null,5]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">[1,3,4,5]</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2024/11/24/tmpkpe40xeh-1.png\" style=\"width: 400px; height: 214px;\" /></p>\n</div>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">root = [1,null,3]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">[1,3]</span></p>\n</div>\n\n<p><strong class=\"example\">Example 4:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">root = []</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">[]</span></p>\n</div>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 100]</code>.</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n","tags":["Tree","Depth-First Search","Breadth-First Search","Binary Tree"],"java_snippet":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public List<Integer> rightSideView(TreeNode root) {\n        \n    }\n}","solution":"<div class=\"flex flex-col w-full\" style=\"position: relative;\"><div class=\"mYe_l WRmCx\">\n<h2 class=\"group/heading relative\" id=\"solution\" level=\"2\"><a aria-hidden=\"true\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" href=\"#solution\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" data-icon=\"link\" data-prefix=\"fas\" focusable=\"false\" role=\"img\" spacing=\"square\" viewbox=\"0 0 640 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\" fill=\"currentColor\"></path></svg></div></a>Solution</h2>\n<hr/>\n<h3 class=\"group/heading relative\" id=\"overview\" level=\"3\"><a aria-hidden=\"true\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" href=\"#overview\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" data-icon=\"link\" data-prefix=\"fas\" focusable=\"false\" role=\"img\" spacing=\"square\" viewbox=\"0 0 640 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\" fill=\"currentColor\"></path></svg></div></a>Overview</h3>\n<p><strong>DFS vs. BFS</strong></p>\n<p>There are two ways to traverse the tree: DFS <em>depth first search</em> and BFS <em>breadth first search</em>. Here is a small summary</p>\n<p></p>\n<p>BFS traverses level by level, and DFS first goes to the leaves.</p>\n<p></p>\n<blockquote>\n<p>Which approach to choose, BFS or DFS?</p>\n</blockquote>\n<ul>\n<li>\n<p>The problem is to return a list of the last elements from all levels, so it's way more natural to implement BFS here.</p>\n</li>\n<li>\n<p>Time complexity is the same <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathcal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span></span> both for DFS and BFS since one has to visit all nodes.</p>\n</li>\n<li>\n<p>Space complexity is <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathcal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right: 0.08125em;\">H</span><span class=\"mclose\">)</span></span></span></span></span> for DFS and <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathcal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">D</span><span class=\"mclose\">)</span></span></span></span></span> for BFS, where <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.08125em;\">H</span></span></span></span></span> is a tree height, and <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">D</span></span></span></span></span> is a tree diameter. They both result in <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathcal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span></span> space in the worst-case scenarios: skewed tree for DFS and complete tree for BFS.</p>\n</li>\n</ul>\n<p>BFS wins for this problem, so let's use the opportunity to check out three different BFS implementations with the queue.</p>\n<p><strong>BFS implementation</strong></p>\n<p>All three implementations use the queue in a standard BFS way:</p>\n<ul>\n<li>\n<p>Push the root into the queue.</p>\n</li>\n<li>\n<p>Pop-out a node from the <em>left</em>.</p>\n</li>\n<li>\n<p>Push the <em>left</em> child into the queue, and then push the <em>right</em> child.</p>\n</li>\n</ul>\n<p></p>\n<p><strong>Three BFS approaches</strong></p>\n<p>The difference is how to find the end of the level, i.e. the rightmost element:</p>\n<ul>\n<li>\n<p>Two queues, one for the previous level and one for the current.</p>\n</li>\n<li>\n<p>One queue with a sentinel to mark the end of the level.</p>\n</li>\n<li>\n<p>One queue + level size measurement.</p>\n</li>\n</ul>\n<br/>\n<br/>\n<hr/>\n<h3 class=\"group/heading relative\" id=\"approach-1-bfs-two-queues\" level=\"3\"><a aria-hidden=\"true\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" href=\"#approach-1-bfs-two-queues\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" data-icon=\"link\" data-prefix=\"fas\" focusable=\"false\" role=\"img\" spacing=\"square\" viewbox=\"0 0 640 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\" fill=\"currentColor\"></path></svg></div></a>Approach 1: BFS: Two Queues</h3>\n<p>Let's use two queues: one for the current level, and one for the next. The idea is to pop the nodes one by one from the current level and push their children into the next level queue. Each time the current queue is empty, we have the right side element in our hands.</p>\n<p></p>\n<p><strong>Algorithm</strong></p>\n<ul>\n<li>\n<p>Initiate the list of the right side view <code>rightside</code>.</p>\n</li>\n<li>\n<p>Initiate two queues: one for the current level, and one for the next. Add root into <code>nextLevel</code> queue.</p>\n</li>\n<li>\n<p>While <code>nextLevel</code> queue is not empty:</p>\n<ul>\n<li>\n<p>Initiate the current level: <code>currLevel = nextLevel</code>, and empty the next level <code>nextLevel</code>.</p>\n</li>\n<li>\n<p>While the current level queue is not empty:</p>\n<ul>\n<li>\n<p>Pop out a node from the current level queue.</p>\n</li>\n<li>\n<p>Add first <em>left</em> and then <em>right</em> child node into <code>nextLevel</code> queue.</p>\n</li>\n</ul>\n</li>\n<li>\n<p>Now <code>currLevel</code> is empty, and the node we have in hands is the last one, and makes a part of the right side view. Add it into <code>rightside</code>.</p>\n</li>\n</ul>\n</li>\n<li>\n<p>Return <code>rightside</code>.</p>\n</li>\n</ul>\n<p><strong>Implementation</strong></p>\n<pre><code>class Solution {\npublic:\n    vector&lt;int&gt; rightSideView(TreeNode* root) {\n        if (root == nullptr) return vector&lt;int&gt;();\n​\n        deque&lt;TreeNode*&gt; nextLevel{root};\n        deque&lt;TreeNode*&gt; currLevel;\n        vector&lt;int&gt; rightside;\n​\n        TreeNode* node = nullptr;\n        while (!nextLevel.empty()) {\n            currLevel = nextLevel;\n            nextLevel.clear();\n​\n            while (!currLevel.empty()) {\n                node = currLevel.front();\n                currLevel.pop_front();\n​\n                if (node-&gt;left != nullptr) nextLevel.push_back(node-&gt;left);\n                if (node-&gt;right != nullptr) nextLevel.push_back(node-&gt;right);\n            }\n​\n            rightside.push_back(node-&gt;val);\n        }\n        return rightside;\n    }\n};</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity: <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathcal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span></span> since one has to visit each node.</p>\n</li>\n<li>\n<p>Space complexity: <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathcal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">D</span><span class=\"mclose\">)</span></span></span></span></span> to keep the queues, where <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">D</span></span></span></span></span> is a tree diameter. Let's use the last level to estimate the queue size. This level could contain up to <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span><span class=\"mord\">/2</span></span></span></span></span> tree nodes in the case of <a href=\"https://leetcode.com/problems/count-complete-tree-nodes/\" target=\"_blank\">complete binary tree</a>.</p>\n<br/>\n</li>\n</ul>\n<br/>\n<hr/>\n<h3 class=\"group/heading relative\" id=\"approach-2-bfs-one-queue--sentinel\" level=\"3\"><a aria-hidden=\"true\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" href=\"#approach-2-bfs-one-queue--sentinel\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" data-icon=\"link\" data-prefix=\"fas\" focusable=\"false\" role=\"img\" spacing=\"square\" viewbox=\"0 0 640 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\" fill=\"currentColor\"></path></svg></div></a>Approach 2: BFS: One Queue + Sentinel</h3>\n<p>Another approach is to push all the nodes in one queue and to use a <a href=\"https://en.wikipedia.org/wiki/Sentinel_node\" target=\"_blank\">sentinel node</a> to separate the levels. Typically, one could use <code>null</code> as a sentinel.</p>\n<p></p>\n<p>The first step is to initiate the first level: <code>root</code> + <code>null</code> as a sentinel. Once it's done, continue to pop the nodes one by one from the left and push their children to the right. Stop each time the current node is <code>null</code> because it means we hit the end of the current level. Each stop is a time to update a right-side view list and to push <code>null</code> in the queue to mark the end of the next level.</p>\n<p><strong>Algorithm</strong></p>\n<ul>\n<li>\n<p>Initiate the list of the right side view <code>rightside</code>.</p>\n</li>\n<li>\n<p>Initiate the queue by adding a root. Add <code>null</code> sentinel to mark the end of the first level.</p>\n</li>\n<li>\n<p>Initiate the current node as <code>root</code>.</p>\n</li>\n<li>\n<p>While the queue is not empty:</p>\n<ul>\n<li>\n<p>Save the previous node <code>prev = curr</code> and pop the current node from the queue <code>curr = queue.poll()</code>.</p>\n</li>\n<li>\n<p>While the current node is not <code>null</code>:</p>\n<ul>\n<li>\n<p>Add first <em>left</em> and then <em>right</em> child node into the queue.</p>\n</li>\n<li>\n<p>Update both previous and current nodes: <code>prev = curr</code>, <code>curr = queue.poll()</code>.</p>\n</li>\n</ul>\n</li>\n<li>\n<p>Now the current node is null, <em>i.e.</em> we reached the end of the current level. Hence the previous node is the rightmost one and makes a part of the right side view. Add it into <code>rightside</code>.</p>\n</li>\n<li>\n<p>If the queue is not empty, push the null node as a sentinel, to mark the end of the next level.</p>\n</li>\n</ul>\n</li>\n<li>\n<p>Return <code>rightside</code>.</p>\n</li>\n</ul>\n<p><strong>Implementation</strong></p>\n<p>Note, that <code>ArrayDeque</code> in Java doesn't support null elements, and hence the data structure to use here is <code>LinkedList</code>.</p>\n<pre><code>class Solution {\npublic:\n    vector&lt;int&gt; rightSideView(TreeNode* root) {\n        if (root == NULL) return vector&lt;int&gt;();\n​\n        queue&lt;TreeNode*&gt; queue;\n        queue.push(root);\n        queue.push(NULL);\n        TreeNode *prev, *curr = root;\n        vector&lt;int&gt; rightside;\n​\n        while (!queue.empty()) {\n            prev = curr;\n            curr = queue.front();\n            queue.pop();\n​\n            while (curr != NULL) {\n                // add child nodes in the queue\n                if (curr-&gt;left != NULL) {\n                    queue.push(curr-&gt;left);\n                }\n                if (curr-&gt;right != NULL) {\n                    queue.push(curr-&gt;right);\n                }\n​\n                prev = curr;\n                curr = queue.front();\n                queue.pop();\n            }\n​\n            // the current level is finished\n            // and prev is its rightmost element\n            rightside.push_back(prev-&gt;val);\n​\n            // add a sentinel to mark the end\n            // of the next level\n            if (!queue.empty()) queue.push(NULL);\n        }\n        return rightside;\n    }\n};</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity: <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathcal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span></span> since one has to visit each node.</p>\n</li>\n<li>\n<p>Space complexity: <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathcal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">D</span><span class=\"mclose\">)</span></span></span></span></span> to keep the queues, where <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">D</span></span></span></span></span> is a tree diameter. Let's use the last level to estimate the queue size. This level could contain up to <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span><span class=\"mord\">/2</span></span></span></span></span> tree nodes in the case of <a href=\"https://leetcode.com/problems/count-complete-tree-nodes/\" target=\"_blank\">complete binary tree</a>.</p>\n<br/>\n</li>\n</ul>\n<br/>\n<hr/>\n<h3 class=\"group/heading relative\" id=\"approach-3-bfs-one-queue--level-size-measurements\" level=\"3\"><a aria-hidden=\"true\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" href=\"#approach-3-bfs-one-queue--level-size-measurements\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" data-icon=\"link\" data-prefix=\"fas\" focusable=\"false\" role=\"img\" spacing=\"square\" viewbox=\"0 0 640 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\" fill=\"currentColor\"></path></svg></div></a>Approach 3: BFS: One Queue + Level Size Measurements</h3>\n<p>Instead of using the sentinel, we could write down the length of the current level.</p>\n<p></p>\n<p><strong>Algorithm</strong></p>\n<ul>\n<li>\n<p>Initiate the list of the right side view <code>rightside</code>.</p>\n</li>\n<li>\n<p>Initiate the queue by adding a root.</p>\n</li>\n<li>\n<p>While the queue is not empty:</p>\n<ul>\n<li>\n<p>Write down the length of the current level: <code>levelLength = queue.size()</code>.</p>\n</li>\n<li>\n<p>Iterate over <code>i</code> from <code>0</code> to <code>level_length - 1</code>:</p>\n<ul>\n<li>\n<p>Pop the current node from the queue: <code>node = queue.poll()</code>.</p>\n</li>\n<li>\n<p>If <code>i == levelLength - 1</code>, then it's the last node in the current level, push it to <code>rightsize</code> list.</p>\n</li>\n<li>\n<p>Add first <em>left</em> and then <em>right</em> child node into the queue.</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>Return <code>rightside</code>.</p>\n</li>\n</ul>\n<p><strong>Implementation</strong></p>\n<pre><code>class Solution {\npublic:\n    vector&lt;int&gt; rightSideView(TreeNode* root) {\n        if (root == nullptr) return {};\n​\n        deque&lt;TreeNode*&gt; queue;\n        queue.push_back(root);\n        vector&lt;int&gt; rightside;\n​\n        while (!queue.empty()) {\n            int levelLength = queue.size();\n​\n            for (int i = 0; i &lt; levelLength; ++i) {\n                TreeNode* node = queue.front();\n                queue.pop_front();\n​\n                // if it's the rightmost element\n                if (i == levelLength - 1) {\n                    rightside.push_back(node-&gt;val);\n                }\n​\n                // add child nodes in the queue\n                if (node-&gt;left != nullptr) {\n                    queue.push_back(node-&gt;left);\n                }\n                if (node-&gt;right != nullptr) {\n                    queue.push_back(node-&gt;right);\n                }\n            }\n        }\n        return rightside;\n    }\n};</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity: <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathcal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span></span> since one has to visit each node.</p>\n</li>\n<li>\n<p>Space complexity: <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathcal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">D</span><span class=\"mclose\">)</span></span></span></span></span> to keep the queues, where <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">D</span></span></span></span></span> is a tree diameter. Let's use the last level to estimate the queue size. This level could contain up to <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span><span class=\"mord\">/2</span></span></span></span></span> tree nodes in the case of <a href=\"https://leetcode.com/problems/count-complete-tree-nodes/\" target=\"_blank\">complete binary tree</a>.</p>\n<br/>\n</li>\n</ul>\n<br/>\n<hr/>\n<h3 class=\"group/heading relative\" id=\"approach-4-recursive-dfs\" level=\"3\"><a aria-hidden=\"true\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" href=\"#approach-4-recursive-dfs\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" data-icon=\"link\" data-prefix=\"fas\" focusable=\"false\" role=\"img\" spacing=\"square\" viewbox=\"0 0 640 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\" fill=\"currentColor\"></path></svg></div></a>Approach 4: Recursive DFS</h3>\n<p>Everyone likes recursive DFS, so let's add it here as well. The idea is simple: to traverse the tree level by level, starting each time from the rightmost child.</p>\n<p><strong>Implementation</strong></p>\n<pre><code>class Solution {\npublic:\n    vector&lt;int&gt; rightside;\n​\n    void helper(TreeNode* node, int level) {\n        if (level == rightside.size()) rightside.push_back(node-&gt;val);\n​\n        if (node-&gt;right != nullptr) helper(node-&gt;right, level + 1);\n        if (node-&gt;left != nullptr) helper(node-&gt;left, level + 1);\n    }\n​\n    vector&lt;int&gt; rightSideView(TreeNode* root) {\n        if (root == nullptr) return rightside;\n​\n        helper(root, 0);\n        return rightside;\n    }\n};</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity: <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathcal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span></span> since one has to visit each node.</p>\n</li>\n<li>\n<p>Space complexity: <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathcal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right: 0.08125em;\">H</span><span class=\"mclose\">)</span></span></span></span></span> to keep the recursion stack, where <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.08125em;\">H</span></span></span></span></span> is a tree height. The worst-case situation is a skewed tree when <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.08125em;\">H</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span></span></span></span></span>.</p>\n</li>\n</ul></div><span style=\"font-size: 0px; line-height: 0;\"> </span></div>"}