{"id":"45","title":"Jump Game II","difficulty":"Medium","content":"<p>You are given a <strong>0-indexed</strong> array of integers <code>nums</code> of length <code>n</code>. You are initially positioned at&nbsp;index 0.</p>\n\n<p>Each element <code>nums[i]</code> represents the maximum length of a forward jump from index <code>i</code>. In other words, if you are at index <code>i</code>, you can jump to any index <code>(i + j)</code>&nbsp;where:</p>\n\n<ul>\n\t<li><code>0 &lt;= j &lt;= nums[i]</code> and</li>\n\t<li><code>i + j &lt; n</code></li>\n</ul>\n\n<p>Return <em>the minimum number of jumps to reach index </em><code>n - 1</code>. The test cases are generated such that you can reach index&nbsp;<code>n - 1</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,3,1,1,4]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,3,0,1,4]\n<strong>Output:</strong> 2\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li>It&#39;s guaranteed that you can reach <code>nums[n - 1]</code>.</li>\n</ul>\n","tags":["Array","Dynamic Programming","Greedy"],"java_snippet":"class Solution {\n    public int jump(int[] nums) {\n        \n    }\n}","solution":"<div class=\"flex flex-col w-full\" style=\"position: relative;\"><div class=\"mYe_l WRmCx\"><h2 class=\"group/heading relative\" id=\"solution\" level=\"2\"><a aria-hidden=\"true\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" href=\"#solution\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" data-icon=\"link\" data-prefix=\"fas\" focusable=\"false\" role=\"img\" spacing=\"square\" viewbox=\"0 0 640 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\" fill=\"currentColor\"></path></svg></div></a>Solution</h2>\n<hr/>\n<h3 class=\"group/heading relative\" id=\"approach-1-greedy\" level=\"3\"><a aria-hidden=\"true\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" href=\"#approach-1-greedy\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" data-icon=\"link\" data-prefix=\"fas\" focusable=\"false\" role=\"img\" spacing=\"square\" viewbox=\"0 0 640 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\" fill=\"currentColor\"></path></svg></div></a>Approach 1: Greedy</h3>\n<h4 id=\"intuition\">Intuition</h4>\n<p>Let's say that we're at the <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.8491em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">i</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.8491em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">t</span><span class=\"mord mathnormal mtight\">h</span></span></span></span></span></span></span></span></span></span></span></span></span> jump which has a value of <code>3</code>, so we have 3 possible destinations for this jump, and the value of the destinations are <code>3</code>, <code>5</code>, and <code>2</code>. All the indexes covered by these ranges are the <strong>reachable indexes</strong> after this jump, as the green cells show in the picture below.</p>\n<p></p>\n<p>If we move on to the jump <code>i + 1</code>, the choices of starting indices for jump <code>i + 1</code> is exactly the reachable indexes of the jump <code>i</code>.</p>\n<p>We can go on and draw the starting range of the jump <code>i + 1</code> and so on, the starting index of each jump is shown in the following picture. With the increase in the number of jumps, our forward distance is also increasing, the first jump that brings us to the last cell is the jump we should choose. It is a workable method, but what is the time complexity?</p>\n<p></p>\n<p>Since we are guaranteed to reach the last index, the starting range of each jump is always larger than its previous jump (otherwise, we would be stuck at a jump forever). Given the length of <code>nums</code> as <code>n</code>, in the worst case, we may have <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></span> jumps and <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1.0641em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.8141em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span> total updates, which is shown by the area of the blue part of the figure below. Considering the maximum size of the input array, an approach with <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1.0641em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.8141em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span> time complexity is likely to end up with Time Limit Exceeded!</p>\n<p></p>\n<p>Let's try an advanced approach to reduce the time complexity. Unlike the previous idea, we don't need to consider all of the updates. Take the first jump at index <code>0</code> for example, suppose the starting indexes of jump <code>0</code> are in the range <code>[0, 2]</code>. When looking for the starting indexes of the next jump, do we still consider the range <code>[0, 2]</code>? The answer is NO!</p>\n<p>We want to reach the ending position by using the least number of jumps possible, so there is no reason in reaching an index using more jumps. Therefore, we shall take a greedy approach that tries to reach each index using the least number of jumps and ignore updates that are destined to end in more jumps.</p>\n<p>Now back to the example, even if we can move to <code>[0, 2]</code> in jump <code>1</code>, we would not consider doing so since we already covered that range with jump <code>0</code>. So the valid range of reachable indexes for jump <code>1</code> is <code>[3, 4]</code> instead of <code>[0, 4]</code>.</p>\n<p></p>\n<p>In short, if we can reach an index using <code>j</code> jumps, we will never consider reaching it using more than <code>j</code> jumps. So the updates marked in red will never be considered, because they represent reaching an index with more jumps.</p>\n<p></p>\n<p>We need two auxiliary marks to help delimit ranges and to avoid repeated visits to the same range:</p>\n<ul>\n<li>\n<p><code>end</code> is the <strong>furthest starting index</strong> of the current jump.</p>\n</li>\n<li>\n<p><code>far</code> is the <strong>furthest reachable index</strong> of the current jump.</p>\n</li>\n</ul>\n<p>Once we have finished iterating over the range of the current jump (we reach index <code>end</code>), the next step is to continue iterating over the reachable indexes that are <strong>larger</strong> than <code>end</code>, which is represented by the range <code>[end + 1, far]</code>. We skip the overlapped range (marked in red) using the greedy approach mentioned before.</p>\n<p></p>\n<p>Let's use the following slides as a detailed example:</p>\n<p></p>\n<br/>\n<p>To summarize: the current jump ends when we reach index <code>end</code>. Between the current index and <code>end</code>, we find the farthest reachable index <code>far</code>. At the end of the current jump, we increment our answer and set <code>end = far</code> for the next jump.</p>\n<h4 id=\"algorithm\">Algorithm</h4>\n<ol>\n<li data-length=\"1\">\n<p>Initialize <code>curEnd = 0</code>, <code>curFar = 0</code> and the number of jumps as <code>answer = 0</code>.</p>\n</li>\n<li data-length=\"1\">\n<p>Interate over <code>nums</code>, for each index <code>i</code>, the farthest index we can reach from <code>i</code> is <code>i + nums[i]</code>. We update <code>curFar = max(curFar, i + nums[i])</code>.</p>\n</li>\n<li data-length=\"1\">\n<p>If <code>i = curEnd</code>, it means we have finished the current jump, and should move on to the next jump. Increment <code>answer</code>, and set <code>curEnd = curFar</code> as the furthest we can reach with the next jump. Repeat from step 2.</p>\n</li>\n</ol>\n<h4 id=\"implementation\">Implementation</h4>\n<pre><code>class Solution {\npublic:\n    int jump(vector&lt;int&gt;&amp; nums) {\n        // The starting range of the first jump is [0, 0]\n        int answer = 0, n = int(nums.size());\n​\n        int curEnd = 0, curFar = 0;\n​\n        for (int i = 0; i &lt; n - 1; ++i) {\n            // Update the farthest reachable index of this jump.\n            curFar = max(curFar, i + nums[i]);\n​\n            // If we finish the starting range of this jump,\n            // Move on to the starting range of the next jump.\n            if (i == curEnd) {\n                answer++;\n                curEnd = curFar;\n            }\n        }\n​\n        return answer;\n    }\n};</code></pre>\n<h4 id=\"complexity-analysis\">Complexity Analysis</h4>\n<p>Let <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></span> be the length of the input array <code>nums</code>.</p>\n<ul>\n<li>\n<p>Time complexity: <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p>We iterate over <code>nums</code> and stop at the second last element. In each step of the iteration, we make some calculations that take constant time. Therefore, the overall time complexity is <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n</li>\n<li>\n<p>Space complexity: <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p>In the iteration, we only need to update three variables, <code>curEnd</code>, <code>curFar</code> and <code>answer</code>, they only take constant space.</p>\n</li>\n</ul>\n<br/></div><span style=\"font-size: 0px; line-height: 0;\"> </span></div>"}