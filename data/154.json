{"id":"154","title":"Find Minimum in Rotated Sorted Array II","difficulty":"Hard","content":"<p>Suppose an array of length <code>n</code> sorted in ascending order is <strong>rotated</strong> between <code>1</code> and <code>n</code> times. For example, the array <code>nums = [0,1,4,4,5,6,7]</code> might become:</p>\n\n<ul>\n\t<li><code>[4,5,6,7,0,1,4]</code> if it was rotated <code>4</code> times.</li>\n\t<li><code>[0,1,4,4,5,6,7]</code> if it was rotated <code>7</code> times.</li>\n</ul>\n\n<p>Notice that <strong>rotating</strong> an array <code>[a[0], a[1], a[2], ..., a[n-1]]</code> 1 time results in the array <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code>.</p>\n\n<p>Given the sorted rotated array <code>nums</code> that may contain <strong>duplicates</strong>, return <em>the minimum element of this array</em>.</p>\n\n<p>You must decrease the overall operation steps as much as possible.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> nums = [1,3,5]\n<strong>Output:</strong> 1\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> nums = [2,2,2,0,1]\n<strong>Output:</strong> 0\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 5000</code></li>\n\t<li><code>-5000 &lt;= nums[i] &lt;= 5000</code></li>\n\t<li><code>nums</code> is sorted and rotated between <code>1</code> and <code>n</code> times.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> This problem is similar to&nbsp;<a href=\"https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/\" target=\"_blank\">Find Minimum in Rotated Sorted Array</a>, but&nbsp;<code>nums</code> may contain <strong>duplicates</strong>. Would this affect the runtime complexity? How and why?</p>\n\n<p>&nbsp;</p>\n","tags":["Array","Binary Search"],"java_snippet":"class Solution {\n    public int findMin(int[] nums) {\n        \n    }\n}","solution":"<h2><a href=\"#solution\"><svg><path></path></svg></a>Solution</h2>\n<hr/>\n<h3><a href=\"#approach-1-variant-of-binary-search\"><svg><path></path></svg></a>Approach 1: Variant of Binary Search</h3>\n<p><strong>Intuition</strong></p>\n<p>Given a sorted array in ascending order (denoted as <code>L[i]</code>), the array is then rotated over certain <em>unknown pivot</em>, (denoted as <code>L'[i]</code>). We are asked to find the <em>minimum value</em> of this sorted and rotated array, which is to find the value of the first element in the original array, <em>i.e.</em> <code>L[0]</code>.</p>\n<p>The problem resembles a common problem of <em>finding a given value from a sorted array</em>, to which problem one could apply the <strong>binary search</strong> algorithm. Intuitively, one might wonder if we could apply a variant of binary search algorithm to solve our problem here.</p>\n<p>Indeed, this is the right intuition, though the tricky part is to figure out a <em><strong>concise solution</strong></em> that could work for all cases.</p>\n<p>To illustrate the algorithm, we draw the array in a 2D dimension in the following graph, where the X axis indicates the index of each element in the array and the Y axis indicates the value of the element.</p>\n<p></p>\n<p><em>The main structure of our algorithm remains the same as the classical binary search algorithm.</em> As a reminder, we summarize it briefly as follows:</p>\n<ul>\n<li>We keep two pointers, <em>i.e.</em> <code>low</code>, <code>high</code> which point to the lowest and highest boundary of our search scope.\n<br/>\n</li>\n<li>We then reduce the search scope by moving either of pointers, according to various situations. Usually we shift one of pointers to the mid point between <code>low</code> and <code>high</code>, (<em>i.e.</em> <code>pivot = (low+high)/2</code>), which reduces the search scope down to half. This is also where the name of the algorithm comes from.\n<br/>\n</li>\n<li>The reduction of the search scope would stop, either we find the desired element or the two pointers converge (<em>i.e.</em> <code>low == high</code>).</li>\n</ul>\n<p><strong>Algorithm</strong></p>\n<p>In the classical binary search algorithm, we would compare the pivot element (<em>i.e.</em> <code>nums[pivot]</code>) with the value that we would like to locate. In our case, however, we would compare the pivot element to the element pointed by the upper bound pointer (<em>i.e.</em> <code>nums[high]</code>).</p>\n<blockquote>\n<p>Following the structure of the binary search algorithm, the essential part remained is to design the cases on how to update the two pointers.</p>\n</blockquote>\n<p>Here we give one example on how we can break it down <em><strong>concisely</strong></em> into three cases. Note that given the array, we consider the element pointed by the <code>low</code> index to be on the left-hand side of the array, and the element pointed by the <code>high</code> index to be on the right-hand side.</p>\n<blockquote>\n<p>Case 1). <code>nums[pivot] &lt; nums[high]</code></p>\n</blockquote>\n<p></p>\n<ul>\n<li>The pivot element resides in <em>the same half</em> as the upper bound element.</li>\n<li>Therefore, the desired minimum element should reside to the <strong>left-hand side</strong> of pivot element. As a result, we then move the upper bound down to the pivot index, <em>i.e.</em> <code>high = pivot</code>.</li>\n</ul>\n<blockquote>\n<p>Case 2). <code>nums[pivot] &gt; nums[high]</code></p>\n</blockquote>\n<p></p>\n<ul>\n<li>The pivot element resides in <em>the different half</em> of array as the upper bound element.</li>\n<li>Therefore, the desired minimum element should reside to the <strong>right-hand side</strong> of the pivot element. As a result, we then move the lower bound up next to the pivot index, <em>i.e.</em> <code>low = pivot + 1</code>.</li>\n</ul>\n<blockquote>\n<p>Case 3). <code>nums[pivot] == nums[high]</code></p>\n</blockquote>\n<p></p>\n<ul>\n<li>In this case, we are not sure which side of the pivot that the desired minimum element would reside.</li>\n<li>To further reduce the search scope, a safe measure would be to reduce the upper bound by one (<em>i.e.</em> <code>high = high - 1</code>), rather than moving <em>aggressively</em> to the pivot point.</li>\n<li>The above strategy would prevent the algorithm from stagnating (<em>i.e.</em> endless loop). More importantly, it maintains the <strong>correctness</strong> of the procedure, <em>i.e.</em> we would not end up with skipping the desired element.</li>\n</ul>\n<p>To summarize, this algorithm differs to the classical binary search algorithm in two parts:</p>\n<ul>\n<li>We use the upper bound of search scope as the reference for the comparison with the pivot element, while in the classical binary search the reference would be the desired value.\n<br/>\n</li>\n<li>When the result of comparison is equal (<em>i.e.</em> Case #3), we further move the upper bound, while in the classical binary search normally we would return the value immediately.</li>\n</ul>\n<p>Here are some sample implementations based on the above algorithm. <em>Note:</em> the idea is inspired by the post from <a href=\"https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/discuss/48808/My-pretty-simple-code-to-solve-it\">sheehan</a> in the discussion forum.</p>\n<pre><code>class Solution {\n    public int findMin(int[] nums) {\n        int low = 0, high = nums.length - 1;\n\n        while (low &lt; high) {\n            int pivot = low + (high - low) / 2;\n            if (nums[pivot] &lt; nums[high]) {\n                high = pivot;\n            } else if (nums[pivot] &gt; nums[high]) {\n                low = pivot + 1;\n            } else {\n                high -= 1;\n            }\n        }\n        return nums[low];\n    }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity: on average O(log2​N) where N is the length of the array, since in general it is a binary search algorithm. However, in the worst case where the array contains identical elements (<em>i.e.</em> case #3 <code>nums[pivot]==nums[high]</code>), the algorithm would deteriorate to iterating each element, as a result, the time complexity becomes O(N).</p>\n</li>\n<li>\n<p>Space complexity : O(1), it's a constant space solution.</p>\n</li>\n</ul>\n<p><strong>Discussion</strong></p>\n<blockquote>\n<p>The problem is a follow-up to the problem of <a href=\"https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/\">153. Find Minimum in Rotated Sorted Array</a>. The difference is that in this problem the array can contain duplicates.<br/>\n<em>So the question is \"Would allow duplicates affect the run-time complexity? How and why?\"</em></p>\n</blockquote>\n<p>First of all, the problem of <a href=\"https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/\">153. Find Minimum in Rotated Sorted Array</a> can be considered as a specific case of this problem, where it just happens that the array does not contain any duplicate. As a result, the very solutions of this problem would work for the problem of <a href=\"https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/\">#153</a> as well. It is just that we would never come cross the case #3 (<em>i.e.</em> <code>nums[pivot] == nums[high]</code>) in the problem of <a href=\"https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/\">#153</a>.</p>\n<p>It is due to the fact that there might exist some duplicates in the array, that we come up the case #3 which eventually render the time complexity of the algorithm to be linear O(N), rather than O(log2​N).</p>\n<blockquote>\n<p>One might wonder that whether it works in case #3 if we move the lower boundary (<em>i.e.</em> <code>low += 1</code>), rather than the upper boundary (<em>i.e.</em> <code>high -= 1</code>).</p>\n</blockquote>\n<p>The short answer is that it could work for some cases, but not for all. For instance, given the input <code>[1, 3, 3]</code>, by moving the lower boundary, we would skip the correct answer.</p>\n<blockquote>\n<p>While we do <code>low = pivot + 1</code> to reduce the search scope, then why not do <code>high = pivot - 1</code> instead of <code>high = pivot</code>?<br/>\nOr a similar question would be <em>\"why don't we do check of <code>low &lt;= high</code> rather than <code>low &lt; high</code>\"?</em></p>\n</blockquote>\n<p>As a matter of fact, the binary search algorithm has several <a href=\"https://en.wikipedia.org/wiki/Binary_search_algorithm\">forms of implementation</a>, regarding how we set the boundaries and the loop conditions. One can refer to the <a href=\"https://leetcode.com/explore/learn/card/binary-search/\">Explore card of Binary Search</a> in LeetCode for more details. As simple as the idea of binary search might seem to be, it is tricky to make it work for all cases.</p>\n<p>As one would discover from the card, the above implementation of binary search complies with the <a href=\"https://leetcode.com/explore/learn/card/binary-search/126/template-ii/937/\">template II</a> of binary search. And by replacing <code>high = pivot</code> with <code>high = pivot - 1</code>, the algorithm will not work.</p>\n<p>As subtle as it looks like, the update of the pointers should be consistent with the conditions of the loop. As a rule of thumb, it is advised to stick with one form of binary search, and not to mix them up.</p>\n<blockquote>\n<p>One might notice that we are calculating the pivot with the formula of <code>pivot = low + (high-low)/2</code>, rather than the more intuitive term <code>pivot = (high+low)/2</code>.</p>\n</blockquote>\n<p>Actually, this is done intentionally to prevent the numeric overflow issue, since the sum of two integers could exceed the limit of the integer number. As a fun fact, the above mistake prevails in many implementations of binary search, as revealed from a post titled <a href=\"https://ai.googleblog.com/2006/06/extra-extra-read-all-about-it-nearly.html\"><em>\"Nearly All Binary Searches and Mergesorts are Broken\"</em></a> from googleblog in 2006.</p>"}