{"id":"102","title":"Binary Tree Level Order Traversal","difficulty":"Medium","content":"<p>Given the <code>root</code> of a binary tree, return <em>the level order traversal of its nodes&#39; values</em>. (i.e., from left to right, level by level).</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg\" style=\"width: 277px; height: 302px;\" />\n<pre>\n<strong>Input:</strong> root = [3,9,20,null,null,15,7]\n<strong>Output:</strong> [[3],[9,20],[15,7]]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [1]\n<strong>Output:</strong> [[1]]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = []\n<strong>Output:</strong> []\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 2000]</code>.</li>\n\t<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n","tags":["Tree","Breadth-First Search","Binary Tree"],"java_snippet":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public List<List<Integer>> levelOrder(TreeNode root) {\n        \n    }\n}","solution":"<h2><a href=\"#solution\"><svg><path></path></svg></a>Solution</h2>\n<hr/>\n<h3><a href=\"#how-to-traverse-the-tree\"><svg><path></path></svg></a>How to traverse the tree</h3>\n<p>There are two general strategies to traverse a tree:</p>\n<ul>\n<li>\n<p><em>Depth First Search</em> (<code>DFS</code>)</p>\n<p>In this strategy, we adopt <code>depth</code> as the priority, so that one would start from a root and reach all the way down to a certain leaf, and then back to root to reach another branch.</p>\n<p>The DFS strategy can further be distinguished as <code>preorder</code>, <code>inorder</code>, and <code>postorder</code> depending on the relative order among the root node, left node, and right node.</p>\n</li>\n<li>\n<p><em>Breadth First Search</em> (<code>BFS</code>)</p>\n<p>We scan through the tree level by level, following the order of height, from top to bottom. The nodes on higher levels would be visited before the ones with lower levels.</p>\n</li>\n</ul>\n<p>In the following figure, the nodes are enumerated in the order you visit them, please follow <code>1-2-3-4-5</code> to compare different strategies.</p>\n<p></p>\n<p>Here the problem is to implement split-level BFS traversal: <code>[[1], [2, 3], [4, 5]]</code>.<br/>\n<br/><br/>\n<br/></p>\n<hr/>\n<h3><a href=\"#approach-1-recursion\"><svg><path></path></svg></a>Approach 1: Recursion</h3>\n<p><strong>Algorithm</strong></p>\n<p>The simplest way to solve the problem is to use a recursion. Let's first ensure that the tree is not empty, and then call recursively the function <code>helper(node, level)</code>, which takes the current node and its level as the arguments.</p>\n<p>This function does the following :</p>\n<ul>\n<li>\n<p>The output list here is called <code>levels</code>, and hence the current level is just a length of this list <code>levels.size()</code>. Compare the number of a current level <code>levels.size()</code> with a node level <code>level</code>. If you're still on the previous level - add the new one by adding a new list into <code>levels</code>.</p>\n</li>\n<li>\n<p>Append the node value to the last list in <code>levels</code>.</p>\n</li>\n<li>\n<p>Process recursively child nodes if they are not <code>null</code>: <code>helper(node.left / node.right, level + 1)</code>.</p>\n</li>\n</ul>\n<p><strong>Implementation</strong></p>\n<p></p>\n<pre><code>class Solution {\n    private List&lt;List&lt;Integer&gt;&gt; levels = new ArrayList&lt;&gt;();\n\n    private void helper(TreeNode node, int level) {\n        if (levels.size() == level) {\n            levels.add(new ArrayList&lt;&gt;());\n        }\n        levels.get(level).add(node.val);\n        if (node.left != null) helper(node.left, level + 1);\n        if (node.right != null) helper(node.right, level + 1);\n    }\n\n    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {\n        if (root == null) return levels;\n        helper(root, 0);\n        return levels;\n    }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity: O(N) since each node is processed exactly once.</p>\n</li>\n<li>\n<p>Space complexity: O(N) to keep the output structure which contains <code>N</code> node values.</p>\n<br/>\n</li>\n</ul>\n<br/>\n<hr/>\n<h3><a href=\"#approach-2-iteration\"><svg><path></path></svg></a>Approach 2: Iteration</h3>\n<p><strong>Algorithm</strong></p>\n<p>The recursion above could be rewritten in the iteration form.</p>\n<p>Let's keep nodes of each tree level in the <em>queue</em> structure, which typically orders elements in a FIFO (first-in-first-out) manner. In Java one could use <a href=\"https://docs.oracle.com/javase/7/docs/api/java/util/Queue.html\"><code>LinkedList</code> implementation of the <code>Queue</code> interface</a>. In Java, the queue implementation with fast <code>add()</code> and <code>poll()</code> operations is sufficient for this problem.</p>\n<p>The zero level contains only one node <code>root</code>. The algorithm is simple :</p>\n<ul>\n<li>\n<p>Initiate queue with a <code>root</code> and start from the level number <code>0</code>: <code>level = 0</code>.</p>\n</li>\n<li>\n<p>While the queue is not empty :</p>\n<ul>\n<li>\n<p>Start the current level by adding an empty list into the output structure <code>levels</code>.</p>\n</li>\n<li>\n<p>Compute how many elements should be on the current level: it's a queue size.</p>\n</li>\n<li>\n<p>Poll out all these elements from the queue and add them to the current level.</p>\n</li>\n<li>\n<p>Add their child nodes into the queue for the next level.</p>\n</li>\n<li>\n<p>Go to the next level <code>level++</code>.</p>\n</li>\n</ul>\n</li>\n</ul>\n<p><strong>Implementation</strong></p>\n<pre><code>class Solution {\n    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {\n        List&lt;List&lt;Integer&gt;&gt; levels = new ArrayList&lt;&gt;();\n        if (root == null) return levels;\n\n        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();\n        queue.add(root);\n        int level = 0;\n\n        while (!queue.isEmpty()) {\n            // start the current level\n            levels.add(new ArrayList&lt;&gt;());\n            // number of elements in the current level\n            int levelLength = queue.size();\n\n            for (int i = 0; i &lt; levelLength; i++) {\n                TreeNode node = queue.poll();\n                // fulfill the current level\n                levels.get(level).add(node.val);\n                // add child nodes of the current level\n                // in the queue for the next level\n                if (node.left != null) queue.add(node.left);\n                if (node.right != null) queue.add(node.right);\n            }\n            // go to next level\n            level++;\n        }\n        return levels;\n    }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity: O(N) since each node is processed exactly once.</p>\n</li>\n<li>\n<p>Space complexity: O(N) to keep the output structure which contains <code>N</code> node values.</p>\n</li>\n</ul>"}