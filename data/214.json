{"id":"214","title":"Shortest Palindrome","difficulty":"Hard","content":"<p>You are given a string <code>s</code>. You can convert <code>s</code> to a <span data-keyword=\"palindrome-string\">palindrome</span> by adding characters in front of it.</p>\n\n<p>Return <em>the shortest palindrome you can find by performing this transformation</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> s = \"aacecaaa\"\n<strong>Output:</strong> \"aaacecaaa\"\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> s = \"abcd\"\n<strong>Output:</strong> \"dcbabcd\"\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= s.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>s</code> consists of lowercase English letters only.</li>\n</ul>\n","tags":["String","Rolling Hash","String Matching","Hash Function"],"java_snippet":"class Solution {\n    public String shortestPalindrome(String s) {\n        \n    }\n}","solution":"<div class=\"flex flex-col w-full\" style=\"position: relative;\"><div class=\"mYe_l WRmCx\"><h2 class=\"group/heading relative\" id=\"solution\" level=\"2\"><a aria-hidden=\"true\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" href=\"#solution\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" data-icon=\"link\" data-prefix=\"fas\" focusable=\"false\" role=\"img\" spacing=\"square\" viewbox=\"0 0 640 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\" fill=\"currentColor\"></path></svg></div></a>Solution</h2>\n<hr/>\n<h3 class=\"group/heading relative\" id=\"overview\" level=\"3\"><a aria-hidden=\"true\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" href=\"#overview\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" data-icon=\"link\" data-prefix=\"fas\" focusable=\"false\" role=\"img\" spacing=\"square\" viewbox=\"0 0 640 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\" fill=\"currentColor\"></path></svg></div></a>Overview</h3>\n<p>We are given a string <code>s</code>. Our task is to build the smallest palindrome by adding characters to the beginning of <code>s</code>.</p>\n<p>To solve this, we can reframe the problem as finding the longest palindromic substring that starts from the index <code>0</code>. Once we know the length of this substring, we can create the shortest palindrome by appending the reverse of the remaining part of the string to the original string to make <code>s</code> a complete palindrome.</p>\n<p>For instance, consider the string <code>s = \"aacecaaa\"</code>. Here, the longest palindromic prefix is <code>\"aacecaa\"</code>(starts at index <code>0</code>). The remaining part of the string is just the last <code>\"a\"</code>. To create the smallest palindrome, we reverse this remaining part and add it to the front of the original string, resulting in <code>\"aaacecaaa\"</code>, which is a palindrome.</p>\n<p>Another example is <code>s = \"abcd\"</code>, where the longest palindromic prefix is just the first character <code>\"a\"</code>. The remaining part, <code>\"bcd\"</code>, is not a palindrome. By reversing <code>\"bcd\"</code> and adding it to the start, we get <code>\"dcbabcd\"</code>, which is the smallest palindrome that can be formed from the original string. This way, we can find the shortest palindrome by adding only the necessary characters to the front of the string.</p>\n<h3 class=\"group/heading relative\" id=\"approach-1-brute-force\" level=\"3\"><a aria-hidden=\"true\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" href=\"#approach-1-brute-force\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" data-icon=\"link\" data-prefix=\"fas\" focusable=\"false\" role=\"img\" spacing=\"square\" viewbox=\"0 0 640 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\" fill=\"currentColor\"></path></svg></div></a>Approach 1: Brute Force</h3>\n<h4 id=\"intuition\">Intuition</h4>\n<p>As we know, a palindrome reads the same forwards and backwards. Therefore, the challenge is to identify the longest prefix of the original string that can be extended to a full palindrome by only adding characters at the start.</p>\n<p>First, we need to find out which part of the string is already a palindrome. So, we check the original string and see how much of it matches the end of its reversed version. This helps us figure out the longest palindromic prefix.</p>\n<p>To do this, we look at different prefixes of the original string and compare them to suffixes of the reversed string. If a prefix matches a suffix of the reversed string, it’s part of a palindrome.</p>\n<p>Once we find the longest palindromic prefix, we need to reverse the rest of the string (the part not included in the prefix) and add this reversed part to the start of the original string. This gives us the shortest possible palindrome.</p>\n<p>For example: Let’s take the string <code>\"abcbabcab\"</code>. We reverse the string to get <code>\"bacbabcba\"</code>. By comparing prefixes of <code>\"abcbabcab\"</code> with suffixes of <code>\"bacbabcba\"</code>, we find that the longest prefix <code>\"abcba\"</code> matches with the suffix <code>\"abcba\"</code> in the reversed string. This is a palindrome.</p>\n<p>To form the shortest palindrome, we then need to reverse the remaining part of the original string that doesn’t overlap with this prefix. In our example, the remaining part is <code>\"bcab\"</code>. Reversing <code>\"bcab\"</code> gives us <code>\"bacb\"</code>. Adding this to the start of the original string results in <code>\"bacbabcbabcab\"</code>.</p>\n<h4 id=\"algorithm\">Algorithm</h4>\n<ul>\n<li>\n<p>Initialize <code>length</code> with the length of the string <code>s</code>.</p>\n</li>\n<li>\n<p>Reverse the string <code>s</code> to get <code>reversedString</code>.</p>\n</li>\n<li>\n<p>Iterate through the string from <code>0</code> to <code>length - 1</code>:</p>\n<ul>\n<li>For each index <code>i</code>, check if the substring <code>s.substring(0, length - i)</code> (i.e., the prefix of <code>s</code> up to <code>length - i</code>) is equal to the substring <code>reversedString.substring(i)</code> (i.e., the suffix of <code>reversedString</code> starting from <code>i</code>).</li>\n<li>If they are equal, it means the prefix of <code>s</code> is a palindrome:\n<ul>\n<li>Return the concatenation of <code>reversedString.substring(0, i)</code> (i.e., the characters in <code>reversedString</code> before <code>i</code>) and the original string <code>s</code>.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>If no valid prefix is found that satisfies the condition, return an empty string <code>\"\"</code>.</p>\n</li>\n</ul>\n<h4 id=\"implementation\">Implementation</h4>\n<blockquote>\n<p><strong>Note:</strong> The C++ code gives MLE because <code>std::string</code> allocates fresh heap memory every time you call <code>substr</code>, which consumes a lot of memory. Repeated allocations quickly exceed the memory limit.</p>\n</blockquote>\n<pre><code>class Solution {\npublic:\n    string shortestPalindrome(string s) {\n        string reversedString = s;\n        // Reverse the original string\n        reverse(reversedString.begin(), reversedString.end());\n​\n        // Iterate through the string to find the longest palindromic prefix\n        for (int i = 0; i &lt; s.size(); ++i) {\n            // memcmp to avoid creating substrings\n            if (!memcmp(s.c_str(), reversedString.c_str() + i, s.size() - i)) {\n                // Append the necessary part to make the palindrome\n                return reversedString.substr(0, i) + s;\n            }\n        }\n        // Fallback case, append the whole reversed string to the original\n        // string\n        return reversedString + s;\n    }\n};</code></pre>\n<h4 id=\"complexity-analysis\">Complexity Analysis</h4>\n<p>Let <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></span> be the length of the input string <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.4306em;\"></span><span class=\"mord mathnormal\">s</span></span></span></span></span>.</p>\n<ul>\n<li>\n<p>Time complexity: <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1.0641em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.8141em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p>The reversal of the string <code>s</code> involves traversing the string once, which has a time complexity of <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n<p>In the loop, for each iteration, we check if the substring of length <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6667em; vertical-align: -0.0833em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span></span> of <code>s</code> matches the substring of length <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6667em; vertical-align: -0.0833em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span></span> of the reversed string. Each check involves string operations that are linear in the length of the substring being compared. Thus, for each iteration <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span></span>, the comparison is <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">)</span></span></span></span></span>. Since <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span></span> ranges from 0 to <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6667em; vertical-align: -0.0833em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.6444em;\"></span><span class=\"mord\">1</span></span></span></span></span>, the total time complexity of the palindrome check part can be expressed as the sum of comparisons of decreasing lengths. This sum is roughly <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1.0641em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.8141em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n<p>Combining these operations, the overall time complexity is <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1.0641em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.8141em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n</li>\n<li>\n<p>Space complexity: <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p>Creating the reversed string involves additional space proportional to the length of the input string, i.e., <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n<p>The substring operations in the <code>for</code> loop do not require additional space proportional to the length of the string but do create new string objects temporarily, which is still <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span> space for each substring.</p>\n<p>Therefore, the overall space complexity is <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n</li>\n</ul>\n<hr/>\n<h3 class=\"group/heading relative\" id=\"approach-2-two-pointer\" level=\"3\"><a aria-hidden=\"true\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" href=\"#approach-2-two-pointer\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" data-icon=\"link\" data-prefix=\"fas\" focusable=\"false\" role=\"img\" spacing=\"square\" viewbox=\"0 0 640 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\" fill=\"currentColor\"></path></svg></div></a>Approach 2: Two Pointer</h3>\n<h4 id=\"intuition-1\">Intuition</h4>\n<p>In the brute force approach, we observe that we need to identify the longest palindromic prefix of a string. To do this, we can now use a method involving two pointers. This method is a bit more efficient compared to checking every possible substring, which would take longer.</p>\n<p>Let's consider an example string: <code>\"abcbabcaba\"</code>. We use two pointers, <code>left</code> and <code>right</code>. We start by setting <code>left</code> to <code>0</code>. Then, we move the <code>right</code> pointer from the end of the string to the beginning. Each time the characters at <code>left</code> and <code>right</code> match, we increment <code>left</code>.</p>\n<p>By following this process, we narrow our search to the substring from the beginning of the string up to <code>left</code>. This substring will always include the longest palindromic prefix.</p>\n<ul>\n<li>If the entire string were a perfect palindrome, the <code>left</code> pointer would move through the entire length of the string, reaching the end (<code>n</code> times).</li>\n<li>If the string isn’t a perfect palindrome, the <code>left</code> pointer will still move forward by the length of the palindromic part at the beginning.</li>\n</ul>\n<p>Therefore, while the substring <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right: 0.1667em;\"></span><span class=\"mord text\"><span class=\"mord\">left</span></span><span class=\"mclose\">)</span></span></span></span></span> may not always be the tightest fit, it will always contain the longest palindromic prefix.</p>\n<p>The best-case scenario for this algorithm is when the entire string is a palindrome. In this case, the <code>left</code> pointer will reach the end of the string quickly. The worst-case scenario is when the string is something like <code>\"aababababababa\"</code>. Here, <code>left</code> initially becomes <code>12</code>, meaning we need to recheck the substring <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right: 0.1667em;\"></span><span class=\"mord\">12</span><span class=\"mclose\">)</span></span></span></span></span>. As we continue, <code>left</code> might decrease to <code>10</code>, and so on. In this worst-case scenario, the substring is reduced by only a few elements at each step, making the total number of steps proportional to the length of the string, or <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n<h4 id=\"algorithm-1\">Algorithm</h4>\n<ul>\n<li>\n<p>If the string <code>s</code> is empty, return <code>s</code> immediately.</p>\n</li>\n<li>\n<p>Find the longest palindromic prefix:</p>\n<ul>\n<li>Initialize <code>left</code> to 0.</li>\n<li>Iterate <code>right</code> from the end of the string (<code>length - 1</code>) to the start (0):\n<ul>\n<li>If the character at <code>right</code> matches the character at <code>left</code>:\n<ul>\n<li>Increment <code>left</code>.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>If <code>left</code> equals the length of the string, <code>s</code> is already a palindrome, so return <code>s</code>.</p>\n</li>\n<li>\n<p>Extract the suffix that is not part of the palindromic prefix:</p>\n<ul>\n<li>Create <code>nonPalindromeSuffix</code> as the substring from <code>left</code> to the end of <code>s</code>.</li>\n<li>Reverse <code>nonPalindromeSuffix</code> to create <code>reverseSuffix</code>.</li>\n</ul>\n</li>\n<li>\n<p>Form the shortest palindrome:</p>\n<ul>\n<li>Recursively call <code>shortestPalindrome</code> on the substring from the start to <code>left</code> (i.e., <code>s.substring(0, left)</code>).</li>\n<li>Concatenate <code>reverseSuffix</code>, the result of the recursive call, and <code>nonPalindromeSuffix</code>.</li>\n</ul>\n</li>\n<li>\n<p>Return the concatenated result as the shortest palindrome.</p>\n</li>\n</ul>\n<h4 id=\"implementation-1\">Implementation</h4>\n<pre><code>class Solution {\npublic:\n    string shortestPalindrome(string s) {\n        int length = s.length();\n        if (length == 0) {\n            return s;\n        }\n​\n        // Find the longest palindromic prefix\n        int left = 0;\n        for (int right = length - 1; right &gt;= 0; right--) {\n            if (s[right] == s[left]) {\n                left++;\n            }\n        }\n​\n        // If the whole string is a palindrome, return the original string\n        if (left == length) {\n            return s;\n        }\n​\n        // Extract the suffix that is not part of the palindromic prefix\n        string nonPalindromeSuffix = s.substr(left);\n        string reverseSuffix =\n            string(nonPalindromeSuffix.rbegin(), nonPalindromeSuffix.rend());\n​\n        // Form the shortest palindrome by prepending the reversed suffix\n        return reverseSuffix + shortestPalindrome(s.substr(0, left)) +\n               nonPalindromeSuffix;\n    }\n};</code></pre>\n<h4 id=\"complexity-analysis-1\">Complexity Analysis</h4>\n<p>Let <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></span> be the length of the input string.</p>\n<ul>\n<li>\n<p>Time Complexity: <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1.0641em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.8141em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p>Each iteration of the <code>shortestPalindrome</code> function operates on a substring of size <code>n</code>. In the worst-case scenario, where the string is not a palindrome and we must continually reduce its size, the function might need to be called up to <code>n/2</code> times.</p>\n<p>The time complexity <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.13889em;\">T</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span> represents the total time taken by the algorithm. At each step, the algorithm processes a substring and then works with a smaller substring by removing two characters. This can be expressed as <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.13889em;\">T</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.13889em;\">T</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord\">2</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span>, where <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span> is the time taken to process the substring of size <code>n</code>.</p>\n<p>Summing up all the steps, we get:<br/>\n<span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.13889em;\">T</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord\">2</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord\">4</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.6667em; vertical-align: -0.0833em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p>This sum of terms approximates to <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1.0641em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.8141em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span> because it is an arithmetic series where the number of terms grows linearly with <code>n</code>.</p>\n</li>\n<li>\n<p>Space Complexity: <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p>The space complexity is linear, <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span>, due to the space needed to store the reversed suffix and other temporary variables.</p>\n</li>\n</ul>\n<hr/>\n<h3 class=\"group/heading relative\" id=\"approach-3-kmp-knuth-morris-pratt-algorithm\" level=\"3\"><a aria-hidden=\"true\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" href=\"#approach-3-kmp-knuth-morris-pratt-algorithm\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" data-icon=\"link\" data-prefix=\"fas\" focusable=\"false\" role=\"img\" spacing=\"square\" viewbox=\"0 0 640 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\" fill=\"currentColor\"></path></svg></div></a>Approach 3: KMP (Knuth-Morris-Pratt) Algorithm</h3>\n<h4 id=\"intuition-2\">Intuition</h4>\n<p>The KMP algorithm is used for pattern matching within strings. The KMP algorithm computes prefix functions to identify substrings that match specific patterns. In our case, we use this efficiency to compute the longest palindromic prefix. We construct a combined string of the original string, a special delimiter, and the reversed original string. By applying KMP, we can determine the longest prefix of the original string that matches a suffix of the reversed string.</p>\n<p>First, we construct a new string by concatenating the original string, a delimiter (such as <code>\"#\"</code>), and the reversed original string. This combined string looks like <code>\"original#reversed\"</code>. The delimiter <code>\"#\"</code> is crucial because it ensures that we are only comparing the original string with its reversed version, and not inadvertently matching parts of the reversed string with itself.</p>\n<p>To proceed, we calculate the prefix function for this combined string. The prefix function or partial match table is an array where each element at index <code>i</code> indicates the length of the longest prefix of the substring ending at <code>i</code> which is also a suffix. This helps us identify the longest segment where the prefix of the original string matches a suffix in the reversed string. The purpose is to identify how much of the original string matches a suffix of the reversed string.</p>\n<br/>\n<p>For example: We construct a combined string using the original string <code>s</code>, a delimiter <code>\"#\"</code>, and the reversed version of <code>s</code>. This combined string helps us find the longest palindromic prefix by applying the KMP algorithm. For the string <code>\"aacecaaa\"</code>, the reversed string is <code>\"aaacecaa\"</code>. Thus, the combined string becomes <code>\"aacecaaa#aaacecaa\"</code>.</p>\n<p>The prefix function helps us determine the length of the longest prefix of the original string that can be matched by a suffix of the reversed string. For the combined string <code>\"aacecaaa#aaacecaa\"</code>, the prefix function will reveal that the longest palindromic prefix of <code>\"aacecaaa\"</code> is <code>\"aacecaa\"</code>.</p>\n<p>To create the shortest palindrome, we need to prepend characters to the original string. Specifically, we reverse the portion of the original string that extends beyond the longest palindromic prefix and prepend it. In this case, the part of the original string that extends beyond <code>\"aacecaa\"</code> is <code>\"a\"</code>. Reversing <code>\"a\"</code> gives <code>\"a\"</code>, so we prepend <code>\"a\"</code> to <code>\"aacecaaa\"</code> and the result is <code>\"aaacecaaa\"</code>.</p>\n<br/>\n<br/>\n<p>The algorithm to generate the prefix table is described below:</p>\n<div class=\"font-menlo mb-6 rounded-lg px-3 py-2.5 text-sm bg-fill-3 dark:bg-dark-fill-3\"><div class=\"group relative\" translate=\"no\"><pre style=\"color: black; font-size: 13px; text-shadow: none; font-family: Menlo, Monaco, Consolas; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 4; hyphens: none; padding: 0px; margin: 0px; overflow: auto; background: transparent; overflow-wrap: normal;\"><code class=\"language-java\" style=\"white-space: pre; text-shadow: none;\"><span><span>prefixTable</span><span class=\"token\" style=\"color: rgb(153, 153, 153);\">[</span><span class=\"token\" style=\"color: rgb(153, 0, 85);\">0</span><span class=\"token\" style=\"color: rgb(153, 153, 153);\">]</span><span> </span><span class=\"token\" style=\"color: rgb(154, 110, 58);\">=</span><span> </span><span class=\"token\" style=\"color: rgb(153, 0, 85);\">0</span><span class=\"token\" style=\"color: rgb(153, 153, 153);\">;</span><span>\n</span></span><span><span></span><span class=\"token\" style=\"color: rgb(0, 119, 170);\">for</span><span> </span><span class=\"token\" style=\"color: rgb(153, 153, 153);\">(</span><span class=\"token\" style=\"color: rgb(0, 119, 170);\">int</span><span> i </span><span class=\"token\" style=\"color: rgb(154, 110, 58);\">=</span><span> </span><span class=\"token\" style=\"color: rgb(153, 0, 85);\">1</span><span class=\"token\" style=\"color: rgb(153, 153, 153);\">;</span><span> i </span><span class=\"token\" style=\"color: rgb(154, 110, 58);\">&lt;</span><span> n</span><span class=\"token\" style=\"color: rgb(153, 153, 153);\">;</span><span> i</span><span class=\"token\" style=\"color: rgb(154, 110, 58);\">++</span><span class=\"token\" style=\"color: rgb(153, 153, 153);\">)</span><span> </span><span class=\"token\" style=\"color: rgb(153, 153, 153);\">{</span><span>\n</span></span><span><span>    </span><span class=\"token\" style=\"color: rgb(0, 119, 170);\">int</span><span> length </span><span class=\"token\" style=\"color: rgb(154, 110, 58);\">=</span><span> prefixTable</span><span class=\"token\" style=\"color: rgb(153, 153, 153);\">[</span><span>i </span><span class=\"token\" style=\"color: rgb(154, 110, 58);\">-</span><span> </span><span class=\"token\" style=\"color: rgb(153, 0, 85);\">1</span><span class=\"token\" style=\"color: rgb(153, 153, 153);\">]</span><span class=\"token\" style=\"color: rgb(153, 153, 153);\">;</span><span>\n</span></span><span><span>    </span><span class=\"token\" style=\"color: rgb(0, 119, 170);\">while</span><span> </span><span class=\"token\" style=\"color: rgb(153, 153, 153);\">(</span><span>length </span><span class=\"token\" style=\"color: rgb(154, 110, 58);\">&gt;</span><span> </span><span class=\"token\" style=\"color: rgb(153, 0, 85);\">0</span><span> </span><span class=\"token\" style=\"color: rgb(154, 110, 58);\">&amp;&amp;</span><span> s</span><span class=\"token\" style=\"color: rgb(153, 153, 153);\">.</span><span class=\"token\" style=\"color: rgb(221, 74, 104);\">charAt</span><span class=\"token\" style=\"color: rgb(153, 153, 153);\">(</span><span>i</span><span class=\"token\" style=\"color: rgb(153, 153, 153);\">)</span><span> </span><span class=\"token\" style=\"color: rgb(154, 110, 58);\">!=</span><span> s</span><span class=\"token\" style=\"color: rgb(153, 153, 153);\">.</span><span class=\"token\" style=\"color: rgb(221, 74, 104);\">charAt</span><span class=\"token\" style=\"color: rgb(153, 153, 153);\">(</span><span>length</span><span class=\"token\" style=\"color: rgb(153, 153, 153);\">)</span><span class=\"token\" style=\"color: rgb(153, 153, 153);\">)</span><span> </span><span class=\"token\" style=\"color: rgb(153, 153, 153);\">{</span><span>\n</span></span><span><span>        length </span><span class=\"token\" style=\"color: rgb(154, 110, 58);\">=</span><span> prefixTable</span><span class=\"token\" style=\"color: rgb(153, 153, 153);\">[</span><span>length </span><span class=\"token\" style=\"color: rgb(154, 110, 58);\">-</span><span> </span><span class=\"token\" style=\"color: rgb(153, 0, 85);\">1</span><span class=\"token\" style=\"color: rgb(153, 153, 153);\">]</span><span class=\"token\" style=\"color: rgb(153, 153, 153);\">;</span><span>\n</span></span><span><span>    </span><span class=\"token\" style=\"color: rgb(153, 153, 153);\">}</span><span>\n</span></span><span><span>    </span><span class=\"token\" style=\"color: rgb(0, 119, 170);\">if</span><span> </span><span class=\"token\" style=\"color: rgb(153, 153, 153);\">(</span><span>s</span><span class=\"token\" style=\"color: rgb(153, 153, 153);\">.</span><span class=\"token\" style=\"color: rgb(221, 74, 104);\">charAt</span><span class=\"token\" style=\"color: rgb(153, 153, 153);\">(</span><span>i</span><span class=\"token\" style=\"color: rgb(153, 153, 153);\">)</span><span> </span><span class=\"token\" style=\"color: rgb(154, 110, 58);\">==</span><span> s</span><span class=\"token\" style=\"color: rgb(153, 153, 153);\">.</span><span class=\"token\" style=\"color: rgb(221, 74, 104);\">charAt</span><span class=\"token\" style=\"color: rgb(153, 153, 153);\">(</span><span>length</span><span class=\"token\" style=\"color: rgb(153, 153, 153);\">)</span><span class=\"token\" style=\"color: rgb(153, 153, 153);\">)</span><span> </span><span class=\"token\" style=\"color: rgb(153, 153, 153);\">{</span><span>\n</span></span><span><span>        length</span><span class=\"token\" style=\"color: rgb(154, 110, 58);\">++</span><span class=\"token\" style=\"color: rgb(153, 153, 153);\">;</span><span>\n</span></span><span><span>    </span><span class=\"token\" style=\"color: rgb(153, 153, 153);\">}</span><span>\n</span></span><span><span>    prefixTable</span><span class=\"token\" style=\"color: rgb(153, 153, 153);\">[</span><span>i</span><span class=\"token\" style=\"color: rgb(153, 153, 153);\">]</span><span> </span><span class=\"token\" style=\"color: rgb(154, 110, 58);\">=</span><span> length</span><span class=\"token\" style=\"color: rgb(153, 153, 153);\">;</span><span>\n</span></span><span><span></span><span class=\"token\" style=\"color: rgb(153, 153, 153);\">}</span></span></code></pre><div class=\"absolute -right-1.5 -top-0.5 flex gap-2\"><div class=\"z-base-1 hidden rounded border group-hover:block border-border-quaternary dark:border-border-quaternary bg-layer-02 dark:bg-layer-02\"><div class=\"relative cursor-pointer flex h-[22px] w-[22px] items-center justify-center bg-layer-02 dark:bg-layer-02 hover:bg-fill-tertiary dark:hover:bg-fill-tertiary rounded-[4px]\" data-state=\"closed\"><div><div data-state=\"closed\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3 h-3.5 w-3.5 text-text-primary dark:text-text-primary\"><svg aria-hidden=\"true\" class=\"svg-inline--fa fa-clone absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" data-icon=\"clone\" data-prefix=\"far\" focusable=\"false\" role=\"img\" viewbox=\"0 0 512 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M64 464H288c8.8 0 16-7.2 16-16V384h48v64c0 35.3-28.7 64-64 64H64c-35.3 0-64-28.7-64-64V224c0-35.3 28.7-64 64-64h64v48H64c-8.8 0-16 7.2-16 16V448c0 8.8 7.2 16 16 16zM224 304H448c8.8 0 16-7.2 16-16V64c0-8.8-7.2-16-16-16H224c-8.8 0-16 7.2-16 16V288c0 8.8 7.2 16 16 16zm-64-16V64c0-35.3 28.7-64 64-64H448c35.3 0 64 28.7 64 64V288c0 35.3-28.7 64-64 64H224c-35.3 0-64-28.7-64-64z\" fill=\"currentColor\"></path></svg></div></div></div></div></div></div></div></div>\n<ul>\n<li>Begin by setting <code>prefixTable[0] = 0</code> since there is no proper prefix for the first character.</li>\n<li>Next, iterate over <code>i</code> from 1 to <code>n - 1</code>:\n<ul>\n<li>Set <code>length = prefixTable[i - 1]</code>, which represents the longest prefix length for the substring up to the previous character.</li>\n<li>While <code>length &gt; 0</code> and the character at position <code>i</code> doesn't match the character at position <code>length</code>, set <code>length = prefixTable[length - 1]</code>. This step is essential when we encounter a mismatch, and we attempt to match a shorter prefix, which is the value of <code>prefixTable[length - 1]</code>, until either we find a match or <code>length</code> becomes 0.</li>\n<li>If <code>s.charAt(i) == s.charAt(length)</code>, we increment <code>length</code> by 1 (extend the matching prefix).</li>\n<li>Finally, set <code>prefixTable[i] = length</code>.</li>\n</ul>\n</li>\n</ul>\n<p>The lookup table generation is as illustrated below:</p>\n<p></p>\n<h4 id=\"algorithm-2\">Algorithm</h4>\n<ul>\n<li>\n<p><code>shortestPalindrome</code> function:</p>\n<ul>\n<li>Create <code>reversedString</code> by reversing the input string <code>s</code>.</li>\n<li>Concatenate <code>s</code>, a separator <code>#</code>, and <code>reversedString</code> to form <code>combinedString</code>.</li>\n<li>Call <code>buildPrefixTable(combinedString)</code> to compute the prefix table for <code>combinedString</code>.</li>\n<li>Extract the length of the longest palindromic prefix from the last value in the prefix table (<code>prefixTable[combinedString.length() - 1]</code>).</li>\n<li>Compute <code>suffix</code> by taking the substring of <code>s</code> starting from the length of the longest palindromic prefix.</li>\n<li>Reverse <code>suffix</code> and prepend it to <code>s</code> to form and return the shortest palindrome.</li>\n</ul>\n</li>\n<li>\n<p><code>buildPrefixTable</code> function:</p>\n<ul>\n<li>Initialize <code>prefixTable</code> with the same length as the input string <code>s</code> and set <code>length</code> to <code>0</code>.</li>\n<li>Iterate over <code>s</code> from index <code>1</code> to the end:\n<ul>\n<li>While <code>length</code> is greater than <code>0</code> and the current character does not match the character at the current length, update <code>length</code> to the value at <code>prefixTable[length - 1]</code>.</li>\n<li>If the current character matches the character at <code>length</code>, increment <code>length</code>.</li>\n<li>Set <code>prefixTable[i]</code> to the current <code>length</code>.</li>\n</ul>\n</li>\n<li>Return the <code>prefixTable</code>.</li>\n</ul>\n</li>\n<li>\n<p>The result is the shortest palindrome string formed by appending the reversed suffix of <code>s</code> to <code>s</code>.</p>\n</li>\n</ul>\n<h4 id=\"implementation-2\">Implementation</h4>\n<pre><code>class Solution {\npublic:\n    string shortestPalindrome(string s) {\n        // Reverse the original string\n        string reversedString = string(s.rbegin(), s.rend());\n​\n        // Combine the original and reversed strings with a separator\n        string combinedString = s + \"#\" + reversedString;\n​\n        // Build the prefix table for the combined string\n        vector&lt;int&gt; prefixTable = buildPrefixTable(combinedString);\n​\n        // Get the length of the longest palindromic prefix\n        int palindromeLength = prefixTable[combinedString.length() - 1];\n​\n        // Construct the shortest palindrome by appending the reverse of the\n        // suffix\n        string suffix = reversedString.substr(0, s.length() - palindromeLength);\n        return suffix + s;\n    }\n​\nprivate:\n    // Helper function to build the KMP prefix table\n    vector&lt;int&gt; buildPrefixTable(const string&amp; s) {\n        vector&lt;int&gt; prefixTable(s.length(), 0);\n        int length = 0;\n​\n        // Build the table by comparing characters\n        for (int i = 1; i &lt; s.length(); i++) {\n            while (length &gt; 0 &amp;&amp; s[i] != s[length]) {\n                length = prefixTable[length - 1];\n            }\n            if (s[i] == s[length]) {\n                length++;\n            }\n            prefixTable[i] = length;\n        }\n        return prefixTable;\n    }\n};</code></pre>\n<h4 id=\"complexity-analysis-2\">Complexity Analysis</h4>\n<p>Let <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></span> be the length of the input string.</p>\n<ul>\n<li>\n<p>Time complexity: <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p>Creating the reversed string requires a pass through the original string, which takes <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span> time.</p>\n<p>Concatenating <code>s</code>, <code>#</code>, and <code>reversedString</code> takes <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span> time, as concatenating strings of length <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></span> is linear in the length of the strings.</p>\n<p>Constructing the prefix table involves iterating over the combined string of length <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.7278em; vertical-align: -0.0833em;\"></span><span class=\"mord\">2</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.6444em;\"></span><span class=\"mord\">1</span></span></span></span></span>. The <code>buildPrefixTable</code> method runs in <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">m</span><span class=\"mclose\">)</span></span></span></span></span> time, where <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.4306em;\"></span><span class=\"mord mathnormal\">m</span></span></span></span></span> is the length of the combined string. In this case, <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.4306em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.7278em; vertical-align: -0.0833em;\"></span><span class=\"mord\">2</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.6444em;\"></span><span class=\"mord\">1</span></span></span></span></span>, so the time complexity is <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n<p>Extracting the suffix and reversing it are both <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span> operations.</p>\n<p>Combining these, the overall time complexity is <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n</li>\n<li>\n<p>Space complexity: <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p>The <code>reversedString</code> and <code>combinedString</code> each use <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span> space.</p>\n<p>The <code>prefixTable</code> array has a size of <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.7278em; vertical-align: -0.0833em;\"></span><span class=\"mord\">2</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.6444em;\"></span><span class=\"mord\">1</span></span></span></span></span>, which is <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span>. Other variables used (such as <code>length</code> and indices) use <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></span> space.</p>\n<p>Combining these, the overall space complexity is <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n</li>\n</ul>\n<hr/>\n<h3 class=\"group/heading relative\" id=\"approach-4-rolling-hash-based-algorithm\" level=\"3\"><a aria-hidden=\"true\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" href=\"#approach-4-rolling-hash-based-algorithm\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" data-icon=\"link\" data-prefix=\"fas\" focusable=\"false\" role=\"img\" spacing=\"square\" viewbox=\"0 0 640 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\" fill=\"currentColor\"></path></svg></div></a>Approach 4: Rolling Hash Based Algorithm</h3>\n<h4 id=\"intuition-3\">Intuition</h4>\n<p>The rolling hash approach uses hash functions to efficiently compare different substrings of the original string with those of the reversed string. Hashing helps determine if a substring matches another by comparing hash values rather than individual characters.</p>\n<p>Rolling hashes were designed to handle substring matching and comparison problems by allowing incremental updates to hash values as we slide through the string. This reduces the number of comparisons needed by comparing hash values instead of actual substrings.</p>\n<p>To start, we compute hash values for all prefixes of the original string and all suffixes of the reversed string using a rolling hash function. The rolling hash function allows us to update the hash values incrementally, which speeds up the computation compared to recalculating hashes from scratch.</p>\n<p>Next, we compare the hash values of the prefixes from the original string with the hash values of the suffixes from the reversed string. When the hash values match, it indicates that the corresponding substrings are identical. This helps us find the longest palindromic prefix.</p>\n<p>For example: Suppose our string is <code>\"aacecaaa\"</code>. We calculate hash values for the prefixes of <code>\"aacecaaa\"</code> and the suffixes of its reverse, <code>\"aaacecaa\"</code>. The hash comparisons reveal that the longest palindromic prefix is <code>\"aacecaaa\"</code>. We then reverse the remaining part of the string (<code>\"a\"</code>), yielding <code>\"a\"</code>. Prepending this reversed part to the original string gives <code>\"aaacecaaa\"</code>.</p>\n<br/>\n<h5 id=\"hash-calculation-details\">Hash Calculation Details:</h5>\n<p>To give you a clearer idea of how the hashing is calculated, let's see this:</p>\n<p>We initialize two hash values: one for the original string and one for its reversed version. Let’s use base <code>29</code> and a large prime modulus <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.8974em; vertical-align: -0.0833em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.8141em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">9</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.6444em;\"></span><span class=\"mord\">7</span></span></span></span></span> for hashing. We also initialize a variable to keep track of powers of the base.</p>\n<p>We iterate through each character of the original string and compute its hash. Suppose we start with the hash value <code>0</code> and process characters one by one:</p>\n<br/>\n<p><span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.8362em;\"></span><span class=\"mord\"><span class=\"mord text\"><span class=\"mord\">Character </span></span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.8362em;\"><span style=\"top: -3.1473em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.7519em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">:</span></span></span></span></span></p>\n<p><span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.8889em; vertical-align: -0.1944em;\"></span><span class=\"mord text\"><span class=\"mord\">Update hash:</span></span></span></span></span></span></p>\n<p><span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6944em;\"></span><span class=\"mord text\"><span class=\"mord\">hash</span></span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord text\"><span class=\"mord\">hash</span></span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.7778em; vertical-align: -0.0833em;\"></span><span class=\"mord text\"><span class=\"mord\">base</span></span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1.06em; vertical-align: -0.31em;\"></span><span class=\"mord text\"><span class=\"mord\">character_value</span></span><span class=\"mclose\">)</span><span class=\"mord\">%</span><span class=\"mord text\"><span class=\"mord\">mod</span></span></span></span></span></span></p>\n<p><span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1.1462em; vertical-align: -0.31em;\"></span><span class=\"mord text\"><span class=\"mord\">Suppose </span></span><span class=\"mord text\"><span class=\"mord\">character_value</span></span><span class=\"mord\"><span class=\"mord text\"><span class=\"mord\"> for </span></span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.8362em;\"><span style=\"top: -3.1473em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.7519em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mord text\"><span class=\"mord\"> is </span></span><span class=\"mord\">1.</span></span></span></span></span></p>\n<p><span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6944em;\"></span><span class=\"mord text\"><span class=\"mord\">hash</span></span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.7278em; vertical-align: -0.0833em;\"></span><span class=\"mord\">29</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mord\">%1000000007</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.6444em;\"></span><span class=\"mord\">1</span></span></span></span></span></p>\n<br/>\n<p><span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.8362em;\"></span><span class=\"mord\"><span class=\"mord text\"><span class=\"mord\">Character </span></span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.8362em;\"><span style=\"top: -3.1473em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.7519em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">:</span></span></span></span></span></p>\n<p><span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.8889em; vertical-align: -0.1944em;\"></span><span class=\"mord text\"><span class=\"mord\">Update hash:</span></span></span></span></span></span></p>\n<p><span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6944em;\"></span><span class=\"mord text\"><span class=\"mord\">hash</span></span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.7278em; vertical-align: -0.0833em;\"></span><span class=\"mord\">29</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mord\">%1000000007</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.6444em;\"></span><span class=\"mord\">30</span></span></span></span></span></p>\n<br/>\n<p>Continue this for all characters. After processing <code>\"aacecaaa\"</code>, let’s assume the final hash is <code>23456789</code> for this substring.</p>\n<p>We do a similar hash calculation for the reversed string <code>\"aaacecaa\"</code>. We compute the hash values for each prefix of the reversed string. Let’s assume the final hash of the reversed string is <code>34567890</code>.</p>\n<p>To compare substrings, we use a rolling hash. As we move the window of comparison along the combined string, we update the hash values based on the new and old characters entering and exiting the window. If the hash of a prefix of the original string matches the hash of a suffix of the reversed string, that prefix is palindromic. Now the comparison shows that the longest prefix of <code>\"aacecaaa\"</code> that matches a suffix of <code>\"aaacecaa\"</code> is <code>\"aacecaa\"</code>. This tells us that <code>\"aacecaa\"</code> is a palindromic segment. Now we identify the remaining part of the original string that extends beyond the palindromic prefix. For <code>\"aacecaaa\"</code>, the remaining part is <code>\"a\"</code>.</p>\n<p>So we reverse the remaining part (<code>\"a\"</code>) to get <code>\"a\"</code>, and prepend this reversed part to the original string.</p>\n<p>Thus the shortest palindrome is <code>\"aaacecaaa\"</code>.</p>\n<h4 id=\"algorithm-3\">Algorithm</h4>\n<ul>\n<li>\n<p>Initialize hash parameters:</p>\n<ul>\n<li>Set <code>hashBase</code> to 29 and <code>modValue</code> to <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.8974em; vertical-align: -0.0833em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.8141em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">9</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.6444em;\"></span><span class=\"mord\">7</span></span></span></span></span>.</li>\n<li>Initialize <code>forwardHash</code> and <code>reverseHash</code> to 0.</li>\n<li>Initialize <code>powerValue</code> to 1.</li>\n<li>Initialize <code>palindromeEndIndex</code> to -1.</li>\n</ul>\n</li>\n<li>\n<p>Iterate over each character <code>currentChar</code> in the string <code>s</code>:</p>\n<ul>\n<li>Update <code>forwardHash</code> to include the current character:\n<ul>\n<li>Compute <code>forwardHash</code> as <code>(forwardHash * hashBase + (currentChar - 'a' + 1)) % modValue</code>.</li>\n</ul>\n</li>\n<li>Update <code>reverseHash</code> to include the current character:\n<ul>\n<li>Compute <code>reverseHash</code> as <code>(reverseHash + (currentChar - 'a' + 1) * powerValue) % modValue</code>.</li>\n</ul>\n</li>\n<li>Update <code>powerValue</code> for the next character:\n<ul>\n<li>Compute <code>powerValue</code> as <code>(powerValue * hashBase) % modValue</code>.</li>\n</ul>\n</li>\n<li>If <code>forwardHash</code> matches <code>reverseHash</code>, update <code>palindromeEndIndex</code> to the current index <code>i</code>.</li>\n</ul>\n</li>\n<li>\n<p>After the loop, find the suffix that follows the longest palindromic prefix:</p>\n<ul>\n<li>Extract the suffix from the string <code>s</code> starting from <code>palindromeEndIndex + 1</code> to the end.</li>\n<li>Reverse the suffix to prepare for prepending.</li>\n</ul>\n</li>\n<li>\n<p>Concatenate the reversed suffix to the original string <code>s</code> and return the result:</p>\n<ul>\n<li>Return <code>reversedSuffix + s</code>.</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"implementation-3\">Implementation</h4>\n<pre><code>class Solution {\npublic:\n    string shortestPalindrome(string s) {\n        long long hashBase = 29;\n        long long modValue = 1e9 + 7;\n        long long forwardHash = 0, reverseHash = 0, powerValue = 1;\n        int palindromeEndIndex = -1;\n​\n        // Calculate rolling hashes and find the longest palindromic prefix\n        for (int i = 0; i &lt; s.length(); ++i) {\n            char currentChar = s[i];\n​\n            // Update forward hash\n            forwardHash =\n                (forwardHash * hashBase + (currentChar - 'a' + 1)) % modValue;\n​\n            // Update reverse hash\n            reverseHash =\n                (reverseHash + (currentChar - 'a' + 1) * powerValue) % modValue;\n            powerValue = (powerValue * hashBase) % modValue;\n​\n            // If forward and reverse hashes match, update palindrome end index\n            if (forwardHash == reverseHash) {\n                palindromeEndIndex = i;\n            }\n        }\n​\n        // Find the remaining suffix after the longest palindromic prefix\n        string suffix = s.substr(palindromeEndIndex + 1);\n        // Reverse the remaining suffix\n        string reversedSuffix(suffix.rbegin(), suffix.rend());\n​\n        // Prepend the reversed suffix to the original string and return the\n        // result\n        return reversedSuffix + s;\n    }\n};</code></pre>\n<h4 id=\"complexity-analysis-3\">Complexity Analysis</h4>\n<p>Let <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></span> be the length of the input string.</p>\n<ul>\n<li>\n<p>Time complexity: <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p>The algorithm performs a single pass over the input string to compute rolling hashes and determine the longest palindromic prefix, resulting in <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span> time complexity. This pass involves constant-time operations for each character, including hash updates and power calculations. After this, we perform an additional pass to reverse the suffix, which is also <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span>. The total time complexity remains <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n</li>\n<li>\n<p>Space complexity: <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p>The space complexity is determined by the space used for the reversed suffix and the additional string manipulations. The space required for the forward and reverse hash values, power value, and palindrome end index is constant and does not scale with input size. However, storing the reversed suffix and the final result string both require <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span> space. Thus, the space complexity is <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n</li>\n</ul>\n<hr/>\n<h3 class=\"group/heading relative\" id=\"approach-5-manachers-algorithm\" level=\"3\"><a aria-hidden=\"true\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" href=\"#approach-5-manachers-algorithm\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" data-icon=\"link\" data-prefix=\"fas\" focusable=\"false\" role=\"img\" spacing=\"square\" viewbox=\"0 0 640 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\" fill=\"currentColor\"></path></svg></div></a>Approach 5: Manacher's Algorithm</h3>\n<h4 id=\"intuition-4\">Intuition</h4>\n<blockquote>\n<p>Note: This algorithm goes beyond what's typically expected in coding interviews. It's more for those who are curious and eager to explore advanced algorithms, simply out of personal interest or a desire to deepen their understanding of data structures and algorithms. If you're someone who loves learning new concepts beyond interview prep, this approach might be for you! Sometimes this is the only algorithm that can give you an <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span> runtime.</p>\n</blockquote>\n<br/>\n<p>Developed to address the problem of finding palindromic substrings efficiently, Manacher’s algorithm preprocesses the string to handle both even and odd-length palindromes uniformly. By inserting special characters between each character of the original string, it computes the radius of the longest palindromic substring centered at each position.</p>\n<p>To handle palindromes of both even and odd lengths uniformly, the algorithm transforms the original string by inserting special characters (e.g., <code>\"#\"</code>) between every character and at the boundaries. This way, every palindrome can be treated as if it’s surrounded by characters, making it easier to apply the same expansion logic for all cases.</p>\n<p>For example, the string <code>\"aacecaaa\"</code> is transformed into <code>\"^#a#a#c#e#c#a#a#a#$\"</code>. Here, <code>^</code> and <code>$</code> are boundary markers that help avoid out-of-bound errors. <code>#</code> helps to treat the string uniformly, making every palindrome appear with a single center.</p>\n<p>Manacher’s algorithm maintains an array <code>P</code> where <code>P[i]</code> denotes the radius of the longest palindromic substring centered at the position <code>i</code> in the transformed string.</p>\n<br/>\n<p>We divide Manacher's algorithm into three steps to achieve linear time complexity:</p>\n<ol>\n<li data-length=\"1\">\n<p>Center and Right Boundary: We track the center <code>C</code> and right boundary <code>R</code> of the rightmost palindrome found so far. For each position <code>i</code>, we check if it falls within the current right boundary. If it does, we use previously computed information to estimate the length of the palindrome centered at <code>i</code>.</p>\n</li>\n<li data-length=\"1\">\n<p>Mirror Property: If a position <code>i</code> is within the right boundary of a known palindrome, we can infer the length of the palindrome centered at <code>i</code> from its mirrored position relative to the current center <code>C</code>. This way we reduce the need for direct expansion by leveraging previously computed palindromes to quickly estimate lengths.</p>\n</li>\n<li data-length=\"1\">\n<p>Expand Around Center: For positions where the estimated palindrome length based on the mirror property is not accurate, we perform direct expansion to find the exact length of the palindrome centered at <code>i</code>. We update the center and right boundary if the newly found palindrome extends beyond the current right boundary.</p>\n</li>\n</ol>\n<br/>\n<p>After computing the array <code>P</code>, we can determine the longest palindromic prefix of the original string. The longest palindromic substring in the transformed string that corresponds to a prefix of the original string gives us the longest palindromic prefix.</p>\n<p>To form the shortest palindrome, identify the part of the original string that does not contribute to this longest palindromic prefix. Reverse this non-matching segment and prepend it to the original string.</p>\n<p>With the string <code>\"aacecaaa\"</code>, after preprocessing to <code>\"#a#a#c#e#c#a#a#a#\"</code>, Manacher’s algorithm identifies <code>\"aacecaaa\"</code> as the longest palindromic prefix. Reversing the remaining part (<code>\"a\"</code>) and prepending it results in <code>\"aaacecaaa\"</code>.</p>\n<p>We highly recommend solving the <a href=\"https://leetcode.com/problems/longest-palindromic-substring/editorial/\" target=\"_blank\">longest palindromic substring problem using Manacher’s algorithm</a>. It is extremely efficient and ideal for solving palindrome-related problems.</p>\n<p>This algorithm is complex, so review various sources to gain a better understanding. It's normal if you don’t grasp it right away, so give yourself time.</p>\n<h4 id=\"algorithm-4\">Algorithm</h4>\n<ul>\n<li><code>shortestPalindrome</code> function:\n<ul>\n<li>\n<p>If the input string <code>s</code> is null or empty, return <code>s</code> immediately.</p>\n</li>\n<li>\n<p>Preprocess the string <code>s</code> by calling <code>preprocessString(s)</code> to handle edge cases and simplify palindrome detection.</p>\n<ul>\n<li><code>preprocessString</code> function:\n<ul>\n<li>Initialize a string with a starting character <code>^</code>.</li>\n<li>Append a <code>#</code> followed by each character in <code>s</code> to string.</li>\n<li>Append a trailing <code>#</code> and a dollar sign to complete the modified string.</li>\n<li>Return the modified string which includes special boundary characters.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>Initialize an integer array <code>palindromeRadiusArray</code> to store the radius of the palindrome centered at each character in the modified string.</p>\n</li>\n<li>\n<p>Initialize <code>center</code> and <code>rightBoundary</code> to track the center and right boundary of the current longest palindrome found.</p>\n</li>\n<li>\n<p>Initialize <code>maxPalindromeLength</code> to track the length of the longest palindrome that touches the start of the string.</p>\n</li>\n<li>\n<p>Iterate through each character <code>i</code> in the modified string (excluding the boundary characters):</p>\n<ul>\n<li>Calculate the <code>mirrorIndex</code> as <code>2 * center - i</code> to utilize previously computed palindromes.</li>\n<li>If <code>rightBoundary</code> is greater than <code>i</code>, update <code>palindromeRadiusArray[i]</code> to the minimum of the remaining length to the <code>rightBoundary</code> or the radius of the palindrome at <code>mirrorIndex</code>.</li>\n<li>Expand around the center <code>i</code> while the characters match and update <code>palindromeRadiusArray[i]</code> accordingly.</li>\n<li>If the expanded palindrome extends beyond <code>rightBoundary</code>, update <code>center</code> and <code>rightBoundary</code> to the new values.</li>\n<li>If the palindrome touches the start of the string (<code>i - palindromeRadiusArray[i] == 1</code>), update <code>maxPalindromeLength</code> with the maximum length found.</li>\n</ul>\n</li>\n<li>\n<p>Extract the suffix of the original string starting from <code>maxPalindromeLength</code> and reverse it.</p>\n</li>\n<li>\n<p>Concatenate the reversed suffix with the original string and return the result.</p>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"implementation-4\">Implementation</h4>\n<pre><code>class Solution {\npublic:\n    string shortestPalindrome(string s) {\n        // Return early if the string is null or empty\n        if (s.empty()) {\n            return s;\n        }\n​\n        // Preprocess the string to handle palindromes uniformly\n        string modifiedString = preprocessString(s);\n        int n = modifiedString.size();\n        vector&lt;int&gt; palindromeRadiusArray(n, 0);\n        int center = 0, rightBoundary = 0;\n        int maxPalindromeLength = 0;\n​\n        // Iterate through each character in the modified string\n        for (int i = 1; i &lt; n - 1; ++i) {\n            int mirrorIndex = 2 * center - i;\n​\n            // Use previously computed values to avoid redundant calculations\n            if (rightBoundary &gt; i) {\n                palindromeRadiusArray[i] =\n                    min(rightBoundary - i, palindromeRadiusArray[mirrorIndex]);\n            }\n​\n            // Expand around the current center while characters match\n            while (modifiedString[i + 1 + palindromeRadiusArray[i]] ==\n                   modifiedString[i - 1 - palindromeRadiusArray[i]]) {\n                ++palindromeRadiusArray[i];\n            }\n​\n            // Update the center and right boundary if the palindrome extends\n            // beyond the current boundary\n            if (i + palindromeRadiusArray[i] &gt; rightBoundary) {\n                center = i;\n                rightBoundary = i + palindromeRadiusArray[i];\n            }\n​\n            // Update the maximum length of palindrome starting at the\n            // beginning\n            if (i - palindromeRadiusArray[i] == 1) {\n                maxPalindromeLength =\n                    max(maxPalindromeLength, palindromeRadiusArray[i]);\n            }\n        }\n​\n        // Construct the shortest palindrome by reversing the suffix and\n        // prepending it to the original string\n        string suffix = s.substr(maxPalindromeLength);\n        reverse(suffix.begin(), suffix.end());\n        return suffix + s;\n    }\n​\nprivate:\n    string preprocessString(const string&amp; s) {\n        // Add boundaries and separators to handle palindromes uniformly\n        string result = \"^\";\n        for (char c : s) {\n            result += \"#\" + string(1, c);\n        }\n        result += \"#$\";\n        return result;\n    }\n};</code></pre>\n<h4 id=\"complexity-analysis-4\">Complexity Analysis</h4>\n<p>Let <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></span> be the length of the input string.</p>\n<ul>\n<li>\n<p>Time complexity: <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p>The <code>preprocessString</code> method adds boundaries and separators to the input string. This takes linear time, <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span>, where <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></span> is the length of the input string.</p>\n<p>The core algorithm iterates through the characters of the modified string once. The expansion step and the updates of the center and right boundary each take constant time in the average case for each character. Thus, this step has a time complexity of <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">m</span><span class=\"mclose\">)</span></span></span></span></span>, where <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.4306em;\"></span><span class=\"mord mathnormal\">m</span></span></span></span></span> is the length of the modified string.</p>\n<p>Since the length of the modified string is <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.7278em; vertical-align: -0.0833em;\"></span><span class=\"mord\">2</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right: 0.1667em;\"></span><span class=\"mopen\">(</span><span class=\"mord text\"><span class=\"mord\">for separators</span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right: 0.1667em;\"></span><span class=\"mopen\">(</span><span class=\"mord text\"><span class=\"mord\">for boundaries</span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.7278em; vertical-align: -0.0833em;\"></span><span class=\"mord\">2</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.6444em;\"></span><span class=\"mord\">3</span></span></span></span></span> , the time complexity of Manacher's algorithm is <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n<p>Constructing the result involves reversing the suffix of the original string and concatenating it with the original string, both of which take linear time, <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n<p>Combining these steps, the total time complexity is <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n</li>\n<li>\n<p>Space complexity: <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p>The space used to store the modified string is proportional to its length, which is <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.7278em; vertical-align: -0.0833em;\"></span><span class=\"mord\">2</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.6444em;\"></span><span class=\"mord\">3</span></span></span></span></span>. Therefore, the space complexity for storing this string is <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n<p>The <code>palindromeRadiusArray</code> is used to store the radius of palindromes for each character in the modified string, which is <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">m</span><span class=\"mclose\">)</span></span></span></span></span>. Since <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.4306em;\"></span><span class=\"mord mathnormal\">m</span></span></span></span></span> is <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.7278em; vertical-align: -0.0833em;\"></span><span class=\"mord\">2</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.6444em;\"></span><span class=\"mord\">3</span></span></span></span></span>, the space complexity for this array is <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n<p>The additional space used for temporary variables, and other operations is constant, <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n<p>Combining these factors, the total space complexity is <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n</li>\n</ul>\n<hr/></div><span style=\"font-size: 0px; line-height: 0;\"> </span></div>"}