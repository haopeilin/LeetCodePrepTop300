{"id":"145","title":"Binary Tree Postorder Traversal","difficulty":"Easy","content":"<p>Given the <code>root</code> of a&nbsp;binary tree, return <em>the postorder traversal of its nodes&#39; values</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">root = [1,null,2,3]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">[3,2,1]</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2024/08/29/screenshot-2024-08-29-202743.png\" style=\"width: 200px; height: 264px;\" /></p>\n</div>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">root = [1,2,3,4,5,null,8,null,null,6,7,9]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">[4,6,7,5,2,9,8,3,1]</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2024/08/29/tree_2.png\" style=\"width: 350px; height: 286px;\" /></p>\n</div>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">root = []</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">[]</span></p>\n</div>\n\n<p><strong class=\"example\">Example 4:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">root = [1]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">[1]</span></p>\n</div>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of the nodes in the tree is in the range <code>[0, 100]</code>.</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> Recursive solution is trivial, could you do it iteratively?","tags":["Stack","Tree","Depth-First Search","Binary Tree"],"java_snippet":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public List<Integer> postorderTraversal(TreeNode root) {\n        \n    }\n}","solution":"<h2><a href=\"#solution\"><svg><path></path></svg></a>Solution</h2>\n<hr/>\n<h3><a href=\"#overview\"><svg><path></path></svg></a>Overview</h3>\n<p>To traverse a tree, we use two main strategies:</p>\n<ul>\n<li>\n<p>Breadth-First Search (BFS): This strategy involves scanning the tree level by level from the top down, visiting nodes at higher levels before those at lower levels.</p>\n</li>\n<li>\n<p>Depth-First Search (DFS): This approach explores as far down a branch as possible before backtracking. It starts at the root, proceeds to a leaf, and then returns to explore other branches. DFS can be further categorized into:</p>\n<ul>\n<li>Preorder: Visit the root first, then the left subtree, followed by the right subtree.</li>\n<li>Inorder: Visit the left subtree first, then the root, and then the right subtree.</li>\n<li>Postorder: Visit the left subtree first, then the right subtree, and finally the root.</li>\n</ul>\n</li>\n</ul>\n<p><br/>\n<em>Figure 1. Nodes are numbered in the order they are visited; refer to the sequence <code>1-2-3-4-5</code> to compare different traversal strategies.</em></p>\n<p>For a binary tree with the root <code>[1, null, 2, 3]</code>, the tree structure is as follows:</p>\n<svg><path></path></svg>\n<p>In Postorder traversal, nodes are visited in the sequence: <code>3</code> (left subtree), <code>2</code> (right subtree), and finally <code>1</code> (root). Thus, the output for this input should be <code>[3, 2, 1]</code>.</p>\n<hr/>\n<h3><a href=\"#approach-1-recursive-postorder-traversal\"><svg><path></path></svg></a>Approach 1: Recursive Postorder Traversal</h3>\n<h4>Intuition</h4>\n<p><br/>\n<em>Figure 2. Recursive DFS traversals.</em></p>\n<p>In this approach, we treat each node as the root of its subtree. We start by recursively traversing the left subtree. If the left child is not null, we continue exploring until the left subtree is fully traversed. Then, we move to the right subtree and repeat the process. After both subtrees are explored, we process the current node by adding its value to the result list.</p>\n<p>The base case occurs when the current node is null, indicating no further subtree to explore. At this point, we simply return and backtrack.</p>\n<h4>Algorithm</h4>\n<ol>\n<li>Define a helper function <code>postorderTraversalHelper</code>:\n<ul>\n<li>If <code>currentNode</code> is <code>null</code>, return to stop further recursion.</li>\n<li>Recursively call <code>postorderTraversalHelper</code> with <code>currentNode.left</code> to process the left subtree.</li>\n<li>Recursively call <code>postorderTraversalHelper</code> with <code>currentNode.right</code> to process the right subtree.</li>\n<li>Append <code>currentNode.val</code> to the <code>result</code> list to collect values in postorder.</li>\n</ul>\n</li>\n<li>In the <code>postorderTraversal</code> function:\n<ul>\n<li>Initialize an empty <code>result</code> list to store the postorder ordering of the nodes in <code>root</code>.</li>\n<li>Call <code>postorderTraversalHelper</code> with the root node and <code>result</code> to start the traversal.</li>\n<li>Return the <code>result</code> list containing the postorder traversal.</li>\n</ul>\n</li>\n</ol>\n<h4>Implementation</h4>\n<pre><code>/**\n * Definition for a binary tree node.\n */\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) {\n        val = x;\n        left = null;\n        right = null;\n    }\n}\n\nclass Solution {\n    public void postorderTraversalHelper(TreeNode currentNode, List&lt;Integer&gt; result) {\n        // Base case: if the node is null, return\n        if (currentNode == null) {\n            return;\n        }\n        // Traverse left subtree\n        postorderTraversalHelper(currentNode.left, result);\n        // Traverse right subtree\n        postorderTraversalHelper(currentNode.right, result);\n        // Add the current node's value to the result list\n        result.add(currentNode.val);\n    }\n\n    public List&lt;Integer&gt; postorderTraversal(TreeNode root) {\n        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();\n        // Start traversal from root\n        postorderTraversalHelper(root, result);\n        return result;\n    }\n}</code></pre>\n<h4>Complexity Analysis</h4>\n<p>Let n be the number of nodes.</p>\n<ul>\n<li>\n<p>Time complexity: O(n)</p>\n<p>Each node is visited once during the traversal, so the time complexity is linear with respect to the number of nodes <code>n</code>.</p>\n</li>\n<li>\n<p>Space complexity: O(n)</p>\n<p>The space complexity is O(n) due to the recursion stack. In the worst case (e.g., a completely unbalanced tree), the recursion stack could hold all <code>n</code> nodes.</p>\n</li>\n</ul>\n<hr/>\n<h3><a href=\"#approach-2-manipulating-preorder-traversal-iterative-hack\"><svg><path></path></svg></a>Approach 2: Manipulating Preorder Traversal (Iterative Hack)</h3>\n<h4>Intuition</h4>\n<p>Let's take a creative leap in this approach by exploiting the relationship between preorder and postorder traversals. In a standard preorder traversal, we visit the root node before we visit the left and right subtrees. However, postorder traversal requires us to visit the left and right subtrees before the root node.</p>\n<p>We can adapt the preorder traversal by visiting nodes in the order of root, right subtree, and then left subtree. Reversing the resulting list from this modified preorder traversal gives us the correct postorder sequence.</p>\n<p>We use a stack to traverse the tree iteratively, starting with the root node. We push the current node onto the stack and add its value to the result list. Instead of moving to the left child, we move to the right child. If there's no right child, we pop a node from the stack and move to its left child. This approach processes the right subtree before the left subtree, aligning with the modified preorder traversal.</p>\n<p>After traversing the entire tree, we reverse the result list to get the postorder sequence: left subtree, right subtree, root.</p>\n<h4>Algorithm</h4>\n<ol>\n<li>Initialize an empty <code>result</code> list to store the traversal result, a <code>traversalStack</code> for nodes, and set <code>currentNode</code> to <code>root</code>.</li>\n<li>While <code>currentNode</code> is not <code>null</code> or <code>traversalStack</code> is not empty:\n<ul>\n<li>If <code>currentNode</code> is not <code>null</code>, add <code>currentNode.val</code> to the <code>result</code> list before processing its children.</li>\n<li>Push <code>currentNode</code> onto the <code>traversalStack</code> to revisit it later.</li>\n<li>Move <code>currentNode</code> to <code>currentNode.right</code> to continue traversal in the right subtree.</li>\n<li>If <code>currentNode</code> is <code>null</code>, pop the top node from <code>traversalStack</code> and set it to <code>currentNode</code>.</li>\n<li>Move <code>currentNode</code> to <code>currentNode.left</code> to process the left subtree.</li>\n</ul>\n</li>\n<li>Reverse the <code>result</code> list to correct the order from preorder to postorder.</li>\n<li>Return the <code>result</code> list with postorder traversal values.</li>\n</ol>\n<h4>Implementation</h4>\n<pre><code>/**\n * Definition for a binary tree node.\n */\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) {\n        val = x;\n        left = null;\n        right = null;\n    }\n}\n\nclass Solution {\n    public List&lt;Integer&gt; postorderTraversal(TreeNode root) {\n        // List to store the result of postorder traversal\n        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();\n        // Stack to facilitate the traversal of nodes\n        Deque&lt;TreeNode&gt; traversalStack = new ArrayDeque&lt;&gt;();\n        TreeNode currentNode = root;\n\n        // Traverse the tree while there are nodes to process\n        while (currentNode != null || !traversalStack.isEmpty()) {\n            if (currentNode != null) {\n                // Add current node's value to result list before going to its children\n                result.add(currentNode.val);\n                // Push current node onto the stack\n                traversalStack.push(currentNode);\n                // Move to the right child\n                currentNode = currentNode.right;\n            } else {\n                // Pop the node from the stack and move to its left child\n                currentNode = traversalStack.pop();\n                currentNode = currentNode.left;\n            }\n        }\n        // Reverse the result list to get the correct postorder sequence\n        Collections.reverse(result);\n        return result;\n    }\n}</code></pre>\n<h4>Complexity Analysis</h4>\n<p>Let n be the number of nodes.</p>\n<ul>\n<li>\n<p>Time complexity: O(n)</p>\n<p>Each node is processed a constant number of times (essentially twice), so the time complexity remains linear with respect to <code>n</code>.</p>\n</li>\n<li>\n<p>Space complexity: O(n)</p>\n<p>The space complexity is O(2n)=O(n) due to the stack used for traversing the tree nodes. This stack could hold up to <code>n</code> nodes in the worst case.</p>\n</li>\n</ul>\n<hr/>\n<h3><a href=\"#approach-3-two-stack-postorder-traversal-iterative\"><svg><path></path></svg></a>Approach 3: Two Stack Postorder Traversal (Iterative)</h3>\n<h4>Intuition</h4>\n<p>Instead of relying on hacks and tricks, this time we will build on the idea that we need to control the order in which nodes are processed to achieve postorder traversal.</p>\n<p>To achieve postorder traversal without recursion, we use two stacks to control the node processing order systematically.</p>\n<p>First, we push the root node onto the first stack. This stack simulates the recursive traversal of the tree. To process nodes in postorder (left-right-root), we need a second stack to reverse the order. As we pop nodes from the first stack, we push them onto the second stack. This reversal ensures that nodes are processed in the correct order.</p>\n<p>After all nodes are transferred to the second stack, popping from it gives us the nodes in postorder sequence. This method efficiently achieves the desired traversal order by leveraging the two stacks to manage the processing sequence without needing a final reversal step.</p>\n<p>In summary, the two-stack approach uses the first stack for tree traversal and the second stack to reverse the order, resulting in a postorder traversal. Despite initially seeming like a manipulation of preorder traversal, the final order of nodes from the second stack aligns with postorder traversal.</p>\n<h4>Algorithm</h4>\n<ol>\n<li>Initialize an empty <code>result</code> list, and create <code>mainStack</code> and <code>pathStack</code> for nodes.</li>\n<li>Check if <code>root</code> is <code>null</code>; if so, return <code>result</code> immediately, indicating there are no nodes to process.</li>\n<li>Push <code>root</code> onto <code>mainStack</code> to start the traversal.</li>\n<li>While <code>mainStack</code> is not empty:\n<ul>\n<li>Peek at the top of <code>mainStack</code> to examine the current node.</li>\n<li>If the top of <code>pathStack</code> is the same as the top of <code>mainStack</code>, add <code>root.val</code> to the <code>result</code> list.</li>\n<li>Pop the top node from both <code>mainStack</code> and <code>pathStack</code> after processing.</li>\n<li>Otherwise, push the current node onto <code>pathStack</code>.</li>\n<li>Push <code>root.right</code> and <code>root.left</code> onto <code>mainStack</code> if they exist to process their children.</li>\n</ul>\n</li>\n<li>Return the <code>result</code> list containing postorder traversal values.</li>\n</ol>\n<h4>Implementation</h4>\n<pre><code>/**\n * Definition for a binary tree node.\n */\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) {\n        val = x;\n        left = null;\n        right = null;\n    }\n}\n\nclass Solution {\n    public List&lt;Integer&gt; postorderTraversal(TreeNode root) {\n        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();\n\n        // If the root is null, return an empty list\n        if (root == null) {\n            return result;\n        }\n\n        // Stack to manage the traversal\n        Deque&lt;TreeNode&gt; mainStack = new ArrayDeque&lt;&gt;();\n        // Stack to manage the path\n        Deque&lt;TreeNode&gt; pathStack = new ArrayDeque&lt;&gt;();\n\n        // Start with the root node\n        mainStack.push(root);\n\n        // Process nodes until the main stack is empty\n        while (!mainStack.isEmpty()) {\n            root = mainStack.peek();\n\n            // If the node is in the path stack and it's the top, add its value\n            if (!pathStack.isEmpty() &amp;&amp; pathStack.peek() == root) {\n                result.add(root.val);\n                mainStack.pop();\n                pathStack.pop();\n            } else {\n                // Push the current node to the path stack\n                pathStack.push(root);\n                // Push right child if it exists\n                if (root.right != null) {\n                    mainStack.push(root.right);\n                }\n                // Push left child if it exists\n                if (root.left != null) {\n                    mainStack.push(root.left);\n                }\n            }\n        }\n\n        return result;\n    }\n}</code></pre>\n<h4>Complexity Analysis</h4>\n<p>Let n be the number of nodes.</p>\n<ul>\n<li>\n<p>Time complexity: O(n)</p>\n<p>Each node is processed a constant number of times (once when pushed to the first stack and once when popped to the second stack), so the time complexity is linear with respect to <code>n</code>.</p>\n</li>\n<li>\n<p>Space complexity: O(n)</p>\n<p>The space complexity is O(n) due to the use of two stacks. Each stack can hold up to <code>n</code> nodes in the worst case.</p>\n</li>\n</ul>\n<hr/>\n<h3><a href=\"#approach-4-single-stack-postorder-traversal-iterative\"><svg><path></path></svg></a>Approach 4: Single Stack Postorder Traversal (Iterative)</h3>\n<h4>Intuition</h4>\n<p>After exploring the two-stack approach, we might seek to optimize further by reducing space complexity. While two stacks effectively manage traversal order, they double our space usage. Instead, we can use a single stack combined with a <code>previousNode</code> reference to track the traversal.</p>\n<p>We start by pushing nodes onto the stack while traversing left, similar to inorder traversal. In postorder traversal, we must process each node after its right subtree. To manage this, the <code>previousNode</code> reference helps remember the last processed node.</p>\n<p>When a node is reached on the stack, we first check if it has an unvisited right child. If so, we move to that right child since we can't process the current node until after its right subtree. If the node has no right child or its right child has already been processed (indicated by <code>previousNode</code>), we process the node by popping it from the stack and adding its value to the result list, then update <code>previousNode</code> to this node.</p>\n<h4>Algorithm</h4>\n<ol>\n<li>Initialize an empty <code>result</code> list, set <code>previousNode</code> to <code>null</code>, and initialize <code>traversalStack</code>.</li>\n<li>Check if <code>root</code> is <code>null</code>; if so, return <code>result</code> immediately, indicating there are no nodes to process.</li>\n<li>While <code>root</code> is not <code>null</code> or <code>traversalStack</code> is not empty:\n<ul>\n<li>If <code>root</code> is not <code>null</code>, push <code>root</code> onto <code>traversalStack</code>.</li>\n<li>Move <code>root</code> to <code>root.left</code> to process the left subtree.</li>\n<li>If <code>root</code> is <code>null</code>, peek at the top of <code>traversalStack</code>.</li>\n<li>If <code>root.right</code> is <code>null</code> or <code>root.right</code> equals <code>previousNode</code>, add <code>root.val</code> to <code>result</code>.</li>\n<li>Pop <code>root</code> from <code>traversalStack</code>, set <code>previousNode</code> to <code>root</code>, and set <code>root</code> to <code>null</code>.</li>\n<li>If <code>root.right</code> is not <code>null</code>, move <code>root</code> to <code>root.right</code> to continue the traversal.</li>\n</ul>\n</li>\n<li>Return the <code>result</code> list containing postorder traversal values.</li>\n</ol>\n<h4>Implementation</h4>\n<pre><code>/**\n * Definition for a binary tree node.\n */\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) {\n        val = x;\n        left = null;\n        right = null;\n    }\n}\n\nclass Solution {\n    public List&lt;Integer&gt; postorderTraversal(TreeNode root) {\n        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();\n\n        // If the root is null, return an empty list\n        if (root == null) {\n            return result;\n        }\n\n        // To keep track of the previously processed node\n        TreeNode previousNode = null;\n        // Stack to manage the traversal\n        Deque&lt;TreeNode&gt; traversalStack = new ArrayDeque&lt;&gt;();\n\n        // Process nodes until both the root is null and the stack is empty\n        while (root != null || !traversalStack.isEmpty()) {\n            // Traverse to the leftmost node\n            if (root != null) {\n                traversalStack.push(root);\n                root = root.left;\n            } else {\n                // Peek at the top node of the stack\n                root = traversalStack.peek();\n\n                // If there is no right child or the right child was already processed\n                if (root.right == null || root.right == previousNode) {\n                    result.add(root.val);\n                    traversalStack.pop();\n                    previousNode = root;\n                    root = null; // Ensure we don’t traverse again from this node\n                } else {\n                    // Move to the right child\n                    root = root.right;\n                }\n            }\n        }\n\n        return result;\n    }\n}</code></pre>\n<h4>Complexity Analysis</h4>\n<p>Let n be the number of nodes.</p>\n<ul>\n<li>\n<p>Time complexity: O(n)</p>\n<p>Each node is processed a constant number of times. The stack operations and reference manipulations also contribute to a linear time complexity with respect to <code>n</code>.</p>\n</li>\n<li>\n<p>Space complexity: O(n)</p>\n<p>Although this approach uses only a single stack, in the worst case, the stack can still hold up to <code>n</code> nodes, so the space complexity remains O(n). However, this approach optimizes the space usage compared to using two stacks.</p>\n</li>\n</ul>\n<hr/>\n<h3><a href=\"#approach-5-morris-traversal-no-stack\"><svg><path></path></svg></a>Approach 5: Morris Traversal (No stack)</h3>\n<h4>Intuition</h4>\n<p>All the approaches so far have been using some auxiliary space. To optimize for space complexity, we can use a traversal algorithm called Morris traversal. In Morris traversal, the tree structure is temporarily modified to create temporary links that simulate the effect of a stack or recursion. As a result, there is no overhead from additional data structures and the space complexity is constant. This traversal is tricky to understand at first, but the high level idea is to link each predecessor back to the current node, which allows us to trace back to the top of the tree. We encourage you to simulate the traversal on a piece of paper to get a stronger understanding.</p>\n<p>In setting up Morris traversal, we introduce a <code>dummyNode</code> with a value that is not part of the original tree and link it to the root. Our traversal begins with this dummyNode, treating it as the new root of the tree.</p>\n<p>For each node, we look for its in-order predecessor, the rightmost node in its left subtree. We do this so that the in-order predecessor can be used to create a temporary link back to the current node, simulating the recursive call stack.</p>\n<ul>\n<li>If the current node has a left child, we find the rightmost node in the left subtree. This rightmost node is the in-order predecessor.</li>\n<li>We then create a temporary link from this predecessor to the current node by setting its right reference to the current node.</li>\n</ul>\n<p>If the predecessor’s right reference is <code>null</code>, set it to point to the current node and move to the left child. This simulates the recursive call by allowing us to return to the current node after processing the left subtree.</p>\n<p>When a node’s predecessor’s right reference points back to the current node, it indicates the left subtree is processed. Process the current node and reverse the temporary link to restore the tree’s structure.</p>\n<p>Finally, move to the right child and continue the traversal.</p>\n<p>Morris traversal operates in O(n) time because finding the predecessor is not done for every node but only for nodes with a valid left child.</p>\n<blockquote>\n<p>Note: Morris traversal may be a surprise topic in interviews. It’s useful to know but not always the main focus; prioritize understanding basic traversal methods first.</p>\n</blockquote>\n<h4>Algorithm</h4>\n<ol>\n<li>Initialize an empty <code>result</code> list and create a dummy node with the value <code>-1</code>. Set <code>dummyNode.left</code> to <code>root</code> and update <code>root</code> to <code>dummyNode</code>.</li>\n<li>Check if <code>root</code> is <code>null</code>; if so, return <code>result</code> immediately, indicating there are no nodes to process.</li>\n<li>While <code>root</code> is not <code>null</code>:\n<ul>\n<li>If <code>root.left</code> is not <code>null</code>, find the rightmost node (predecessor) in the <code>root.left</code> subtree.</li>\n<li>If the right child of the predecessor is <code>null</code>, set the right child to <code>root</code> and move <code>root</code> to <code>root.left</code>.</li>\n<li>If the right child of the predecessor is <code>root</code>, perform reverse traversal of the <code>root.left</code> subtree and add values to <code>result</code>.</li>\n<li>Reverse the subtree back to its original state by restoring references.</li>\n<li>Remove the temporary link from the predecessor to <code>root</code> and move <code>root</code> to <code>root.right</code>.</li>\n<li>If <code>root.left</code> is <code>null</code>, move <code>root</code> to <code>root.right</code>.</li>\n</ul>\n</li>\n<li>Return the <code>result</code> list containing postorder traversal values.</li>\n</ol>\n<h4>Implementation</h4>\n<pre><code>/**\n * Definition for a binary tree node.\n */\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) {\n        val = x;\n        left = null;\n        right = null;\n    }\n}\n\nclass Solution {\n    public List&lt;Integer&gt; postorderTraversal(TreeNode root) {\n        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();\n\n        // If the root is null, return an empty list\n        if (root == null) {\n            return result;\n        }\n\n        // Create a dummy node to simplify edge cases\n        TreeNode dummyNode = new TreeNode(-1);\n        TreeNode predecessor;\n        dummyNode.left = root;\n        root = dummyNode;\n\n        // Traverse the tree\n        while (root != null) {\n            // If the current node has a left child\n            if (root.left != null) {\n                predecessor = root.left;\n\n                // Find the rightmost node in the left subtree or the thread back to the current node\n                while (predecessor.right != null &amp;&amp; predecessor.right != root) {\n                    predecessor = predecessor.right;\n                }\n\n                // Create a thread if it doesn't exist\n                if (predecessor.right == null) {\n                    predecessor.right = root;\n                    root = root.left;\n                } else {\n                    // Process the nodes in the left subtree\n                    TreeNode node = predecessor;\n                    reverseSubtreeLinks(root.left, predecessor);\n\n                    // Add nodes from right to left\n                    while (node != root.left) {\n                        result.add(node.val);\n                        node = node.right;\n                    }\n\n                    result.add(node.val); // Add root.left's value\n                    reverseSubtreeLinks(predecessor, root.left);\n                    predecessor.right = null;\n                    root = root.right;\n                }\n            } else {\n                // Move to the right child if there's no left child\n                root = root.right;\n            }\n        }\n\n        return result;\n    }\n\n    private void reverseSubtreeLinks(TreeNode startNode, TreeNode endNode) {\n        if (startNode == endNode) {\n            return; // No need to reverse if start and end are the same\n        }\n\n        TreeNode prev = null;\n        TreeNode current = startNode;\n        TreeNode next;\n\n        // Reverse the direction of the references in the subtree\n        while (current != endNode) {\n            next = current.right;\n            current.right = prev;\n            prev = current;\n            current = next;\n        }\n\n        // Reverse the last node\n        current.right = prev;\n    }\n}</code></pre>\n<h4>Complexity Analysis</h4>\n<p>Let n be the number of nodes.</p>\n<ul>\n<li>\n<p>Time complexity: O(n)</p>\n<p>Each node is visited a constant number of times, and the traversal through the tree is linear in terms of <code>n</code>.</p>\n</li>\n<li>\n<p>Space complexity: O(1)</p>\n<p>The Morris Traversal technique uses no extra space beyond the references used for traversal. The temporary modifications to the tree structure are reversed before the traversal ends, so the space complexity is constant.</p>\n</li>\n</ul>\n<hr/>"}