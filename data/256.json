{"id":"256","title":"Paint House","difficulty":"Medium","content":"<p>There is a row of <code>n</code> houses, where each house can be painted one of three colors: red, blue, or green. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color.</p>\n\n<p>The cost of painting each house with a certain color is represented by an <code>n x 3</code> cost matrix <code>costs</code>.</p>\n\n<ul>\n\t<li>For example, <code>costs[0][0]</code> is the cost of painting house <code>0</code> with the color red; <code>costs[1][2]</code> is the cost of painting house 1 with color green, and so on...</li>\n</ul>\n\n<p>Return <em>the minimum cost to paint all houses</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> costs = [[17,2,17],[16,16,5],[14,3,19]]\n<strong>Output:</strong> 10\n<strong>Explanation:</strong> Paint house 0 into blue, paint house 1 into green, paint house 2 into blue.\nMinimum cost: 2 + 5 + 3 = 10.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> costs = [[7,6,2]]\n<strong>Output:</strong> 2\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>costs.length == n</code></li>\n\t<li><code>costs[i].length == 3</code></li>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li><code>1 &lt;= costs[i][j] &lt;= 20</code></li>\n</ul>\n","tags":["Array","Dynamic Programming"],"java_snippet":"class Solution {\n    public int minCost(int[][] costs) {\n        \n    }\n}","solution":"<div class=\"flex flex-col w-full\" style=\"position: relative;\"><div class=\"mYe_l WRmCx\"><h2 class=\"group/heading relative\" id=\"solution\" level=\"2\"><a aria-hidden=\"true\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" href=\"#solution\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" data-icon=\"link\" data-prefix=\"fas\" focusable=\"false\" role=\"img\" spacing=\"square\" viewbox=\"0 0 640 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\" fill=\"currentColor\"></path></svg></div></a>Solution</h2>\n<p>For those already familiar with memoization and dynamic programming, this question will be easy. For those who are very new to Leetcoding, it might seem like a medium, or even a hard. <em><strong>For those who are starting to learn about memoization and dynamic programming, this question is a great one for getting started</strong></em>!</p>\n<p>This article is aimed at those of you getting started with dynamic programming and memoization. I’ll assume you have already worked through prerequisite concepts such as n-ary trees (or binary trees), including with recursion. If you haven’t, then I strongly recommend that you come back to this question after working through either the <a href=\"https://leetcode.com/explore/learn/card/n-ary-tree/\" target=\"_blank\">N-ary Trees module</a> or the <a href=\"https://leetcode.com/explore/learn/card/data-structure-tree/\" target=\"_blank\">Binary Trees module</a>. The intuition behind memoization and dynamic programming is best understood using trees, so that is what I’ve done in this article. Understanding how to recognize and then approach memoization and dynamic programming problems is essential for interview success.</p>\n<br/>\n<hr/>\n<h3 class=\"group/heading relative\" id=\"approach-1-brute-force\" level=\"3\"><a aria-hidden=\"true\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" href=\"#approach-1-brute-force\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" data-icon=\"link\" data-prefix=\"fas\" focusable=\"false\" role=\"img\" spacing=\"square\" viewbox=\"0 0 640 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\" fill=\"currentColor\"></path></svg></div></a>Approach 1: Brute force</h3>\n<p><strong>Intuition</strong></p>\n<p>The brute force approach is often a good place to start. From there, we can identify unnecessary work and further optimize. In this case, the brute force algorithm would be to generate every valid permutation of house colors (or all permutations and then remove all the invalid ones, e.g. ones that have 2 red houses side-by-side) and score them. Then, the lowest score is the value we need to return.</p>\n<p>For this article, we'll use the following input. It is for 4 houses.</p>\n<div class=\"font-menlo mb-6 rounded-lg px-3 py-2.5 text-sm bg-fill-3 dark:bg-dark-fill-3\"><div class=\"group relative\" translate=\"no\"><pre style=\"color: black; font-size: 13px; text-shadow: none; font-family: Menlo, Monaco, Consolas; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 4; hyphens: none; padding: 0px; margin: 0px; overflow: auto; background: transparent; overflow-wrap: normal;\"><code style=\"white-space: pre; text-shadow: none;\"><span><span>[[17, 2, 17], [8, 4, 10], [6, 3, 19], [4, 8, 12]]</span></span></code></pre><div class=\"absolute -right-1.5 -top-0.5 flex gap-2\"><div class=\"z-base-1 hidden rounded border group-hover:block border-border-quaternary dark:border-border-quaternary bg-layer-02 dark:bg-layer-02\"><div class=\"relative cursor-pointer flex h-[22px] w-[22px] items-center justify-center bg-layer-02 dark:bg-layer-02 hover:bg-fill-tertiary dark:hover:bg-fill-tertiary rounded-[4px]\" data-state=\"closed\"><div><div data-state=\"closed\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3 h-3.5 w-3.5 text-text-primary dark:text-text-primary\"><svg aria-hidden=\"true\" class=\"svg-inline--fa fa-clone absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" data-icon=\"clone\" data-prefix=\"far\" focusable=\"false\" role=\"img\" viewbox=\"0 0 512 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M64 464H288c8.8 0 16-7.2 16-16V384h48v64c0 35.3-28.7 64-64 64H64c-35.3 0-64-28.7-64-64V224c0-35.3 28.7-64 64-64h64v48H64c-8.8 0-16 7.2-16 16V448c0 8.8 7.2 16 16 16zM224 304H448c8.8 0 16-7.2 16-16V64c0-8.8-7.2-16-16-16H224c-8.8 0-16 7.2-16 16V288c0 8.8 7.2 16 16 16zm-64-16V64c0-35.3 28.7-64 64-64H448c35.3 0 64 28.7 64 64V288c0 35.3-28.7 64-64 64H224c-35.3 0-64-28.7-64-64z\" fill=\"currentColor\"></path></svg></div></div></div></div></div></div></div></div>\n<p></p>\n<p>These are all the valid sequences you can get with 4 houses. In total, there are 24 of them. The one with the lowest total cost is highlighted.</p>\n<p></p>\n<p>The best option is to paint the first house green, second house red, third house green, and fourth house red. This will cost a total of <code>17</code>.</p>\n<p><strong>Algorithm</strong></p>\n<p>It's not worth worrying about how you'd implement the brute force solution—it's completely infeasible and useless in practice. Additionally, the latter approaches move in a different direction, and the permutation code actually takes some effort to understand (which would be a distraction for you). Therefore, I haven't included code for it. You wouldn't be writing code for it in an interview either, instead you'd simply describe a possible approach and move onto optimizing, and then write code for a more optimal algorithm.</p>\n<p>There are many different approaches to it. All are based on permutation generation, but some only generate permutations that follow the color rules, and others generate all permutations and then remove the non-valid ones afterwards. Some are recursive, and others are iterative. Some use <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span> space by only generating one permutation at a time and then processing it before generating the next, and others use a lot more (discussed below) from generating all the sequences first and then processing them.</p>\n<p>The simplest is probably to generate every possible length-n string of <code>0</code>, <code>1</code>, and <code>2</code>, remove any that have the same digit twice in a row, and then score those that are left, keeping track of the smallest cost seen so far.</p>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.6644em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span> or <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord\">3</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.6644em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n<p>Without writing code, we can get a good idea of the cost. At the very least, we would have to process every valid permutation. The number of valid permutations grows exponentially with each additional house. For example, with 4 houses, there were <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.8141em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.8141em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">4</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.6444em;\"></span><span class=\"mord\">16</span></span></span></span></span> valid permutations. Adding a 5th house would require extending each permutation of 4 houses with 2 different colors for the 5th house, giving <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.8141em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.8141em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.6444em;\"></span><span class=\"mord\">32</span></span></span></span></span> valid permutations. Thus, the growth rate of valid permutations is exponential, specifically <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.6644em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n<p>If we were to generate all permutations of 0, 1, and 2 (representing 3 colors for each house) and then prune out the invalid ones, the situation would be even worse. There would initially be <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6644em;\"></span><span class=\"mord\"><span class=\"mord\">3</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.6644em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span></span> total permutations, which would then need to be filtered. This process would result in a time complexity of <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord\">3</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.6644em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n</li>\n<li>\n<p>Space complexity : Anywhere from <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span> to <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord\"><span class=\"mord\">3</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.6644em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n<p>This would depend entirely on the implementation. If you generated all the permutations at the same time and put them in a massive list, then you'd be using <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.6644em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span> or <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord\"><span class=\"mord\">3</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.6644em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span> space. If you generated one, processed it, generated the next, processed it, etc, without keeping the long list, it'd require <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span> space.</p>\n</li>\n</ul>\n<br/>\n<hr/>\n<h3 class=\"group/heading relative\" id=\"approach-2-brute-force-with-a-recursive-tree\" level=\"3\"><a aria-hidden=\"true\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" href=\"#approach-2-brute-force-with-a-recursive-tree\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" data-icon=\"link\" data-prefix=\"fas\" focusable=\"false\" role=\"img\" spacing=\"square\" viewbox=\"0 0 640 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\" fill=\"currentColor\"></path></svg></div></a>Approach 2: Brute force with a Recursive Tree</h3>\n<p><strong>Intuition</strong></p>\n<p>Like the first approach, this approach still isn't good enough. However, it bridges the gap between approach 1 and approach 3, with approach 3 further building on it. So make sure you understand it well.</p>\n<p>When we have permutations, we can think of them as forming a big tree of all the options. Drawing out the tree (or part of it) can give useful insights and reveal other possible algorithms. We'll continue using the sample example that we did above:</p>\n<p></p>\n<p>And here is how we can represent it using a tree. Each path from root to leaf represents a different possible permutation of house colors. There are 24 leaf nodes on the tree, just like there was 24 permutations identified in the brute force approach.</p>\n<p></p>\n<p>The tree representation gives a useful model of the problem and all the possible permutations. It shows that, for example, if we paint the first house red, then we have 2 options for the second house: green or blue. And then if we choose green for the second house, we could choose red or blue for the 3rd house. And so forth.</p>\n<p>Without worrying yet about how we would actually implement it, we'll now explore a straightforward algorithm that can be used to solve the problem using this tree.</p>\n<p>If the first 3 houses were red, green, and red then we could paint the 4th house green or blue. Which would we want to choose?</p>\n<p></p>\n<p>To minimize cost, we'd choose green. This is because green is <code>8</code>, and blue is <code>12</code>. <em>Under the assumption that we'd already decided that the first 3 houses would be red, green, and red</em>, this decision is definitely optimal. We know that there's no way we could do better.</p>\n<p>What we were effectively doing was deciding which was cheaper out of 2 permutations: <code>red, green, red, green</code> or <code>red, green, red, blue</code>. Because the former is cheaper, we have completely ruled out the latter. We can simplify our tree with this new information by adding the cost of the 4th house to the cost of the 3rd house on that branch.</p>\n<p></p>\n<p>We can repeatedly remove leaf nodes following this same process, as shown in this animation.</p>\n<p></p>\n<p>We are left with the conclusion that:</p>\n<ul>\n<li>Painting the first house red would have a <em>total</em> cost of <code>34</code>.</li>\n<li>Painting the first house green would have a <em>total</em> cost of <code>17</code>.</li>\n<li>Painting the first house blue would have a <em>total</em> cost of <code>32</code>.</li>\n</ul>\n<p>So, it makes sense to paint the first house green. This gives a total cost of <code>17</code>, which was the same answer our brute force in approach 1 arrived at.</p>\n<p><strong>Algorithm</strong></p>\n<p>To actually implement it, we'll need to change the way we think about it. What we did here was a <em>bottom-up</em> algorithm, meaning that we started by processing leaf nodes and then worked our way up. When we implement algorithms like this though, we almost always do it <em>top-down</em>. This allows us to use an <em>implicit tree</em> with recursion, instead of actually making a tree (i.e. having to work with <code>TreeNode</code>'s'). The recursive calls all form a tree structure. If you're not too familiar with this idea yet, don't panic, there is an animation of the algorithm and the code in the next section. The best way to get your head around recursion is to look at examples and recognise common patterns.</p>\n<p>Let's get started. Remember how we determined the cost of painting each house in the tree?</p>\n<p></p>\n<p>By <em>total cost</em>, we mean the cost of painting that house a particular color <em>and</em> painting the ones after it optimally.</p>\n<p>In pseudocode the top-down recursive algorithm looks like this:</p>\n<div class=\"font-menlo mb-6 rounded-lg px-3 py-2.5 text-sm bg-fill-3 dark:bg-dark-fill-3\"><div class=\"group relative\" translate=\"no\"><pre style=\"color: black; font-size: 13px; text-shadow: none; font-family: Menlo, Monaco, Consolas; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 4; hyphens: none; padding: 0px; margin: 0px; overflow: auto; background: transparent; overflow-wrap: normal;\"><code class=\"language-text\" style=\"white-space: pre; text-shadow: none;\"><span><span>print min(paint(0, 0), paint(0, 1), paint(0, 2))\n</span></span><span>\n</span><span>define function paint(n, color):\n</span><span>  total_cost = costs[n][color]\n</span><span>  if n is the last house number:\n</span><span>    pass [go straight to the return]\n</span><span>  else if color is red (0):\n</span><span>    total_cost += min(paint(n+1, 1), paint(n+1, 2))\n</span><span>  else if color is green (1):\n</span><span>    total_cost += min(paint(n+1, 0), paint(n+1, 2))\n</span><span>  else if color is blue (2):\n</span><span>    total_cost += min(paint(n+1, 0), paint(n+1, 1))\n</span><span>  return the total_cost    </span></code></pre><div class=\"absolute -right-1.5 -top-0.5 flex gap-2\"><div class=\"z-base-1 hidden rounded border group-hover:block border-border-quaternary dark:border-border-quaternary bg-layer-02 dark:bg-layer-02\"><div class=\"relative cursor-pointer flex h-[22px] w-[22px] items-center justify-center bg-layer-02 dark:bg-layer-02 hover:bg-fill-tertiary dark:hover:bg-fill-tertiary rounded-[4px]\" data-state=\"closed\"><div><div data-state=\"closed\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3 h-3.5 w-3.5 text-text-primary dark:text-text-primary\"><svg aria-hidden=\"true\" class=\"svg-inline--fa fa-clone absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" data-icon=\"clone\" data-prefix=\"far\" focusable=\"false\" role=\"img\" viewbox=\"0 0 512 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M64 464H288c8.8 0 16-7.2 16-16V384h48v64c0 35.3-28.7 64-64 64H64c-35.3 0-64-28.7-64-64V224c0-35.3 28.7-64 64-64h64v48H64c-8.8 0-16 7.2-16 16V448c0 8.8 7.2 16 16 16zM224 304H448c8.8 0 16-7.2 16-16V64c0-8.8-7.2-16-16-16H224c-8.8 0-16 7.2-16 16V288c0 8.8 7.2 16 16 16zm-64-16V64c0-35.3 28.7-64 64-64H448c35.3 0 64 28.7 64 64V288c0 35.3-28.7 64-64 64H224c-35.3 0-64-28.7-64-64z\" fill=\"currentColor\"></path></svg></div></div></div></div></div></div></div></div>\n<p>Here is an animation/ walkthrough of the algorithm. It also shows how the recursive calls make the same structure as the tree we were playing around with before, without actually building a tree. While this algorithm might be a bit to get your head around if you're not too familiar with recursion, doing so is essential to understanding approach 3.</p>\n<p></p>\n<p>And here is the code. While you're reading over it, have an initial think about how you could optimize it so that it no longer takes exponential time. Hint: look closely at the parameters of the recursive function. Are we actually repeating the same thing over and over? Fixing this problem will be what we tackle in Approach 3.</p>\n<pre><code>class Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; costs;\n    int minCost(vector&lt;vector&lt;int&gt;&gt;&amp; costs) {\n        if (costs.size() == 0) {\n            return 0;\n        }\n        this-&gt;costs = costs;\n        return min(paintCost(0, 0), min(paintCost(0, 1), paintCost(0, 2)));\n    }\n​\n    int paintCost(int n, int color) {\n        int totalCost = costs[n][color];\n        if (n == costs.size() - 1) {\n        } else if (color == 0) {  // Red\n            totalCost += min(paintCost(n + 1, 1), paintCost(n + 1, 2));\n        } else if (color == 1) {  // Green\n            totalCost += min(paintCost(n + 1, 0), paintCost(n + 1, 2));\n        } else {  // Blue\n            totalCost += min(paintCost(n + 1, 0), paintCost(n + 1, 1));\n        }\n        return totalCost;\n    }\n};</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.6644em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n<p>While this approach is an improvement on the previous approach, it still requires exponential time. Think about the number of leaf nodes. Each permutation has its own leaf node. The number of internal nodes is the same as the number of leaf nodes too. Remember how there are <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6644em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.6644em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span></span> different permutations? Each effectively adds <code>2</code> nodes to the tree, so dropping the constant of <code>2</code> gives us <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.6644em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n<p>This is better than the previous approach, which had an additional factor of <code>n</code>, giving <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.6644em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span>. That extra factor of <code>n</code> has disappeared here because the permutations are now \"sharing\" their similar parts, unlike before. The idea of \"sharing\" similar parts can be taken much further for this particular problem, as we will see with the remaining approaches that knock the time complexity all the way down to <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n</li>\n<li>\n<p>Space complexity : <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n<p>This algorithm might initially appear to be <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></span>, because we are not allocating any new data structures. However, we need to take into account space usage on the <strong>run-time stack</strong>. The run-time stack was shown in the animation. Whenever we are processing the last house (house number <code>n - 1</code>), there are <code>n</code> stack frames on the stack. This space usages counts for complexity analysis (it's memory usage, like any other memory usage) and so the space complexity is <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n</li>\n</ul>\n<br/>\n<hr/>\n<h3 class=\"group/heading relative\" id=\"approach-3-memoization\" level=\"3\"><a aria-hidden=\"true\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" href=\"#approach-3-memoization\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" data-icon=\"link\" data-prefix=\"fas\" focusable=\"false\" role=\"img\" spacing=\"square\" viewbox=\"0 0 640 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\" fill=\"currentColor\"></path></svg></div></a>Approach 3: Memoization</h3>\n<p><strong>Intuition</strong></p>\n<p>You may have noticed a very important pattern while we were working on the previous approach. Let's take a closer look.</p>\n<p>This is the tree before we removed any layers.</p>\n<p></p>\n<p>Look at the leaf nodes. All the red houses cost <code>4</code>, the green houses <code>8</code>, and the blue houses <code>12</code>. This makes sense, as the original input told us the costs of painting the <code>4th</code> house red, green, or blue were <code>4</code>, <code>8</code>, and <code>12</code> respectively.</p>\n<p>But look at what happens when we remove those leaf nodes in the way we described in the previous section.</p>\n<p></p>\n<p>Again, all the red houses are the same at <code>14</code>, the green houses are <code>7</code>, and the blue houses are <code>23</code>. Why has this happened? Well, we were always adding the cheapest of the 2 children to the parent, before deleting the 2 children. Painting the 3rd house itself red <em>always</em> costs <code>6</code>. And then we can <em>always</em> choose between painting the 4th house green or blue. It only ever made sense to choose green, as that was <code>8</code> (compared to <code>12</code> to paint it blue) Therefore, all those branches became <code>6 + 8 = 14</code>. Similar arguments apply to painting the 3rd house blue or green.</p>\n<p>And here's the tree when we'd removed another layer again.</p>\n<p></p>\n<p>Unsurprisingly, the pattern still continues.</p>\n<p>This pattern is important, because it shows us that we're actually doing the same few calculations over and over again. Instead of repeatedly doing the same (expensive) calculations, we should instead save and re-use results where possible.</p>\n<p>For example, imagine if in school you'd been given this math homework (and were <em>not</em> allowed to use a calculator). How would you approach it?</p>\n<div class=\"font-menlo mb-6 rounded-lg px-3 py-2.5 text-sm bg-fill-3 dark:bg-dark-fill-3\"><div class=\"group relative\" translate=\"no\"><pre style=\"color: black; font-size: 13px; text-shadow: none; font-family: Menlo, Monaco, Consolas; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 4; hyphens: none; padding: 0px; margin: 0px; overflow: auto; background: transparent; overflow-wrap: normal;\"><code style=\"white-space: pre; text-shadow: none;\"><span><span>1) 345 * 282 = ?\n</span></span><span>2) 43 + (345 * 282) = ?\n</span><span>3) (345 * 282) + 89 = ?\n</span><span>4) (345 * 282) * 5 + 19 = ?</span></code></pre><div class=\"absolute -right-1.5 -top-0.5 flex gap-2\"><div class=\"z-base-1 hidden rounded border group-hover:block border-border-quaternary dark:border-border-quaternary bg-layer-02 dark:bg-layer-02\"><div class=\"relative cursor-pointer flex h-[22px] w-[22px] items-center justify-center bg-layer-02 dark:bg-layer-02 hover:bg-fill-tertiary dark:hover:bg-fill-tertiary rounded-[4px]\" data-state=\"closed\"><div><div data-state=\"closed\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3 h-3.5 w-3.5 text-text-primary dark:text-text-primary\"><svg aria-hidden=\"true\" class=\"svg-inline--fa fa-clone absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" data-icon=\"clone\" data-prefix=\"far\" focusable=\"false\" role=\"img\" viewbox=\"0 0 512 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M64 464H288c8.8 0 16-7.2 16-16V384h48v64c0 35.3-28.7 64-64 64H64c-35.3 0-64-28.7-64-64V224c0-35.3 28.7-64 64-64h64v48H64c-8.8 0-16 7.2-16 16V448c0 8.8 7.2 16 16 16zM224 304H448c8.8 0 16-7.2 16-16V64c0-8.8-7.2-16-16-16H224c-8.8 0-16 7.2-16 16V288c0 8.8 7.2 16 16 16zm-64-16V64c0-35.3 28.7-64 64-64H448c35.3 0 64 28.7 64 64V288c0 35.3-28.7 64-64 64H224c-35.3 0-64-28.7-64-64z\" fill=\"currentColor\"></path></svg></div></div></div></div></div></div></div></div>\n<p>Unless you really, really love arithmetic, I think you would have done the working for <code>345 * 282</code> just <em>once</em> and then inserted it into all the other equations. You probably wouldn't have done the long multiplication 4 separate times for it!</p>\n<p>And it's the same for calculating the costs for painting these houses. We only need to calculate the cost of painting the 2nd house red <em>once</em>.</p>\n<p>So to do this, we'll use <strong>memoization</strong>. Immediately before returning a value we've finished computing, we'll write it into a dictionary with the input values as the key and the return value as the result. Then at the start of the function, we'll first check if the answer is already in the dictionary. If it is, we can immediately return it. If not, then we need to continue like before and compute it.</p>\n<p><strong>Algorithm</strong></p>\n<p>The algorithm is almost the same as before. The only difference is that we create an empty dictionary at the start, write the return values into it, and check it first to see if we've already found the answer for a particular set of input parameters.</p>\n<div class=\"font-menlo mb-6 rounded-lg px-3 py-2.5 text-sm bg-fill-3 dark:bg-dark-fill-3\"><div class=\"group relative\" translate=\"no\"><pre style=\"color: black; font-size: 13px; text-shadow: none; font-family: Menlo, Monaco, Consolas; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 4; hyphens: none; padding: 0px; margin: 0px; overflow: auto; background: transparent; overflow-wrap: normal;\"><code class=\"language-text\" style=\"white-space: pre; text-shadow: none;\"><span><span>print min(paint(0, 0), paint(0, 1), paint(0, 2))\n</span></span><span>\n</span><span>memo = a new, empty dictionary\n</span><span>\n</span><span>define function paint(n, color):\n</span><span>  if (n, color) is a key in memo:\n</span><span>     return memo[(n, color)]\n</span><span>  total_cost = costs[n][color]\n</span><span>  if n is the last house number:\n</span><span>    pass [go straight to return]\n</span><span>  else if color is red (0):\n</span><span>    total_cost += min(paint(n+1, 1), paint(n+1, 2))\n</span><span>  else if color is green (1):\n</span><span>    total_cost += min(paint(n+1, 0), paint(n+1, 2))\n</span><span>  else if color is blue (2):\n</span><span>    total_cost += min(paint(n+1, 0), paint(n+1, 1))\n</span><span>  memo[(n, color)] = total_cost\n</span><span>  return the total_cost    </span></code></pre><div class=\"absolute -right-1.5 -top-0.5 flex gap-2\"><div class=\"z-base-1 hidden rounded border group-hover:block border-border-quaternary dark:border-border-quaternary bg-layer-02 dark:bg-layer-02\"><div class=\"relative cursor-pointer flex h-[22px] w-[22px] items-center justify-center bg-layer-02 dark:bg-layer-02 hover:bg-fill-tertiary dark:hover:bg-fill-tertiary rounded-[4px]\" data-state=\"closed\"><div><div data-state=\"closed\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3 h-3.5 w-3.5 text-text-primary dark:text-text-primary\"><svg aria-hidden=\"true\" class=\"svg-inline--fa fa-clone absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" data-icon=\"clone\" data-prefix=\"far\" focusable=\"false\" role=\"img\" viewbox=\"0 0 512 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M64 464H288c8.8 0 16-7.2 16-16V384h48v64c0 35.3-28.7 64-64 64H64c-35.3 0-64-28.7-64-64V224c0-35.3 28.7-64 64-64h64v48H64c-8.8 0-16 7.2-16 16V448c0 8.8 7.2 16 16 16zM224 304H448c8.8 0 16-7.2 16-16V64c0-8.8-7.2-16-16-16H224c-8.8 0-16 7.2-16 16V288c0 8.8 7.2 16 16 16zm-64-16V64c0-35.3 28.7-64 64-64H448c35.3 0 64 28.7 64 64V288c0 35.3-28.7 64-64 64H224c-35.3 0-64-28.7-64-64z\" fill=\"currentColor\"></path></svg></div></div></div></div></div></div></div></div>\n<p>Remember how the previous approach made a recursive function call for every node in the tree we drew? Well this approach only needs to do the calculations shown. The brighter circles represent where it needed to actually calculate the answer and the dull circles show where an answer was looked up in the dictionary.</p>\n<p></p>\n<pre><code>class Solution {\nprivate:\n    vector&lt;vector&lt;int&gt;&gt; costs;\n    unordered_map&lt;string, int&gt; memo;\n​\npublic:\n    int minCost(vector&lt;vector&lt;int&gt;&gt;&amp; _costs) {\n        if (_costs.size() == 0) {\n            return 0;\n        }\n        this-&gt;costs = _costs;\n        return min(paintCost(0, 0), min(paintCost(0, 1), paintCost(0, 2)));\n    }\n​\nprivate:\n    int paintCost(int n, int color) {\n        string key = getKey(n, color);\n        if (memo.find(key) != memo.end()) {\n            return memo[key];\n        }\n        int totalCost = costs[n][color];\n        if (n == costs.size() - 1) {\n        } else if (color == 0) {  // Red\n            totalCost += min(paintCost(n + 1, 1), paintCost(n + 1, 2));\n        } else if (color == 1) {  // Green\n            totalCost += min(paintCost(n + 1, 0), paintCost(n + 1, 2));\n        } else {  // Blue\n            totalCost += min(paintCost(n + 1, 0), paintCost(n + 1, 1));\n        }\n        memo[key] = totalCost;\n​\n        return totalCost;\n    }\n​\n    string getKey(int n, int color) {\n        return to_string(n) + \" \" + to_string(color);\n    }\n};</code></pre>\n<p>In Python, we can use the <code>lru_cache</code> decorator from the <code>functools</code> package.  If you're not familar with this, you can find it <a href=\"https://docs.python.org/3/library/functools.html#functools.lru_cache\" target=\"_blank\">In the python documentation</a>. It's very useful!</p>\n<p>Here's the code using it.</p>\n<pre><code>class Solution {\npublic:\n    int minCost(vector&lt;vector&lt;int&gt;&gt;&amp; costs) {\n        if (costs.size() == 0) return 0;\n​\n        vector&lt;vector&lt;int&gt;&gt; memo = {costs.size() + 1, vector&lt;int&gt;(3, 0)};\n​\n        for (int i = costs.size() - 1; i &gt;= 0; --i) {\n            memo[i][0] = costs[i][0] + min(memo[i + 1][1], memo[i + 1][2]);\n            memo[i][1] = costs[i][1] + min(memo[i + 1][0], memo[i + 1][2]);\n            memo[i][2] = costs[i][2] + min(memo[i + 1][0], memo[i + 1][1]);\n        }\n​\n        return min(min(memo[0][0], memo[0][1]), memo[0][2]);\n    }\n};</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n<p>Analyzing memoization algorithms can be tricky at first, and requires understanding how recursion impacts the cost differently to loops. The key thing to notice is that the full function runs once for each possible set of parameters. There are <code>3 * n</code> different possible sets of parameters, because there are <code>n</code> houses and <code>3</code> colors. Because the function body is <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></span> (it's simply a conditional), this gives us a total of <code>3 * n</code>. There can't be more than <code>3 * 2 * n</code> searches into the memoization dictionary either. The tree showed this clearly—the nodes representing lookups had to be the child of a call where a full calculation was done. Because the constants are all dropped, this leaves <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n</li>\n<li>\n<p>Space complexity : <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n<p>Like the previous approach, the main space usage is on the stack. When we go down the first branch of function calls (see the tree visualization), we won't find any results in the dictionary. Therefore, every house will make a stack frame. Because there are <code>n</code> houses, this gives a worst case space usage of <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span>. Note that this could be a problem in languages such as Python, where stack frames are large.</p>\n</li>\n</ul>\n<br/>\n<hr/>\n<h3 class=\"group/heading relative\" id=\"approach-4-dynamic-programming\" level=\"3\"><a aria-hidden=\"true\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" href=\"#approach-4-dynamic-programming\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" data-icon=\"link\" data-prefix=\"fas\" focusable=\"false\" role=\"img\" spacing=\"square\" viewbox=\"0 0 640 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\" fill=\"currentColor\"></path></svg></div></a>Approach 4: Dynamic Programming</h3>\n<p><strong>Intuition</strong></p>\n<p>In approach 2, we started with, although didn't actually implement, a bottom up algorithm. The reason we didn't implement it is because we would have had to generate an actual tree which would have been a lot of work, and unnecessary for what we were trying to accomplish. However, there is another way of writing an iterative bottom-up algorithm to solve this problem. It utilizes the same pattern that we identified in approach 3.</p>\n<p>As a starting point, what would the tree look like if we converted it into a directed graph without the repetition? In other words, if we made it so that the 2nd house being blue was pointed to by both the 1st house being green and the 1st house being red? Well, it'd look something like this.</p>\n<p></p>\n<p>Directly generating this graph (i.e. not generating the massive tree first) and then using the same algorithm from approach 2 would achieve comparable time complexity to approach 3. But there's a far simpler way that doesn't even require generating the graph: dynamic programming! Dynamic programming is iterative, unlike memoization, which is recursive.</p>\n<p>We'll define a subproblem to be calculating the total cost for a particular house position and color.</p>\n<p>For the 4-house example, the memoization approach needed to solve a total of 12 different subproblems. We know this, because there were 3 possible values for the color (0, 1, 2), and 4 possible values for the house number (0, 1, 2, 3). In total, this gave us 12 different possibilities. The dynamic programming approach will need to solve these same subproblems, except in an iterative manner.</p>\n<p></p>\n<p>Now, remember the size of the input array? It's the same! Also, notice how it maps onto the tree. Again, it's the same.</p>\n<p></p>\n<p>We can, therefore, calculate the cost of each subproblem, starting from the ones with the highest house numbers, and write the results directly into the input array. In effect, we will replace each single-house cost value in the array with the cost of painting the house that color and the minimum cost to paint all the houses after it. This is almost the same as what we did on the tree. The only difference is that we are only doing each calculation once and we are writing results directly into the input table. It is bottom up, because we are solving the \"lower\" problems first, and then the \"higher\" ones once we've solved all the lower ones that they depend on.</p>\n<p>First thing to realize is that we don't need to do anything to the last row. Like in the tree, these costs are the total costs because there are no further houses after them.</p>\n<p></p>\n<p>Now, what about the second-to-last row? Well, we know that if we painted that house red, that it'd cost itself and the cheapest out of blue and green from the next row, which is 8. So the total cost there would be 14, and we can put that into the cell.</p>\n<p></p>\n<p>Just like we did with the tree, we can work our way up through the grid, repeatedly applying the same algorithm to determine the total value for each cell. Once we have updated all the cells, we then simply need to take the minimum value from the first row and return it. Here is an animation showing the process.</p>\n<p></p>\n<p><strong>Algorithm</strong></p>\n<p>The algorithm is straightforward. We iterate backwards over all the rows in the grid (starting from the second-to-last) and calculate a total cost for each cell in the way shown in the animation.</p>\n<pre><code>class Solution {\npublic:\n    int minCost(vector&lt;vector&lt;int&gt;&gt;&amp; costs) {\n        if (costs.size() == 0) return 0;\n        for (int n = costs.size() - 2; n &gt;= 0; n--) {\n            // Total cost of painting the nth house red.\n            costs[n][0] += min(costs[n + 1][1], costs[n + 1][2]);\n            // Total cost of painting the nth house green.\n            costs[n][1] += min(costs[n + 1][0], costs[n + 1][2]);\n            // Total cost of painting the nth house blue.\n            costs[n][2] += min(costs[n + 1][0], costs[n + 1][1]);\n        }\n​\n        return min(min(costs[0][0], costs[0][1]), costs[0][2]);\n    }\n};</code></pre>\n<p>You could also avoid the hardcoding of the colors and instead iterate over the colors. This approach will be covered in the solution article for the follow up question where there are <code>m</code> colors instead of just 3.</p>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity : <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n<p>Finding the minimum of two values and adding it to another value is an <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></span> operation. We are doing these <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></span> operations for <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6444em;\"></span><span class=\"mord\">3</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></span> cells in the grid. Expanding that out, we get <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6444em;\"></span><span class=\"mord\">3</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.6667em; vertical-align: -0.0833em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.6444em;\"></span><span class=\"mord\">3</span></span></span></span></span>. The constants don't matter in big-oh notation, so we drop them, leaving us with <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n<p><em>A word of warning:</em> This would <em>not</em> be correct if there were <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.4306em;\"></span><span class=\"mord mathnormal\">m</span></span></span></span></span> colors. For this particular problem we were told there's only <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6444em;\"></span><span class=\"mord\">3</span></span></span></span></span> colors. However, a logical follow-up question would be to make the code work for any number of colors. In that case, the time complexity would actually be <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mclose\">)</span></span></span></span></span>, because <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.4306em;\"></span><span class=\"mord mathnormal\">m</span></span></span></span></span> is not a constant, whereas <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6444em;\"></span><span class=\"mord\">3</span></span></span></span></span> is. If this confused you, I'd recommend reading up on big-oh notation.</p>\n</li>\n<li>\n<p>Space Complexity : <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p>We don't allocate any new data structures, and are only using a few local variables. All the work is done directly into the input array. Therefore, the algorithm is in-place, requiring constant extra space.</p>\n</li>\n</ul>\n<br/>\n<hr/>\n<h3 class=\"group/heading relative\" id=\"approach-5-dynamic-programming-with-optimized-space-complexity\" level=\"3\"><a aria-hidden=\"true\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" href=\"#approach-5-dynamic-programming-with-optimized-space-complexity\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" data-icon=\"link\" data-prefix=\"fas\" focusable=\"false\" role=\"img\" spacing=\"square\" viewbox=\"0 0 640 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\" fill=\"currentColor\"></path></svg></div></a>Approach 5: Dynamic Programming with Optimized Space Complexity</h3>\n<p><strong>Intuition</strong></p>\n<p>Overwriting the input array isn't always desirable. What if, for example, other functions also needed to use that same array?</p>\n<p>We could allocate our own array and then continue in the same way as approach 4. This would bring our space complexity up to <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span> (for the same reason the time complexity is <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span>, the constants are dropped in big-oh notation).</p>\n<p>Using <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span> space isn't necessary though—we can further optimize the space complexity. Remember how the dynamic programming animation blanked out rows to show we'd no longer be looking at them? We only needed to look at the previous row, and the row we're currently working on. The rest could have been thrown away. So to avoid overwriting the input, we keep track of the previous row and the current row as length-3 arrays.</p>\n<p>This space-optimization technique applies to many dynamic programming problems. As a general rule, I'd recommend first trying to come up with an algorithm that has optimal time complexity, and then looking at if you can trim down the space complexity.</p>\n<p><strong>Algorithm</strong></p>\n<p>It's up to you whether you do this using length-3 arrays or variables. Arrays are better in terms of writing clean code though. They will also be easier to adapt if you were asked to make the algorithm work with <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.4306em;\"></span><span class=\"mord mathnormal\">m</span></span></span></span></span> colors. I have chosen to use arrays here as keeping track of 6 seperate variables is too messy.</p>\n<p>The <code>previous_row</code> starts as being the last row of the input array. The <code>current_row</code> is the row <code>n</code> is currently up to (starts as the second to last row). At each step we update the values in <code>current_row</code> by adding values from <code>previous_row</code>. We then set <code>previous_row</code> to be <code>current_row</code> and go on to the next value of <code>n</code> where we repeat the process. At the end, the first row will be sitting in the <code>previous_row</code> variable, so we find the minimum like we did before.</p>\n<p>Note that we have to be careful about not overwriting the <code>costs</code> array inadvertently. Any rows we take out of the array that will be <em>written</em> into will need to be copies. This can be done using <code>clone</code> in Java (suitable for an array of primitive types such as integers) and <code>copy.deepcopy</code> in Python.</p>\n<pre><code>class Solution {\npublic:\n    int minCost(vector&lt;vector&lt;int&gt;&gt;&amp; costs) {\n        if (costs.size() == 0) return 0;\n​\n        vector&lt;int&gt; previousRow = costs[costs.size() - 1];\n​\n        for (int n = costs.size() - 2; n &gt;= 0; n--) {\n            vector&lt;int&gt; currentRow = costs[n];\n            // Total cost of painting the nth house red.\n            currentRow[0] += min(previousRow[1], previousRow[2]);\n            // Total cost of painting the nth house green.\n            currentRow[1] += min(previousRow[0], previousRow[2]);\n            // Total cost of painting the nth house blue.\n            currentRow[2] += min(previousRow[0], previousRow[1]);\n            previousRow = currentRow;\n        }\n​\n        return min({previousRow[0], previousRow[1], previousRow[2]});\n    }\n};</code></pre>\n<p>Thanks so much to <a href=\"https://leetcode.com/bitbleach\" target=\"_blank\">@bitbleach</a> for pointing out that the original code I had here was over writing the input array! Because this is such an easy mistake to make, I've kept the original code for reference.</p>\n<pre><code>// This code OVERWRITES the input vector!\n​\nclass Solution {\npublic:\n    int minCost(vector&lt;vector&lt;int&gt;&gt;&amp; costs) {\n        if (costs.size() == 0) return 0;\n​\n        vector&lt;int&gt; previousRow = costs[costs.size() - 1];\n​\n        for (int n = costs.size() - 2; n &gt;= 0; n--) {\n            // PROBLEMATIC CODE IS HERE\n            // This line here is NOT making a copy of the original, it's simply\n            // making a reference to it Therefore, any writes into currentRow\n            // will also be written into \"costs\". This is not what we wanted!\n            vector&lt;int&gt;&amp; currentRow = costs[n];\n​\n            // Total cost of painting nth house red?\n            currentRow[0] += min(previousRow[1], previousRow[2]);\n            // Total cost of painting nth house green?\n            currentRow[1] += min(previousRow[0], previousRow[2]);\n            // Total cost of painting nth house blue?\n            currentRow[2] += min(previousRow[0], previousRow[1]);\n            previousRow = currentRow;\n        }\n​\n        return min(min(previousRow[0], previousRow[1]), previousRow[2]);\n    }\n};</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity : <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n<p>Same as previous approach.</p>\n</li>\n<li>\n<p>Space Complexity : <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p>We're \"remembering\" up to <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6444em;\"></span><span class=\"mord\">6</span></span></span></span></span> calculations at a time (using 2 x length-3 arrays). Because this is actually a constant, the space complexity is still <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n<p>Like the time complexity though, this analysis is dependent on there being a constant number of colors (i.e. 3). If the problem was changed to be <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.4306em;\"></span><span class=\"mord mathnormal\">m</span></span></span></span></span> colors, then the space complexity would become <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">m</span><span class=\"mclose\">)</span></span></span></span></span> as we'd need to keep track of a couple of length-m arrays.</p>\n</li>\n</ul>\n<br/>\n<hr/>\n<h3 class=\"group/heading relative\" id=\"justifying-why-this-is-a-dynamic-programming-problem\" level=\"3\"><a aria-hidden=\"true\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" href=\"#justifying-why-this-is-a-dynamic-programming-problem\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" data-icon=\"link\" data-prefix=\"fas\" focusable=\"false\" role=\"img\" spacing=\"square\" viewbox=\"0 0 640 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\" fill=\"currentColor\"></path></svg></div></a>Justifying why this is a Dynamic Programming Problem</h3>\n<p>Many dynamic programming problems have very straightforward solutions. As you get more experience with them, you'll gain a better intuition for when a problem might be solvable with dynamic programming, and you'll also get better at quickly identifying the overlapping subproblems (e.g. that painting the 3rd house green will have the same total cost regardless of whether the 2nd house was blue or red). Thinking about the tree structure can help too for identifying those subproblems, although you won't always need to draw it out fully like we did here.</p>\n<p>Remember that a <strong>subproblem</strong> is any call to the recursive function. Subproblems are solved either as a base case (in this case a simple lookup from the table and no further calculations) or by looking at the solutions of a bunch of lower down subproblems. In dynamic programming lingo, we say that this problem has an <strong>optimal substructure</strong>. This means that the optimal cost for each <strong>subproblem</strong> is constructed from the <strong>optimal cost</strong> of <strong>subproblems</strong> below it. This is the same property that must be true for greedy algorithms to work.</p>\n<p>If, for example, we hadn't been able to choose the minimum and know it was optimal (perhaps because it would impact a choice further up the tree) then there would <em>not</em> have been <strong>optimal substructure</strong>.</p>\n<p>In addition this problem also had <strong>overlapping subproblems</strong>. This just means that the lower subproblems were often shared (remember how the tree had lots of branches that looked the same?)</p>\n<p>Problems that have <strong>optimal substructure</strong> can be solved with greedy algorithms. If they <em>also</em> have <strong>overlapping subproblems</strong>, then they can be solved with dynamic programming algorithms.</p></div><span style=\"font-size: 0px; line-height: 0;\"> </span></div>"}