{"id":"185","title":"Department Top Three Salaries","difficulty":"Hard","content":"<p>Table: <code>Employee</code></p>\n\n<pre>\n+--------------+---------+\n| Column Name  | Type    |\n+--------------+---------+\n| id           | int     |\n| name         | varchar |\n| salary       | int     |\n| departmentId | int     |\n+--------------+---------+\nid is the primary key (column with unique values) for this table.\ndepartmentId is a foreign key (reference column) of the ID from the <code>Department </code>table.\nEach row of this table indicates the ID, name, and salary of an employee. It also contains the ID of their department.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Table: <code>Department</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| id          | int     |\n| name        | varchar |\n+-------------+---------+\nid is the primary key (column with unique values) for this table.\nEach row of this table indicates the ID of a department and its name.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>A company&#39;s executives are interested in seeing who earns the most money in each of the company&#39;s departments. A <strong>high earner</strong> in a department is an employee who has a salary in the <strong>top three unique</strong> salaries for that department.</p>\n\n<p>Write a solution to find the employees who are <strong>high earners</strong> in each of the departments.</p>\n\n<p>Return the result table <strong>in any order</strong>.</p>\n\n<p>The&nbsp;result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nEmployee table:\n+----+-------+--------+--------------+\n| id | name  | salary | departmentId |\n+----+-------+--------+--------------+\n| 1  | Joe   | 85000  | 1            |\n| 2  | Henry | 80000  | 2            |\n| 3  | Sam   | 60000  | 2            |\n| 4  | Max   | 90000  | 1            |\n| 5  | Janet | 69000  | 1            |\n| 6  | Randy | 85000  | 1            |\n| 7  | Will  | 70000  | 1            |\n+----+-------+--------+--------------+\nDepartment table:\n+----+-------+\n| id | name  |\n+----+-------+\n| 1  | IT    |\n| 2  | Sales |\n+----+-------+\n<strong>Output:</strong> \n+------------+----------+--------+\n| Department | Employee | Salary |\n+------------+----------+--------+\n| IT         | Max      | 90000  |\n| IT         | Joe      | 85000  |\n| IT         | Randy    | 85000  |\n| IT         | Will     | 70000  |\n| Sales      | Henry    | 80000  |\n| Sales      | Sam      | 60000  |\n+------------+----------+--------+\n<strong>Explanation:</strong> \nIn the IT department:\n- Max earns the highest unique salary\n- Both Randy and Joe earn the second-highest unique salary\n- Will earns the third-highest unique salary\n\nIn the Sales department:\n- Henry earns the highest salary\n- Sam earns the second-highest salary\n- There is no third-highest salary as there are only two employees\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>There are no employees with the <strong>exact</strong> same name, salary <em>and</em> department.</li>\n</ul>\n","tags":["Database"],"java_snippet":"","solution":"<p>​</p>\n<p>​</p>\n<h1><a href=\"#solution\"><svg><path></path></svg></a>Solution</h1>\n<h2><a href=\"#\"><svg><path></path></svg></a>​</h2>\n<p>​</p>\n<h2><a href=\"#pandas\"><svg><path></path></svg></a>pandas</h2>\n<h3><a href=\"#approach-1-return-the-first-n-rows-using-nlargest\"><svg><path></path></svg></a>Approach 1: Return the First n Rows Using nlargest()</h3>\n<h4>Algorithm</h4>\n<p>For this problem, we can either identify the top earners first using DataFrame <code>employee</code> and then join the DataFrame <code>department</code> to get the department name, or join the DataFrame <code>department</code> first to get the department name before identifying the top earners. In this approach, we use the latter logic.</p>\n<p>In this step, we can also update the column name in the DataFrame <code>department</code> from <code>name</code> to <code>Department</code> as requested by the final output.</p>\n<pre><code>// Java: join employee and department data\nList<employeedepartment> employeeDepartment =\n    employees.stream()\n        .flatMap(e -&gt;\n            departments.stream()\n                .filter(d -&gt; d.getId() == e.getDepartmentId())\n                .map(d -&gt; new EmployeeDepartment(\n                        d.getName(),\n                        e.getDepartmentId(),\n                        e.getSalary(),\n                        e.getName(),\n                        e.getId()\n                ))\n        )\n        .collect(Collectors.toList());</employeedepartment></code></pre><svg><path></path></svg>\n<p>Now we have the employee and department information stored in the same DataFrame:</p>\n<table><thead><tr><th>id_x</th><th>name_x</th><th>salary</th><th>departmentId</th><th>id_y</th><th>Department</th></tr></thead><tbody><tr><td>1</td><td>Joe</td><td>85000</td><td>1</td><td>1</td><td>IT</td></tr><tr><td>4</td><td>Max</td><td>90000</td><td>1</td><td>1</td><td>IT</td></tr><tr><td>5</td><td>Janet</td><td>69000</td><td>1</td><td>1</td><td>IT</td></tr><tr><td>6</td><td>Randy</td><td>85000</td><td>1</td><td>1</td><td>IT</td></tr><tr><td>7</td><td>Will</td><td>70000</td><td>1</td><td>1</td><td>IT</td></tr><tr><td>2</td><td>Henry</td><td>80000</td><td>2</td><td>2</td><td>Sales</td></tr><tr><td>3</td><td>Sam</td><td>60000</td><td>2</td><td>2</td><td>Sales</td></tr></tbody></table>\n<p>Since the definition of a <strong>high earner</strong> is an employee who has a salary in the top three <strong>unique</strong> salaries for the department, we want to make sure the salary is unique at the department level for later calculation. To do this, we select only the department and salary from the DataFrame created in the last step and drop any duplicated records if existed.</p>\n<pre><code>// Java: keep unique department and salary pairs\nList<deptsalary> uniqueDeptSalaries =\n    employeeDepartment.stream()\n        .map(ed -&gt; new DeptSalary(ed.getDepartment(), ed.getDepartmentId(), ed.getSalary()))\n        .distinct()\n        .collect(Collectors.toList());</deptsalary></code></pre><svg><path></path></svg>\n<p>Here's the output after this step:</p>\n<table><thead><tr><th>Department</th><th>departmentId</th><th>salary</th></tr></thead><tbody><tr><td>IT</td><td>1</td><td>85000</td></tr><tr><td>IT</td><td>1</td><td>90000</td></tr><tr><td>IT</td><td>1</td><td>69000</td></tr><tr><td>IT</td><td>1</td><td>70000</td></tr><tr><td>Sales</td><td>2</td><td>80000</td></tr><tr><td>Sales</td><td>2</td><td>60000</td></tr></tbody></table>\n<p>Now we can identify the top 3 unique salaries for each department. We use the function <a href=\"https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.nlargest.html\"><code>nlargest()</code></a> to get this value. The parameter '3' is passed to the function as it defines the number of rows to return.</p>\n<pre><code>// Java: group by department and get top 3 salaries\nMap<integer, list<integer=\"\">&gt; topSalariesByDept =\n    uniqueDeptSalaries.stream()\n        .collect(Collectors.groupingBy(\n            DeptSalary::getDepartmentId,\n            Collectors.mapping(\n                DeptSalary::getSalary,\n                Collectors.collectingAndThen(\n                    Collectors.toSet(),\n                    set -&gt; set.stream()\n                              .sorted(Comparator.reverseOrder())\n                              .limit(3)\n                              .collect(Collectors.toList())\n                )\n            )\n        ));</integer,></code></pre><svg><path></path></svg>\n<table><thead><tr><th>Department</th><th>departmentId</th><th>level_2</th><th>salary</th></tr></thead><tbody><tr><td>IT</td><td>1</td><td>1</td><td>90000</td></tr><tr><td>IT</td><td>1</td><td>0</td><td>85000</td></tr><tr><td>IT</td><td>1</td><td>4</td><td>70000</td></tr><tr><td>Sales</td><td>2</td><td>5</td><td>80000</td></tr><tr><td>Sales</td><td>2</td><td>6</td><td>60000</td></tr></tbody></table>\n<p>Now we only need to identify the employees are in these departments and making the same amount of salary. To do this, we can merge the DataFrame <code>top_salary</code>, which contains the top three unique salary for each department, to the DataFrame <code>employee</code> on <code>departmentId</code> and <code>salary</code>, so only the employees that match both criteria will be retained.</p>\n<pre><code>// Java: filter employees by top salaries\nList<employee> result =\n    employees.stream()\n        .filter(e -&gt;\n            topSalariesByDept.containsKey(e.getDepartmentId()) &amp;&amp;\n            topSalariesByDept.get(e.getDepartmentId()).contains(e.getSalary())\n        )\n        .collect(Collectors.toList());</employee></code></pre><svg><path></path></svg>\n<table><thead><tr><th>Department</th><th>departmentId</th><th>level_2</th><th>salary</th><th>id</th><th>name</th></tr></thead><tbody><tr><td>IT</td><td>1</td><td>1</td><td>90000</td><td>4</td><td>Max</td></tr><tr><td>IT</td><td>1</td><td>0</td><td>85000</td><td>1</td><td>Joe</td></tr><tr><td>IT</td><td>1</td><td>0</td><td>85000</td><td>6</td><td>Randy</td></tr><tr><td>IT</td><td>1</td><td>4</td><td>70000</td><td>7</td><td>Will</td></tr><tr><td>Sales</td><td>2</td><td>5</td><td>80000</td><td>2</td><td>Henry</td></tr><tr><td>Sales</td><td>2</td><td>6</td><td>60000</td><td>3</td><td>Sam</td></tr></tbody></table>\n<p>Lastly, we clean the DataFrame as per requested by the final output. We keep only the columns needed and rename the columns accordingly.</p>\n<pre><code>// Java: map to final output structure\nList<resultrow> output =\n    result.stream()\n        .map(e -&gt; new ResultRow(\n            departmentMap.get(e.getDepartmentId()),\n            e.getName(),\n            e.getSalary()\n        ))\n        .collect(Collectors.toList());</resultrow></code></pre><svg><path></path></svg>\n<h4>Implementation</h4>\n<p>​<pre><code>public List<resultrow> topThreeSalaries(List<employee> employees, List<department> departments) {\n\n    Map<integer, string=\"\"> departmentMap =\n        departments.stream()\n            .collect(Collectors.toMap(Department::getId, Department::getName));\n\n    Map<integer, list<integer=\"\">&gt; topSalariesByDept =\n        employees.stream()\n            .collect(Collectors.groupingBy(\n                Employee::getDepartmentId,\n                Collectors.mapping(\n                    Employee::getSalary,\n                    Collectors.collectingAndThen(\n                        Collectors.toSet(),\n                        set -&gt; set.stream()\n                                  .sorted(Comparator.reverseOrder())\n                                  .limit(3)\n                                  .collect(Collectors.toList())\n                    )\n                )\n            ));\n\n    return employees.stream()\n        .filter(e -&gt;\n            topSalariesByDept.containsKey(e.getDepartmentId()) &amp;&amp;\n            topSalariesByDept.get(e.getDepartmentId()).contains(e.getSalary())\n        )\n        .map(e -&gt; new ResultRow(\n            departmentMap.get(e.getDepartmentId()),\n            e.getName(),\n            e.getSalary()\n        ))\n        .collect(Collectors.toList());\n}</integer,></integer,></department></employee></resultrow></code></pre></p>\n<h3><a href=\"#approach-2-return-the-first-n-rows-using-rank\"><svg><path></path></svg></a>Approach 2: Return the First n Rows Using rank()</h3>\n<h4>Algorithm</h4>\n<p>For this approach, we first identify the top earners from the DataFrame <code>employee</code> and then join the DataFrame <code>department</code> to get the department name.</p>\n<p>To identify the high earners for each department, we use ranking logic equivalent to <a href=\"https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.rank.html\"><code>rank()</code></a> to apply dense rank on the column <code>salary</code> so we can get the top three <strong>unique</strong> salaries. The parameter <code>ascending=False</code> is passed so the salary is sorted from the maximum to the minimum. Within the same step, we can also add the filter to keep only the records with a rank smaller than or equal to 3.</p>\n<pre><code>// Java: compute dense rank per department\nMap<integer, list<employee=\"\">&gt; ranked =\n    employees.stream()\n        .collect(Collectors.groupingBy(Employee::getDepartmentId));\n\nList<employee> topSalary =\n    ranked.values().stream()\n        .flatMap(list -&gt; {\n            List<integer> salaries = list.stream()\n                .map(Employee::getSalary)\n                .distinct()\n                .sorted(Comparator.reverseOrder())\n                .limit(3)\n                .collect(Collectors.toList());\n            return list.stream().filter(e -&gt; salaries.contains(e.getSalary()));\n        })\n        .collect(Collectors.toList());</integer></employee></integer,></code></pre><svg><path></path></svg>\n<p>Only employees who are <code>high earners</code> retained in the new DataFrame:</p>\n<table><thead><tr><th>id</th><th>name</th><th>salary</th><th>departmentId</th></tr></thead><tbody><tr><td>1</td><td>Joe</td><td>85000</td><td>1</td></tr><tr><td>2</td><td>Henry</td><td>80000</td><td>2</td></tr><tr><td>3</td><td>Sam</td><td>60000</td><td>2</td></tr><tr><td>4</td><td>Max</td><td>90000</td><td>1</td></tr><tr><td>6</td><td>Randy</td><td>85000</td><td>1</td></tr><tr><td>7</td><td>Will</td><td>70000</td><td>1</td></tr></tbody></table>\n<p>Now we want to <code>merge</code> to the DataFrame <code>department</code> to get the <code>name</code> of the department. In the same step, we can also select only the columns needed for the final output.</p>\n<pre><code>// Java: join with department and select fields\nList<resultrow> employeeDepartment =\n    topSalary.stream()\n        .map(e -&gt; new ResultRow(\n            departmentMap.get(e.getDepartmentId()),\n            e.getName(),\n            e.getSalary()\n        ))\n        .collect(Collectors.toList());</resultrow></code></pre><svg><path></path></svg>\n<table><thead><tr><th>name_y</th><th>name_x</th><th>salary</th></tr></thead><tbody><tr><td>IT</td><td>Joe</td><td>85000</td></tr><tr><td>IT</td><td>Max</td><td>90000</td></tr><tr><td>IT</td><td>Randy</td><td>85000</td></tr><tr><td>IT</td><td>Will</td><td>70000</td></tr><tr><td>Sales</td><td>Henry</td><td>80000</td></tr><tr><td>Sales</td><td>Sam</td><td>60000</td></tr></tbody></table>\n<p>We are almost there! To get the final output, we need to update the column name as per requested.</p>\n<pre><code>// Java: already mapped to Department, Employee, Salary\nreturn employeeDepartment;</code></pre><svg><path></path></svg>\n<h4>Implementation</h4>\n<pre><code>public List<resultrow> topThreeSalaries(List<employee> employees, Map<integer, string=\"\"> departmentMap) {\n\n    Map<integer, list<employee=\"\">&gt; byDept =\n        employees.stream()\n            .collect(Collectors.groupingBy(Employee::getDepartmentId));\n\n    return byDept.values().stream()\n        .flatMap(list -&gt; {\n            List<integer> topSalaries = list.stream()\n                .map(Employee::getSalary)\n                .distinct()\n                .sorted(Comparator.reverseOrder())\n                .limit(3)\n                .collect(Collectors.toList());\n            return list.stream()\n                .filter(e -&gt; topSalaries.contains(e.getSalary()));\n        })\n        .map(e -&gt; new ResultRow(\n            departmentMap.get(e.getDepartmentId()),\n            e.getName(),\n            e.getSalary()\n        ))\n        .collect(Collectors.toList());\n}</integer></integer,></integer,></employee></resultrow></code></pre>\n---\n<h2><a href=\"#database\"><svg><path></path></svg></a>Database</h2>\n<h3><a href=\"#approach-1-return-the-first-n-rows-using-correlated-subquery\"><svg><path></path></svg></a>Approach 1: Return the First n Rows Using Correlated Subquery</h3>\n<h4>Algorithm</h4>\n<p>​<br/>\nWe can build a correlated subquery to identify the top N records from more than one category. Since the correlated subquery is dependent on the main query, the idea behind this approach is to compare the values between the main query and the subquery, so that in the subquery, at most N-1 salaries can be greater than each selected salary from the main query.</p>\n<p>To do this, we first build the main query. In the main query, we can also join the table <code>Employee</code> to the table <code>Department</code> on <code>departmentId</code> to get the <code>name</code> of the departments and rename the columns as requested by the final output.</p>\n<pre><code>// Java: SQL query string\nString baseQuery =\n    \"SELECT d.name AS Department, e1.name AS Employee, e1.salary AS Salary \" +\n    \"FROM Employee e1 JOIN Department d ON e1.departmentId = d.id\";</code></pre><svg><path></path></svg>\n<p>In the correlated subquery, we select the number of salaries from the same table <code>Employee</code>. To compare the salaries between the main query and the subquery, we make sure the department is the same from both queries, but the salary from the subquery is always bigger than the salary from the main query.</p>\n<pre><code>// Java: correlated subquery condition\nString correlatedCondition =\n    \"(SELECT COUNT(DISTINCT e2.salary) FROM Employee e2 \" +\n    \"WHERE e2.salary &gt; e1.salary AND e1.departmentId = e2.departmentId)\";</code></pre><svg><path></path></svg>\n<p>Since we need to identify the top three high earners in the main query, and the subquery always has larger salaries than the salaries from the main query, the maximum count of the larger salaries in the subquery is two. We add this criteria as a filter to the main query.</p>\n<h4>Implementation</h4>\n<pre><code>// Java: full SQL query\nString sql =\n    \"SELECT d.name AS Department, e1.name AS Employee, e1.salary AS Salary \" +\n    \"FROM Employee e1 JOIN Department d ON e1.departmentId = d.id \" +\n    \"WHERE 3 &gt; (SELECT COUNT(DISTINCT e2.salary) FROM Employee e2 \" +\n    \"WHERE e2.salary &gt; e1.salary AND e1.departmentId = e2.departmentId)\";</code></pre><svg><path></path></svg>\n<p>​</p>\n<h3><a href=\"#approach-2-return-the-first-n-rows-using-dense_rank\"><svg><path></path></svg></a>Approach 2: Return the First n Rows Using DENSE_RANK()</h3>\n<h4>Algorithm</h4>\n<p>​<br/>\nUnlike the previous approach that utilized a correlated subquery, in this approach, we sorted the salaries in descending order, ranked employees based on their salaries within the department, and selected only the first 3 employees for the final output.</p>\n<p>We first create a subquery or CTE to rank the employees. Since the definition of a high earner is the employee who has a salary in the top three <strong>unique</strong> salaries for the department, we can use the function <code>DENSE_RANK()</code> to avoid the scenario that employees from the same department make the same amount of salary. In this step, we can also join the table <code>Department</code> on <code>departmentId</code> to get the <code>name</code> of the departments and rename the columns for the final output.</p>\n<pre><code>// Java: SQL with CTE using DENSE_RANK\nString cte =\n    \"WITH employee_department AS ( \" +\n    \"SELECT d.id, d.name AS Department, e.salary AS Salary, e.name AS Employee, \" +\n    \"DENSE_RANK() OVER (PARTITION BY d.id ORDER BY e.salary DESC) AS rnk \" +\n    \"FROM Department d JOIN Employee e ON d.id = e.departmentId )\";</code></pre><svg><path></path></svg>\n<p>Now, each employee has a rank based on the <code>salary</code> in a descending order for each department.</p>\n<table><thead><tr><th>id</th><th>Department</th><th>Salary</th><th>Employee</th><th>rnk</th></tr></thead><tbody><tr><td>1</td><td>IT</td><td>90000</td><td>Max</td><td>1</td></tr><tr><td>1</td><td>IT</td><td>85000</td><td>Joe</td><td>2</td></tr><tr><td>1</td><td>IT</td><td>85000</td><td>Randy</td><td>2</td></tr><tr><td>1</td><td>IT</td><td>70000</td><td>Will</td><td>3</td></tr><tr><td>1</td><td>IT</td><td>69000</td><td>Janet</td><td>4</td></tr><tr><td>2</td><td>Sales</td><td>80000</td><td>Henry</td><td>1</td></tr><tr><td>2</td><td>Sales</td><td>60000</td><td>Sam</td><td>2</td></tr></tbody></table>\n<p>With the rank, we can select the high earners. We can add the filter to select employees that have a rank smaller than or equal to 3 in the main query.</p>\n<pre><code>// Java: final select from CTE\nString finalQuery =\n    cte + \" SELECT Department, Employee, Salary FROM employee_department WHERE rnk &lt;= 3\";</code></pre><svg><path></path></svg>\n<h4>Implementation</h4>\nMySQL<pre><code>// Java: execute finalQuery using JDBC\nPreparedStatement stmt = connection.prepareStatement(finalQuery);\nResultSet rs = stmt.executeQuery();</code></pre><svg><path></path></svg>\n<h2><a href=\"#-1\"><svg><path></path></svg></a>​</h2>"}