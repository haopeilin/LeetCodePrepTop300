{"id":"153","title":"Find Minimum in Rotated Sorted Array","difficulty":"Medium","content":"<p>Suppose an array of length <code>n</code> sorted in ascending order is <strong>rotated</strong> between <code>1</code> and <code>n</code> times. For example, the array <code>nums = [0,1,2,4,5,6,7]</code> might become:</p>\n\n<ul>\n\t<li><code>[4,5,6,7,0,1,2]</code> if it was rotated <code>4</code> times.</li>\n\t<li><code>[0,1,2,4,5,6,7]</code> if it was rotated <code>7</code> times.</li>\n</ul>\n\n<p>Notice that <strong>rotating</strong> an array <code>[a[0], a[1], a[2], ..., a[n-1]]</code> 1 time results in the array <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code>.</p>\n\n<p>Given the sorted rotated array <code>nums</code> of <strong>unique</strong> elements, return <em>the minimum element of this array</em>.</p>\n\n<p>You must write an algorithm that runs in&nbsp;<code>O(log n) time</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,4,5,1,2]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> The original array was [1,2,3,4,5] rotated 3 times.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [4,5,6,7,0,1,2]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> The original array was [0,1,2,4,5,6,7] and it was rotated 4 times.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [11,13,15,17]\n<strong>Output:</strong> 11\n<strong>Explanation:</strong> The original array was [11,13,15,17] and it was rotated 4 times. \n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 5000</code></li>\n\t<li><code>-5000 &lt;= nums[i] &lt;= 5000</code></li>\n\t<li>All the integers of <code>nums</code> are <strong>unique</strong>.</li>\n\t<li><code>nums</code> is sorted and rotated between <code>1</code> and <code>n</code> times.</li>\n</ul>\n","tags":["Array","Binary Search"],"java_snippet":"class Solution {\n    public int findMin(int[] nums) {\n        \n    }\n}","solution":"<h2><a href=\"#solution\"><svg><path></path></svg></a>Solution</h2>\n<hr/>\n<h3><a href=\"#approach-1-binary-search\"><svg><path></path></svg></a>Approach 1: Binary Search</h3>\n<p><strong>Intuition</strong></p>\n<p>A very brute way of solving this question is to search the entire array and find the minimum element. The time complexity for that would be O(N) given that <code>N</code> is the size of the array.</p>\n<p>A very cool way of solving this problem is using the <code>Binary Search</code> algorithm. In binary search we find out the mid point and decide to either search on the left or right depending on some condition.</p>\n<p>Since the given array is sorted, we can make use of binary search. However, the array is rotated. So simply applying the binary search won't work here.</p>\n<p>In this question we would essentially apply a modified version of binary search where the <code>condition</code> that decides the search direction would be different than in a standard binary search.</p>\n<p>We want to find the smallest element in a rotated sorted array. What if the array is not rotated? How do we check that?</p>\n<p>If the array is not rotated and the array is in ascending order, then <code>last element &gt; first element</code>.</p>\n<p>In the above example <code>7 &gt; 2</code>. This means that the array is still sorted and has no rotation.</p>\n<p>In the above example <code>3 &lt; 4</code>. Hence the array is rotated. This happens because the array was initially <code>[2, 3 ,4 ,5 ,6 ,7]</code>. But after the rotation the smaller elements<code>[2,3]</code> go at the back. i.e. [4, 5, 6, 7, <code>2, 3]</code>. Because of this the first element <code>[4]</code> in the rotated array becomes greater than the last element.</p>\n<p>This means there is a point in the array at which you would notice a change. This is the point which would help us in this question. We call this the <code>Inflection Point</code>.</p>\n<p>In this modified version of binary search algorithm, we are looking for this point. In the above example notice the <code>Inflection Point</code> .</p>\n<blockquote>\n<p>All the elements to the left of inflection point &gt; first element of the array.<br/><br/>\nAll the elements to the right of inflection point &lt; first element of the array.</p>\n</blockquote>\n<p><strong>Algorithm</strong></p>\n<ol>\n<li>\n<p>Find the <code>mid</code> element of the array.</p>\n</li>\n<li>\n<p>If <code>mid element &gt; first element of array</code> this means that we need to look for the inflection point on the right of <code>mid</code>.</p>\n</li>\n<li>\n<p>If <code>mid element &lt; first element of array</code> this means that we need to look for the inflection point on the left of <code>mid</code>.</p>\n</li>\n</ol>\n<p>In the above example mid element <code>6</code> is greater than first element <code>4</code>. Hence we continue our search for the inflection point to the right of mid.</p>\n<p>4 . We stop our search when we find the inflection point, when either of the two conditions is satisfied:</p>\n<p><code>nums[mid] &gt; nums[mid + 1]</code> Hence, <strong>mid+1</strong> is the smallest.</p>\n<p><code>nums[mid - 1] &gt; nums[mid]</code> Hence, <strong>mid</strong> is the smallest.</p>\n<p>In the above example. With the marked left and right pointers. The mid element is <code>2</code>. The element just before <code>2</code> is <code>7</code> and <code>7&gt;2</code> i.e. <code>nums[mid - 1] &gt; nums[mid]</code>. Thus we have found the point of inflection and <code>2</code> is the smallest element.</p>\n<p><strong>Implementation</strong></p>\n<pre><code>class Solution {\n    public int findMin(int[] nums) {\n        // If the list has just one element then return that element.\n        if (nums.length == 1) {\n            return nums[0];\n        }\n\n        // Initializing left and right pointers.\n        int left = 0, right = nums.length - 1;\n\n        // If the last element is greater than the first element then there is\n        // no rotation. E.g. 1 &lt; 2 &lt; 3 &lt; 4 &lt; 5 &lt; 7. Already sorted array. Hence\n        // the smallest element is first element. nums[0]\n        if (nums[right] &gt; nums[0]) {\n            return nums[0];\n        }\n\n        // Binary search way\n        while (right &gt;= left) {\n            // Find the mid element\n            int mid = left + (right - left) / 2;\n\n            // If the mid element is greater than its next element then mid+1\n            // element is the smallest. This point would be the point of change\n            // from higher to lower value.\n            if (nums[mid] &gt; nums[mid + 1]) {\n                return nums[mid + 1];\n            }\n\n            // If the mid element is lesser than its previous element then mid\n            // element is the smallest\n            if (nums[mid - 1] &gt; nums[mid]) {\n                return nums[mid];\n            }\n\n            // If the mid element's value is greater than the 0th element this\n            // means the least value is still somewhere to the right as we are\n            // still dealing with elements greater than nums[0]\n            if (nums[mid] &gt; nums[0]) {\n                left = mid + 1;\n            } else {\n                // If nums[0] is greater than the mid value then this means the\n                // smallest value is somewhere to the left\n                right = mid - 1;\n            }\n        }\n\n        return -1;\n    }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time Complexity : Same as Binary Search O(logN)</li>\n<li>Space Complexity : O(1)<br/>\n<br/><br/></li>\n</ul>"}