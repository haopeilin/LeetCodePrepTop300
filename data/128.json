{"id":"128","title":"Longest Consecutive Sequence","difficulty":"Medium","content":"<p>Given an unsorted array of integers <code>nums</code>, return <em>the length of the longest consecutive elements sequence.</em></p>\n\n<p>You must write an algorithm that runs in&nbsp;<code>O(n)</code>&nbsp;time.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [100,4,200,1,3,2]\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> The longest consecutive elements sequence is <code>[1, 2, 3, 4]</code>. Therefore its length is 4.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [0,3,7,2,5,8,4,6,0,1]\n<strong>Output:</strong> 9\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,0,1,2]\n<strong>Output:</strong> 3\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n","tags":["Array","Hash Table","Union-Find"],"java_snippet":"class Solution {\n    public int longestConsecutive(int[] nums) {\n        \n    }\n}","solution":"<h2><a href=\"#solution\"><svg><path></path></svg></a>Solution</h2>\n<hr/>\n<h3><a href=\"#approach-1-brute-force\"><svg><path></path></svg></a>Approach 1: Brute Force</h3>\n<h4>Intuition</h4>\n<p>Because a sequence could start at any number in <code>nums</code>, we can exhaust the<br/>\nentire search space by building as long a sequence as possible from every<br/>\nnumber.</p>\n<h4>Algorithm</h4>\n<p>The brute force algorithm does not do anything clever - it just considers<br/>\neach number in <code>nums</code>, attempting to count as high as possible from that<br/>\nnumber using only numbers in <code>nums</code>. After it counts too high (i.e.<br/>\n<code>currentNum</code> refers to a number that <code>nums</code> does not contain), it records the<br/>\nlength of the sequence if it is larger than the current best. The algorithm<br/>\nis necessarily optimal because it explores every possibility.</p>\n<h4>Implementation</h4>\n<pre><code>class Solution {\n    private boolean arrayContains(int[] arr, int num) {\n        for (int i = 0; i &lt; arr.length; i++) {\n            if (arr[i] == num) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public int longestConsecutive(int[] nums) {\n        int longestStreak = 0;\n        for (int num : nums) {\n            int currentNum = num;\n            int currentStreak = 1;\n            while (arrayContains(nums, currentNum + 1)) {\n                currentNum += 1;\n                currentStreak += 1;\n            }\n            longestStreak = Math.max(longestStreak, currentStreak);\n        }\n        return longestStreak;\n    }\n}</code></pre>\n<h4>Complexity Analysis</h4>\n<ul>\n<li>\n<p>Time complexity : O(n3).</p>\n<p>The outer loop runs exactly n times, and because <code>currentNum</code><br/>\nincrements by 1 during each iteration of the <code>while</code> loop, it runs in<br/>\nO(n) time. Then, on each iteration of the <code>while</code> loop, an O(n)<br/>\nlookup in the array is performed. Therefore, this brute force algorithm<br/>\nis really three nested O(n) loops, which compound multiplicatively to a<br/>\ncubic runtime.</p>\n</li>\n<li>\n<p>Space complexity : O(1).</p>\n<p>The brute force algorithm only allocates a handful of integers, so it uses constant<br/>\nadditional space.</p>\n</li>\n</ul>\n<br/>\n<hr/>\n<h3><a href=\"#approach-2-sorting\"><svg><path></path></svg></a>Approach 2: Sorting</h3>\n<h4>Intuition</h4>\n<p>If we can iterate over the numbers in ascending order, then it will be<br/>\neasy to find sequences of consecutive numbers. To do so, we can sort the<br/>\narray.</p>\n<h4>Algorithm</h4>\n<p>Before we do anything, we check for the base case input of the empty array.<br/>\nThe longest sequence in an empty array is, of course, 0, so we can simply<br/>\nreturn that. For all other cases, we sort <code>nums</code> and consider each number<br/>\nafter the first (because we need to compare each number to its previous<br/>\nnumber). If the current number and the previous are equal, then our current<br/>\nsequence is neither extended nor broken, so we simply move on to the next<br/>\nnumber. If they are unequal, then we must check whether the current number<br/>\nextends the sequence (i.e. <code>nums[i] == nums[i-1] + 1</code>). If it does, then we<br/>\nadd to our current count and continue. Otherwise, the sequence is broken, so<br/>\nwe record our current sequence and reset it to 1 (to include the number that<br/>\nbroke the sequence). It is possible that the last element of <code>nums</code> is part<br/>\nof the longest sequence, so we return the maximum of the current sequence and<br/>\nthe longest one.</p>\n<p></p>\n<p>Here, an example array is sorted before the linear scan identifies all consecutive sequences.<br/>\nThe longest sequence is colored in red.</p>\n<h4>Implementation</h4>\n<pre><code>import java.util.Arrays;\n\nclass Solution {\n    public int longestConsecutive(int[] nums) {\n        if (nums.length == 0) {\n            return 0;\n        }\n\n        Arrays.sort(nums);\n\n        int longestStreak = 1;\n        int currentStreak = 1;\n\n        for (int i = 1; i &lt; nums.length; i++) {\n            if (nums[i] != nums[i - 1]) {\n                if (nums[i] == nums[i - 1] + 1) {\n                    currentStreak += 1;\n                } else {\n                    longestStreak = Math.max(longestStreak, currentStreak);\n                    currentStreak = 1;\n                }\n            }\n        }\n\n        return Math.max(longestStreak, currentStreak);\n    }\n}</code></pre>\n<h4>Complexity Analysis</h4>\n<ul>\n<li>\n<p>Time complexity : O(nlogn)</p>\n<p>The main <code>for</code> loop does constant work n times, so the algorithm's time<br/>\ncomplexity is dominated by the invocation of <code>Arrays.sort</code>, which will run in<br/>\nO(nlogn) time for any sensible implementation.</p>\n</li>\n<li>\n<p>Space complexity : O(logn) or O(n)</p>\n<p>Note that some extra space is used when we sort an array in place. The space complexity of the sorting algorithm depends on the programming language.</p>\n<ul>\n<li>In Python, the <code>sort</code> method sorts a list using the Tim Sort algorithm which is a combination of Merge Sort and Insertion Sort and has O(n) additional space. Additionally, Tim Sort is designed to be a stable algorithm.</li>\n<li>In Java, <code>Arrays.sort()</code> is implemented using a variant of the Quick Sort algorithm which has a space complexity of O(logn) for sorting an array.</li>\n</ul>\n</li>\n</ul>\n<hr/>\n<h3><a href=\"#approach-3-hashset-and-intelligent-sequence-building\"><svg><path></path></svg></a>Approach 3: HashSet and Intelligent Sequence Building</h3>\n<p><strong>Intuition</strong></p>\n<p>It turns out that our initial brute force solution was on the right track, but missing<br/>\na few optimizations necessary to reach O(n) time complexity.</p>\n<p><strong>Algorithm</strong></p>\n<p>This optimized algorithm contains only two changes from the brute force<br/>\napproach: the numbers are stored in a <code>HashSet</code> to<br/>\nallow O(1) lookups, and we only attempt to build sequences from numbers<br/>\nthat are not already part of a longer sequence. This is accomplished by first<br/>\nensuring that the number that would immediately precede the current number in<br/>\na sequence is not present, as that number would necessarily be part of a<br/>\nlonger sequence.</p>\n<pre><code>import java.util.HashSet;\nimport java.util.Set;\n\nclass Solution {\n    public int longestConsecutive(int[] nums) {\n        Set&lt;Integer&gt; numSet = new HashSet&lt;&gt;();\n        for (int num : nums) {\n            numSet.add(num);\n        }\n\n        int longestStreak = 0;\n\n        for (int num : numSet) {\n            if (!numSet.contains(num - 1)) {\n                int currentNum = num;\n                int currentStreak = 1;\n\n                while (numSet.contains(currentNum + 1)) {\n                    currentNum += 1;\n                    currentStreak += 1;\n                }\n\n                longestStreak = Math.max(longestStreak, currentStreak);\n            }\n        }\n\n        return longestStreak;\n    }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : O(n).</p>\n<p>Although the time complexity appears to be quadratic due to the <code>while</code><br/>\nloop nested within the <code>for</code> loop, closer inspection reveals it to be<br/>\nlinear. Because the <code>while</code> loop is reached only when <code>currentNum</code> marks<br/>\nthe beginning of a sequence (i.e. <code>currentNum-1</code> is not present in<br/>\n<code>nums</code>), the <code>while</code> loop can only run for n iterations throughout the<br/>\nentire runtime of the algorithm. This means that despite looking like<br/>\nO(nâ‹…n) complexity, the nested loops actually run in O(n+n)=O(n)<br/>\ntime. All other computations occur in constant time, so the overall<br/>\nruntime is linear.</p>\n</li>\n<li>\n<p>Space complexity : O(n).</p>\n<p>In order to set up O(1) containment lookups, we allocate linear space<br/>\nfor a hash table to store the O(n) numbers in <code>nums</code>. Other than that,<br/>\nthe space complexity is identical to that of the brute force solution.</p>\n</li>\n</ul>"}