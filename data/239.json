{"id":"239","title":"Sliding Window Maximum","difficulty":"Hard","content":"<p>You are given an array of integers&nbsp;<code>nums</code>, there is a sliding window of size <code>k</code> which is moving from the very left of the array to the very right. You can only see the <code>k</code> numbers in the window. Each time the sliding window moves right by one position.</p>\n\n<p>Return <em>the max sliding window</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,3,-1,-3,5,3,6,7], k = 3\n<strong>Output:</strong> [3,3,5,5,6,7]\n<strong>Explanation:</strong> \nWindow position                Max\n---------------               -----\n[1  3  -1] -3  5  3  6  7       <strong>3</strong>\n 1 [3  -1  -3] 5  3  6  7       <strong>3</strong>\n 1  3 [-1  -3  5] 3  6  7      <strong> 5</strong>\n 1  3  -1 [-3  5  3] 6  7       <strong>5</strong>\n 1  3  -1  -3 [5  3  6] 7       <strong>6</strong>\n 1  3  -1  -3  5 [3  6  7]      <strong>7</strong>\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1], k = 1\n<strong>Output:</strong> [1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= nums.length</code></li>\n</ul>\n","tags":["Array","Queue","Sliding Window","Heap (Priority Queue)","Monotonic Queue"],"java_snippet":"class Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        \n    }\n}","solution":"<div class=\"flex flex-col w-full\" style=\"position: relative;\"><div class=\"mYe_l WRmCx\"><h2 class=\"group/heading relative\" id=\"solution\" level=\"2\"><a aria-hidden=\"true\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" href=\"#solution\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" data-icon=\"link\" data-prefix=\"fas\" focusable=\"false\" role=\"img\" spacing=\"square\" viewbox=\"0 0 640 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\" fill=\"currentColor\"></path></svg></div></a>Solution</h2>\n<hr/>\n<h3 class=\"group/heading relative\" id=\"overview\" level=\"3\"><a aria-hidden=\"true\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" href=\"#overview\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" data-icon=\"link\" data-prefix=\"fas\" focusable=\"false\" role=\"img\" spacing=\"square\" viewbox=\"0 0 640 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\" fill=\"currentColor\"></path></svg></div></a>Overview</h3>\n<p>We are given an array of integers <code>nums</code> and there is a sliding window of size <code>k</code> which is moving from the left of the array to the right.</p>\n<p>Our task is to return a list of integers that contains the largest element from each window.</p>\n<hr/>\n<h3 class=\"group/heading relative\" id=\"approach-monotonic-deque\" level=\"3\"><a aria-hidden=\"true\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" href=\"#approach-monotonic-deque\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" data-icon=\"link\" data-prefix=\"fas\" focusable=\"false\" role=\"img\" spacing=\"square\" viewbox=\"0 0 640 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\" fill=\"currentColor\"></path></svg></div></a>Approach: Monotonic Deque</h3>\n<h4 id=\"intuition\">Intuition</h4>\n<p>An intuitive way to solve the problem is to iterate over all windows and then iterate over all the elements in a window to find the largest element. There are a total of <code>n - k + 1</code> (where <code>n</code> is the size of <code>nums</code>) windows and it would take <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right: 0.03148em;\">k</span><span class=\"mclose\">)</span></span></span></span></span> to find the largest element from each window. This strategy is too slow and would result in TLE.</p>\n<p>Let's make some observations and reduce the time complexity.</p>\n<p>We may observe that in a window, the elements that come before the largest element will never be selected as the largest element of any future windows. For example, consider a window <code>[1, 2, 3, 4, 1]</code>. Because the window is sliding left to right, any window with the first three elements <code>1</code>, <code>2</code>, and <code>3</code> would also have the <code>4</code>.</p>\n<p>However, we cannot ignore the items that follow the largest element. If we use the above example, we cannot ignore the last element <code>1</code> since there may be a window from the fourth index (0-based indexing) until the eighth index where <code>1</code> is the largest element. The elements at indices <code>3</code> and <code>4</code> are those that will be <strong>\"useful\"</strong> in the following windows.</p>\n<p>Therefore, we can discard the first three elements and only take into account the elements at indices <code>3</code> and <code>4</code>.</p>\n<p>Now, let's consider the next element and call it <code>x</code>. We need to add <code>x</code> to the window to consider the next window. If <code>x &gt; 1</code>, then we can now discard the <code>1</code> because <code>x</code> will be in any future windows that <code>1</code> is in. If <code>x &gt; 4</code>, we can discard the <code>4</code> as well for the same reason.</p>\n<blockquote>\n<p>In general, whenever we encounter a new element <code>x</code>, we want to discard all elements that are less than <code>x</code> before adding <code>x</code>. Let's say we currently have <code>[63, 15, 8, 3]</code> and we encounter <code>12</code>. Any future window with <code>8</code> or <code>3</code> will also contain <code>12</code>, so we can discard them. After discarding them and adding <code>12</code>, we have <code>[63, 15, 12]</code>. As you can see, we keep elements in descending order.</p>\n</blockquote>\n<p>To perform these operations, we can use a <strong>monotonic queue</strong> as it supports efficient insertion, deletion, and retrieval of elements from the ends of a window. We will implement it with the <strong>deque</strong> data structure.</p>\n<p>A monotonic data structure is one where the elements are always sorted. In our case, we want a monotonic decreasing queue, which means that the elements in the queue are always sorted descending. When we want to add a new element <code>x</code>, we maintain the monotonic property by removing all elements less than <code>x</code> before adding <code>x</code>.</p>\n<p>We initialize a deque of integers <code>dq</code>. It will contain the indices of the \"useful\" elements in the current window. The reason we need to store the indices instead of the elements themselves is that we need to detect when elements leave the window due to sliding too far to the right.</p>\n<p>We also initialize an array of integers <code>res</code> to store the answer.</p>\n<p>By maintaining the monotonic decreasing property, the largest element in the window must always be the first element in the deque, which is <code>nums[dq[0]]</code>.</p>\n<p>We initialize the first window with the first <code>k</code> elements. Then we iterate over the indices <code>i</code> in the range <code>[k, n - 1]</code>, and for each element, we add its index to <code>dq</code> while maintaining the monotonic property. We also remove the first element in <code>dq</code> if it is too far to the left (<code>dq[0] = i - k</code>). After these operations, <code>dq</code> will correctly hold the indices of all useful elements in the current window in decreasing order. Thus, we can push <code>nums[dq[0]]</code> to the answer.</p>\n<p>Here's an animation visually showing how the approach works:</p>\n<p></p>\n<p>You can see that the deque's size never goes above <code>k</code> at any time. This is because we are only ever taking into account the \"useful\" elements of the current window.</p>\n<p>There can be <code>k</code> indices in the deque when all the elements of a window are sorted in descending order. If the elements are not sorted, there will be some useless elements and the size of the deque would be less than <code>k</code>.</p>\n<p>Since we consistently add the largest index to the end of the deque and remove some other indices that correspond to useless elements, we are essentially storing indices in ascending order. When taking into account a window with the last element at index <code>i</code>, all of the deque's elements are greater than <code>i - k</code>. As a result, the size of deque can never exceed <code>k</code>.</p>\n<h4 id=\"algorithm\">Algorithm</h4>\n<ol>\n<li data-length=\"1\">Create a deque <code>dq</code> of integers.</li>\n<li data-length=\"1\">Create a list of integers <code>res</code> to store the answer.</li>\n<li data-length=\"1\">Iterate over the first <code>k</code> elements from <code>i = 0</code> to <code>k - 1</code> and perform the following:\n<ul>\n<li>While <code>dq</code> is not empty and the current element <code>nums[i]</code> is greater or equal to <code>nums[dq.peekLast()]</code>, continue to pop the last element.</li>\n<li>Push <code>i</code> at the end of <code>dq</code>.</li>\n</ul>\n</li>\n<li data-length=\"1\">Push the largest element of the first window <code>nums[dq.peekFirst()]</code> to the answer.</li>\n<li data-length=\"1\">We iterate over all the remaining elements from <code>i = k</code> to <code>n - 1</code> to move to the next windows. We perform the following in this loop:\n<ul>\n<li>Check if the element at the front of <code>dq</code> is equal to <code>i - k</code>. If it is equal to <code>i - k</code>, it cannot be included in the current window. We pop this element.</li>\n<li>While <code>dq</code> is not empty and the current element <code>nums[i]</code> is greater or equal to <code>nums[dq.back()]</code>, continue to pop the last element.</li>\n<li>Push <code>i</code> at the end of <code>dq</code>.</li>\n<li>Push the largest element of the current window <code>nums[dq.peekFirst()]</code> to the answer.</li>\n</ul>\n</li>\n<li data-length=\"1\">Return <code>res</code>.</li>\n</ol>\n<h4 id=\"implementation\">Implementation</h4>\n<pre><code>class Solution {\npublic:\n    vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k){\n        deque&lt;int&gt; dq;\n        vector&lt;int&gt; res;\n        for (int i = 0; i &lt; k; i++) {\n            while (!dq.empty() &amp;&amp; nums[i] &gt;= nums[dq.back()]) {\n                dq.pop_back();\n            }\n            dq.push_back(i);\n        }\n        res.push_back(nums[dq.front()]);\n​\n        for (int i = k; i &lt; nums.size(); i++) {\n            if(dq.front() == i - k) {\n                dq.pop_front();\n            }\n            while (!dq.empty() &amp;&amp; nums[i] &gt;= nums[dq.back()]) {\n                dq.pop_back();\n            }\n​\n            dq.push_back(i);\n            res.push_back(nums[dq.front()]);\n        }\n        \n        return res;\n    }\n};</code></pre>\n<h4 id=\"complexity-analysis\">Complexity Analysis</h4>\n<p>Here <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></span> is the size of <code>nums</code>.</p>\n<ul>\n<li>\n<p>Time complexity: <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n<ul>\n<li>At first glance, it may look like the time complexity of this algorithm should be <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1.0641em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.8141em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span>, because there is a nested while loop inside the for loop. However, each element can only be added to the deque once, which means the deque is limited to <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></span> pushes. Every iteration of the while loop uses <code>1</code> pop, which means the while loop will not iterate more than <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></span> times in total, across all iterations of the for loop.</li>\n<li>An easier way to think about this is that in the worst case, every element will be pushed and popped once. This gives a time complexity of <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span>.</li>\n</ul>\n</li>\n<li>\n<p>Space complexity: <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right: 0.03148em;\">k</span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n<ul>\n<li>The size of the deque can grow a maximum up to a size of <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.03148em;\">k</span></span></span></span></span>.</li>\n</ul>\n</li>\n</ul></div><span style=\"font-size: 0px; line-height: 0;\"> </span></div>"}