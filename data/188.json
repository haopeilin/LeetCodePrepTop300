{"id":"188","title":"Best Time to Buy and Sell Stock IV","difficulty":"Hard","content":"<p>You are given an integer array <code>prices</code> where <code>prices[i]</code> is the price of a given stock on the <code>i<sup>th</sup></code> day, and an integer <code>k</code>.</p>\n\n<p>Find the maximum profit you can achieve. You may complete at most <code>k</code> transactions: i.e. you may buy at most <code>k</code> times and sell at most <code>k</code> times.</p>\n\n<p><strong>Note:</strong> You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> k = 2, prices = [2,4,1]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> k = 2, prices = [3,2,6,5,0,3]\n<strong>Output:</strong> 7\n<strong>Explanation:</strong> Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4. Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= 100</code></li>\n\t<li><code>1 &lt;= prices.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= prices[i] &lt;= 1000</code></li>\n</ul>\n","tags":["Array","Dynamic Programming"],"java_snippet":"class Solution {\n    public int maxProfit(int k, int[] prices) {\n        \n    }\n}","solution":"<h2><a href=\"#solution\"><svg><path></path></svg></a>Solution</h2>\n<hr/>\n<h3><a href=\"#overview\"><svg><path></path></svg></a>Overview</h3>\n<p>You probably can guess from the problem title, that this is the fourth problem in the series of <a href=\"https://leetcode.com/problems/best-time-to-buy-and-sell-stock/\">Best Time to Buy and Sell Stock</a> problem. It's strongly recommended that you should finish the previous problems before starting this one. Nevertheless, it's not necessary to finish the previous problems to understand this solution, and you can even use the methods we provide to help you solve the other problems.</p>\n<p>Here, two approaches are introduced: <em>Dynamic Programming</em> approach, and <em>Merging</em> approach. Both are awesome, but the first method is more universal to other problems.</p>\n<hr/>\n<h3><a href=\"#approach-1-dynamic-programming\"><svg><path></path></svg></a>Approach 1: Dynamic Programming</h3>\n<h4>Intuition</h4>\n<p><a href=\"https://en.wikipedia.org/wiki/Dynamic_programming\">Dynamic programming</a> (DP) is a popular method among hard-level problems. Its basic idea is to store the previous result to reduce redundant calculations. However, it is hard for beginners to think of the DP method. Below, a step-by-step tutorial on how to think of dp is introduced. If you are already familiar with dp, you can jump to the algorithm part to check out the actual implementation.</p>\n<p>Generally, there are two ways to come up with a DP solution. One way is to start with a brute-force approach and reduce unnecessary calculations. Another way is to treat the stored results as \"states\", and try to jump from the starting state to the ending state.</p>\n<p>For beginners, it is recommended to start with the brute force approach. So, how to brute force solve this problem?</p>\n<p>Back to (part of) the question:</p>\n<blockquote>\n<p>Say you have an array for which the i-th element is the price of a given stock on day i.</p>\n<p>Design an algorithm to find the maximum profit. You may complete at most k transactions.</p>\n</blockquote>\n<p>Cool, looks like we need to arrange at most k transactions. A natural idea is to iterate all the possible combinations of k transactions, and then find the best combination. As for those with less than k transactions, they are similar and can be considered later. A transaction consists of two parts: buying and selling. Therefore, we need to find 2k points in the stock line, k points for buying, and k points for selling.</p>\n<p>Now, we can roughly estimate the time complexity. Suppose there are n days in total, and we need to pick 2k days. The number of possible situations is about Cn2k​=(2k)!(n−2k)!n!​. It's not a good result because it involves factorial, which is likely to cause Time Limit Exceeded (TLE). Usually what we need is a polynomial one. However, it includes some invalid situations so the actual number is smaller.</p>\n<p>Another problem is that what if <code>k * 2</code> is larger than n? In this case, we are not able to pick 2k points from n points, which means we will not reach the limit no matter how we try. Therefore, all we need to do is to iterate each day, and if the price of day <code>i</code> rises, buy the stock in i-1th day and sell it at ith day.</p>\n<blockquote>\n<p>k⋅2≥n is a special case and can be addressed easily.</p>\n</blockquote>\n<p>Back to our factorial number. The next step is to review our brute force approach and find out the possible redundant calculations. In our brute force approach, we need to iterate all the possible combinations and calculate the profit of each one to find the best. Can you find out where repeated calculations are?</p>\n<p>Consider the following case, where the red color represents a possible combination, and the green represents another one:</p>\n<p></p>\n<p>The two combinations are the same before day 10. If we calculate the profits separately, we need to calculate the profit before day 10 twice. Here is where dp comes in! We can store the current balance on day 9, and reuse it later. Therefore, we can store the result in a hash map, where the key is the day number and the transactions we made before, and the value is the balance. Wait a minute, can we do better?</p>\n<p>Consider another case:</p>\n<p></p>\n<p>The only difference is that the red sells stock at a lower price during the second transaction. Therefore, the red has a lower profit on day 10 than the green has. In this case, we need not calculate the rest profit of the red, since it can not beat the green in the future.</p>\n<p>Therefore, we can compare those reds, and continue the next day with the one with the highest profit. However, we need to ensure that the best one will not be beaten by the \"losers\" in the future, so they should have the same \"resources\" at the time we store and compare the balances.</p>\n<p>Hence, we can use three characteristics to store the profit: the day number, the transaction number used, and the stock holding status. You can use other representations of resources, such as using \"the day remained\" instead of \"the day number\". Feel free to try. Now, let's go to the algorithm part.</p>\n<h4>Algorithm</h4>\n<p>In the previous part, we introduced an intuitive idea from brute force to dp method, and here we need to decide the details of the algorithm.</p>\n<p>We can either store the dp results in a dictionary or an array. An array costs less time to access and update than a dictionary, so we always prefer an array when possible. Because of three needed characteristics (day number, transaction number used, stock holding status), a three-dimensional array is our choice. We can use<br/>\n<code>dp[day_number][used_transaction_number][stock_holding_status]</code> to represent our states, where <code>stock_holding_status</code> is a 0/1 number representing whether you hold the stock or not.</p>\n<blockquote>\n<p>The value of <code>dp[i][j][l]</code> represents the best profit we can have at the end of the <code>i</code>-th day, with <code>j</code> remaining transactions to make and <code>l</code> stocks.</p>\n</blockquote>\n<p>The next step is finding out the so-called \"transition equation\", which is a method that tells you how to jump from one state to another.</p>\n<p>We start with <code>dp[0][0][0] = 0</code> and <code>dp[0][1][1]=-prices[0]</code>, and our final aim is max of <code>dp[n-1][j][0]</code> from <code>j=0</code> to <code>j=k</code>. Now, we need to fill out the entire array to find out the result. Assume we have gotten the results before day <code>i</code>, and we need to calculate the profit of day <code>i</code>. There are only four possible actions we can do on the day <code>i</code>: 1. keep holding the stock, 2. keep not holding the stock, 3. buy the stock, or 4. sell the stock. The profit is easy to calculate.</p>\n<ol>\n<li>Keep holding the stock:</li>\n</ol>\n<p>dp[i][j][1]=dp[i−1][j][1]</p>\n<ol>\n<li>Keep not holding the stock:</li>\n</ol>\n<p>dp[i][j][0]=dp[i−1][j][0]</p>\n<ol>\n<li>Buying, when j&gt;0:</li>\n</ol>\n<p>dp[i][j][1]=dp[i−1][j−1][0]−prices[i]</p>\n<ol>\n<li>Selling:</li>\n</ol>\n<p>dp[i][j][0]=dp[i−1][j][1]+prices[i]</p>\n<p>We can combine them together to find the maximum profit:</p>\n<p>dp[i][j][1]=max(dp[i−1][j][1],dp[i−1][j−1][0]−prices[i])</p>\n<p>dp[i][j][0]=max(dp[i−1][j][0],dp[i−1][j][1]+prices[i])</p>\n<p>Awesome! Now we can use for-loop to calculate the whole dp array and achieve our final result. Remember to solve the special cases when k⋅2≥n.</p>\n<h4>Implementation</h4>\n<pre><code>class Solution {\n    public int maxProfit(int k, int[] prices) {\n        int n = prices.length;\n\n        // Solve special cases\n        if (n &lt;= 0 || k &lt;= 0) {\n            return 0;\n        }\n\n        if (k * 2 &gt;= n) {\n            int res = 0;\n            for (int i = 1; i &lt; n; i++) {\n                res += Math.max(0, prices[i] - prices[i - 1]);\n            }\n            return res;\n        }\n\n        // dp[i][used_k][is_hold] = balance\n        // is_hold: 0 not_hold, 1 hold\n        int[][][] dp = new int[n][k + 1][2];\n\n        // initialize the array with -inf\n        // we use Integer.MIN_VALUE / 2 here to prevent overflow\n        for (int i = 0; i &lt; n; i++) {\n            for (int j = 0; j &lt;= k; j++) {\n                dp[i][j][0] = Integer.MIN_VALUE / 2;\n                dp[i][j][1] = Integer.MIN_VALUE / 2;\n            }\n        }\n\n        // set starting value\n        dp[0][0][0] = 0;\n        dp[0][1][1] = -prices[0];\n\n        // fill the array\n        for (int i = 1; i &lt; n; i++) {\n            for (int j = 0; j &lt;= k; j++) {\n                // transition equation\n                dp[i][j][0] = Math.max(dp[i - 1][j][0], dp[i - 1][j][1] + prices[i]);\n                // you can't hold stock without any transaction\n                if (j &gt; 0) {\n                    dp[i][j][1] =\n                        Math.max(dp[i - 1][j][1], dp[i - 1][j - 1][0] - prices[i]);\n                }\n            }\n        }\n\n        int res = 0;\n        for (int j = 0; j &lt;= k; j++) {\n            res = Math.max(res, dp[n - 1][j][0]);\n        }\n\n        return res;\n    }\n}</code></pre>\n<p>There are a few points you should notice from the code above:</p>\n<ol>\n<li>\n<p>Take care of the initial values in the DP array. Generally, it's okay to initialize them to zero. However, in this case, we need to make them -inf to mark impossible situations, such as <code>dp[0][0][1]</code>.</p>\n</li>\n<li>\n<p>You can reverse the order of filling the dp array, with some modifications in the transition equation. For example, decreasing <code>j</code> instead of increasing it.</p>\n</li>\n<li>\n<p>Some state-compressed methods can be applied if you want. For example, we only need <code>dp[i-1]</code>, when calculating <code>dp[i]</code>, therefore we can delete other useless <code>dp</code> to save memory. Just using two arrays to store <code>dp[i-1]</code> and <code>dp[i]</code> and refreshing them every iteration will do.</p>\n</li>\n<li>\n<p>The code above is not the fastest because we prioritize readability. It would be faster if you put the larger dimension in the inner array since it uses the CPU cache more efficiently.</p>\n</li>\n</ol>\n<h4>Complexity Analysis</h4>\n<ul>\n<li>\n<p>Time Complexity: O(nk) if k⋅2≤n, O(n) if k⋅2&gt;n, where n is the length of the <code>prices</code> sequence since we have two for-loop.</p>\n<br/>\n</li>\n<li>\n<p>Space Complexity: O(nk) without state-compressed, and O(k) with state-compressed, where n is the length of the <code>prices</code> sequence.</p>\n</li>\n</ul>\n<hr/>\n<h3><a href=\"#approach-2-merging\"><svg><path></path></svg></a>Approach 2: Merging</h3>\n<h4>Intuition</h4>\n<p>This approach starts from a simple situation with k=infinity and decreases k one by one.</p>\n<p>Consider a weakened problem when k=infinity. Since we already know the prices of tomorrow, our solution is to trade whenever <code>prices[i-1] &lt; prices[i]</code>. Below is an example.</p>\n<p></p>\n<p>We only used 4 transactions! However, what we need to solve is the case with an actual k. Let's decrease k from inf and see what happens. Our solution can handle all the k &gt;= 4 since we only used 4 transactions. But what if k=3?</p>\n<p>Notice that on day 5, we buy and sell the stock at the same time. We can cancel the redundant transaction without impacting the final profit!</p>\n<p></p>\n<p>We can conclude that for the consecutively increasing subsequence, we only need to buy once at the start and sell once at the end.</p>\n<p>How about k=2? Maybe we need to delete one transaction. We can iterate all the transactions and delete the one with the least revenue. However, deleting can not always achieve our best solution. Consider the following example:</p>\n<p></p>\n<p>When k=2, the best solution is to buy on day 1 and day 9 and to sell on day 6 and day 10. Deleting any transactions cannot reach this solution. However, we can merge the previous two transactions to get to this. A naive approach is iterating all the near transactions and finding out the pair with the lowest impact on the revenue. Since we decrease k one by one, reducing one transaction is enough. Ok, let's go to the algorithm part to check the details.</p>\n<h4>Algorithm</h4>\n<p>The general idea is to store all consecutively increasing subsequence as the initial solution. Then delete or merge transactions until the number of transactions is less than or equal to k.</p>\n<h4>Implementation</h4>\n<pre><code>class Solution {\n    public int maxProfit(int k, int[] prices) {\n        int n = prices.length;\n\n        // solve special cases\n        if (n &lt;= 0 || k &lt;= 0) {\n            return 0;\n        }\n\n        // find all consecutively increasing subsequence\n        java.util.List&lt;int[]&gt; transactions = new java.util.ArrayList&lt;&gt;();\n        int start = 0;\n        int end = 0;\n        for (int i = 1; i &lt; n; i++) {\n            if (prices[i] &gt;= prices[i - 1]) {\n                end = i;\n            } else {\n                if (end &gt; start) {\n                    transactions.add(new int[]{start, end});\n                }\n                start = i;\n            }\n        }\n        if (end &gt; start) {\n            transactions.add(new int[]{start, end});\n        }\n\n        while (transactions.size() &gt; k) {\n            // check delete loss\n            int deleteIndex = 0;\n            int minDeleteLoss = Integer.MAX_VALUE;\n            for (int i = 0; i &lt; transactions.size(); i++) {\n                int[] t = transactions.get(i);\n                int profitLoss = prices[t[1]] - prices[t[0]];\n                if (profitLoss &lt; minDeleteLoss) {\n                    minDeleteLoss = profitLoss;\n                    deleteIndex = i;\n                }\n            }\n\n            // check merge loss\n            int mergeIndex = 0;\n            int minMergeLoss = Integer.MAX_VALUE;\n            for (int i = 1; i &lt; transactions.size(); i++) {\n                int[] t1 = transactions.get(i - 1);\n                int[] t2 = transactions.get(i);\n                int profitLoss = prices[t1[1]] - prices[t2[0]];\n                if (profitLoss &lt; minMergeLoss) {\n                    minMergeLoss = profitLoss;\n                    mergeIndex = i;\n                }\n            }\n\n            // delete or merge\n            if (minDeleteLoss &lt;= minMergeLoss) {\n                transactions.remove(deleteIndex);\n            } else {\n                int[] t1 = transactions.get(mergeIndex - 1);\n                int[] t2 = transactions.get(mergeIndex);\n                t1[1] = t2[1];\n                transactions.remove(mergeIndex);\n            }\n        }\n\n        int res = 0;\n        for (int[] t : transactions) {\n            res += prices[t[1]] - prices[t[0]];\n        }\n\n        return res;\n    }\n}</code></pre>\n<h4>Complexity Analysis</h4>\n<ul>\n<li>\n<p>Time Complexity: O(n(n−k)) if 2k​≤n , O(n) if 2k​&gt;n, where n is the length of the price sequence. The maximum size of <code>transactions</code> is O(n), and we need O(n−k) iterations.</p>\n<br/>\n</li>\n<li>\n<p>Space Complexity: O(n), since we need a list to store <code>transactions</code>.</p>\n</li>\n</ul>"}