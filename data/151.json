{"id":"151","title":"Reverse Words in a String","difficulty":"Medium","content":"<p>Given an input string <code>s</code>, reverse the order of the <strong>words</strong>.</p>\n\n<p>A <strong>word</strong> is defined as a sequence of non-space characters. The <strong>words</strong> in <code>s</code> will be separated by at least one space.</p>\n\n<p>Return <em>a string of the words in reverse order concatenated by a single space.</em></p>\n\n<p><b>Note</b> that <code>s</code> may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;the sky is blue&quot;\n<strong>Output:</strong> &quot;blue is sky the&quot;\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;  hello world  &quot;\n<strong>Output:</strong> &quot;world hello&quot;\n<strong>Explanation:</strong> Your reversed string should not contain leading or trailing spaces.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;a good   example&quot;\n<strong>Output:</strong> &quot;example good a&quot;\n<strong>Explanation:</strong> You need to reduce multiple spaces between two words to a single space in the reversed string.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>s</code> contains English letters (upper-case and lower-case), digits, and spaces <code>&#39; &#39;</code>.</li>\n\t<li>There is <strong>at least one</strong> word in <code>s</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><b data-stringify-type=\"bold\">Follow-up:&nbsp;</b>If the string data type is mutable in your language, can&nbsp;you solve it&nbsp;<b data-stringify-type=\"bold\">in-place</b>&nbsp;with&nbsp;<code data-stringify-type=\"code\">O(1)</code>&nbsp;extra space?</p>\n","tags":["Two Pointers","String"],"java_snippet":"class Solution {\n    public String reverseWords(String s) {\n        \n    }\n}","solution":"<h2><a href=\"#solution\"><svg><path></path></svg></a>Solution</h2>\n<hr/>\n<h3><a href=\"#overview\"><svg><path></path></svg></a>Overview</h3>\n<p>Different interviewers would probably expect different approaches to this problem. The holy war question is whether to use or not use built-in methods. As you may notice, most of the design problems on Leetcode are voted down because of two main reasons:</p>\n<ol>\n<li>\n<p>There was no approach with built-in methods/data structures in the article.</p>\n</li>\n<li>\n<p>One of the approaches in the article did contain built-in methods/data structures.</p>\n</li>\n</ol>\n<p>Seems like the community has no common opinion yet, and in practice that means an unpredictable interview experience for some sort of problem.</p>\n<p>Here we consider three different solutions for linear time and space complexity:</p>\n<ol>\n<li>\n<p>Use built-in split and reverse. Benefits: in-place in Java (in-place, but linear space complexity!) and the simplest one to write.</p>\n</li>\n<li>\n<p>The most straightforward one. Trim the whitespaces, reverse the whole string, and then reverse each word. Benefits: This could be done in place for the languages with mutable strings.</p>\n</li>\n<li>\n<p>Two passes approach with a deque. Move along the string, word by word, and push each new word in front of the deque. Convert the deque back into a string. Benefits: two passes.</p>\n</li>\n</ol>\n<h3><a href=\"#approach-1-built-in-split--reverse\"><svg><path></path></svg></a>Approach 1: Built-in Split + Reverse</h3>\n<p></p>\n<p><strong>Implementation</strong></p>\n<pre><code>class Solution {\n    public String reverseWords(String s) {\n        // remove leading and trailing spaces\n        s = s.trim();\n\n        // split by spaces\n        String[] words = s.split(\"\\\\s+\");\n\n        // reverse and join\n        StringBuilder sb = new StringBuilder();\n        for (int i = words.length - 1; i &gt;= 0; i--) {\n            sb.append(words[i]);\n            if (i != 0) {\n                sb.append(\" \");\n            }\n        }\n        return sb.toString();\n    }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity: O(N), where N is the number of characters in the input string.</p>\n</li>\n<li>\n<p>Space complexity: O(N), to store the result of split by spaces.</p>\n</li>\n</ul>\n<br/>\n<br/>\n<hr/>\n<h3><a href=\"#approach-2-reverse-the-whole-string-and-then-reverse-each-word\"><svg><path></path></svg></a>Approach 2: Reverse the Whole String and Then Reverse Each Word</h3>\n<p>The implementation of this approach will be different for Java/Python (= immutable strings) and Java (= mutable strings).</p>\n<p>In the case of immutable strings, one has first to convert the string into a mutable data structure, and hence it makes sense to trim all spaces during that conversion.</p>\n<p></p>\n<p>In the case of <em>mutable</em> strings, there is no need to allocate an additional data structure, one could get all jobs done in-place. In such a case it makes sense to reverse words and trim spaces at the same time.</p>\n<p></p>\n<p><strong>Implementation</strong></p>\n<pre><code>class Solution {\n    public String reverseWords(String s) {\n        // convert to a mutable structure\n        StringBuilder sb = new StringBuilder(s);\n        sb.reverse();\n\n        int n = sb.length();\n        int idx = 0;\n\n        for (int start = 0; start &lt; n; start++) {\n            if (sb.charAt(start) != ' ') {\n                // add space between words\n                if (idx != 0) {\n                    sb.setCharAt(idx++, ' ');\n                }\n\n                int end = start;\n                while (end &lt; n &amp;&amp; sb.charAt(end) != ' ') {\n                    sb.setCharAt(idx++, sb.charAt(end++));\n                }\n\n                // reverse the word\n                reverse(sb, idx - (end - start), idx);\n\n                // move to the next word\n                start = end;\n            }\n        }\n\n        sb.setLength(idx);\n        return sb.toString();\n    }\n\n    private void reverse(StringBuilder sb, int left, int right) {\n        right--;\n        while (left &lt; right) {\n            char tmp = sb.charAt(left);\n            sb.setCharAt(left, sb.charAt(right));\n            sb.setCharAt(right, tmp);\n            left++;\n            right--;\n        }\n    }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity: O(N).</p>\n</li>\n<li>\n<p>Space complexity: O(N).</p>\n<br/>\n</li>\n</ul>\n<br/>\n<hr/>\n<h3><a href=\"#approach-3-deque-of-words\"><svg><path></path></svg></a>Approach 3: Deque of Words</h3>\n<p></p>\n<p><strong>Implementation</strong></p>\n<pre><code>import java.util.ArrayDeque;\nimport java.util.Deque;\n\nclass Solution {\n    public String reverseWords(String s) {\n        int left = 0, right = s.length() - 1;\n        while (left &lt;= right &amp;&amp; s.charAt(left) == ' ') left++;\n        while (left &lt;= right &amp;&amp; s.charAt(right) == ' ') right--;\n\n        Deque<string> d = new ArrayDeque&lt;&gt;();\n        StringBuilder word = new StringBuilder();\n\n        while (left &lt;= right) {\n            char c = s.charAt(left);\n            if (c == ' ' &amp;&amp; word.length() &gt; 0) {\n                d.addFirst(word.toString());\n                word.setLength(0);\n            } else if (c != ' ') {\n                word.append(c);\n            }\n            left++;\n        }\n        d.addFirst(word.toString());\n\n        StringBuilder result = new StringBuilder();\n        while (!d.isEmpty()) {\n            result.append(d.pollFirst());\n            if (!d.isEmpty()) {\n                result.append(\" \");\n            }\n        }\n        return result.toString();\n    }\n}</string></code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity: O(N).</p>\n</li>\n<li>\n<p>Space complexity: O(N).</p>\n</li>\n</ul>"}