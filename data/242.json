{"id":"242","title":"Valid Anagram","difficulty":"Easy","content":"<p>Given two strings <code>s</code> and <code>t</code>, return <code>true</code> if <code>t</code> is an <span data-keyword=\"anagram\">anagram</span> of <code>s</code>, and <code>false</code> otherwise.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">s = &quot;anagram&quot;, t = &quot;nagaram&quot;</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">true</span></p>\n</div>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">s = &quot;rat&quot;, t = &quot;car&quot;</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">false</span></p>\n</div>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length, t.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>s</code> and <code>t</code> consist of lowercase English letters.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> What if the inputs contain Unicode characters? How would you adapt your solution to such a case?</p>\n","tags":["Hash Table","String","Sorting"],"java_snippet":"class Solution {\n    public boolean isAnagram(String s, String t) {\n        \n    }\n}","solution":"<h2><a href=\"#solution-article\"><svg><path></path></svg></a>Solution Article</h2>\n<hr/>\n<h3><a href=\"#approach-1-sorting\"><svg><path></path></svg></a>Approach 1: Sorting</h3>\n<h4>Algorithm</h4>\n<p>An anagram is produced by rearranging the letters of s into t. Therefore, if t is an anagram of s, sorting both strings will result in two identical strings. Furthermore, if s and t have different lengths, t must not be an anagram of s and we can return early.</p>\n<pre><code>public boolean isAnagram(String s, String t) {\n    if (s.length() != t.length()) {\n        return false;\n    }\n    char[] str1 = s.toCharArray();\n    char[] str2 = t.toCharArray();\n    Arrays.sort(str1);\n    Arrays.sort(str2);\n    return Arrays.equals(str1, str2);\n}</code></pre>\n<h4>Complexity Analysis</h4>\n<ul>\n<li>\n<p>Time complexity: O(nlogn).<br/>\nAssume that n is the length of s, sorting costs O(nlogn) and comparing two strings costs O(n). Sorting time dominates and the overall time complexity is O(nlogn).</p>\n</li>\n<li>\n<p>Space complexity: O(1).<br/>\nSpace depends on the sorting implementation which, usually, costs O(1) auxiliary space if <code>heapsort</code> is used. Note that in Java, <code>toCharArray()</code> makes a copy of the string so it costs O(n) extra space, but we ignore this for complexity analysis because:</p>\n<ul>\n<li>It is a language dependent detail.</li>\n<li>It depends on how the function is designed. For example, the function parameter types can be changed to <code>char[]</code>.</li>\n</ul>\n</li>\n</ul>\n<hr/>\n<h3><a href=\"#approach-2-frequency-counter\"><svg><path></path></svg></a>Approach 2: Frequency Counter</h3>\n<h4>Algorithm</h4>\n<p>To examine if t is a rearrangement of s, we can count occurrences of each letter in the two strings and compare them. We could use a hash table to count the frequency of each letter, however, since both s and t only contain letters from a to z, a simple array of size 26 will suffice.</p>\n<p>Do we need <em>two</em> counters for comparison? Actually no, because we can increment the count for each letter in s and decrement the count for each letter in t, and then check if the count for every character is zero.</p>\n<pre><code>public boolean isAnagram(String s, String t) {\n    if (s.length() != t.length()) {\n        return false;\n    }\n    int[] counter = new int[26];\n    for (int i = 0; i &lt; s.length(); i++) {\n        counter[s.charAt(i) - 'a']++;\n        counter[t.charAt(i) - 'a']--;\n    }\n    for (int count : counter) {\n        if (count != 0) {\n            return false;\n        }\n    }\n    return true;\n}</code></pre>\n<p>Or we could first increment the counter for s, then decrement the counter for t. If at any point the counter drops below zero, we know that t contains an extra letter not in s and return false immediately. We don't need to check whether \"s\" contains extra characters not in \"t\" because an extra character in \"t\" comes at the expense of an extra character in \"s\" so we need to check for only \"t\".</p>\n<pre><code>public boolean isAnagram(String s, String t) {\n    if (s.length() != t.length()) {\n        return false;\n    }\n    int[] table = new int[26];\n    for (int i = 0; i &lt; s.length(); i++) {\n        table[s.charAt(i) - 'a']++;\n    }\n    for (int i = 0; i &lt; t.length(); i++) {\n        table[t.charAt(i) - 'a']--;\n        if (table[t.charAt(i) - 'a'] &lt; 0) {\n            return false;\n        }\n    }\n    return true;\n}</code></pre>\n<h4>Complexity Analysis</h4>\n<ul>\n<li>\n<p>Time complexity: O(n).<br/>\nTime complexity is O(n) because accessing the counter table is a constant time operation.</p>\n</li>\n<li>\n<p>Space complexity: O(1).<br/>\nAlthough we do use extra space, the space complexity is O(1) because the table's size stays constant no matter how large n is.</p>\n</li>\n</ul>\n<p><strong>Follow up</strong></p>\n<p>What if the inputs contain unicode characters? How would you adapt your solution to such case?</p>\n<p><strong>Answer</strong></p>\n<p>Use a hash table instead of a fixed size counter. Imagine allocating a large size array to fit the entire range of unicode characters, which could go up to <a href=\"http://stackoverflow.com/a/5928054/490463\">more than 1 million</a>. A hash table is a more generic solution and could adapt to any range of characters.</p>"}