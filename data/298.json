{"id":"298","title":"Binary Tree Longest Consecutive Sequence","difficulty":"Medium","content":"<p>Given the <code>root</code> of a binary tree, return <em>the length of the longest <strong>consecutive sequence path</strong></em>.</p>\n\n<p>A <strong>consecutive sequence path</strong> is a path where the values <strong>increase by one</strong> along the path.</p>\n\n<p>Note that the path can start <strong>at any node</strong> in the tree, and you cannot go from a node to its parent in the path.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/14/consec1-1-tree.jpg\" style=\"width: 306px; height: 400px;\" />\n<pre>\n<strong>Input:</strong> root = [1,null,3,2,4,null,null,null,5]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> Longest consecutive sequence path is 3-4-5, so return 3.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/14/consec1-2-tree.jpg\" style=\"width: 249px; height: 400px;\" />\n<pre>\n<strong>Input:</strong> root = [2,null,3,2,null,1]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> Longest consecutive sequence path is 2-3, not 3-2-1, so return 2.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[1, 3 * 10<sup>4</sup>]</code>.</li>\n\t<li><code>-3 * 10<sup>4</sup> &lt;= Node.val &lt;= 3 * 10<sup>4</sup></code></li>\n</ul>\n","tags":["Tree","Depth-First Search","Binary Tree"],"java_snippet":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int longestConsecutive(TreeNode root) {\n        \n    }\n}","solution":"<h2><a href=\"#solution\"><svg><path></path></svg></a>Solution</h2>\n<hr/>\n<h3><a href=\"#approach-1-top-down-depth-first-search-accepted\"><svg><path></path></svg></a>Approach #1 (Top Down Depth-first Search) [Accepted]</h3>\n<p><strong>Algorithm</strong></p>\n<p>A top-down approach is used, using depth-first search in a manner similar to a pre-order traversal, where a variable <code>length</code> is maintained to track the current consecutive path length and is passed down the tree; at each node, the current value is compared with its parent to determine whether the sequence remains consecutive, and if it does not, the length is reset.</p>\n<pre><code>private int maxLength = 0;\npublic int longestConsecutive(TreeNode root) {\n    dfs(root, null, 0);\n    return maxLength;\n}\n​\nprivate void dfs(TreeNode p, TreeNode parent, int length) {\n    if (p == null) return;\n    length = (parent != null &amp;&amp; p.val == parent.val + 1) ? length + 1 : 1;\n    maxLength = Math.max(maxLength, length);\n    dfs(p.left, p, length);\n    dfs(p.right, p, length);\n}</code></pre>\n<p>@lightmark presents <a href=\"https://leetcode.com/discuss/66486/short-and-simple-c-solution\">a neat approach</a> without storing the maxLength as a global variable.</p>\n<pre><code>public int longestConsecutive(TreeNode root) {\n    return dfs(root, null, 0);\n}\n​\nprivate int dfs(TreeNode p, TreeNode parent, int length) {\n    if (p == null) return length;\n    length = (parent != null &amp;&amp; p.val == parent.val + 1) ? length + 1 : 1;\n    return Math.max(length, Math.max(dfs(p.left, p, length),\n                                     dfs(p.right, p, length)));\n}</code></pre>\n<p><strong>Complexity analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : O(n).<br/>\nThe time complexity is the same as an in-order traversal of a binary tree with n nodes.</p>\n</li>\n<li>\n<p>Space complexity : O(n).<br/>\nThe extra space comes from implicit stack space due to recursion. For a skewed binary tree, the recursion could go up to n levels deep.</p>\n</li>\n</ul>\n<hr/>\n<h3><a href=\"#approach-2-bottom-up-depth-first-search-accepted\"><svg><path></path></svg></a>Approach #2 (Bottom Up Depth-first Search) [Accepted]</h3>\n<p><strong>Algorithm</strong></p>\n<p>The bottom-up approach is similar to a post-order traversal. We return the consecutive path length starting at current node to its parent. Then its parent can examine if its node value can be included in this consecutive path.</p>\n<pre><code>private int maxLength = 0;\npublic int longestConsecutive(TreeNode root) {\n    dfs(root);\n    return maxLength;\n}\n​\nprivate int dfs(TreeNode p) {\n    if (p == null) return 0;\n    int L = dfs(p.left) + 1;\n    int R = dfs(p.right) + 1;\n    if (p.left != null &amp;&amp; p.val + 1 != p.left.val) {\n        L = 1;\n    }\n    if (p.right != null &amp;&amp; p.val + 1 != p.right.val) {\n        R = 1;\n    }\n    int length = Math.max(L, R);\n    maxLength = Math.max(maxLength, length);\n    return length;\n}</code></pre>\n<p><strong>Complexity analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : O(n).<br/>\nThe time complexity is the same as a post-order traversal in a binary tree, which is O(n).</p>\n</li>\n<li>\n<p>Space complexity : O(n).<br/>\nThe extra space comes from implicit stack space due to recursion. For a skewed binary tree, the recursion could go up to n levels deep.</p>\n</li>\n</ul>"}