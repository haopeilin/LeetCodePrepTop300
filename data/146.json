{"id":"146","title":"LRU Cache","difficulty":"Medium","content":"<p>Design a data structure that follows the constraints of a <strong><a href=\"https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU\" target=\"_blank\">Least Recently Used (LRU) cache</a></strong>.</p>\n\n<p>Implement the <code>LRUCache</code> class:</p>\n\n<ul>\n\t<li><code>LRUCache(int capacity)</code> Initialize the LRU cache with <strong>positive</strong> size <code>capacity</code>.</li>\n\t<li><code>int get(int key)</code> Return the value of the <code>key</code> if the key exists, otherwise return <code>-1</code>.</li>\n\t<li><code>void put(int key, int value)</code> Update the value of the <code>key</code> if the <code>key</code> exists. Otherwise, add the <code>key-value</code> pair to the cache. If the number of keys exceeds the <code>capacity</code> from this operation, <strong>evict</strong> the least recently used key.</li>\n</ul>\n\n<p>The functions <code>get</code> and <code>put</code> must each run in <code>O(1)</code> average time complexity.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;LRUCache&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;get&quot;]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\n<strong>Output</strong>\n[null, null, null, 1, null, -1, null, -1, 3, 4]\n\n<strong>Explanation</strong>\nLRUCache lRUCache = new LRUCache(2);\nlRUCache.put(1, 1); // cache is {1=1}\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\nlRUCache.get(1);    // return 1\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\nlRUCache.get(2);    // returns -1 (not found)\nlRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\nlRUCache.get(1);    // return -1 (not found)\nlRUCache.get(3);    // return 3\nlRUCache.get(4);    // return 4\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= capacity &lt;= 3000</code></li>\n\t<li><code>0 &lt;= key &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= value &lt;= 10<sup>5</sup></code></li>\n\t<li>At most <code>2 * 10<sup>5</sup></code> calls will be made to <code>get</code> and <code>put</code>.</li>\n</ul>\n","tags":["Hash Table","Linked List","Design","Doubly-Linked List"],"java_snippet":"class LRUCache {\n\n    public LRUCache(int capacity) {\n        \n    }\n    \n    public int get(int key) {\n        \n    }\n    \n    public void put(int key, int value) {\n        \n    }\n}\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache obj = new LRUCache(capacity);\n * int param_1 = obj.get(key);\n * obj.put(key,value);\n */","solution":"<h2><a href=\"#solution\"><svg><path></path></svg></a>Solution</h2>\n<hr/>\n<h3><a href=\"#overview\"><svg><path></path></svg></a>Overview</h3>\n<p>Let's start by thinking about how we can implement the data structure without caring about time complexity.</p>\n<p>The description of the <code>put</code> method states that we are storing key-value pairs. This means the data structure is similar to a hash map, which also stores key-value pairs.</p>\n<p>It's easy enough to add new key-value pairs or update existing ones using a hash map. The thing that makes this problem tricky is that the hash map is limited to a size of <code>capacity</code>. When the hash map exceeds this capacity, we cannot arbitrarily remove a key - we need to remove the least recently used one. After we remove it, we need to know what the second least recently used one was (as it will be the next one to be deleted).</p>\n<p>To keep the order in which keys have been used, we can implement a queue. The key at the front of the queue is the least recently used key, and the key at the back of the queue is the most recently used key. When we insert a key for the first time, we put it in the back of the queue. When we use an existing key (with either <code>get</code> or <code>put</code>), we locate it in the queue and move it to the back. If the data structure exceeds <code>capacity</code>, we can reference the front of the queue to find the key that should be deleted.</p>\n<p>If we use an array/list to implement the queue, operations will cost O(n). This is because we will frequently be removing elements from arbitrary positions in the list, which costs O(n).</p>\n<p>We need a way to implement this queue such that the operations will run in O(1).</p>\n<hr/>\n<h3><a href=\"#approach-1-doubly-linked-list\"><svg><path></path></svg></a>Approach 1: Doubly Linked List</h3>\n<p><strong>Intuition</strong></p>\n<p>We need a way to store data in an ordered manner such that elements can be removed from any position in constant time.</p>\n<p>A linked list is a great candidate for this task. Removing from arbitrary positions is one of the few things that a linked list does better than an array.</p>\n<p>Let's say you have a linked list <code>A -&gt; B -&gt; C -&gt; D -&gt; E</code>. We can remove the <code>C</code> from the list by performing <code>B.next = D</code>. As <code>C</code> is no longer reachable, it is effectively \"removed\" from the list. If you were to traverse from the head (<code>A</code>), you would visit nodes <code>A, B, D, E</code>. This operation is done in constant time, no matter how large the list is.</p>\n<p>To remove <code>C</code> from the list, we needed a reference to the node before it <code>B</code>, so that we could change <code>B.next</code>. In general, if we want to remove a node from the list, we need a pointer to the node before it. Because of this, we shall use a doubly linked list. That way, when we want to remove a node, we have a <code>prev</code> pointer to reference the node before it.</p>\n<pre><code>class Node {\n    int key;\n    int val;\n    Node next;\n    Node prev;\n\n    Node(int key, int val) {\n        this.key = key;\n        this.val = val;\n    }\n}</code></pre>\n<blockquote>\n<p>Note: in Java, we use <code>Node</code> instead of <code>ListNode</code> to avoid conflicts with predefined linked list node classes.</p>\n</blockquote>\n<p>As each node represents an element in the data structure, we can also store the key-value pair in each node.</p>\n<p>Let's think about how we can implement the data structure again. We need to achieve the following functionality:</p>\n<ol>\n<li>Store a key-value pair</li>\n<li>Update a key-value pair</li>\n<li>Given a key, determine if it exists in the data structure. If it does, return the value. If it doesn't, return <code>-1</code>.</li>\n<li>When a new key-value pair is added, create a new linked list node and put it at the back.</li>\n<li>When an existing key is updated or fetched, find its associated linked list node. Move it to the back.</li>\n<li>When a new key-value pair is added and the size of the data structure exceeds <code>capacity</code>, remove the linked list node at the front.</li>\n</ol>\n<blockquote>\n<p>Tasks 4 - 6 follow the process that we determined in the overview.</p>\n</blockquote>\n<p>Tasks 1, 2, and 3 can all easily be achieved using a standard built-in hash map. How do we accomplish tasks 4, 5, and 6?</p>\n<p>In tasks 4 and 5, we need to add nodes to the back of the linked list. Because we are aiming for an O(1) time complexity, we must keep a reference to the tail of our linked list. In task 6, we need to remove from the front of the linked list. This means we must also keep a reference to the head (although we would probably do this anyways since you always want to keep the head of a linked list).</p>\n<p>We can easily detect when the size of the data structure exceeds <code>capacity</code> by checking the size of our hash map.</p>\n<p>This leaves us with one final thing to implement:</p>\n<blockquote>\n<ol>\n<li>When an existing key is updated or fetched, find its associated linked list node. <del>Move it to the back.</del></li>\n</ol>\n</blockquote>\n<p>It's true that we can remove a node from a doubly linked list at any position in O(1) - but <strong>only</strong> if we already have a reference to the node. Given a key, how can we find the node associated with it in O(1)?</p>\n<p>In our hash map, instead of mapping each key to its value (<code>int: int</code>), let's have it map each key to its associated node (<code>int: Node</code>).</p>\n<p>Now, in task 5, when we update or fetch a <code>key</code>, we can reference the hash map to find the key's node in O(1). Once we have the node, we can remove it from the list in O(1). Finally, we can move it to the back by referencing the linked list's tail.</p>\n<p>So if we are storing <code>Node</code> in the hash map instead of the values, how do we implement the <code>get</code> method? Remember that our <code>Node</code> objects also have <code>key</code> and <code>val</code> attributes. Therefore, to get a value associated with <code>key</code>, we can first use the hash map to get the key's <code>node</code> in O(1), and then just check <code>node.val</code>.</p>\n<p>For our <code>LRUCache</code> class, we need the following attributes:</p>\n<ol>\n<li><code>capacity</code> - to detect when we need to start deleting key-value pairs.</li>\n<li><code>dic</code> - short for dictionary, this will be our hash map that maps keys to nodes.</li>\n<li><code>head</code> - the head of our linked list</li>\n<li><code>tail</code> - the tail of our linked list</li>\n</ol>\n<p>Before we start implementation, let's talk about an edge case.</p>\n<p>We know that we are going to need to remove from the front of the linked list and add to the end of the linked list frequently. We plan on doing this by using the <code>head</code> and <code>tail</code> attributes. What happens if the linked list is empty? This is a frustrating case - we will need to check for it every time and handle it completely differently.</p>\n<p>Imagine that the linked list is empty and we call <code>put</code> to create a new key-value pair. We create a <code>node</code> for this key-value pair, then we need to set it as both the <code>head</code> and <code>tail</code> (since it's the only node).</p>\n<p>What if <code>capacity = 1</code> and we call <code>put</code> again with a new key? You can imagine the headache that might ensue - we need to delete the only existing node, which means we are deleting both the <code>head</code> and <code>tail</code>. Then we need to add the new node, but since the linked list is empty again, we will be setting the new node as the head and tail again.</p>\n<p>The cleanest way to handle the empty list case is by using <strong>sentinel nodes</strong>.</p>\n<p>We will have our <code>head</code> and <code>tail</code> attributes both set to dummy nodes. The \"real\" head will be <code>head.next</code> and the \"real\" tail will be <code>tail.prev</code>. These dummy nodes sit just \"outside\" of our linked list. What is the purpose? We never want <code>head</code> or <code>tail</code> to be <code>null</code>.</p>\n<p> <br/></p>\n<blockquote>\n<p>These dummy nodes can have any keys and any values, it doesn't matter. We should initialize <code>head.next = tail</code> and <code>tail.prev = head</code>.</p>\n</blockquote>\n<p>We now have everything we need! Let's implement some methods.</p>\n<hr/>\n<p><strong>Algorithm</strong></p>\n<p><strong>Adding a node to the back of the linked list</strong></p>\n<p>We need to add a node to the end of our linked list whenever we add a new key or update an existing one. Let's write a helper method <code>add(Node node)</code> that takes a <code>node</code> and puts it at the end of our linked list.</p>\n<pre><code>void add(Node node) {\n    Node previousEnd = tail.prev;\n    previousEnd.next = node;\n    node.prev = previousEnd;\n    node.next = tail;\n    tail.prev = node;\n}</code></pre>\n<hr/>\n<p><strong>Removing a node from the linked list</strong></p>\n<pre><code>void remove(Node node) {\n    node.prev.next = node.next;\n    node.next.prev = node.prev;\n}</code></pre>\n<hr/>\n<p><strong>The <code>get(int key)</code> method</strong></p>\n<pre><code>int get(int key) {\n    if (!dic.containsKey(key)) {\n        return -1;\n    }\n\n    Node node = dic.get(key);\n    remove(node);\n    add(node);\n    return node.val;\n}</code></pre>\n<hr/>\n<p><strong>The <code>put(int key, int value)</code> method</strong></p>\n<pre><code>void put(int key, int value) {\n    if (dic.containsKey(key)) {\n        Node oldNode = dic.get(key);\n        remove(oldNode);\n    }\n\n    Node node = new Node(key, value);\n    dic.put(key, node);\n    add(node);\n\n    if (dic.size() &gt; capacity) {\n        Node nodeToDelete = head.next;\n        remove(nodeToDelete);\n        dic.remove(nodeToDelete.key);\n    }\n}</code></pre>\n<p><strong>Implementation</strong></p>\n<pre><code>import java.util.HashMap;\nimport java.util.Map;\n\nclass Node {\n    int key;\n    int val;\n    Node next;\n    Node prev;\n\n    Node(int key, int val) {\n        this.key = key;\n        this.val = val;\n    }\n}\n\nclass LRUCache {\n    int capacity;\n    Map<integer, node=\"\"> dic = new HashMap&lt;&gt;();\n    Node head = new Node(-1, -1);\n    Node tail = new Node(-1, -1);\n\n    LRUCache(int capacity) {\n        this.capacity = capacity;\n        head.next = tail;\n        tail.prev = head;\n    }\n\n    int get(int key) {\n        if (!dic.containsKey(key)) {\n            return -1;\n        }\n\n        Node node = dic.get(key);\n        remove(node);\n        add(node);\n        return node.val;\n    }\n\n    void put(int key, int value) {\n        if (dic.containsKey(key)) {\n            remove(dic.get(key));\n        }\n\n        Node node = new Node(key, value);\n        dic.put(key, node);\n        add(node);\n\n        if (dic.size() &gt; capacity) {\n            Node nodeToDelete = head.next;\n            remove(nodeToDelete);\n            dic.remove(nodeToDelete.key);\n        }\n    }\n\n    void add(Node node) {\n        Node previousEnd = tail.prev;\n        previousEnd.next = node;\n        node.prev = previousEnd;\n        node.next = tail;\n        tail.prev = node;\n    }\n\n    void remove(Node node) {\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n    }\n}</integer,></code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity: O(1) for both <code>get</code> and <code>put</code>.</p>\n</li>\n<li>\n<p>Space complexity: O(capacity)</p>\n</li>\n</ul>\n<br/>\n<hr/>\n<h3><a href=\"#approach-2-built-in\"><svg><path></path></svg></a>Approach 2: Built-in</h3>\n<p><strong>Intuition</strong></p>\n<p>Java has a built-in data structure that makes this problem much easier.</p>\n<blockquote>\n<p>Note: using these data structures sort of defeats the purpose of the problem. It is likely that if you are asked this problem in an interview, the interviewer wants to see you implement the first approach. It is not recommended that you use these data structures without asking the interviewer first.</p>\n<p>We have included this approach for the sake of completeness.</p>\n</blockquote>\n<p>In Java, we will be using <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/LinkedHashMap.html\">LinkedHashMap</a>, which is a hash map that maintains access order and can automatically evict the least recently used entry.</p>\n<p><strong>Implementation</strong></p>\n<pre><code>import java.util.LinkedHashMap;\nimport java.util.Map;\n\nclass LRUCache {\n    private final int capacity;\n    private final LinkedHashMap<integer, integer=\"\"> map;\n\n    LRUCache(int capacity) {\n        this.capacity = capacity;\n        this.map = new LinkedHashMap&lt;&gt;(capacity, 0.75f, true) {\n            protected boolean removeEldestEntry(Map.Entry<integer, integer=\"\"> eldest) {\n                return size() &gt; LRUCache.this.capacity;\n            }\n        };\n    }\n\n    int get(int key) {\n        return map.getOrDefault(key, -1);\n    }\n\n    void put(int key, int value) {\n        map.put(key, value);\n    }\n}</integer,></integer,></code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity: O(1) for both <code>get</code> and <code>put</code>.</p>\n</li>\n<li>\n<p>Space complexity: O(capacity)</p>\n</li>\n</ul>\n<br/>\n<hr/>"}