{"id":"250","title":"Count Univalue Subtrees","difficulty":"Medium","content":"<p>Given the <code>root</code> of a binary tree, return <em>the number of <strong>uni-value</strong> </em><span data-keyword=\"subtree\"><em>subtrees</em></span>.</p>\n\n<p>A <strong>uni-value subtree</strong> means all nodes of the subtree have the same value.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/21/unival_e1.jpg\" style=\"width: 450px; height: 258px;\" />\n<pre>\n<strong>Input:</strong> root = [5,1,5,5,5,null,5]\n<strong>Output:</strong> 4\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = []\n<strong>Output:</strong> 0\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [5,5,5,5,5,null,5]\n<strong>Output:</strong> 6\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of the node in the tree will be in the range <code>[0, 1000]</code>.</li>\n\t<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n","tags":["Tree","Depth-First Search","Binary Tree"],"java_snippet":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int countUnivalSubtrees(TreeNode root) {\n        \n    }\n}","solution":"<div class=\"flex flex-col w-full\" style=\"position: relative;\"><div class=\"mYe_l WRmCx\"><h2 class=\"group/heading relative\" id=\"solution\" level=\"2\"><a aria-hidden=\"true\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" href=\"#solution\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" data-icon=\"link\" data-prefix=\"fas\" focusable=\"false\" role=\"img\" spacing=\"square\" viewbox=\"0 0 640 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\" fill=\"currentColor\"></path></svg></div></a>Solution</h2>\n<hr/>\n<h3 class=\"group/heading relative\" id=\"overview\" level=\"3\"><a aria-hidden=\"true\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" href=\"#overview\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" data-icon=\"link\" data-prefix=\"fas\" focusable=\"false\" role=\"img\" spacing=\"square\" viewbox=\"0 0 640 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\" fill=\"currentColor\"></path></svg></div></a>Overview</h3>\n<p>Given the <code>root</code> of a binary tree, return the number of <strong>uni-value subtrees</strong> where a <strong>uni-value subtree</strong> means all nodes of the subtree have the same value.</p>\n<hr/>\n<h3 class=\"group/heading relative\" id=\"approach-1-depth-first-search\" level=\"3\"><a aria-hidden=\"true\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" href=\"#approach-1-depth-first-search\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" data-icon=\"link\" data-prefix=\"fas\" focusable=\"false\" role=\"img\" spacing=\"square\" viewbox=\"0 0 640 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\" fill=\"currentColor\"></path></svg></div></a>Approach 1: Depth First Search</h3>\n<h4 id=\"intuition\">Intuition</h4>\n<p>Given a <code>node</code> in our tree, we know that it is a uni-value subtree if it meets the following criteria:</p>\n<ol>\n<li data-length=\"1\">The children are also uni-value subtrees.</li>\n<li data-length=\"1\">The children have the same value as <code>node</code>.</li>\n</ol>\n<p>The preceding conditions automatically apply to a leaf node because a leaf node's subtree contains only that node.</p>\n<p>We can recursively iterate through the <code>left</code> and <code>right</code> children of each <code>node</code> to see if the children form uni-value subtrees. If all of the children form uni-value subtrees, we can then check if each child has the same value as the value of <code>node</code>.</p>\n<p>We can use a depth-first search to perform this recursive traversal.</p>\n<p>In DFS, we use a recursive function to explore nodes as far as possible along each branch. Upon reaching the end of a branch, we backtrack to the previous node and continue exploring the next branches.</p>\n<p>If you are new to Depth First Search, please see our <a href=\"https://leetcode.com/explore/featured/card/graph/619/depth-first-search-in-graph/3882/\" target=\"_blank\">Leetcode Explore Card</a> for more information on it!</p>\n<p>We implement a <code>dfs</code> method that takes a <code>TreeNode node</code> as an argument and starts the traversal from there. We begin with <code>root</code>. The <code>dfs</code> method returns a boolean that indicates whether or not the subtree rooted at <code>node</code> is a uni-value subtree.</p>\n<p>If <code>node</code> is null, we don't need to worry about it, but we also don't want it to affect the \"parent\" (the node we came from to get to null). Therefore, if <code>node == null</code>, we return <code>true</code>. Notice that for a leaf node, both children will be null, thus both children's call will return <code>true</code>, which is what we want.</p>\n<p>We recursively perform DFS traversal over the <code>left</code> and <code>right</code> child to see if they create uni-value subtrees. We perform <code>isLeftUniValue = dfs(node.left)</code> and <code>isRightUniValue = dfs(node.right)</code>.</p>\n<p>If both children form uni-value subtrees, i.e., <code>isLeftUniValue &amp;&amp; isRightUniValue</code> is <code>true</code>, we verify whether both children (if they exist) have the same value as <code>node</code>. If the <code>left</code> child exists and <code>node.left.val != node.val</code>, we return <code>false</code>. While the <code>left</code> child forms a uni-value subtree, its value differs from that of <code>node</code>, so the current <code>node</code>'s subtree cannot be a uni-value subtree. We apply the same logic for the <code>right</code> child.</p>\n<p>If we do not return <code>false</code> in any of the preceding cases, it means that the children who exist have the same value as <code>node</code>, forming a uni-value subtree. As a result, we add <code>1</code> to our count variable and return <code>true</code>.</p>\n<p>Otherwise, if any child does not form a uni-value subtree, i.e., <code>isLeftUniValue &amp;&amp; isRightUniValue</code> returns <code>false</code>, the subtree rooted at <code>node</code> cannot be a uni-value subtree.</p>\n<p>Here's a visual representation of how the approach works in the first example given in the problem description:</p>\n<p></p>\n<h4 id=\"algorithm\">Algorithm</h4>\n<ol>\n<li data-length=\"1\">Create an integer variable <code>count</code> to count the number of uni-value subtrees. We initialize it to <code>0</code>.</li>\n<li data-length=\"1\">Perform the DFS traversal over the given binary tree. We perform <code>dfs(root)</code> where <code>dfs</code> is a recursive method that takes a <code>TreeNode node</code> as a parameter from which the traversal begins. It returns a boolean indicating whether the subtree rooted at <code>node</code> is a uni-value subtree or not. We perform the following in this method:\n<ul>\n<li>If <code>node</code> is <code>null</code>, return <code>true</code>.</li>\n<li>Recursively check whether the <code>left</code> child forms a uni-value subtree. We perform <code>isLeftUniValue = dfs(node.left)</code>.</li>\n<li>Recursively check whether the <code>right</code> child forms a uni-value subtree. We perform <code>isRightUniValue = dfs(node.right)</code>.</li>\n<li>If both the children form uni-value subtrees, i.e, <code>isLeftUniValue &amp;&amp; isRightUniValue</code> is <code>true</code>, we compare the values of the <code>node</code>'s children with <code>node</code>' value. If the <code>left</code> child exists and <code>node.left.val != node.val</code>, we return <code>false</code> as the values don't match and we don't have a uni-value subtree. Likewise, if the <code>right</code> child exists and <code>node.right.val != node.val</code>, we return <code>false</code>. Otherwise, we increment <code>count</code> by <code>1</code> and return <code>true</code>.</li>\n<li>Otherwise, one or both of the children do not form a uni-value subtree, so the tree rooted at <code>node</code> cannot either. We return <code>false</code>.</li>\n</ul>\n</li>\n<li data-length=\"1\">Return <code>count</code>.</li>\n</ol>\n<h4 id=\"implementation\">Implementation</h4>\n<pre><code>class Solution {\npublic:\n    int count = 0;\n​\n    bool dfs(TreeNode* node) {\n        if (node == nullptr) {\n            return true;\n        }\n​\n        bool isLeftUniValue = dfs(node-&gt;left);\n        bool isRightUniValue = dfs(node-&gt;right);\n​\n        // If both the children form uni-value subtrees, we compare the value of\n        // chidren's node with the node value.\n        if (isLeftUniValue &amp;&amp; isRightUniValue) {\n            if (node-&gt;left != nullptr &amp;&amp; node-&gt;left-&gt;val != node-&gt;val) {\n                return false;\n            }\n            if (node-&gt;right != nullptr &amp;&amp; node-&gt;right-&gt;val != node-&gt;val) {\n                return false;\n            }\n            count++;\n            return true;\n        }\n        // Else if any of the child does not form a uni-value subtree, the subtree\n        // rooted at node cannot be a uni-value subtree.\n        return false;\n    }\n​\n    int countUnivalSubtrees(TreeNode* root) {\n        dfs(root);\n        return count;\n    }\n};</code></pre>\n<h4 id=\"complexity-analysis\">Complexity Analysis</h4>\n<p>Here <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></span> is the number of nodes in the given binary tree.</p>\n<ul>\n<li>\n<p>Time complexity: <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n<ul>\n<li>We traverse once over each node of the tree using DFS traversal which takes <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span> time.</li>\n</ul>\n</li>\n<li>\n<p>Space complexity: <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n<ul>\n<li>The DFS traversal is recursive and would take some space to store the stack calls. The maximum number of active stack calls at a time would be the tree's height, which in the worst case would be <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span> when the tree is a straight line.</li>\n</ul>\n</li>\n</ul>\n<hr/>\n<h3 class=\"group/heading relative\" id=\"approach-2-depth-first-search-without-using-the-global-variable\" level=\"3\"><a aria-hidden=\"true\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" href=\"#approach-2-depth-first-search-without-using-the-global-variable\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" data-icon=\"link\" data-prefix=\"fas\" focusable=\"false\" role=\"img\" spacing=\"square\" viewbox=\"0 0 640 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\" fill=\"currentColor\"></path></svg></div></a>Approach 2: Depth First Search Without Using The Global Variable</h3>\n<h4 id=\"intuition-1\">Intuition</h4>\n<p>In the previous approach we used a non-constant global variable <code>count</code> to count the number of uni-value subtrees. The non-constant global variables are evil because their value can be changed by any function. Using global variables reduces the modularity and flexibility of the program. It is always suggested not to use global variables and instead use local variables in the program.</p>\n<p>To avoid using global variables, we alter the <code>dfs</code> method, which accepts a <code>TreeNode node</code> as an argument and returns a list of two values. The first value in the list provides a boolean indicating whether or not the subtree rooted at <code>node</code> is a uni-value subtree (exactly the same as in the previous approach), and the second value indicates the number of uni-value subtrees in the tree rooted at <code>node</code>.</p>\n<p>Our answer would be <code>dfs(root)[1]</code>, i.e., the second element in the list which would give the number of uni-value subtrees in the tree rooted at <code>root</code>, which is what we want.</p>\n<h4 id=\"algorithm-1\">Algorithm</h4>\n<ol>\n<li data-length=\"1\">Perform the DFS traversal over the given binary tree. We implement a recursive <code>dfs</code> method that takes a <code>TreeNode node</code> as an argument from which the traversal begins. We perform the following in this method:\n<ul>\n<li>If <code>node</code> is <code>null</code>, we return <code>true</code> similar to the previous approach but also return <code>0</code> as an empty tree cannot have any uni-value subtrees. We return <code>{true, 0}</code>.</li>\n<li>Recursively call <code>dfs</code> for the <code>left</code> child. We perform <code>left = dfs(node.left)</code>.</li>\n<li>Recursively call <code>dfs</code> for the <code>right</code> child. We perform <code>right = dfs(node.right)</code>.</li>\n<li>We create two boolean variables <code>isLeftUniValue = left.first</code> and <code>isRightUniValue = right.first</code>, to indicate whether the <code>left</code> and <code>right</code> subtrees constitute uni-value subtrees or not. We additionally keep a <code>count</code> of the number of uni-value subtrees in the <code>left</code> and <code>right</code> subtrees.</li>\n<li>If both the children form uni-value subtrees, i.e, <code>isLeftUniValue &amp;&amp; isRightUniValue</code> is <code>true</code>, we compare the values of the <code>node</code>'s children with <code>node</code>' value. If the <code>left</code> child exists and <code>node.left.val != node.val</code>, we return <code>{false, count}</code> as this is not a uni-value subtree and we have <code>count</code> number of uni-value subtrees in the tree rooted at <code>node</code>. Likewise, if the <code>right</code> child exists and <code>node.right.val != node.val</code>, we return <code>{false, count}</code>. Otherwise, the subtree rooted at <code>node</code> forms a uni-value subtree, so we return <code>{true, count + 1}</code>.</li>\n<li>Otherwise, one or both of the children do not form a uni-value subtree, so the tree rooted at <code>node</code> cannot either. We return <code>{false, count}</code>.</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"implementation-1\">Implementation</h4>\n<pre><code>class Solution {\npublic:\n    pair&lt;bool, int&gt; dfs(TreeNode* node) {\n        if (!node) {\n            return {true, 0};\n        }\n​\n        auto left = dfs(node-&gt;left);\n        auto right = dfs(node-&gt;right);\n        bool isLeftUniValue = left.first;\n        bool isRightUniValue = right.first;\n        int count = left.second + right.second;\n​\n        // If both the children form uni-value subtrees, we compare the value of\n        // chidrens node with the node value.\n        if (isLeftUniValue &amp;&amp; isRightUniValue) {\n            if (node-&gt;left &amp;&amp; node-&gt;val != node-&gt;left-&gt;val) {\n                return {false, count};\n            }\n            if (node-&gt;right &amp;&amp; node-&gt;val != node-&gt;right-&gt;val) {\n                return {false, count};\n            }\n            return {true, count + 1};\n        }\n        // Else if any of the child does not form a uni-value subtree, the subtree\n        // rooted at node cannot be a uni-value subtree.\n        return {false, count};\n    }\n​\n    int countUnivalSubtrees(TreeNode* root) {\n        return dfs(root).second;\n    }\n};</code></pre>\n<p>We used the global variable <code>count</code> in place of a local variable in the first approach to ensure that the same variable is updated every time a new uni-value subtree is discovered. If we had used a local variable <code>count</code> and simply passed it into the <code>dfs</code> method, each call would create a new duplicate of the integer. Incrementing this new copy of the integer would have had no effect on our initial local variable <code>count</code>.</p>\n<p>We can use pass by reference to modify the same integer without creating a global variable. We pass an integer or an integer array with just one element to count the number of uni-valued subtrees in the given tree based on the language. We can use an integer variable <code>count = 0</code> and pass it by reference in <code>C++</code>. Because we cannot pass integers by reference in <code>Java</code> and <code>Python3</code>, we create an integer array <code>count</code> with only one element and use it for these languages.</p>\n<p>It's worth noting that here we would need to initialize (expose) the <code>count</code> variable in the <code>countUnivalSubtrees</code> method, which wasn't necessary in the previous implementation of this approach, therefore the previous solution with multiple return values is better in terms of design.</p>\n<p>You can take a look at the implementation using pass by reference below:</p>\n<pre><code>class Solution {\npublic:\n    bool dfs(TreeNode* node, int&amp; count) {\n        if (node == nullptr) {\n            return true;\n        }\n​\n        bool isLeftUniValue = dfs(node-&gt;left, count);\n        bool isRightUniValue = dfs(node-&gt;right, count);\n​\n        // If both the children form uni-value subtrees, we compare the value of\n        // chidren's node with the node value.\n        if (isLeftUniValue &amp;&amp; isRightUniValue) {\n            if (node-&gt;left != nullptr &amp;&amp; node-&gt;left-&gt;val != node-&gt;val) {\n                return false;\n            }\n            if (node-&gt;right != nullptr &amp;&amp; node-&gt;right-&gt;val != node-&gt;val) {\n                return false;\n            }\n            count++;\n            return true;\n        }\n        // Else if any of the child does not form a uni-value subtree, the subtree\n        // rooted at node cannot be a uni-value subtree.\n        return false;\n    }\n​\n    int countUnivalSubtrees(TreeNode* root) {\n        int count = 0;\n        dfs(root, count);\n        return count;\n    }\n};</code></pre>\n<h4 id=\"complexity-analysis-1\">Complexity Analysis</h4>\n<p>Here <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></span> is the number of nodes in the given binary tree.</p>\n<ul>\n<li>\n<p>Time complexity: <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n<ul>\n<li>We traverse once over each node of the tree using DFS traversal which takes <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span> time.</li>\n</ul>\n</li>\n<li>\n<p>Space complexity: <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n<ul>\n<li>The DFS traversal is recursive and would take some space to store the stack calls. The maximum number of active stack calls at a time would be the tree's height, which in the worst case would be <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span> when the tree is a straight line.</li>\n</ul>\n</li>\n</ul></div><span style=\"font-size: 0px; line-height: 0;\"> </span></div>"}