{"id":"174","title":"Dungeon Game","difficulty":"Hard","content":"<p>The demons had captured the princess and imprisoned her in <strong>the bottom-right corner</strong> of a <code>dungeon</code>. The <code>dungeon</code> consists of <code>m x n</code> rooms laid out in a 2D grid. Our valiant knight was initially positioned in <strong>the top-left room</strong> and must fight his way through <code>dungeon</code> to rescue the princess.</p>\n\n<p>The knight has an initial health point represented by a positive integer. If at any point his health point drops to <code>0</code> or below, he dies immediately.</p>\n\n<p>Some of the rooms are guarded by demons (represented by negative integers), so the knight loses health upon entering these rooms; other rooms are either empty (represented as 0) or contain magic orbs that increase the knight&#39;s health (represented by positive integers).</p>\n\n<p>To reach the princess as quickly as possible, the knight decides to move only <strong>rightward</strong> or <strong>downward</strong> in each step.</p>\n\n<p>Return <em>the knight&#39;s minimum initial health so that he can rescue the princess</em>.</p>\n\n<p><strong>Note</strong> that any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/13/dungeon-grid-1.jpg\" style=\"width: 253px; height: 253px;\" />\n<pre>\n<strong>Input:</strong> dungeon = [[-2,-3,3],[-5,-10,1],[10,30,-5]]\n<strong>Output:</strong> 7\n<strong>Explanation:</strong> The initial health of the knight must be at least 7 if he follows the optimal path: RIGHT-&gt; RIGHT -&gt; DOWN -&gt; DOWN.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> dungeon = [[0]]\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == dungeon.length</code></li>\n\t<li><code>n == dungeon[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 200</code></li>\n\t<li><code>-1000 &lt;= dungeon[i][j] &lt;= 1000</code></li>\n</ul>\n","tags":["Array","Dynamic Programming","Matrix"],"java_snippet":"class Solution {\n    public int calculateMinimumHP(int[][] dungeon) {\n        \n    }\n}","solution":"<h2><a href=\"#solution\"><svg><path></path></svg></a>Solution</h2>\n<hr/>\n<h3><a href=\"#approach-1-dynamic-programming\"><svg><path></path></svg></a>Approach 1: Dynamic Programming</h3>\n<p><strong>Overview</strong></p>\n<p>Like many problems with 2D grid, often the case one can apply either the technique of <a href=\"https://leetcode.com/explore/learn/card/recursion-ii/472/backtracking/\">backtracking</a> or dynamic programming.</p>\n<p>Specifically, as it turns out, <em><strong>dynamic programming</strong></em> would work perfectly for this problem.</p>\n<blockquote>\n<p>As a general pattern of dynamic programming, usually we construct a array of one or two dimensions (<em>i.e.</em> <code>dp[i]</code>) where each element holds the optimal solution for the corresponding subproblem.</p>\n</blockquote>\n<p>To calculate one particular element in the <code>dp[i]</code> array, we would refer to the previously calculated elements. And the <strong>last</strong> element that we figure out in the array would be the desired solution for the original problem.</p>\n<p><strong>Intuition</strong></p>\n<p>Following the above guideline, here is how we break down the problem into subproblems and apply the dynamic programming algorithm.</p>\n<p>We are asked to calculate the minimal health point that the knight needs, in order to recuse the princess. The knight would move from the up-left corner of the grid to reach the down-right corner where the princess is located (<em>e.g.</em> as shown in the following graph).</p>\n<p></p>\n<blockquote>\n<p>Though the <strong>down-right</strong> corner is the final destination of the knight, we could start from the destination and deduce <em><strong>backwards</strong></em> the minimal health point that the knight would need at each step along the way.</p>\n</blockquote>\n<p>So starting from the destination where the princess is locked down, as one can see from the following graph, the knight would need <em>at least</em> 6 health points to survive the damage (5 points) caused by the daemon.</p>\n<p></p>\n<p>Let us now take one step back. Before reaching the destination, there are two possible positions that the knight might situate, <em>i.e.</em> the one right above the destination so that the knight would take a <em>down</em> step, and the one to the left of the destination so that the knight would take a <em>right</em> step.</p>\n<p>Let us look at the cell (denoted as <em>cell U</em>) right above the destination, as shown in the following graph. As we know now, the knight should possess at least 6 health points upon reaching the destination. Since at the <em>cell U</em> we have a magic org which would increase the health of knight by 1 point, the knight would just need to possess 5 health points at the arrival of <em>cell U</em>.</p>\n<p></p>\n<p>As another alternative to reach the destination, the knight might situate at the cell (denoted as <em>cell L</em>) to the left side of the destination, as shown in the following graph. In this case, similarly the knight would encounter a magic orb which would give him a 30-points boost on health. With this boost of health, it would be more than enough for the knight to survive the final daemon in the destination. As a result, the knight just needs to possess the minimal 1 health point upon entering the <em>cell L</em>.</p>\n<p></p>\n<p>Now that we have calculated the minimal health points that the knight would need before reaching the destination from two of the possible directions, we can carry on to one more step further from the destination. Let us look at the cell (denoted as <em>cell UL</em>) located at the up-left corner from the destination.</p>\n<p>Following the same logic as we have seen in the above steps, we could obtain two values for this cell, which represent the minimal health points that the knight would need for each of the directions that he takes. As one can see from the following graph, at the <em>cell UL</em>, if the knight takes a right step next, he would need at least 5+10=15 health points, in order to rescue the princess at the end. If he takes a down step next, he would need at least 1+10=11 health points.</p>\n<p></p>\n<p>With all the 3 examples above, we conclude with the following graph where each cell is marked with two minimal health points respectively for each direction that the knight might take, except the destination cell. As one can see, starting from the up-left corner of the grid, the knight would only need 7 health points to rescue the princess.</p>\n<p></p>\n<p><strong>Algorithm</strong></p>\n<p>Given the above intuition, let us see how we can model it with the general code pattern of dynamic programming algorithm.</p>\n<p>First, we define a matrix <code>dp[row][col]</code>, where the element <code>dp[row][col]</code> indicates the minimal health points that the knight would need, starting from the corresponding dungeon cell <code>dungeon[row][col]</code>, in order to reach the destination.</p>\n<p>In the following graph, we show what the <code>dp</code> matrix looks like, for the examples that we listed in the intuition section.</p>\n<p></p>\n<blockquote>\n<p>The main idea of the algorithm is clear: we need to calculate the values in the <code>dp</code> matrix. And the last value we calculate for the matrix would be the desired solution for the problem.</p>\n</blockquote>\n<p>In order to calculate the values of <code>dp</code> matrix, we start from the down-right corner of the dungeon, and walk following the orders of <strong>from-right-to-left</strong> and <strong>from-down-to-up</strong>. Along with each cell in the dungeon, we calculate the corresponding value of <code>dp[row][col]</code> in the matrix.</p>\n<p>The value of <code>dp[row][col]</code> is determined by the following conditions:</p>\n<ul>\n<li>\n<p>If possible, by taking the right step from the current dungeon cell, the knight might need <code>right_health</code> health points.</p>\n<br/>\n</li>\n<li>\n<p>If possible, by taking the down step from the current dungeon cell, the knight would might <code>down_health</code> health points.</p>\n<br/>\n</li>\n<li>\n<p>If either of the above two alternatives exists, we then take the minimal value of them as the value for <code>dp[row][col]</code>.</p>\n<br/>\n</li>\n<li>\n<p>If none of the above alternatives exists, <em>i.e.</em> we are at the destination cell, there are two sub-cases:</p>\n<ul>\n<li>\n<p>If the current cell is of magic orb, then 1 health point would suffice.</p>\n</li>\n<li>\n<p>If the current cell is of daemon, then the knight should possess one health point plus the damage points that would be caused by the daemon.</p>\n</li>\n</ul>\n</li>\n</ul>\n<pre><code>class Solution {\n    public int calculateMinimumHP(int[][] dungeon) {\n        int rows = dungeon.length;\n        int cols = dungeon[0].length;\n        int[][] dp = new int[rows][cols];\n\n        int INF = Integer.MAX_VALUE;\n        for (int i = 0; i &lt; rows; i++) {\n            for (int j = 0; j &lt; cols; j++) {\n                dp[i][j] = INF;\n            }\n        }\n\n        for (int row = rows - 1; row &gt;= 0; row--) {\n            for (int col = cols - 1; col &gt;= 0; col--) {\n                int currCell = dungeon[row][col];\n\n                int rightHealth = INF;\n                if (col + 1 &lt; cols) {\n                    rightHealth = Math.max(1, dp[row][col + 1] - currCell);\n                }\n\n                int downHealth = INF;\n                if (row + 1 &lt; rows) {\n                    downHealth = Math.max(1, dp[row + 1][col] - currCell);\n                }\n\n                int nextHealth = Math.min(rightHealth, downHealth);\n\n                if (nextHealth != INF) {\n                    dp[row][col] = nextHealth;\n                } else {\n                    dp[row][col] = currCell &gt;= 0 ? 1 : 1 - currCell;\n                }\n            }\n        }\n\n        return dp[0][0];\n    }\n}</code></pre>\n<p><strong>Complexity</strong></p>\n<ul>\n<li>\n<p>Time Complexity: O(M⋅N) where M⋅N is the size of the dungeon. We iterate through the entire dungeon once and only once.</p>\n</li>\n<li>\n<p>Space Complexity: O(M⋅N) where M⋅N is the size of the dungeon. In the algorithm, we keep a dp matrix that is of the same size as the dungeon.</p>\n<br/>\n</li>\n</ul>\n<br/>\n<hr/>\n<h3><a href=\"#approach-2-dynamic-programming-with-circular-queue\"><svg><path></path></svg></a>Approach 2: Dynamic Programming with Circular Queue</h3>\n<p><strong>Intuition</strong></p>\n<p>In the above dynamic programming algorithm, there is not much we can do to optimize the time complexity, other than reducing the costy condition checks with some tricks on the initial values of the dp matrix.</p>\n<p>On the other hand, we could reduce the space complexity of the algorithm from O(M⋅N) to O(N) where N is the number of columns.</p>\n<p>First of all, let us flatten the dp matrix into 1D array, <em>i.e.</em> <code>dp[row][col] = dp[row * N + col]</code>.</p>\n<blockquote>\n<p>As one might notice in the above process, in order to calculate each <code>dp[i]</code>, we would refer to at most two previously calculated <code>dp</code> values, <em>i.e.</em> <code>dp[i-1]</code> and <code>dp[i-N]</code>. Therefore, once we calculate the value for <code>dp[i]</code>, we could discard all the previous values that are beyond the range of <code>N</code>.</p>\n</blockquote>\n<p>The above characteristics of the dp array might remind you the container named <strong><em>CircularQueue</em></strong> which could serve as a sliding window to scan a long list.</p>\n<p></p>\n<p>Indeed, we could use the CircularQueue to calculate the dp array, as we show in the above graph. At any moment, the size of the CircularQueue would not exceed the predefined capacity, which would be <code>N</code> in our case. As a result, we reduce the overall space complexity of the algorithm to O(N).</p>\n<p><strong>Algorithm</strong></p>\n<pre><code>class MyCircularQueue {\n    private int[] queue;\n    private int tailIndex;\n    private int capacity;\n\n    public MyCircularQueue(int capacity) {\n        this.capacity = capacity;\n        this.tailIndex = 0;\n        this.queue = new int[capacity];\n    }\n\n    public void enQueue(int value) {\n        queue[tailIndex] = value;\n        tailIndex = (tailIndex + 1) % capacity;\n    }\n\n    public int get(int index) {\n        return queue[index % capacity];\n    }\n}\n\nclass Solution {\n    public int calculateMinimumHP(int[][] dungeon) {\n        int rows = dungeon.length;\n        int cols = dungeon[0].length;\n        MyCircularQueue dp = new MyCircularQueue(cols);\n        int inf = Integer.MAX_VALUE;\n\n        for (int row = 0; row &lt; rows; row++) {\n            for (int col = 0; col &lt; cols; col++) {\n                int currCell = dungeon[rows - row - 1][cols - col - 1];\n\n                int rightHealth = inf;\n                if (col - 1 &gt;= 0) {\n                    int index = cols * row + (col - 1);\n                    rightHealth = Math.max(1, dp.get(index) - currCell);\n                }\n\n                int downHealth = inf;\n                if (row - 1 &gt;= 0) {\n                    int index = cols * (row - 1) + col;\n                    downHealth = Math.max(1, dp.get(index) - currCell);\n                }\n\n                int nextHealth = Math.min(rightHealth, downHealth);\n\n                int minHealth;\n                if (nextHealth != inf) {\n                    minHealth = nextHealth;\n                } else {\n                    minHealth = currCell &gt;= 0 ? 1 : 1 - currCell;\n                }\n\n                dp.enQueue(minHealth);\n            }\n        }\n\n        return dp.get(cols - 1);\n    }\n}</code></pre>\n<p><strong>Complexity</strong></p>\n<ul>\n<li>\n<p>Time Complexity: O(M⋅N) where M⋅N is the size of the dungeon. We iterate through the entire dungeon once and only once.</p>\n</li>\n<li>\n<p>Space Complexity: O(N) where N is the number of columns in the dungeon.</p>\n<br/>\n</li>\n</ul>\n<br/>"}