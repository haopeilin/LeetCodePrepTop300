{"id":"218","title":"The Skyline Problem","difficulty":"Hard","content":"<p>A city&#39;s <strong>skyline</strong> is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Given the locations and heights of all the buildings, return <em>the <strong>skyline</strong> formed by these buildings collectively</em>.</p>\n\n<p>The geometric information of each building is given in the array <code>buildings</code> where <code>buildings[i] = [left<sub>i</sub>, right<sub>i</sub>, height<sub>i</sub>]</code>:</p>\n\n<ul>\n\t<li><code>left<sub>i</sub></code> is the x coordinate of the left edge of the <code>i<sup>th</sup></code> building.</li>\n\t<li><code>right<sub>i</sub></code> is the x coordinate of the right edge of the <code>i<sup>th</sup></code> building.</li>\n\t<li><code>height<sub>i</sub></code> is the height of the <code>i<sup>th</sup></code> building.</li>\n</ul>\n\n<p>You may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height <code>0</code>.</p>\n\n<p>The <strong>skyline</strong> should be represented as a list of &quot;key points&quot; <strong>sorted by their x-coordinate</strong> in the form <code>[[x<sub>1</sub>,y<sub>1</sub>],[x<sub>2</sub>,y<sub>2</sub>],...]</code>. Each key point is the left endpoint of some horizontal segment in the skyline except the last point in the list, which always has a y-coordinate <code>0</code> and is used to mark the skyline&#39;s termination where the rightmost building ends. Any ground between the leftmost and rightmost buildings should be part of the skyline&#39;s contour.</p>\n\n<p><b>Note:</b> There must be no consecutive horizontal lines of equal height in the output skyline. For instance, <code>[...,[2 3],[4 5],[7 5],[11 5],[12 7],...]</code> is not acceptable; the three lines of height 5 should be merged into one in the final output as such: <code>[...,[2 3],[4 5],[12 7],...]</code></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/01/merged.jpg\" style=\"width: 800px; height: 331px;\" />\n<pre>\n<strong>Input:</strong> buildings = [[2,9,10],[3,7,15],[5,12,12],[15,20,10],[19,24,8]]\n<strong>Output:</strong> [[2,10],[3,15],[7,12],[12,0],[15,10],[20,8],[24,0]]\n<strong>Explanation:</strong>\nFigure A shows the buildings of the input.\nFigure B shows the skyline formed by those buildings. The red points in figure B represent the key points in the output list.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> buildings = [[0,2,3],[2,5,3]]\n<strong>Output:</strong> [[0,3],[5,0]]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= buildings.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= left<sub>i</sub> &lt; right<sub>i</sub> &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li><code>1 &lt;= height<sub>i</sub> &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li><code>buildings</code> is sorted by <code>left<sub>i</sub></code> in&nbsp;non-decreasing order.</li>\n</ul>\n","tags":["Array","Divide and Conquer","Binary Indexed Tree","Segment Tree","Sweep Line","Sorting","Heap (Priority Queue)","Ordered Set"],"java_snippet":"class Solution {\n    public List<List<Integer>> getSkyline(int[][] buildings) {\n        \n    }\n}","solution":"<div class=\"flex flex-col w-full\" style=\"position: relative;\"><div class=\"mYe_l WRmCx\"><h2 class=\"group/heading relative\" id=\"solution\" level=\"2\"><a aria-hidden=\"true\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" href=\"#solution\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" data-icon=\"link\" data-prefix=\"fas\" focusable=\"false\" role=\"img\" spacing=\"square\" viewbox=\"0 0 640 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\" fill=\"currentColor\"></path></svg></div></a>Solution</h2>\n<hr/>\n<h3 class=\"group/heading relative\" id=\"overview\" level=\"3\"><a aria-hidden=\"true\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" href=\"#overview\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" data-icon=\"link\" data-prefix=\"fas\" focusable=\"false\" role=\"img\" spacing=\"square\" viewbox=\"0 0 640 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\" fill=\"currentColor\"></path></svg></div></a>Overview</h3>\n<p>In this problem, we are given a list of buildings and would like to construct the <strong>skyline</strong>, a set of key points that describes the contour of the buildings, as shown in the picture below.</p>\n<p></p>\n<p>This problem is very interesting and challenging with some tricky corner cases. Here we introduce several approaches starting with two brute-force algorithms that might not pass under the limited time but can pave the way for more efficient approaches.</p>\n<br/>\n<hr/>\n<h3 class=\"group/heading relative\" id=\"approach-1-brute-force-i\" level=\"3\"><a aria-hidden=\"true\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" href=\"#approach-1-brute-force-i\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" data-icon=\"link\" data-prefix=\"fas\" focusable=\"false\" role=\"img\" spacing=\"square\" viewbox=\"0 0 640 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\" fill=\"currentColor\"></path></svg></div></a>Approach 1: Brute Force I</h3>\n<p>Collect all the positions of the left and right edges from <code>buildings</code>, that's all the possible <code>x</code> where skyline key points are generated. For convenience, let's number these unique positions sequentially, representing these positions by indexes according to their location on the x-axis.</p>\n<p></p>\n<p>If a building with height <code>h</code> covers the indexes from <code>x_i</code> to <code>x_j</code>, then all the indexes from <code>x_i</code> to <code>x_j</code> (exclusive) have the height of <code>h</code> at least. Notice that the right edge of a building doesn't count!</p>\n<p>Therefore, we can iterate over all the buildings, and for each building we find the positions of its left edge and right edge and their corresponding indexes <code>left_index</code> and <code>right_index</code>. Then we update the maximum height for all the indexes within the range <code>[left_index, right_index)</code>. Finally, traverse the updated <code>heights</code> and output all the positions where height changes as skyline key points!</p>\n<p></p>\n<p><strong>Algorithm</strong></p>\n<ol>\n<li data-length=\"1\">Collect all unique positions for the left and right edges of the buildings in <code>buildings</code> and save them in list <code>edgeSet</code>.</li>\n<li data-length=\"1\">Initalize:\n<ul>\n<li>an empty list <code>heights</code> of the same length as <code>edgeSet</code>.</li>\n<li>hashtable <code>edge_index_map</code> stores corresponding index and value of elements from <code>heights</code>.</li>\n<li>empty list <code>answer</code> for skyline key points.</li>\n</ul>\n</li>\n<li data-length=\"1\">Iterate over <code>buildings</code>, for each building <code>buildings[i]</code>:\n<ul>\n<li>Get the index of its left edge and right edge <code>left_index</code>, <code>right_index</code>, and its height <code>height</code>.</li>\n<li>For index in <code>[left_index, right_index)</code>, update <code>heights[index]</code> if necessary.</li>\n</ul>\n</li>\n<li data-length=\"1\">Traverse the updated <code>heights</code> and add all the positions where the height changes to <code>answer</code> as skyline key points.</li>\n<li data-length=\"1\">Return <code>answer</code> as the skyline.</li>\n</ol>\n<p><strong>Implementation</strong></p>\n<pre><code>class Solution {\npublic: \n    vector&lt;vector&lt;int&gt;&gt; getSkyline(vector&lt;vector&lt;int&gt;&gt;&amp; buildings) {\n        // Sort the unique positions of all the edges.\n        set&lt;int&gt; edgeSet;\n        for (auto building : buildings) {\n            int left = building[0], right = building[1];\n            edgeSet.insert(left);\n            edgeSet.insert(right);\n        }\n        vector&lt;int&gt; edges(edgeSet.begin(), edgeSet.end());\n        // Use hash table 'edgeIndexMap' to record every {position : index} pairs in edges.\n        map&lt;int, int&gt; edgeIndexMap;\n        for (int i = 0; i &lt; edges.size(); ++i) {\n            edgeIndexMap[edges[i]] = i;\n        }\n        \n        // Use 'heights' to record maximum height at each index.\n        vector&lt;int&gt; heights(edges.size());\n        \n        // Iterate over all the buildings.\n        for (auto building : buildings) {\n            // Find the indexes of the left and right edges\n            // and update the max height within the range [left_idx, right_idx)\n            int left = building[0], right = building[1], height = building[2];\n            int leftIndex = edgeIndexMap[left], rightIndex = edgeIndexMap[right];\n            for (int idx = leftIndex; idx &lt; rightIndex; ++idx) {\n                heights[idx] = max(heights[idx], height);\n            }\n        }\n        \n        vector&lt;vector&lt;int&gt;&gt; answer;\n​\n        // Iterate over 'heights'.\n        for (int i = 0; i &lt; heights.size(); ++i) {\n            // Add all the positions where the height changes to 'answer'.\n            int currHeight = heights[i], currPos = edges[i];\n            if (i == 0 || currHeight != heights[i - 1]) {\n                answer.push_back({currPos, currHeight});\n            }\n        }\n        return answer;\n    }\n};</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<p>Let <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></span> be the length of the input array <code>buildings</code>.</p>\n<ul>\n<li>Time complexity: <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1.0641em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.8141em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span>\n<ul>\n<li>Obtaining our sorted list of positions will require an average of <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right: 0.1667em;\"></span><span class=\"mop\">lo<span style=\"margin-right: 0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right: 0.1667em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span> time.</li>\n<li>Then for each of the <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></span> buildings, we need to update the maximum heights at all the indexes covered by its left edge and right edge. In the worst-case scenario, we have to update <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></span> values in each iteration step, so this process will take <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1.0641em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.8141em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span> time.</li>\n</ul>\n</li>\n<li>Space complexity: <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span>\n<ul>\n<li>The number of left and right edges is <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6444em;\"></span><span class=\"mord\">2</span><span class=\"mord mathnormal\">n</span></span></span></span></span>, thus we need a set and an array of size <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span>.</li>\n<li>Then we need a hash table of indexes and an array of heights, both of size <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span>.</li>\n<li>We also use an answer array to store all the skyline points, of which there are at most <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></span>.</li>\n</ul>\n</li>\n</ul>\n<br/>\n<hr/>\n<h3 class=\"group/heading relative\" id=\"approach-2-brute-force-ii-sweep-line\" level=\"3\"><a aria-hidden=\"true\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" href=\"#approach-2-brute-force-ii-sweep-line\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" data-icon=\"link\" data-prefix=\"fas\" focusable=\"false\" role=\"img\" spacing=\"square\" viewbox=\"0 0 640 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\" fill=\"currentColor\"></path></svg></div></a>Approach 2: Brute Force II, Sweep Line</h3>\n<p>Another instinctive idea is to use a vertical line of infinite length to sweep over the ground from the left to right. The line stops by every edge and we shall record the maximum height among all the buildings that intersect with the line. As shown in the picture below, the right edge of a building doesn't count!</p>\n<p></p>\n<p>Let's refer to the slides below for an explanation:</p>\n<p></p>\n<p>For more information about Sweep Line Algorithm, please refer to <a href=\"https://en.wikipedia.org/wiki/Sweep_line_algorithm\" target=\"_blank\">wikipedia</a>.</p>\n<p><strong>Algorithm</strong></p>\n<ol>\n<li data-length=\"1\">Initialize an empty list <code>answer</code> for skyline key points.</li>\n<li data-length=\"1\">Use a set (<code>edgeSet</code>) to store all distinct edges in <code>buildings</code>.</li>\n<li data-length=\"1\">Iterate over the sorted <code>positions</code>, and for each position:\n<ul>\n<li>Check for buildings that intersect with the imaginary vertical line at <code>position</code>. (A building is considered to be intersecting with the line if <code>position</code> is within the range <code>[left, right)</code>.)</li>\n</ul>\n</li>\n<li data-length=\"1\">The <code>max_height</code> is the maximum height of the intersecting buildings at <code>position</code>, or <code>0</code> if no building intersects with the line.</li>\n<li data-length=\"1\">If <code>max_height</code> differs from that of the previous skyline point, add a new skyline point to <code>answer</code>.</li>\n<li data-length=\"1\">Return <code>answer</code> as the skyline.</li>\n</ol>\n<p><strong>Implementation</strong></p>\n<pre><code>class Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; getSkyline(vector&lt;vector&lt;int&gt;&gt;&amp; buildings) {\n        // Collect and sort the unique positions of all the edges.\n        set&lt;int&gt; edgeSet;\n        for (auto building : buildings) {\n            edgeSet.insert(building[0]);\n            edgeSet.insert(building[1]);\n        }\n        vector&lt;int&gt; positions(edgeSet.begin(), edgeSet.end());\n        \n        vector&lt;vector&lt;int&gt;&gt; answer;\n            \n        // For each position, draw an imaginary vertical line.\n        for (auto position : positions) {\n            int maxHeight = 0;\n            // Check if any buildings intersect with the line at position.\n            for (auto building : buildings) {\n                int left = building[0], right = building[1], height = building[2];\n                \n                // Update 'maxHeight' if necessary.\n                if (position &gt;= left and position &lt; right) {\n                    maxHeight = max(maxHeight, height);\n                }\n            }\n            \n            // Add all the positions where the height changes to 'answer'.\n            if (answer.empty() || answer[answer.size() - 1][1] != maxHeight) {\n                answer.push_back({position, maxHeight});\n            }\n        }\n        return answer;\n    }\n};</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<p>Let <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></span> be the length of the input array <code>buildings</code>.</p>\n<ul>\n<li>\n<p>Time complexity: <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1.0641em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.8141em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span></p>\n<ul>\n<li>Obtaining our sorted list of positions will require an average of <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right: 0.1667em;\"></span><span class=\"mop\">lo<span style=\"margin-right: 0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right: 0.1667em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span> time.</li>\n<li>Then for each of the <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6444em;\"></span><span class=\"mord\">2</span><span class=\"mord mathnormal\">n</span></span></span></span></span> positions we need to check if any of the <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></span> buildings intersect with the line at that position. This process will take <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1.0641em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.8141em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span> time.</li>\n</ul>\n</li>\n<li>\n<p>Space complexity: <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<ul>\n<li>The number of left and right edges is <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6444em;\"></span><span class=\"mord\">2</span><span class=\"mord mathnormal\">n</span></span></span></span></span>, thus we need a set and an array of size <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span>.</li>\n<li>We also use an answer array to store all the skyline points, of which there are at most <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></span>.</li>\n</ul>\n</li>\n</ul>\n<br/>\n<hr/>\n<h3 class=\"group/heading relative\" id=\"approach-3-sweep-line--priority-queue\" level=\"3\"><a aria-hidden=\"true\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" href=\"#approach-3-sweep-line--priority-queue\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" data-icon=\"link\" data-prefix=\"fas\" focusable=\"false\" role=\"img\" spacing=\"square\" viewbox=\"0 0 640 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\" fill=\"currentColor\"></path></svg></div></a>Approach 3: Sweep Line + Priority Queue</h3>\n<p><strong>Intuition</strong></p>\n<p>In the previous sweep line approach, we had to iterate through all the buildings at each position and ended up with <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1.0641em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.8141em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span> time complexity. We are looking for a more efficient way of determining such intersecting buildings. (For convenience, let's call them \"live\" buildings from now on.)</p>\n<p>Notice that the current height is only decided by the tallest \"live\" building, hence we no longer need to traverse over all the buildings if we can get the tallest \"live\" building directly! This can be implemented by using a <strong>priority queue</strong>. Similar to the previous approach, we can use a vertical line to sweep along the <code>x</code> axis. In this approach, however, we add each intersecting building to the priority queue <code>live</code>. Therefore, whenever we need to get the height of the tallest \"live\" building, we can just check the top result from <code>live</code> (or 0 if <code>live</code> is empty), rather than iterating over all the buildings!</p>\n<p><strong>What if we run into the right edge of a building?</strong></p>\n<p>Theoretically, we should remove the building from <code>live</code> once we run into its right edge (recall the right-edge-doesn't-count conclusion), meaning we have passed this building so it won't contribute to the skyline height anymore. As long as the tallest building is surely live, it's okay if some lower buildings that have been passed are still in <code>live</code>. We only need to make sure we remove a \"past\" building once it becomes the tallest one in <code>live</code>.</p>\n<p></p>\n<p>First, we need to sort all the edges in non-decreasing order for the sweep line algorithm. In order to track which building a certain edge belongs to, we should also mark each edge with the index of the building in <code>buildings</code>.</p>\n<p>Since there might be multiple edges at the same position on the x-axis, we should finish handling all edges at the same position before moving on to the next position.</p>\n<p>Take the slide below as an example!</p>\n<p></p>\n<p><strong>Algorithm</strong></p>\n<ol start=\"2\">\n<li data-length=\"1\">Iterate over <code>buildings</code> and store each building's edges separately with the building's index as a reference in <code>edges</code>.</li>\n<li data-length=\"1\">Sort the entries in <code>edges</code> by their first element.</li>\n<li data-length=\"1\">Iterate over the sorted <code>edges</code> and for each edge/index:\n<ul>\n<li>If <code>buildings[b][0] == curr_x</code>, meaning its a left edge and the <code>building[b]</code> is live, we add <code>(height, right)</code> to <code>live</code>.</li>\n<li>While the tallest live building has been passed, remove it from <code>live</code>.</li>\n</ul>\n</li>\n<li data-length=\"1\">Once we finish handling all the edges at the <code>curr_x</code>, we shall move on to the next position.</li>\n<li data-length=\"1\">After the iteration, return <code>answer</code> as the skyline.</li>\n</ol>\n<p><strong>Implementation</strong></p>\n<pre><code>class Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; getSkyline(vector&lt;vector&lt;int&gt;&gt;&amp; buildings) {\n        // Iterate over all buildings, for each building i,\n        // add (position, i) to edges.\n        vector&lt;vector&lt;int&gt;&gt; edges;\n        for (int i = 0; i &lt; buildings.size(); ++i){\n            edges.push_back({buildings[i][0], i});\n            edges.push_back({buildings[i][1], i});\n        }\n        \n        // Sort edges by non-decreasing order.\n        sort(edges.begin(), edges.end());\n        \n        // Initailize an empty Priority Queue 'live' to store all the newly added buildings,\n        // an empty list 'answer' to store the skyline key points.\n        priority_queue&lt;pair&lt;int, int&gt;&gt; live;\n        vector&lt;vector&lt;int&gt;&gt; answer;\n        int idx = 0;\n        \n        // Iterate over all the sorted edges.\n        while (idx &lt; edges.size()){\n            \n            // Since we might have multiple edges at same x,\n            // Let the 'currX' be the current position.\n            int currX = edges[idx][0];\n            \n            // While we are handling the edges at 'currX':\n            while (idx &lt; edges.size() &amp;&amp; edges[idx][0] == currX){\n                // The index 'b' of this building in 'buildings'\n                int b = edges[idx][1];\n                \n                // If this is a left edge of building 'b', we\n                // add (height, right) of building 'b' to 'live'.\n                if (buildings[b][0] == currX){\n                    int right = buildings[b][1];\n                    int height = buildings[b][2];\n                    live.push({height, right});\n                }\n                idx += 1;\n            }\n            \n            // If the tallest live building has been passed,\n            // we remove it from 'live'.\n            while (!live.empty() &amp;&amp; live.top().second &lt;= currX)\n                live.pop();\n            \n            // Get the maximum height from 'live'.\n            int currHeight = live.empty() ? 0 : live.top().first;\n            \n            // If the height changes at 'currX', we add this\n            // skyline key point [currX, max_height] to 'answer'.\n            if (answer.empty() || answer[answer.size() - 1][1] != currHeight)\n                answer.push_back({currX, currHeight});\n        }\n        \n        // Return 'answer' as the skyline.\n        return answer;\n    }\n};</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<p>Let <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></span> be the length of the input array <code>buildings</code>.</p>\n<ul>\n<li>\n<p>Time complexity: <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right: 0.1667em;\"></span><span class=\"mop\">lo<span style=\"margin-right: 0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right: 0.1667em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<ul>\n<li>There are <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6444em;\"></span><span class=\"mord\">2</span><span class=\"mord mathnormal\">n</span></span></span></span></span> edges so we have at most <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span> unique positions during the iteration.</li>\n<li>At each step, we need to pop out the passed buildings from priority queue <code>live</code> and put in the newly added building (if exist). In worse-case scenario, we have <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span> live buildings in <code>live</code>, both the <code>pop</code> and <code>push</code> operations take <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mop\">lo<span style=\"margin-right: 0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right: 0.1667em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span> time.</li>\n<li>To sum up, the overall time complexity is <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right: 0.1667em;\"></span><span class=\"mop\">lo<span style=\"margin-right: 0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right: 0.1667em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span>.</li>\n</ul>\n</li>\n<li>\n<p>Space complexity: <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<ul>\n<li>We initalize <code>edges</code> of size <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">2</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span> to store all the edges and its indexes, empty list <code>answer</code> to store all the skyline key points.</li>\n<li>We maintain a priority queue <code>live</code> which has at most <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span> elements.</li>\n<li>There can be at most <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span> skyline key points, thus <code>answer</code> takes at most <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span> space.</li>\n<li>Therefore, the overall space complexity is <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span>.</li>\n</ul>\n</li>\n</ul>\n<br/>\n<hr/>\n<h3 class=\"group/heading relative\" id=\"approach-4-sweep-line--two-priority-queue\" level=\"3\"><a aria-hidden=\"true\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" href=\"#approach-4-sweep-line--two-priority-queue\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" data-icon=\"link\" data-prefix=\"fas\" focusable=\"false\" role=\"img\" spacing=\"square\" viewbox=\"0 0 640 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\" fill=\"currentColor\"></path></svg></div></a>Approach 4: Sweep Line + Two Priority Queue</h3>\n<p>We still use a priority queue <code>live</code> to keep all the buildings we picked up. Recall that in the previous approaches, we have to assign an auxiliary mark (the mark could either be the position of its right edge, or its original index in <code>buildings</code>) to each building, thus we can get the position of its right edge, so as to judge if the top building from <code>live</code> should be dropped. Here, we can make this step more intuitive, by discarding this unique index and only storing the heights of buildings: Whenever we meet the left edge of a building, we just add its height to <code>live</code>.</p>\n<p>But how do we know if some buildings apart from the top buildings should be removed? Since we are not expected to remove an intermediate element from a regular priority queue.</p>\n<blockquote>\n<p>We use another priority queue (let's call it <code>past</code>) to keep all the buildings that <strong>should be</strong> removed from <code>live</code> but <strong>haven't been</strong> yet.</p>\n</blockquote>\n<p>We can see that <code>live</code> works as a debt card: it can temporarily record our \"debt\". Once we are able to pay the \"debt\", that is. when the top building in <code>live</code> equals the top building in <code>past</code>, we will remove it from <code>past</code>. Since the \"debt\" has been cleared, we will remove the top building from <code>past</code> as well.</p>\n<p>We repeatedly remove top building from both <code>live</code> and <code>past</code>, until:</p>\n<ul>\n<li><code>past</code> is empty, meaning every building in <code>live</code> is literally \"live\".</li>\n<li>The top building in <code>live</code> is taller than the top building in <code>past</code>, in this case, we may still have some buildings to remove, but their height is too small to affect the height of the top building.</li>\n</ul>\n<p>Take the following slides as an example:</p>\n<p></p>\n<p><strong>Algorithm</strong></p>\n<ol>\n<li data-length=\"1\">Initalize:\n<ul>\n<li>an empty list <code>edges</code> for storing all the x-values of the left and right edges.</li>\n<li>an empty list <code>answer</code> for storing all the skyline key points.</li>\n<li>an empty priority queue <code>live</code> for storing the live buildings.</li>\n<li>an empty priority queue <code>past</code> for storing the buildings that should be removed already.</li>\n</ul>\n</li>\n<li data-length=\"1\">Iterate over <code>buildings</code>, for <code>building[i] = [left, right, height]</code>, add <code>[left, height]</code>, <code>[right, -height]</code> to <code>edges</code>, thus we can easily distinguish if an edge is a left edge (<code>height &gt; 0</code>) or a right edge (<code>height &lt; 0</code>).</li>\n<li data-length=\"1\">Sort <code>edges</code> by the first elements of its elements.</li>\n<li data-length=\"1\">Iterate over <code>edges</code>, for every <code>edges[idx]</code> let <code>curr_x = edge[idx][0]</code>, while <code>curr_x = edge[idx][0]</code>:\n<ul>\n<li>If <code>height &gt; 0</code>, add <code>height</code> to <code>live</code>.</li>\n<li>Otherwise, add <code>height</code> to <code>past</code>.</li>\n<li>increment <code>idx</code> by 1.</li>\n</ul>\n</li>\n<li data-length=\"1\">While <code>past</code> is not empty and top buildings from <code>live</code> and <code>past</code> have the same height, remove top building from both <code>live</code> and <code>past</code>.</li>\n<li data-length=\"1\">Get <code>max_height</code> from <code>live</code> (<code>max_height = 0</code> if <code>live</code> is empty).</li>\n<li data-length=\"1\">If <code>answer</code> is empty or <code>max_height</code> changes, add <code>[curr_x, max_height]</code> to <code>answer</code> as a new skyline key point.</li>\n<li data-length=\"1\">After the iteration, return <code>answer</code> as the skyline.</li>\n</ol>\n<p><strong>Implementation</strong></p>\n<pre><code>class Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; getSkyline(vector&lt;vector&lt;int&gt;&gt;&amp; buildings) {\n        // Iterate over all buildings, for each building i,\n        // add (position, i) to 'edges'.\n        vector&lt;vector&lt;int&gt;&gt; edges;\n        for (int i = 0; i &lt; buildings.size(); ++i){\n            edges.push_back({buildings[i][0], buildings[i][2]});\n            edges.push_back({buildings[i][1], -buildings[i][2]});\n        }\n        \n        // Sort edges by non-decreasing order.\n        sort(edges.begin(), edges.end());\n        \n        // Initailize twp empty priority queues 'live' and 'past',\n        // an empty list 'answer' to store the skyline key points.\n        priority_queue&lt;int&gt; live;\n        priority_queue&lt;int&gt; past;\n        vector&lt;vector&lt;int&gt;&gt; answer;\n        \n        int idx = 0;\n​\n        // Iterate over all the sorted edges.\n        while (idx &lt; edges.size()){\n            \n            // Since we might have multiple edges at same x,\n            // Let the 'currX' be the current position.\n            int currX = edges[idx][0];\n            \n            // While we are handling the edges at 'currX':\n            while (idx &lt; edges.size() &amp;&amp; edges[idx][0] == currX){\n                // The height of the current building.\n                int height = edges[idx][1];\n                \n                // If this is a left edge, add `height` to 'live'.\n                // Otherwise, add `height` to `past`.\n                if (height &gt; 0){\n                    live.push(height);\n                } else {\n                    past.push(-height);\n                }\n                idx += 1;\n            }\n            \n            // If the tallest live building has been passed,\n            // we remove it from 'live'.\n            while (!past.empty() &amp;&amp; live.top() == past.top()) {\n                live.pop();\n                past.pop();\n            }\n            \n            // Get the maximum height from 'live'.\n            int currHeight = live.empty() ? 0 : live.top();\n            \n            // If the height changes at 'currX', we add this\n            // skyline key point [currX, max_height] to 'answer'.\n            if (answer.empty() || answer.back()[1] != currHeight)\n                answer.push_back({currX, currHeight});\n        }\n            \n        // Return 'answer' as the skyline.\n        return answer;  \n    }\n};</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<p>Let <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></span> be the length of the input array <code>buildings</code>.</p>\n<ul>\n<li>\n<p>Time complexity: <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mop\">lo<span style=\"margin-right: 0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right: 0.1667em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<ul>\n<li>We sort a list with length of <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6444em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></span>, which takes <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span> time.</li>\n<li>Then we iterate over all the sorted edges, during the iteration, we have to manipulate on two priority queues, the amortized cost of this operation is <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mop\">lo<span style=\"margin-right: 0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right: 0.1667em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span>.</li>\n<li>To sum up, the overall time complexity is <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mop\">lo<span style=\"margin-right: 0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right: 0.1667em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span></li>\n</ul>\n</li>\n<li>\n<p>Space complexity: <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<ul>\n<li>We used an empty array <code>edges</code> to store the information of all the left and right edges. There are <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6444em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></span> edges and will cost <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span> space.</li>\n<li>Besides, we need to maintain two priority queues, in the worst-case scenario, each of them takes <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span> space.</li>\n<li>To sum up, the overall space complexity is <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span>.</li>\n</ul>\n</li>\n</ul>\n<br/>\n<hr/>\n<h3 class=\"group/heading relative\" id=\"approach-5-union-find\" level=\"3\"><a aria-hidden=\"true\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" href=\"#approach-5-union-find\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" data-icon=\"link\" data-prefix=\"fas\" focusable=\"false\" role=\"img\" spacing=\"square\" viewbox=\"0 0 640 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\" fill=\"currentColor\"></path></svg></div></a>Approach 5: Union Find</h3>\n<p><strong>Algorithm</strong></p>\n<p>Recall the first brute-force solution with <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1.0641em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.8141em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span> time complexity; whenever we added a new building, we had to traverse over all the indexes covered by the building and update the appropriate values in <code>heights</code>. Now suppose that a building has a very small height, and many of its <code>heights</code> values have previously been updated by some taller buildings, thus won't update this time.</p>\n<p></p>\n<p>Can we find a method to avoid such \"unnecessary\" non-updates? The answer is: \"Yes!\"</p>\n<p>Imagine if we give some indexes a billboard saying:</p>\n<blockquote>\n<p><strong>All the heights starting from me and ending by XXX (an index on its right) have already been updated! These heights are larger than yours, thus you don't need to bother attempting to update these heights; just jump directly to XXX and move on!</strong></p>\n</blockquote>\n<p>It seems feasible! Let's give it a shot by assigning a value to each edge, which equals the rightmost edge of the consecutive range having a height no less than the current edge.</p>\n<p><strong>What is the use of such value?</strong></p>\n<blockquote>\n<p>It will help identify the range of edges that we can just skip past.</p>\n</blockquote>\n<p></p>\n<p>As shown in the picture below, unlike iterating over every index and updating nothing, we will first look up the current index in <code>root</code> to see if we can skip past any intermediate indexes that have already been updated by some taller buildings. This is the core difference between this approach and the brute-force one!</p>\n<p></p>\n<p><strong>How can we maximize skips by assuring that the updates are made by taller buildings first?</strong></p>\n<blockquote>\n<p>We can iterate over the buildings by descending height. Therefore, for each building, all the previous updates in <code>heights</code> are made by buildings of larger or equal height! We can safely skip those indexes that have been updated already.</p>\n</blockquote>\n<p><strong>Which data structure should we use?</strong></p>\n<blockquote>\n<p>We can use a disjoint-set data structure to store this relation between indexes. The <code>root</code> of an index <code>x_i</code> can be regarded as the rightmost index <code>x_j</code> where all indexes in the range <code>[x_i, x_j)</code> have larger or equal heights as that of <code>x_i</code>.</p>\n</blockquote>\n<p>Let's refer to the slides below as an example:</p>\n<p></p>\n<p><strong>Implementation</strong></p>\n<ol>\n<li data-length=\"1\">Use a set to collect all the unique positions of left and right edges of the buildings in <code>buildings</code> and make sure they're in sorted order.</li>\n<li data-length=\"1\">Iterate over all the buildings by descending height, and for each building:\n<ul>\n<li>Use the hash table to convert the left and right edges into <code>leftIndex</code> and <code>rightIndex</code>.</li>\n<li>While <code>leftIndex &lt; rightIndex</code>:\n<ul>\n<li>Use the <code>UnionFind.Find()</code> to advance <code>leftIndex</code> to <code>Find(leftIndex)</code>, skipping past unnecessary indexes.</li>\n<li>Update <code>heights</code> with the current <code>height</code> at the new <code>leftIndex</code>.</li>\n<li>Use the <code>UnionFind.Union()</code> to set the root of <code>leftIndex</code> to the root of <code>rightIndex</code> and increment <code>leftIndex</code> by 1.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li data-length=\"1\">Iterate over the updated <code>heights</code> and add every position where the height changes to <code>answer</code> as the skyline key points.</li>\n</ol>\n<pre><code>​\n// Define the disjoint-set data structure.\nclass UnionFind {   \n    private:\n        vector&lt;int&gt; root;\n    public:\n        UnionFind(int n): root(n) {\n            iota(root.begin(), root.end(), 0);\n        }\n        int find(int x) {\n            if (root[x] != x) \n                return find(root[x]);\n            return root[x];\n        }\n        void merge(int x, int y) {\n            root[x] = root[y];\n        }\n};\n​\nclass Solution {\n    public:\n    vector&lt;vector&lt;int&gt;&gt; getSkyline(vector&lt;vector&lt;int&gt;&gt;&amp; buildings) {\n        // Sort buildings by descending height.\n        sort(buildings.begin(), buildings.end(), [](auto &amp;a, auto &amp;b) {\n           return a[2] &gt; b[2]; \n        });\n        // Use a set to store the unique positions of all the edges and sort them.\n        set&lt;int&gt; edgeSet;\n        for (auto building : buildings) {\n            edgeSet.insert(building[0]);\n            edgeSet.insert(building[1]);\n        }\n        vector&lt;int&gt; edges(edgeSet.begin(), edgeSet.end());\n        int n = edges.size();\n        \n        // Map together the x value of each edge to its index in `edges`\n        unordered_map&lt;int, int&gt; edgeIndexMap;\n        for (int i = 0; i &lt; n; ++i) {\n            edgeIndexMap[edges[i]] = i;\n        }\n​\n        // We'll use a disjoint set to allow us to skip past\n        // already-updated indexes in `heights`.\n        UnionFind edgeUF(n);\n        vector&lt;int&gt; heights(n);\n        \n        // Iterate over all the buildings by descending height.\n        for (auto building : buildings) {\n            int leftEdge = building[0], rightEdge = building[1];\n            int height = building[2];\n            \n            // Find the left and right starting indexes using `edgeIndexMap`.\n            // We should use `find()` to jump forward to the first necessary index.\n            int leftIndex = edgeUF.find(edgeIndexMap[leftEdge]);\n            int rightIndex = edgeIndexMap[rightEdge];\n            while (leftIndex &lt; rightIndex) {\n                heights[leftIndex] = height;\n                \n                // Use `merge()` to create a new shortcut to `rightIndex`.\n                edgeUF.merge(leftIndex, rightIndex);\n                \n                // Then move forward and find the next necessary height to update.\n                leftIndex = edgeUF.find(++leftIndex);\n            }\n        }\n        \n        // Finally, we just need to iterate over the updated 'heights'\n        // and add every skyline key point to 'answer'.\n        vector&lt;vector&lt;int&gt;&gt; answer;\n        for (int i = 0; i &lt; n; ++i) {\n            if (i == 0 || heights[i] != heights[i - 1]) {\n                answer.push_back({edges[i], heights[i]});\n            }\n        }\n        return answer;  \n    }\n};</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<p>Let <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></span> be the length of the input array <code>buildings</code>.</p>\n<ul>\n<li>\n<p>Time complexity: <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right: 0.1667em;\"></span><span class=\"mop\">lo<span style=\"margin-right: 0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right: 0.1667em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<ul>\n<li>Sorting the <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></span> buildings has an average time complexity of <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right: 0.1667em;\"></span><span class=\"mop\">lo<span style=\"margin-right: 0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right: 0.1667em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span>, though sorting algorithms vary by language.</li>\n<li>There are at most <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6444em;\"></span><span class=\"mord\">2</span><span class=\"mord mathnormal\">n</span></span></span></span></span> unique positions for <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6444em;\"></span><span class=\"mord\">2</span><span class=\"mord mathnormal\">n</span></span></span></span></span> edges, and sorting them similarly has an average time complexity of <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right: 0.1667em;\"></span><span class=\"mop\">lo<span style=\"margin-right: 0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right: 0.1667em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span>.</li>\n<li>The <code>UnionFind.union()</code> function has a time complexity of <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></span> and will run at most <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6444em;\"></span><span class=\"mord\">2</span><span class=\"mord mathnormal\">n</span></span></span></span></span> times for an overall time complexity of <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span>.</li>\n<li>The <code>UnionFind.find()</code> function has a time complexity of <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span> for the worst-case scenario, but using a collapsing find technique brings this down to <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></span> with repeated use. This amortizes to an overall time complexity of <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span>, as each successful <code>find()</code> will update a value in <code>root</code>, and there are up to <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6444em;\"></span><span class=\"mord\">2</span><span class=\"mord mathnormal\">n</span></span></span></span></span> elements in <code>root</code>. As shown in the picture below.</li>\n</ul>\n<p></p>\n</li>\n<li>\n<p>Space complexity: <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<ul>\n<li>There are at most <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6444em;\"></span><span class=\"mord\">2</span><span class=\"mord mathnormal\">n</span></span></span></span></span> edges, thus the set <code>edgeSet</code>, the lists <code>edges</code>, <code>heights</code>, and <code>answers</code>, the union-find's <code>root</code> list, and the recursion stack for the union-find's <code>find()</code> are each limited to <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span> space.</li>\n</ul>\n</li>\n</ul>\n<br/>\n<hr/>\n<h3 class=\"group/heading relative\" id=\"approach-6-divide-and-conquer\" level=\"3\"><a aria-hidden=\"true\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" href=\"#approach-6-divide-and-conquer\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" data-icon=\"link\" data-prefix=\"fas\" focusable=\"false\" role=\"img\" spacing=\"square\" viewbox=\"0 0 640 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\" fill=\"currentColor\"></path></svg></div></a>Approach 6: Divide-and-Conquer</h3>\n<p><strong>Intuition</strong></p>\n<p>The divide-and-conqueror algorithm is a common algorithmic paradigm based on recursion with three core parts:</p>\n<ul>\n<li>Divide: Divide the original problem into a number of smaller sub-problems.</li>\n<li>Conquer: Solve the sub-problems recursively.</li>\n<li>Combine: Merge these sub-problem solutions into a solution for the original problem.</li>\n</ul>\n<p>For more information on divide-and-conqueror, please refer to the <a href=\"https://leetcode.com/explore/learn/card/recursion-ii/470/divide-and-conquer/\" target=\"_blank\">LeetCode explore card</a>.</p>\n<p>Recall how we sort a list of numbers using merge-sort (divide-and-conqueror):</p>\n<ul>\n<li>Divide the unsorted list into two roughly even sublists.</li>\n<li>Sort each of the sublists recursively.</li>\n<li>Merge the sorted sublists back together.</li>\n</ul>\n<p>Similarly, we can solve this problem using the divide-and-conquer algorithm.</p>\n<ul>\n<li>Divide the list of buildings into two roughly even sublists.</li>\n<li>Get the skyline from each of the sublists recursively.</li>\n<li>Merge the two skylines together.</li>\n</ul>\n<p></p>\n<p>The first step is straightforward as we can simply split the list of buildings into two halves. For the base case in the second step, we can get the skyline from a single building directly. In the third part, two skylines should be merged into one skyline, we would use a much simplier version of sweep line algorithm.</p>\n<p>Let's take the following slides as an example.</p>\n<p></p>\n<blockquote>\n<p>We always compare the heights from both skylines, even if <code>R</code> comes before <code>L</code>, we should also consider the height of <code>L</code> as well.</p>\n</blockquote>\n<p>Take the picture below as an example:</p>\n<p></p>\n<p>In the graphic's first case, <code>R</code> has many skyline points, yet we don't add any of them to our answer, That's because they're \"hidden\" behind the taller building in <code>L</code>. Hence the merged skyline's height doesn't change unless the current point's height is taller than the current height of the opposite side. In the graphic's second case, for example, we can add a skyline point where the height of <code>R</code> exceeds <code>L</code>.</p>\n<p><strong>Algorithm</strong></p>\n<ol>\n<li data-length=\"1\">Recursively divide the current array <code>buildings</code> into two halves.</li>\n<li data-length=\"1\">When the recursion reaches the base case of a single building, return the simple skyline.</li>\n<li data-length=\"1\">Merge the resulting skylines using a line sweep algorithm moving from left to right.</li>\n<li data-length=\"1\">Return the fully merged skyline.</li>\n</ol>\n<p><strong>Implementation</strong></p>\n<pre><code>using vv = vector&lt;vector&lt;int&gt;&gt;;\n​\nclass Solution {\npublic:\n    vv getSkyline(vv&amp; buildings) {\n        // Pass `buildings` on to the recursive divide-and-conquer function.\n        return divideAndConquer(buildings, 0, buildings.size() - 1);\n    }\n    // Recursively divide buildings and merge the skylines.\n    vv divideAndConquer(vv&amp; buildings, int left, int right) {\n        // If the given array of buildings contains only 1 building,\n        // we can directly return the corresponding skyline.\n        if (left == right) {\n            return {{buildings[left][0], buildings[left][2]}, {buildings[left][1], 0}};\n        }\n​\n        // Otherwise, recursively divide the buildings and merge the skylines.\n        int mid = left + (right - left) / 2;\n        vv leftSkyline = divideAndConquer(buildings, left, mid);\n        vv rightSkyline = divideAndConquer(buildings, mid + 1, right);\n        return mergeSkylines(leftSkyline, rightSkyline);\n    }\n    \n    // Merge two skylines into one.\n    vv mergeSkylines(vv&amp; left, vv&amp; right) {\n        int leftPos = 0, rightPos = 0;\n        int leftPrevHeight = 0, rightPrevHeight = 0;\n        int curY = 0, curX = 0;\n        vv answer;\n​\n        // Process both skylines in order of increasing X value.\n        while (leftPos &lt; left.size() &amp;&amp; rightPos &lt; right.size()) {\n            // For each of the three possible cases,\n            // update the current position and previous heights.\n            int nextLeftX = left[leftPos][0], nextRightX = right[rightPos][0];\n            if (nextLeftX &lt; nextRightX) {\n                curX = nextLeftX;\n                curY = max(left[leftPos][1], rightPrevHeight);\n                leftPrevHeight = left[leftPos++][1];\n            } else if (nextLeftX &gt; nextRightX) {\n                curX = nextRightX;\n                curY = max(right[rightPos][1], leftPrevHeight);\n                rightPrevHeight = right[rightPos++][1];\n            } else {\n                curX = nextLeftX;\n                curY = max(left[leftPos][1], right[rightPos][1]);\n                leftPrevHeight = left[leftPos++][1];\n                rightPrevHeight = right[rightPos++][1];\n            }\n​\n            // If the height has changed, add the skyline point to our answer.\n            if (answer.empty() || curY != answer.back()[1]) {\n                answer.push_back({curX, curY});\n            }\n        }\n​\n        // If we have reached the end of one of the skylines,\n        // append the other skyline's remaining points to our answer. \n        while (leftPos &lt; left.size()) {\n            answer.push_back(left[leftPos++]);\n        }\n        while (rightPos &lt; right.size()) {\n            answer.push_back(right[rightPos++]);\n        }\n        return answer;\n    }\n};</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<p>Let <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></span> be the length of the input array <code>buildings</code>.</p>\n<ul>\n<li>\n<p>Time complexity: <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right: 0.1667em;\"></span><span class=\"mop\">lo<span style=\"margin-right: 0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right: 0.1667em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<ul>\n<li>During the divide-and-conquer process, we recursively cut the array into two halves, thus <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.8889em; vertical-align: -0.1944em;\"></span><span class=\"mop\">lo<span style=\"margin-right: 0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right: 0.1667em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></span> steps are needed to split the original input array into single buildings and then merge them back together. In other words, the recursion stack has a depth of <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.8889em; vertical-align: -0.1944em;\"></span><span class=\"mop\">lo<span style=\"margin-right: 0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right: 0.1667em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></span> levels.</li>\n<li>In each level of the recursion, it takes a total of <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span> time to merge all the sub-skylines into larger skylines.</li>\n</ul>\n</li>\n<li>\n<p>Space complexity: <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<ul>\n<li>We need <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span> space to create the answer array to record the merged skylines as there are at most <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6444em;\"></span><span class=\"mord\">2</span><span class=\"mord mathnormal\">n</span></span></span></span></span> skyline key points.</li>\n<li>The recursion stack also requires an additional <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mop\">lo<span style=\"margin-right: 0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right: 0.1667em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span> space.</li>\n</ul>\n</li>\n</ul>\n<br/></div><span style=\"font-size: 0px; line-height: 0;\"> </span></div>"}