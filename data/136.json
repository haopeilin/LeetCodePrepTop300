{"id":"136","title":"Single Number","difficulty":"Easy","content":"<p>Given a <strong>non-empty</strong>&nbsp;array of integers <code>nums</code>, every element appears <em>twice</em> except for one. Find that single one.</p>\n\n<p>You must&nbsp;implement a solution with a linear runtime complexity and use&nbsp;only constant&nbsp;extra space.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">nums = [2,2,1]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">1</span></p>\n</div>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">nums = [4,1,2,1,2]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">4</span></p>\n</div>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">nums = [1]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">1</span></p>\n</div>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>-3 * 10<sup>4</sup> &lt;= nums[i] &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li>Each element in the array appears twice except for one element which appears only once.</li>\n</ul>\n","tags":["Array","Bit Manipulation"],"java_snippet":"class Solution {\n    public int singleNumber(int[] nums) {\n        \n    }\n}","solution":"<h2><a href=\"#solution\"><svg><path></path></svg></a>Solution</h2>\n<hr/>\n<blockquote>\n<p><strong>Note:</strong> In this article, only the fourth approach satisfies both the time and space complexity requirements provided in the problem description. However, the first three approaches are included to show a diverse set of ways to approach this problem.</p>\n</blockquote>\n<h3><a href=\"#approach-1-list-operation\"><svg><path></path></svg></a>Approach 1: List operation</h3>\n<p><strong>Algorithm</strong></p>\n<ol>\n<li>Iterate over all the elements in nums</li>\n<li>If some number in nums is new to the list, append it</li>\n<li>If some number is already in the list, remove it</li>\n</ol>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : O(n2). We iterate through nums, taking O(n) time. We search the whole list to find whether there is a duplicate number, taking O(n) time. Because the search is inside the <code>for</code> loop, we have to multiply both time complexities, which is O(n2).</p>\n</li>\n<li>\n<p>Space complexity : O(n). We need a list of size n to contain elements in nums.</p>\n<br/>\n</li>\n</ul>\n<br/>\n<hr/>\n<h3><a href=\"#approach-2-hash-table\"><svg><path></path></svg></a>Approach 2: Hash Table</h3>\n<p><strong>Algorithm</strong></p>\n<p>We use a hash table to avoid the O(n) time required for searching the elements.</p>\n<ol>\n<li>Iterate through all elements in <code>nums</code> and set up key/value pairs using a hash table.</li>\n<li>Return the element which appeared only once.</li>\n</ol>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : O(n⋅1)=O(n). Time complexity of the <code>for</code> loop is O(n). Time complexity of hash table operations (for example, <code>put</code> and <code>get</code> in a Java <code>HashMap</code>) is O(1).</p>\n</li>\n<li>\n<p>Space complexity : O(n). The space required by the hash table is equal to the number of elements in nums.</p>\n<br/>\n</li>\n</ul>\n<br/>\n<hr/>\n<h3><a href=\"#approach-3-math\"><svg><path></path></svg></a>Approach 3: Math</h3>\n<p><strong>Concept</strong></p>\n<p>2∗(a+b+c)−(a+a+b+b+c)=c</p>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : O(n+n)=O(n). Computing the sum requires iterating through nums. In Java, this is typically done using a loop (or streams), which takes O(n) time because of the number of elements (n) in nums.</p>\n</li>\n<li>\n<p>Space complexity : O(n+n)=O(n). A <code>Set</code> needs space for the elements in <code>nums</code>.</p>\n<br/>\n</li>\n</ul>\n<br/>\n<hr/>\n<h3><a href=\"#approach-4-bit-manipulation\"><svg><path></path></svg></a>Approach 4: Bit Manipulation</h3>\n<p><strong>Concept</strong></p>\n<ul>\n<li>If we take XOR of zero and some bit, it will return that bit\n<ul>\n<li>a⊕0=a</li>\n</ul>\n</li>\n<li>If we take XOR of two same bits, it will return 0\n<ul>\n<li>a⊕a=0</li>\n</ul>\n</li>\n<li>a⊕b⊕a=(a⊕a)⊕b=0⊕b=b</li>\n</ul>\n<p>So we can XOR all bits together to find the unique number.</p>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : O(n). We only iterate through nums, so the time complexity depends on the number of elements in nums.</p>\n</li>\n<li>\n<p>Space complexity : O(1).</p>\n</li>\n</ul>"}