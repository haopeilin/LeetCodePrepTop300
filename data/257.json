{"id":"257","title":"Binary Tree Paths","difficulty":"Easy","content":"<p>Given the <code>root</code> of a binary tree, return <em>all root-to-leaf paths in <strong>any order</strong></em>.</p>\n\n<p>A <strong>leaf</strong> is a node with no children.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/12/paths-tree.jpg\" style=\"width: 207px; height: 293px;\" />\n<pre>\n<strong>Input:</strong> root = [1,2,3,null,5]\n<strong>Output:</strong> [&quot;1-&gt;2-&gt;5&quot;,&quot;1-&gt;3&quot;]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [1]\n<strong>Output:</strong> [&quot;1&quot;]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[1, 100]</code>.</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n","tags":["String","Backtracking","Tree","Depth-First Search","Binary Tree"],"java_snippet":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public List<String> binaryTreePaths(TreeNode root) {\n        \n    }\n}","solution":"<h2><a href=\"#solution\"><svg><path></path></svg></a>Solution</h2>\n<hr/>\n<h3><a href=\"#binary-tree-definition\"><svg><path></path></svg></a>Binary tree definition</h3>\n<p>First of all, here is the definition of the <code>TreeNode</code> which we will use in the following implementation.</p>\n<br/>\n<br/>\n<hr/>\n<h3><a href=\"#approach-1-recursion\"><svg><path></path></svg></a>Approach 1: Recursion</h3>\n<p>The most intuitive way is to use recursion here. One is going through the tree by considering at each step the node itself and its children. If node <em>is not</em> a leaf, one extends the current path by a node value and calls recursively the path construction for its children. If node <em>is</em> a leaf, one closes the current path and adds it into the list of paths.</p>\n<pre><code>class Solution {\n  public void construct_paths(TreeNode root, String path, LinkedList&lt;String&gt; paths) {\n    if (root != null) {\n      path += Integer.toString(root.val);\n      if ((root.left == null) &amp;&amp; (root.right == null))  // if reach a leaf\n        paths.add(path);  // update paths\n      else {\n        path += \"-&gt;\";  // extend the current path\n        construct_paths(root.left, path, paths);\n        construct_paths(root.right, path, paths);\n      }\n    }\n  }\n​\n  public List&lt;String&gt; binaryTreePaths(TreeNode root) {\n    LinkedList&lt;String&gt; paths = new LinkedList();\n    construct_paths(root, \"\", paths);\n    return paths;\n  }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity: O(NlogN)</p>\n<p>We visit each node exactly once, which contributes O(N) to the time complexity.</p>\n<p>At each node, we are copying the current path to store it. The length of the path is proportional to the height of the tree, which is logN. Since this copying operation occurs for each node, and there are N nodes, this contributes an additional O(NlogN) complexity due to copying paths.</p>\n<p>Combining these factors, the total time complexity is O(NlogN). This is because, although we visit each node once, the cost of copying paths (which can be proportional to the height of the tree) adds a logN factor to the complexity.</p>\n</li>\n<li>\n<p>Space complexity: O(N).</p>\n<p>Here we use the space for a stack call and for a  <code>paths</code> list to store the answer. <code>paths</code> contains as many elements as leaves in the tree and hence couldn't be larger than logN for the trees containing more than one element. Hence the space complexity is determined by a stack call. In the worst case, when the tree is completely unbalanced, <em>e.g.</em> each node has only one child node, the recursion call would occur N times (the height of the tree), therefore the storage to keep the call stack would be O(N). But in the best case (the tree is balanced), the height of the tree would be log(N). Therefore, the space complexity in this case would be O(log(N)).</p>\n</li>\n</ul>\n<br/>\n<br/>\n<hr/>\n<h3><a href=\"#approach-2-iterations\"><svg><path></path></svg></a>Approach 2: Iterations</h3>\n<p>The approach above could be rewritten with the help of iterations. This way we initiate the stack by a root node and then at each step, we pop out one node and its path. If the poped node <em>is</em> a leaf, one updates the list of all paths. If not, one pushes its child nodes and corresponding paths into the stack till all nodes are checked.</p>\n<p></p>\n<pre><code>class Solution {\n  public List&lt;String&gt; binaryTreePaths(TreeNode root) {\n    LinkedList&lt;String&gt; paths = new LinkedList();\n    if (root == null)\n      return paths;\n​\n    LinkedList&lt;TreeNode&gt; node_stack = new LinkedList();\n    LinkedList&lt;String&gt; path_stack = new LinkedList();\n    node_stack.add(root);\n    path_stack.add(Integer.toString(root.val));\n    TreeNode node;\n    String path;\n​\n    while ( !node_stack.isEmpty() ) {\n      node = node_stack.pollLast();\n      path = path_stack.pollLast();\n      if ((node.left == null) &amp;&amp; (node.right == null))\n        paths.add(path);\n      if (node.left != null) {\n        node_stack.add(node.left);\n        path_stack.add(path + \"-&gt;\" + Integer.toString(node.left.val));\n      }\n      if (node.right != null) {\n        node_stack.add(node.right);\n        path_stack.add(path + \"-&gt;\" + Integer.toString(node.right.val));\n      }\n    }\n    return paths;\n  }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time complexity: O(N) since each node is visited exactly once.</li>\n<li>Space complexity: O(N) as we could keep up to the entire tree.</li>\n</ul>"}