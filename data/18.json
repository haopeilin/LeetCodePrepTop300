{"id":"18","title":"4Sum","difficulty":"Medium","content":"<p>Given an array <code>nums</code> of <code>n</code> integers, return <em>an array of all the <strong>unique</strong> quadruplets</em> <code>[nums[a], nums[b], nums[c], nums[d]]</code> such that:</p>\n\n<ul>\n\t<li><code>0 &lt;= a, b, c, d&nbsp;&lt; n</code></li>\n\t<li><code>a</code>, <code>b</code>, <code>c</code>, and <code>d</code> are <strong>distinct</strong>.</li>\n\t<li><code>nums[a] + nums[b] + nums[c] + nums[d] == target</code></li>\n</ul>\n\n<p>You may return the answer in <strong>any order</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,0,-1,0,-2,2], target = 0\n<strong>Output:</strong> [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,2,2,2,2], target = 8\n<strong>Output:</strong> [[2,2,2,2]]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 200</code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= target &lt;= 10<sup>9</sup></code></li>\n</ul>\n","tags":["Array","Two Pointers","Sorting"],"java_snippet":"class Solution {\n    public List<List<Integer>> fourSum(int[] nums, int target) {\n        \n    }\n}","solution":"<h2><a href=\"#solution\"><svg><path></path></svg></a>Solution</h2>\n<p>This problem is a follow-up of <a href=\"https://leetcode.com/articles/3sum/\">3Sum</a>, so take a look at that problem first if you haven't. 4Sum and 3Sum are very similar; the difference is that we are looking for unique quadruplets instead of triplets.</p>\n<p>As you see, 3Sum just wraps Two Sum in an outer loop. As it iterates through each value <code>v</code>, it finds all pairs whose sum is equal to <code>target - v</code> using one of these approaches:</p>\n<ol>\n<li><a href=\"https://leetcode.com/articles/two-sum/\">Two Sum</a> uses a hash set to check for a matching value.</li>\n<li><a href=\"https://leetcode.com/articles/two-sum-ii-input-array-is-sorted/\">Two Sum II</a> uses the two pointers pattern in a sorted array.</li>\n</ol>\n<p>Following a similar logic, we can implement 4Sum by wrapping 3Sum in another loop. But wait - there is a catch. If an interviewer asks you to solve 4Sum, they can follow-up with 5Sum, 6Sum, and so on. What they are really expecting at this point is a kSum solution. Therefore, we will focus on a generalized implementation here.</p>\n<hr/>\n<h3><a href=\"#approach-1-two-pointers\"><svg><path></path></svg></a>Approach 1: Two Pointers</h3>\n<p><strong>Intuition</strong></p>\n<p>The two pointers pattern requires the array to be sorted, so we do that first. Also, it's easier to deal with duplicates if the array is sorted: repeated values are next to each other and easy to skip.</p>\n<p>For 3Sum, we enumerate each value in a single loop, and use the two pointers pattern for the rest of the array. For kSum, we will have <code>k - 2</code> nested loops to enumerate all combinations of <code>k - 2</code> values.</p>\n<p></p>\n<p><strong>Algorithm</strong></p>\n<p>We can implement <code>k - 2</code> loops using a recursion. We will pass the starting point and <code>k</code> as the parameters. When <code>k == 2</code>, we will call <code>twoSum</code>, terminating the recursion.</p>\n<ol>\n<li>\n<p>For the main function:</p>\n<ul>\n<li>Sort the input array <code>nums</code>.</li>\n<li>Call <code>kSum</code> with <code>start = 0</code>, <code>k = 4</code>, and <code>target</code>, and return the result.</li>\n</ul>\n</li>\n<li>\n<p>For <code>kSum</code> function:</p>\n<ul>\n<li>At the start of the <code>kSum</code> function, we will check three conditions:\n<ol>\n<li>Have we run out of numbers to choose from?</li>\n<li>Is the smallest number remaining greater than <code>target / k</code>? <br/>If so, then any <code>k</code> numbers we choose will be too large.</li>\n<li>Is the largest number remaining smaller than <code>target / k</code>? <br/>If so, then any <code>k</code> numbers we choose will be too small.</li>\n</ol>\n<ul>\n<li>If any of these conditions is true, there is no need to continue as no combination of the remaining elements can sum to <code>target</code>.</li>\n</ul>\n</li>\n<li>If <code>k</code> equals <code>2</code>, call <code>twoSum</code> and return the result.</li>\n<li>Iterate <code>i</code> through the array from <code>start</code>:\n<ul>\n<li>If the current value is the same as the one before, skip it.</li>\n<li>Recursively call <code>kSum</code> with <code>start = i + 1</code>, <code>k = k - 1</code>, and <code>target - nums[i]</code>.</li>\n<li>For each returned <code>subset</code> of values:\n<ul>\n<li>Include the current value <code>nums[i]</code> into <code>subset</code>.</li>\n<li>Add <code>subset</code> to the result <code>res</code>.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Return the result <code>res</code>.</li>\n</ul>\n</li>\n<li>\n<p>For <code>twoSum</code> function:</p>\n<ul>\n<li>Set the low pointer <code>lo</code> to <code>start</code>, and high pointer <code>hi</code> to the last index.</li>\n<li>While low pointer is smaller than high:\n<ul>\n<li>If the sum of <code>nums[lo]</code> and <code>nums[hi]</code> is less than <code>target</code>, increment <code>lo</code>.\n<ul>\n<li>Also increment <code>lo</code> if the value is the same as for <code>lo - 1</code>.</li>\n</ul>\n</li>\n<li>If the sum is greater than <code>target</code>, decrement <code>hi</code>.\n<ul>\n<li>Also decrement <code>hi</code> if the value is the same as for <code>hi + 1</code>.</li>\n</ul>\n</li>\n<li>Otherwise, we found a pair:\n<ul>\n<li>Add it to the result <code>res</code>.</li>\n<li>Decrement <code>hi</code> and increment <code>lo</code>.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Return the result <code>res</code>.</li>\n</ul>\n</li>\n</ol>\n<p><strong>Implementation</strong></p>\n<pre><code>class Solution {\n    public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) {\n        Arrays.sort(nums);\n        return kSum(nums, target, 0, 4);\n    }\n\n    private List&lt;List&lt;Integer&gt;&gt; kSum(int[] nums, long target, int start, int k) {\n        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();\n\n        // If we have run out of numbers to add, return res.\n        if (start == nums.length) {\n            return res;\n        }\n\n        // There are k remaining values to add to the sum. The\n        // average of these values is at least target / k.\n        long averageValue = target / k;\n\n        // We cannot obtain a sum of target if the smallest value\n        // in nums is greater than target / k or if the largest\n        // value in nums is smaller than target / k.\n        if (nums[start] &gt; averageValue || averageValue &gt; nums[nums.length - 1]) {\n            return res;\n        }\n\n        if (k == 2) {\n            return twoSum(nums, target, start);\n        }\n\n        for (int i = start; i &lt; nums.length; i++) {\n            if (i == start || nums[i - 1] != nums[i]) {\n                for (List&lt;Integer&gt; subset : kSum(nums, target - nums[i], i + 1, k - 1)) {\n                    List&lt;Integer&gt; curr = new ArrayList&lt;&gt;();\n                    curr.add(nums[i]);\n                    curr.addAll(subset);\n                    res.add(curr);\n                }\n            }\n        }\n\n        return res;\n    }\n\n    private List&lt;List&lt;Integer&gt;&gt; twoSum(int[] nums, long target, int start) {\n        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();\n        int lo = start, hi = nums.length - 1;\n\n        while (lo &lt; hi) {\n            int currSum = nums[lo] + nums[hi];\n            if (currSum &lt; target || (lo &gt; start &amp;&amp; nums[lo] == nums[lo - 1])) {\n                lo++;\n            } else if (currSum &gt; target || (hi &lt; nums.length - 1 &amp;&amp; nums[hi] == nums[hi + 1])) {\n                hi--;\n            } else {\n                res.add(Arrays.asList(nums[lo++], nums[hi--]));\n            }\n        }\n\n        return res;\n    }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: O(nk−1), or O(n3) for 4Sum. We have k−2 loops, and <code>twoSum</code> is O(n).</p>\n<p>Note that for k&gt;2, sorting the array does not change the overall time complexity.</p>\n</li>\n<li>\n<p>Space Complexity: O(n). We need O(k) space for the recursion. k can be the same as n in the worst case for the generalized algorithm.</p>\n<p>Note that, for the purpose of complexity analysis, we ignore the memory required for the output.</p>\n</li>\n</ul>\n<hr/>\n<h3><a href=\"#approach-2-hash-set\"><svg><path></path></svg></a>Approach 2: Hash Set</h3>\n<p><strong>Intuition</strong></p>\n<p>Since elements must sum up to the exact target value, we can also use the <a href=\"https://leetcode.com/articles/two-sum/#approach-3-one-pass-hash-table\">Two Sum: One-pass Hash Table</a> approach.</p>\n<p>In <a href=\"https://leetcode.com/articles/3sum/#approach-2-hash-set\">3Sum: Hash Set</a>, we solved the problem without sorting the array. To do that, we needed to sort values within triplets, and track them in a hash set. Doing the same for k values could be impractical.</p>\n<p>So, for this approach, we will also sort the array and skip duplicates the same way as in the Two Pointers approach above. Thus, the code will only differ in the <code>twoSum</code> implementation.</p>\n<p><strong>Algorithm</strong></p>\n<p><code>twoSum</code> implementation here is almost the same as in <a href=\"https://leetcode.com/articles/two-sum/#approach-3-one-pass-hash-table\">Two Sum: One-pass Hash Table</a>. The only difference is the check to avoid duplicates. Since the array is sorted, we can just compare the found pair with the last one in the result <code>res</code>.</p>\n<p><strong>Implementation</strong></p>\n<pre><code>class Solution {\n    public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) {\n        Arrays.sort(nums);\n        return kSum(nums, target, 0, 4);\n    }\n\n    private List&lt;List&lt;Integer&gt;&gt; kSum(int[] nums, long target, int start, int k) {\n        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();\n\n        // If we have run out of numbers to add, return res.\n        if (start == nums.length) {\n            return res;\n        }\n\n        // There are k remaining values to add to the sum. The\n        // average of these values is at least target / k.\n        long averageValue = target / k;\n\n        // We cannot obtain a sum of target if the smallest value\n        // in nums is greater than target / k or if the largest\n        // value in nums is smaller than target / k.\n        if (nums[start] &gt; averageValue || averageValue &gt; nums[nums.length - 1]) {\n            return res;\n        }\n\n        if (k == 2) {\n            return twoSum(nums, target, start);\n        }\n\n        for (int i = start; i &lt; nums.length; i++) {\n            if (i == start || nums[i - 1] != nums[i]) {\n                for (List&lt;Integer&gt; subset : kSum(nums, target - nums[i], i + 1, k - 1)) {\n                    List&lt;Integer&gt; curr = new ArrayList&lt;&gt;();\n                    curr.add(nums[i]);\n                    curr.addAll(subset);\n                    res.add(curr);\n                }\n            }\n        }\n\n        return res;\n    }\n\n    private List&lt;List&lt;Integer&gt;&gt; twoSum(int[] nums, long target, int start) {\n        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();\n        Set&lt;Long&gt; seen = new HashSet&lt;&gt;();\n\n        for (int i = start; i &lt; nums.length; i++) {\n            if (res.isEmpty() || res.get(res.size() - 1).get(1) != nums[i]) {\n                if (seen.contains(target - nums[i])) {\n                    res.add(Arrays.asList((int) (target - nums[i]), nums[i]));\n                }\n            }\n            seen.add((long) nums[i]);\n        }\n\n        return res;\n    }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: O(nk−1), or O(n3) for 4Sum. We have k−2 loops iterating over n elements, and <code>twoSum</code> is O(n).</p>\n<p>Note that for k&gt;2, sorting the array does not change the overall time complexity.</p>\n</li>\n<li>\n<p>Space Complexity: O(n) for the hash set. The space needed for the recursion will not exceed O(n).</p>\n</li>\n</ul>"}