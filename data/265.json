{"id":"265","title":"Paint House II","difficulty":"Hard","content":"<p>There are a row of <code>n</code> houses, each house can be painted with one of the <code>k</code> colors. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color.</p>\n\n<p>The cost of painting each house with a certain color is represented by an <code>n x k</code> cost matrix costs.</p>\n\n<ul>\n\t<li>For example, <code>costs[0][0]</code> is the cost of painting house <code>0</code> with color <code>0</code>; <code>costs[1][2]</code> is the cost of painting house <code>1</code> with color <code>2</code>, and so on...</li>\n</ul>\n\n<p>Return <em>the minimum cost to paint all houses</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> costs = [[1,5,3],[2,9,4]]\n<strong>Output:</strong> 5\n<strong>Explanation:</strong>\nPaint house 0 into color 0, paint house 1 into color 2. Minimum cost: 1 + 4 = 5; \nOr paint house 0 into color 2, paint house 1 into color 0. Minimum cost: 3 + 2 = 5.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> costs = [[1,3],[2,4]]\n<strong>Output:</strong> 5\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>costs.length == n</code></li>\n\t<li><code>costs[i].length == k</code></li>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li><code>2 &lt;= k &lt;= 20</code></li>\n\t<li><code>1 &lt;= costs[i][j] &lt;= 20</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Could you solve it in <code>O(nk)</code> runtime?</p>\n","tags":["Array","Dynamic Programming"],"java_snippet":"class Solution {\n    public int minCostII(int[][] costs) {\n        \n    }\n}","solution":"<h2><a href=\"#solution\"><svg><path></path></svg></a>Solution</h2>\n<p><strong>Paint House II</strong> is a follow up question of <a href=\"https://leetcode.com/problems/paint-house/\">Paint House</a>. In the original Paint House problem, <code>k</code> was always <code>3</code>. In this problem, <code>k</code> is no longer fixed and instead can be any non-negative integer.</p>\n<p>If you haven't yet attempted the original <a href=\"https://leetcode.com/problems/paint-house/\">Paint House</a> question and are having trouble with this question, go attempt Paint House first and come back. There is also an in-depth <a href=\"https://leetcode.com/articles/paint-house/\">Paint House Solution Article</a>. This solution article will assume you are already comfortable with the memoization and dynamic programming solutions for Paint House.</p>\n<hr/>\n<h3><a href=\"#approach-1-memoization\"><svg><path></path></svg></a>Approach 1: Memoization</h3>\n<p><strong>Intuition</strong></p>\n<p>Remembering that we already know how to solve this problem using memoization when <code>k = 3</code> (check the <a href=\"https://leetcode.com/articles/paint-house/\">Paint House Solution Article</a>) if you can't remember how), let's think through some of the other possible values of <code>k</code>.</p>\n<p>For this explanation, we'll call a way of painting the houses <em>valid</em> if, and only if, there are no adjacent houses painted the same color. We'll call an input <em>valid</em> if it is possible to paint the houses in a <em>valid</em> way. <strong>The test cases here on Leetcode are all valid inputs</strong>. In an interview however, you'd need to ensure that it is safe to assume that the input is always valid though.</p>\n<p>If <code>k = 0</code>, then this means we have no colors. If there are no colors, it's probably reasonable to assume there are no houses either, i.e. <code>n = 0</code>. In other words, the input is <code>[]</code>. <strong>For this question here on Leetcode, this is a safe assumption</strong>. In an interview though it could be a good idea to ask the interviewer whether or not the input is <em>guaranteed</em> to be valid. For example, could you get a test case such as <code>[[],[],[],[]]</code>? This would be <code>k = 0</code> and <code>n = 4</code>. Of course, this case doesn't make much sense, because we are supposed to be painting houses, but can't with no paint. Either you'd be told it could never happen, or that you needed to do something special for it, such as returning <code>-1</code>.</p>\n<p>If <code>k = 1</code> (all houses have to be the same color), then it's probably safe to assume that <code>n = 1</code>. Otherwise, the problem would be impossible to solve without breaking the adjacent color rule. Again, this is a safe assumption here, but do consider asking the interviewer whether or not you could get an invalid input that had <code>k = 1</code> and <code>n &gt; 1</code>. So, assuming that <code>k = 1</code> and <code>n = 1</code>, the total cost will be the cost of painting that one house the only color available.</p>\n<p>If <code>k = 2</code> (there are two colors), then we know the problem is always solvable, because we can simply paint the houses alternating colors. For example, when <code>n = 5</code> and <code>k = 2</code>, here are the only 2 valid ways of painting the houses. Anything else would be invalid.</p>\n<p></p>\n<p>The answer will be the one that leads to the lowest cost. It'd be easy to check both.</p>\n<p>When <code>k = 3</code>, the problem is equivalent to <a href=\"https://leetcode.com/problems/paint-house/\">Paint House</a>. In the Solution Article for that question, we worked through an example where <code>n = 4</code>.</p>\n<svg><path></path></svg>\n<p>A good way to visualize all of the valid painting permutations is to use a tree. Each root-to-leaf path represents one valid way of painting the houses.</p>\n<p></p>\n<p>The cheapest cost of painting the houses is, therefore, the root-to-leaf path with the lowest total sum of its nodes. This animation shows the algorithm we used to solve this problem for Paint House.</p>\n<p></p>\n<p>Luckily, we didn't actually need to create the tree itself—there is a simpler way using recursion.</p>\n<p>Say we have a <code>paint</code> function that takes 2 parameters: a house number and a color to paint that house. The output is the <em><strong>total</strong></em> <strong>cost of painting that house and all the ones after it</strong>. For example <code>paint(1, red)</code> would be the cost of painting house <code>1</code> red, along with the cost of painting the houses after it (taking into account restrictions caused by painting house <code>1</code> red).</p>\n<p>Therefore the cheapest way of painting all the houses can be expressed as follows, where <code>0</code> is the first house.</p>\n<p><code>min(paint(0, \"red\"), paint(0, \"green\"), paint(0, \"blue\"))</code></p>\n<p>The <code>paint</code> function has a recursive implementation. <code>costs</code> refers to the <em>input</em> table.</p>\n<svg><path></path></svg>\n<p>The <strong>base case</strong> is where <code>i</code> refers to the <em>last house</em>. Painting the last house a particular color can be obtained from the <code>costs</code> table.</p>\n<p>The <strong>recursive case</strong> is where we also need to consider the houses after <code>i</code>. It is obtained by looking up the cost of painting house <code>i</code> the given color (in the <code>costs</code> table) and then by determining the cost of painting the houses after it. The cost of painting the houses after requires making recursive paint calls to determine the cost of painting house <code>i + 1</code> each of the 2 other colors and then finding the minimum of those 2 values.</p>\n<p>This algorithm is inefficient though. There is a lot of repetition in the tree, meaning we're doing the same calculations over and over again. For example, the total cost of painting the <em>second</em> house blue will be the same regardless of whether the first house was red or green. For example, both these branches of the tree are identical.</p>\n<p></p>\n<p>This should also be apparent from the definition of the <code>paint</code> function. The parameters are simply a house number and a color. It doesn't require any information about <em>where</em> exactly in the tree it is.</p>\n<p>To solve this problem, we add <strong>memoization</strong> to the <code>paint</code> function. Recall that memoization is where before returning an answer, the recursive function writes the answer into a dictionary with the input parameters as the key and the answer as the value. Then before doing a calculation, it checks whether or not that particular calculation has already been done. For the example above, the function would only calculate the cost of painting the second house blue <em>once</em>, and then the second time it would look it up in the dictionary.</p>\n<p>Here is a visualization that shows the calculations that need to be done when using memoization. The brighter circles show where the function body runs, and the duller circles show where a lookup was done and the function immediately returned. These are the only times the function is called.</p>\n<p></p>\n<p><strong>If this explanation wasn't thorough enough for you</strong>, then please check out the full <a href=\"https://leetcode.com/articles/paint-house/\">Paint House Solution Article</a>. In that article I go into a lot more depth about memoization and how this algorithm was derived.</p>\n<p>The <code>k &gt; 3</code> case is really no different to this. The only difference is that instead of only considering 2 possible colors for the <em>next</em> house, we're considering <code>k - 1</code> colors (all colors except for the color of the current house).</p>\n<p><strong>Algorithm</strong></p>\n<p>Unlike the pseudocode above, we don't need to worry about the names of the colors. Instead, they are represented by numbers between <code>0</code> and <code>k - 1</code>. Additionally, we're also using memoization (<code>lru_cache</code> in Python, and a dictionary in Java).</p>\n<p><strong>Implementation</strong></p>\n<pre><code>class Solution {\n​\n    private int n;\n    private int k;\n    private int[][] costs;\n    private Map&lt;String, Integer&gt; memo;\n​\n    public int minCostII(int[][] costs) {\n        if (costs.length == 0) return 0;\n        this.k = costs[0].length;\n        this.n = costs.length;\n        this.costs = costs;\n        this.memo = new HashMap&lt;&gt;();\n        int minCost = Integer.MAX_VALUE;\n        for (int color = 0; color &lt; k; color++) {\n            minCost = Math.min(minCost, memoSolve(0, color));\n        }\n        return minCost;\n    }\n​\n    private int memoSolve(int houseNumber, int color) {\n​\n        // Base case: There are no more houses after this one.\n        if (houseNumber == n - 1) {\n            return costs[houseNumber][color];\n        }\n​\n        // Memoization lookup case: Have we already solved this subproblem?\n        if (memo.containsKey(getKey(houseNumber, color))) {\n            return memo.get(getKey(houseNumber, color));\n        }\n​\n        // Recursive case: Determine the minimum cost for the remainder.\n        int minRemainingCost = Integer.MAX_VALUE;\n        for (int nextColor = 0; nextColor &lt; k; nextColor++) {\n            if (color == nextColor) continue;\n            int currentRemainingCost = memoSolve(houseNumber + 1, nextColor);\n            minRemainingCost = Math.min(currentRemainingCost, minRemainingCost);\n        }\n        int totalCost = costs[houseNumber][color] + minRemainingCost;\n        memo.put(getKey(houseNumber, color), totalCost);\n        return totalCost;\n    }\n​\n    // Convert a house number and color into a simple string key for the memo.\n    private String getKey(int n, int color) {\n        return String.valueOf(n) + \" \" + String.valueOf(color);\n    }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : O(n⋅k2).</p>\n<p>Determining the total time complexity of a recursive memoization algorithm requires looking at how many calls are made to the <code>paint</code> function, and how much each call costs (remember that the memoization lookups are O(1)). The function is called once for each possible pair of house number and color. This gives n⋅k calls. Then, each call has a loop that loops over each of the k colors. Therefore, we have n⋅k⋅k=n⋅k2 which is O(n⋅k2).</p>\n<p>The part outside of the recursive function is O(k) and therefore does not impact the overall complexity.</p>\n</li>\n<li>\n<p>Space complexity : O(n⋅k).</p>\n<p>There are 2 different places memory is being used that we need to consider.</p>\n<p>Firstly, the memoization is storing the answers for each pair of house number and color. There are n⋅k of these, and so O(n⋅k) memory used.</p>\n<p>Secondly, we need to consider the memory used on the run-time stack. In the worst case, there's a stack frame for each house number on the stack. This is a total of O(n).</p>\n<p>The O(n) is insignficant to the O(n⋅k), so we're left with a total of O(n⋅k).</p>\n</li>\n</ul>\n<br/>\n<hr/>\n<h3><a href=\"#approach-2-dynamic-programming\"><svg><path></path></svg></a>Approach 2: Dynamic Programming</h3>\n<p><strong>Intuition</strong></p>\n<p>Let's look at a bigger example now, and view the problem in a different way to how we did before. For this example, <code>k = 6</code> and <code>n = 5</code>.</p>\n<p><code>[[10, 6, 16, 25, 7, 28], [7, 16, 18, 30, 16, 25], [8, 26, 6, 22, 26, 19], [10, 23, 14, 17, 23, 9], [12, 14, 27, 7, 8, 9]]</code></p>\n<p>And here is a diagram of the input grid.</p>\n<p></p>\n<p>Each row represents the different colors a house could be. <em>Remember that the colors are represented by numbers</em>. The actual colors are only to make the table easier to read.</p>\n<p>The problem we're trying to solve is equivalent to the following: <strong>pick exactly one number from each row</strong> such that the <strong>sum of those numbers is minimized</strong>. Because 2 adjacent houses cannot be the same color, <strong>adjacent rows must be picked from different columns</strong>. This is a straightforward variant of one of those \"classic\" minimum-path-in-a-grid dynamic programming problems.</p>\n<p>The way that we solve it is to iterate over the cells and determine what the cheapest way of getting to that cell is. We'll work from top to bottom.</p>\n<p>To begin with, we say the first row (house 0) is already completed. We don't need to make any changes to it.</p>\n<p>Then, for each cell in the second row, we work out the cheapest way of getting to it from the first row is. For example, to get to <code>[1][red]</code> we have to go through any of the non-red cells from the row above. We want to go through the minimum.</p>\n<p></p>\n<p>We show our decision by updating <code>[1][red]</code>  to <code>7 + 6 = 13</code>.</p>\n<p>We can repeat this for the rest of the second row, and then work down each of the remaining rows.</p>\n<p>Here's an animation of the algorithm being carried out.</p>\n<p>When we're finished, the final answer is the <strong>minimum value in the last row</strong>.</p>\n<p><strong>Algorithm</strong></p>\n<p>We'll do this in the same way we did in the animation above—an in-place algorithm that over-writes the input grid.</p>\n<p><strong>Implementation</strong></p>\n<pre><code>class Solution {\n    public int minCostII(int[][] costs) {\n​\n        if (costs.length == 0) return 0;\n        int k = costs[0].length;\n        int n = costs.length;\n​\n        for (int house = 1; house &lt; n; house++) {\n            for (int color = 0; color &lt; k; color++) {\n                int min = Integer.MAX_VALUE;\n                for (int previousColor = 0; previousColor &lt; k; previousColor++) {\n                    if (color == previousColor) continue;\n                    min = Math.min(min, costs[house - 1][previousColor]);\n                }\n                costs[house][color] += min;\n            }\n        }\n​\n        // Find the minimum in the last row.\n        int min = Integer.MAX_VALUE;\n        for (int c : costs[n - 1]) {\n            min = Math.min(min, c);\n        }\n        return min;\n    }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : O(n⋅k2).</p>\n<p>We iterate over each of the n⋅k cells. For each of the cells, we're finding the minimum of the k values in the row above, excluding the one that is in the same column. This operation is O(k). Multiplying this out, we get O(n⋅k2).</p>\n</li>\n<li>\n<p>Space complexity : O(1) if done in-place, O(n⋅k) if input is copied.</p>\n<p>We're not creating any new data structures in the code above, and so it has a space complexity of O(1). This is, however, overwriting the given input, which might not be ideal in some situations.</p>\n<p>If we don't want to overwrite the input, we could instead create a copy of it first and then do the calculations in the copy. This will require an additional O(n⋅k) space.</p>\n</li>\n</ul>\n<br/>\n<hr/>\n<h3><a href=\"#approach-3-dynamic-programming-with-ok-additional-space\"><svg><path></path></svg></a>Approach 3: Dynamic Programming with O(k) additional Space.</h3>\n<p><strong>Intuition</strong></p>\n<p>Implementing the algorithm in-place meant that we only needed O(1) additional space. This, however required modifying the input, which could be a problem in some situations.</p>\n<p>The easiest solution is to make a copy of the input array and then do the calculations in that instead. This would require O(n⋅k) additional space.</p>\n<p>There is a way that uses less space though. We're only ever working with 2 rows at a time: the current row, and the row before it. The rows before that are never looked at again, and the rows after are still the same as the input array. Therefore, we can take advantage of this to only use O(k) space.</p>\n<p><strong>Algorithm</strong></p>\n<p>Instead of writing the updated costs into the input array, the algorithm writes them into a k-length array. The k-length array from the previous row is held onto in-order to do these calculations.</p>\n<p><strong>Implementation</strong></p>\n<pre><code>class Solution {\n​\n    public int minCostII(int[][] costs) {\n​\n        if (costs.length == 0) return 0;\n        int k = costs[0].length;\n        int n = costs.length;\n​\n        int[] previousRow = costs[0];\n​\n        for (int house = 1; house &lt; n; house++) {\n            int[] currentRow = new int[k];\n            for (int color = 0; color &lt; k; color++) {\n                int min = Integer.MAX_VALUE;\n                for (int previousColor = 0; previousColor &lt; k; previousColor++) {\n                    if (color == previousColor) continue;\n                    min = Math.min(min, previousRow[previousColor]);\n                }\n                currentRow[color] += costs[house][color] += min;\n            }\n            previousRow = currentRow;\n        }\n​\n        // Find the minimum in the last row.\n        int min = Integer.MAX_VALUE;\n        for (int c : previousRow) {\n            min = Math.min(min, c);\n        }\n        return min;\n    }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : O(n⋅k2).</p>\n<p>Same as above.</p>\n</li>\n<li>\n<p>Space complexity : O(k).</p>\n<p>The previous row and the current row are represented as k-length arrays.</p>\n<p>This approach does <em>not</em> modify the input grid.</p>\n</li>\n</ul>\n<br/>\n<hr/>\n<h3><a href=\"#approach-4-dynamic-programming-with-optimized-time\"><svg><path></path></svg></a>Approach 4: Dynamic programming with Optimized Time</h3>\n<p><strong>Intuition</strong></p>\n<p>Despite Paint House II being listed as a hard question, and the problem statement listing O(n⋅k) time as a \"follow up\", you'd possibly be expected to come up with this solution at top companies as it's still a fairly basic dynamic programming algorithm. You should, therefore, ensure you're comfortable with this approach and could identify and apply similar observations in other dynamic programming problems. At the very least, it'll make you look awesome!</p>\n<p>So far, all of our approaches have had a O(n⋅k2) time complexity. This is because calculating the new value for each of the O(n⋅k) cells required looking at each of the k cells in the row immediately below.</p>\n<p>However, we don't need to look at the entire previous row for every cell. Let's look again at the large example from above. When we're calculating the values for the second row, we're adding the minimum from the first row onto them. The only cell we can't do this for is the one that was <em>directly below the minimum</em>, as this would break the adjacency rule. For this one, it makes sense to add the second minimum.</p>\n<p></p>\n<p>Here's an animation of the entire algorithm.</p>\n<p></p>\n<p><strong>Algorithm</strong></p>\n<p>The simplest way of implementing this algorithm is to base it on the animation above. This requires overwriting the input.</p>\n<p><strong>Implementation</strong></p>\n<pre><code>class Solution {\n​\n    public int minCostII(int[][] costs) {\n​\n        if (costs.length == 0) return 0;\n        int k = costs[0].length;\n        int n = costs.length;\n​\n        for (int house = 1; house &lt; n; house++) {\n​\n            // Find the minimum and second minimum color in the PREVIOUS row.\n            int minColor = -1; int secondMinColor = -1;\n            for (int color = 0; color &lt; k; color++) {\n                int cost = costs[house - 1][color];\n                if (minColor == -1 || cost &lt; costs[house - 1][minColor]) {\n                    secondMinColor = minColor;\n                    minColor = color;\n                } else if (secondMinColor == -1 || cost &lt; costs[house - 1][secondMinColor]) {\n                    secondMinColor = color;\n                }\n            }\n​\n            // And now calculate the new costs for the current row.\n            for (int color = 0; color &lt; k; color++) {\n                if (color == minColor) {\n                    costs[house][color] += costs[house - 1][secondMinColor];\n                } else {\n                    costs[house][color] += costs[house - 1][minColor];\n                }\n            }\n        }\n​\n        // Find the minimum in the last row.\n        int min = Integer.MAX_VALUE;\n        for (int c : costs[n - 1]) {\n            min = Math.min(min, c);\n        }\n        return min;\n    }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : O(n⋅k).</p>\n<p>The first loop that finds the minimums of the first row is O(k) because it looks at each of the k values in the first row exactly once. The second loop is O(n⋅k) because the outer loop loops n times, and the inner loop loops k times. O(n⋅k)+O(k)=O(n⋅k). We know it is <em>impossible</em> to ever do better here, because we cannot solve the problem without at least looking at each of the n⋅k cells once.</p>\n</li>\n<li>\n<p>Space complexity : O(1).</p>\n<p>Like approach 2, this approach also modifies the input instead of allocating its own space.</p>\n</li>\n</ul>\n<br/>\n<hr/>\n<h3><a href=\"#approach-5-dynamic-programming-with-optimized-time-and-space\"><svg><path></path></svg></a>Approach 5: Dynamic programming with Optimized Time and Space</h3>\n<p><strong>Intuition</strong></p>\n<p>There is another way we can still solve the problem in O(1) space and O(n⋅k) time complexity, <em>and</em> preserving the input.</p>\n<p>The only thing the algorithm in the previous approach is really doing is going through the rows, and finding the 2 minimums of each row. It does this by calculating all the new costs for the row, writing them into the input, and then finding the minimums. This overwriting isn't necessary though—we can simply keep track of the 2 smallest values we've seen so far, as we go, in the current row. We also need to remember the 2 from the previous row.</p>\n<p><strong>Algorithm</strong></p>\n<p>The approach is a hybrid of approach 3 and 4. Like approach 4, it finds the minimums once instead of repeatedly. Like approach 3, it keeps track of information only from the current and previous rows. Unlike approach 3 though, the only information kept is the minimums.</p>\n<p><strong>Implementation</strong></p>\n<pre><code>class Solution {\n​\n    public int minCostII(int[][] costs) {\n​\n        if (costs.length == 0) return 0;\n        int k = costs[0].length;\n        int n = costs.length;\n​\n​\n        /* Firstly, we need to determine the 2 lowest costs of\n         * the first row. We also need to remember the color of\n         * the lowest. */\n        int prevMin = -1; int prevSecondMin = -1; int prevMinColor = -1;\n        for (int color = 0; color &lt; k; color++) {\n            int cost = costs[0][color];\n            if (prevMin == -1 || cost &lt; prevMin) {\n                prevSecondMin = prevMin;\n                prevMinColor = color;\n                prevMin = cost;\n            } else if (prevSecondMin == -1 || cost &lt; prevSecondMin) {\n                prevSecondMin = cost;\n            }\n        }\n​\n        // And now, we need to work our way down, keeping track of the minimums.\n        for (int house = 1; house &lt; n; house++) {\n            int min = -1; int secondMin = -1; int minColor = -1;\n            for (int color = 0; color &lt; k; color++) {\n                // Determine the cost for this cell (without writing it in).\n                int cost = costs[house][color];\n                if (color == prevMinColor) {\n                    cost += prevSecondMin;\n                } else {\n                    cost += prevMin;\n                }\n                // Determine whether or not this current cost is also a minimum.\n                if (min == -1 || cost &lt; min) {\n                    secondMin = min;\n                    minColor = color;\n                    min = cost;\n                } else if (secondMin == -1 || cost &lt; secondMin) {\n                    secondMin = cost;\n                }\n            }\n            // Transfer current mins to be previous mins.\n            prevMin = min;\n            prevSecondMin = secondMin;\n            prevMinColor = minColor;\n        }\n​\n        return prevMin;\n    }\n}</code></pre>\n<p>There are many ways to compact the code a bit more, particularly in the case of the Python. I haven't done this here as it could be problematic for those less familiar with the 2 languages I have provided solutions in, however feel free to post your own solutions in the comments. I'm excited to see the elegance you can come up with!</p>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : O(n⋅k).</p>\n<p>Same as the previous approach.</p>\n</li>\n<li>\n<p>Space complexity : O(1).</p>\n<p>The only additional working memory we're using is a constant number of single-value variables to keep track of the 2 minimums in the current and previous row, and to calculate the cost of the current cell. Because the memory usage is constant, we say it is O(1). Unlike the previous approach one though, this one does not overwrite the input.</p>\n</li>\n</ul>\n<br/>"}