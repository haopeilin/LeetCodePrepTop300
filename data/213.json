{"id":"213","title":"House Robber II","difficulty":"Medium","content":"<p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are <strong>arranged in a circle.</strong> That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and&nbsp;<b>it will automatically contact the police if two adjacent houses were broken into on the same night</b>.</p>\n\n<p>Given an integer array <code>nums</code> representing the amount of money of each house, return <em>the maximum amount of money you can rob tonight <strong>without alerting the police</strong></em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,3,2]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,1]\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3]\n<strong>Output:</strong> 3\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>\n</ul>\n","tags":["Array","Dynamic Programming"],"java_snippet":"class Solution {\n    public int rob(int[] nums) {\n        \n    }\n}","solution":"<div class=\"flex flex-col w-full\" style=\"position: relative;\"><div class=\"mYe_l WRmCx\"><h2 class=\"group/heading relative\" id=\"solution\" level=\"2\"><a aria-hidden=\"true\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" href=\"#solution\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" data-icon=\"link\" data-prefix=\"fas\" focusable=\"false\" role=\"img\" spacing=\"square\" viewbox=\"0 0 640 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\" fill=\"currentColor\"></path></svg></div></a>Solution</h2>\n<p>This problem is a minor extension to the original <a href=\"https://leetcode.com/problems/house-robber/\" target=\"_blank\">House Robber Problem</a>. The only difference is that the first and the last houses are adjacent to each other and therefore, if the thief has robbed the first house, they cannot steal the last house and vice versa. As Hint 1 in the question suggests, \"the problem becomes to rob either <code>House[1]-House[n-1]</code> or <code>House[2]-House[n]</code>, depending on which choice offers more money. Now the problem has degenerated to the House Robber\".</p>\n<hr/>\n<h3 class=\"group/heading relative\" id=\"approach-1-dynamic-programming\" level=\"3\"><a aria-hidden=\"true\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" href=\"#approach-1-dynamic-programming\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" data-icon=\"link\" data-prefix=\"fas\" focusable=\"false\" role=\"img\" spacing=\"square\" viewbox=\"0 0 640 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\" fill=\"currentColor\"></path></svg></div></a>Approach 1: Dynamic Programming</h3>\n<p><strong>Intuition</strong></p>\n<p>Assume we have <code>nums</code> of <code>[7,4,1,9,3,8,6,5]</code> as shown in the figure.<br/>\nSince the start house and last house are adjacent to each other, if the thief decides to rob the start house <code>7</code>, they cannot rob the last house <code>5</code>. Similarly, if they select last house <code>5</code>, they have to start from a house with value <code>4</code>. Therefore, the final solution that we are looking for is to take the maximum value the thief can rob between houses of list <code>[7,4,1,9,3,8,6]</code> and <code>[4,1,9,3,8,6,5]</code>. For each of the lists, all we need to do is to figure the maximum value the thief can get using the approach in the original <a href=\"https://leetcode.com/problems/house-robber/\" target=\"_blank\">House Robber Problem</a>.</p>\n<p></p>\n<p><strong>Solving Original House Robber Problem with Dynamic Programming</strong></p>\n<p>Trivial cases:</p>\n<ul>\n<li>If there is one house, the answer is the value of that house.</li>\n<li>If there are two houses, the answer is <code>max(house1, house2)</code>.</li>\n<li>If there are three houses, you can either pick the middle house or the sum of the first and the last house. Therefore, it boils down to <code>max(house3 + house1, house2)</code>.</li>\n</ul>\n<p>To make the example more illustrative, imagine two thieves (<code>t1</code> and <code>t2</code>) coordinating a grand robbery. They are equipped with walkie-talkies to communicate the values of houses to each other.</p>\n<ul>\n<li>\n<p>Before entering any of the houses, both <code>t1</code> and <code>t2</code> have values of zero.</p>\n</li>\n<li>\n<p><code>t1</code>, enters the first house and record the value of the house. If that is the only house to rob, they can rob this house and be done with it.</p>\n</li>\n<li>\n<p>If there is more than one house, <code>t1</code> will leave a note of maximum value reaped until this point (which is just the value of the first house) and move to the next house while <code>t2</code> moves into the house <code>t1</code> was in. Now, <code>t1</code> and <code>t2</code> are going to communicate over the walkie-talkie to ask who has the most value. At this point, <code>t2</code> will read the note left by <code>t1</code> when the values are compared. If they have only two houses to rob, they would rob the house with the most value and be done with it.</p>\n</li>\n<li>\n<p>If there are three houses, <code>t1</code> will leave a note of the maximum value reaped until this point and move to the next house. Then <code>t1</code> will compare the value of the sum of the current house and the house which <code>t2</code> is in with the value of the house <code>t1</code> was in. The maximum value between those two will be chosen and <code>t2</code> will move into the house next to it.</p>\n</li>\n<li>\n<p>If there are four houses, <code>t1</code> will leave a note of the maximum value reaped until this point and move to the next house. Then <code>t1</code> will compare the value of the sum of the current house and the house which <code>t2</code> is in with the value of the house <code>t1</code> was in. The maximum value between those two will be chosen and <code>t2</code> will move into the house next to it.</p>\n</li>\n<li>\n<p>This procedure is done over and over again as long as there are houses in <code>nums</code>. If <code>t1</code> has reached to the end of <code>nums</code>, <code>t1</code> should have reaped the maximum amount obtainable from houses in <code>nums</code>.</p>\n</li>\n</ul>\n<p></p>\n<p><strong>Implementation</strong></p>\n<pre><code>class Solution {\npublic:\n    int rob(vector&lt;int&gt;&amp; nums) {\n        if (nums.size() == 0) return 0;\n​\n        if (nums.size() == 1) return nums[0];\n​\n        int max1 = rob_simple(nums, 0, nums.size() - 2);\n        int max2 = rob_simple(nums, 1, nums.size() - 1);\n​\n        return max(max1, max2);\n    }\n​\nprivate:\n    int rob_simple(vector&lt;int&gt;&amp; nums, int start, int end) {\n        int t1 = 0, t2 = 0;\n        for (int i = start; i &lt;= end; ++i) {\n            int temp = t1;\n            t1 = max(nums[i] + t2, t1);\n            t2 = temp;\n        }\n​\n        return t1;\n    }\n};</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span></span> where <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span></span></span></span></span> is the size of <code>nums</code>. We are accumulating results as we are scanning <code>nums</code>.</p>\n</li>\n<li>\n<p>Space complexity : <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></span> since we are not consuming additional space other than variables for two previous results and a temporary variable to hold one of the previous results.</p>\n</li>\n</ul></div><span style=\"font-size: 0px; line-height: 0;\"> </span></div>"}