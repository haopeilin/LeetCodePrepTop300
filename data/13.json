{"id":"13","title":"Roman to Integer","difficulty":"Easy","content":"<p>Roman numerals are represented by seven different symbols:&nbsp;<code>I</code>, <code>V</code>, <code>X</code>, <code>L</code>, <code>C</code>, <code>D</code> and <code>M</code>.</p>\n\n<pre>\n<strong>Symbol</strong>       <strong>Value</strong>\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000</pre>\n\n<p>For example,&nbsp;<code>2</code> is written as <code>II</code>&nbsp;in Roman numeral, just two ones added together. <code>12</code> is written as&nbsp;<code>XII</code>, which is simply <code>X + II</code>. The number <code>27</code> is written as <code>XXVII</code>, which is <code>XX + V + II</code>.</p>\n\n<p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not <code>IIII</code>. Instead, the number four is written as <code>IV</code>. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as <code>IX</code>. There are six instances where subtraction is used:</p>\n\n<ul>\n\t<li><code>I</code> can be placed before <code>V</code> (5) and <code>X</code> (10) to make 4 and 9.&nbsp;</li>\n\t<li><code>X</code> can be placed before <code>L</code> (50) and <code>C</code> (100) to make 40 and 90.&nbsp;</li>\n\t<li><code>C</code> can be placed before <code>D</code> (500) and <code>M</code> (1000) to make 400 and 900.</li>\n</ul>\n\n<p>Given a roman numeral, convert it to an integer.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;III&quot;\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> III = 3.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;LVIII&quot;\n<strong>Output:</strong> 58\n<strong>Explanation:</strong> L = 50, V= 5, III = 3.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;MCMXCIV&quot;\n<strong>Output:</strong> 1994\n<strong>Explanation:</strong> M = 1000, CM = 900, XC = 90 and IV = 4.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 15</code></li>\n\t<li><code>s</code> contains only&nbsp;the characters <code>(&#39;I&#39;, &#39;V&#39;, &#39;X&#39;, &#39;L&#39;, &#39;C&#39;, &#39;D&#39;, &#39;M&#39;)</code>.</li>\n\t<li>It is <strong>guaranteed</strong>&nbsp;that <code>s</code> is a valid roman numeral in the range <code>[1, 3999]</code>.</li>\n</ul>\n","tags":["Hash Table","Math","String"],"java_snippet":"class Solution {\n    public int romanToInt(String s) {\n        \n    }\n}","solution":"<h2><a href=\"#solution-article\"><svg><path></path></svg></a>Solution Article</h2>\n<hr/>\n<h3><a href=\"#overview\"><svg><path></path></svg></a>Overview</h3>\n<p>In a lot of countries, Roman Numerals are taught in elementary school-level math. This has made them a somewhat popular \"easy\" interview question. Unfortunately though, this ignores the fact that <em>not everybody learned them in school</em>, and therefore a big advantage has been given to those who did. I suspect it's also difficult for a lot of us who <em>have</em> learned them previously to fully appreciate how much easier prior experience makes this question. While this is very unfair, and possibly very frustrating, keep in mind that the best thing you can do is work through this question and the related question <a href=\"https://leetcode.com/problems/integer-to-roman/\">Integer to Roman</a> so that you don't get caught out by it in a real interview.</p>\n<p><strong>Can we assume the input is valid?</strong></p>\n<p>Yes. Here on Leetcode, you can make that assumption because you <em>haven't</em> been told what to do if it <em>isn't</em>.</p>\n<p>In a real interview, this is a question you should ask the interviewer. Don't ever assume without asking in a real interview that the input has to be valid.</p>\n<p><strong>Is there only one valid representation for each number?</strong></p>\n<p>This is more relevant to the other question, <a href=\"https://leetcode.com/problems/integer-to-roman/\">Integer to Roman</a>, however we'll still briefly look at it now.</p>\n<p>Given that the representation for <code>3</code> is <code>III</code>, it could seem natural that the representation for <code>15</code> is <code>VVV</code>, because that would be <code>5 + 5 + 5</code>. However, it's actually <code>XV</code>, which is <code>10 + 5</code>. How are you even supposed to know which is correct?</p>\n<p>The trick is to use the \"biggest\" symbols you can. Because <code>X</code> is bigger than <code>V</code>, we should use an <code>X</code> first and then make up the remainder with a single <code>V</code>, giving <code>XV</code>.</p>\n<p>We'll talk more about this in the <a href=\"https://leetcode.com/problems/integer-to-roman/\">Integer to Roman</a> article. This question is a lot simpler because there's only one logical way of converting from a <em>Roman Numeral to an Integer</em>. This is also why this question is labelled as \"easy\", whereas the other is labelled as \"medium\".</p>\n<p><strong>A few more examples</strong></p>\n<p>If you're not very familiar with Roman Numerals, work through these examples and then have another go at writing your own algorithm before reading the rest of this solution article.</p>\n<p><em>What is <code>CXVII</code> as an integer?</em></p>\n<p>Recall that <code>C = 100</code>, <code>X = 10</code>, <code>V = 5</code>, and <code>I = 1</code>. Because the symbols are ordered from most significant to least, we can simply add the symbols, i.e. <code>C + X + V + I + I = 100 + 10 + 5 + 1 + 1 = 117</code>.</p>\n<p><em>What is <code>DXCI</code> as an integer?</em></p>\n<p>Recall that <code>D = 500</code>.</p>\n<p>Now, notice that this time the symbols are <em>not</em> ordered from most significant to least—the <code>X</code> and <code>C</code> are out of numeric order. Because of this, we subtract the value of <code>X</code> (<code>10</code>) from the value of <code>C</code> (<code>100</code>) to get <code>90</code>.</p>\n<p>So, going from left to right, we have <code>D + (C - X) + I = 500 + 90 + 1 = 591</code>.</p>\n<p><em>What is <code>CMXCIV</code> as an integer?</em></p>\n<p>Recall that <code>M = 1000</code>.</p>\n<p>The symbols barely look sorted at all here—from left-to-right we have <code>100, 1000, 10, 100, 1, 5</code>. Do not panic though, we just need to look for each occurrence of a smaller symbols <em>preceding</em> a bigger symbol. The first, third, and fifth symbols are all smaller than their next symbol. Therefore they are all going to be subtracted from their next.</p>\n<ul>\n<li>The first two symbols are <code>CM</code>. This is <code>M - C = 1000 - 100 = 900</code></li>\n<li>The second two symbols are <code>XC</code>. This is <code>C - X = 100 - 10 = 90</code>.</li>\n<li>The final two symbols are <code>IV</code>. This is <code>V - I = 5 - 1 = 4</code>.</li>\n</ul>\n<p>Like we did above, we add these together. <code>(M - C) + (C - X) + (V - I) = 900 + 90 + 4 = 994</code>.</p>\n<hr/>\n<h3><a href=\"#approach-1-left-to-right-pass\"><svg><path></path></svg></a>Approach 1: Left-to-Right Pass</h3>\n<p><strong>Intuition</strong></p>\n<p>Let's hard-code a mapping with the value of each symbol so that we can easily look them up.</p>\n<p></p>\n<p>Now, recall that each symbol adds its own value, <em>except for</em> when a <em>smaller valued symbol</em> is <em>before</em> a <em>larger valued symbol</em>. In those cases, instead of adding both symbols to the total, we need to <em>subtract the large from the small</em>, adding that instead.</p>\n<p>Therefore, the simplest algorithm is to use a pointer to scan through the string, at each step deciding whether to add the current symbol and go forward 1 place, or add the difference of the next 2 symbols and go forward 2 places. Here is this algorithm written in Java.</p>\n<svg><path></path></svg>\n<p>Here is an animation of the above algorithm.</p>\n<p></p>\n<p>Recall that the <em>input is always valid</em>. This means that we don't need to worry about being given inputs such as <code>ICD</code>.</p>\n<p><strong>Algorithm</strong></p>\n<pre><code>import java.util.HashMap;\nimport java.util.Map;\n\nclass Solution {\n    public int romanToInt(String s) {\n        Map&lt;Character, Integer&gt; values = new HashMap&lt;&gt;();\n        values.put('I', 1);\n        values.put('V', 5);\n        values.put('X', 10);\n        values.put('L', 50);\n        values.put('C', 100);\n        values.put('D', 500);\n        values.put('M', 1000);\n\n        int sum = 0;\n        int i = 0;\n\n        while (i &lt; s.length()) {\n            char currentSymbol = s.charAt(i);\n            int currentValue = values.get(currentSymbol);\n\n            int nextValue = 0;\n            if (i + 1 &lt; s.length()) {\n                char nextSymbol = s.charAt(i + 1);\n                nextValue = values.get(nextSymbol);\n            }\n\n            if (currentValue &lt; nextValue) {\n                sum += (nextValue - currentValue);\n                i += 2;\n            } else {\n                sum += currentValue;\n                i += 1;\n            }\n        }\n\n        return sum;\n    }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<p>Let n be the length of the input string (the total number of symbols in it).</p>\n<ul>\n<li>\n<p>Time complexity : O(1).</p>\n<p>As there is a finite set of roman numerals, the maximum number possible number can be <code>3999</code>, which in roman numerals is  <code>MMMCMXCIX</code>. As such the time complexity is O(1).</p>\n<p>If roman numerals had an arbitrary number of symbols, then the time complexity would be proportional to the length of the input, i.e. O(n). This is assuming that looking up the value of each symbol is O(1).</p>\n</li>\n<li>\n<p>Space complexity : O(1).</p>\n<p>Because only a constant number of single-value variables are used, the space complexity is O(1).</p>\n</li>\n</ul>\n<br/>\n<hr/>\n<h3><a href=\"#approach-2-left-to-right-pass-improved\"><svg><path></path></svg></a>Approach 2: Left-to-Right Pass Improved</h3>\n<p><strong>Intuition</strong></p>\n<p>Instead of viewing a Roman Numeral as having <code>7</code> unique symbols, we could instead view it as having <code>13</code> unique symbols—some of length-1 and some of length-2.</p>\n<p></p>\n<p>For example, here is the Roman Numeral <code>MMCMLXXXIX</code> broken into its symbols using this definition:</p>\n<p></p>\n<p>We can then look up the value of each symbol and add them together.</p>\n<p></p>\n<p>After making a <code>Map</code> of <code>String -&gt; Integer</code> with the <code>13</code> \"symbols\", we need to work our way down the string in the same way as before (we'll do left-to-right, however right-to-left will work okay too), firstly checking if we're at a length-2 symbol, and if not, then treating it as a length-1 symbol.</p>\n<svg><path></path></svg>\n<p>Here is an animation showing the algorithm.</p>\n<p></p>\n<p><strong>Algorithm</strong></p>\n<pre><code>import java.util.HashMap;\nimport java.util.Map;\n\nclass Solution {\n    private static final Map&lt;String, Integer&gt; values = new HashMap&lt;&gt;();\n\n    static {\n        values.put(\"I\", 1);\n        values.put(\"V\", 5);\n        values.put(\"X\", 10);\n        values.put(\"L\", 50);\n        values.put(\"C\", 100);\n        values.put(\"D\", 500);\n        values.put(\"M\", 1000);\n        values.put(\"IV\", 4);\n        values.put(\"IX\", 9);\n        values.put(\"XL\", 40);\n        values.put(\"XC\", 90);\n        values.put(\"CD\", 400);\n        values.put(\"CM\", 900);\n    }\n\n    public int romanToInt(String s) {\n        int sum = 0;\n        int i = 0;\n\n        while (i &lt; s.length()) {\n            if (i &lt; s.length() - 1) {\n                String doubleSymbol = s.substring(i, i + 2);\n                if (values.containsKey(doubleSymbol)) {\n                    sum += values.get(doubleSymbol);\n                    i += 2;\n                    continue;\n                }\n            }\n\n            String singleSymbol = s.substring(i, i + 1);\n            sum += values.get(singleSymbol);\n            i += 1;\n        }\n\n        return sum;\n    }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : O(1).</p>\n<p>Same as Approach 1.</p>\n</li>\n<li>\n<p>Space complexity : O(1).</p>\n<p>Same as Approach 1.</p>\n</li>\n</ul>\n<br/>\n<hr/>\n<h3><a href=\"#approach-3-right-to-left-pass\"><svg><path></path></svg></a>Approach 3: Right-to-Left Pass</h3>\n<p><strong>Intuition</strong></p>\n<p>This approach is a more elegant variant of Approach 1. Just to be clear though, <em>Approach 1 and Approach 2 are probably sufficient for an interview. This approach is still well worth understanding though.</em></p>\n<p>In the \"subtraction\" cases, such as <code>XC</code>, we've been updating our running <code>sum</code> as follows:</p>\n<svg><path></path></svg>\n<p>However, notice that this is mathematically equivalent to the following:</p>\n<svg><path></path></svg>\n<p>Utilizing this means that we can process <em>one</em> symbol each time we go around the main loop. We still need to determine whether or not our current symbol should be added or subtracted by looking at the neighbour though.</p>\n<p>In Approach 1, we had to be careful when inspecting the next symbol to not go over the end of the string. This check wasn't difficult to do, but it increased the code complexity a bit, and it turns out we can avoid it with this approach!</p>\n<p>Observe the following:</p>\n<ol>\n<li>Without looking at the next symbol, we <em>don't</em> know whether or not the left-most symbol should be added or subtracted.</li>\n<li>The right-most symbol is <em>always</em> added. It is either by itself, or the additive part of a pair.</li>\n</ol>\n<p>So, what we can do is initialise sum to be the value of the right-most (last) symbol. Then, we work <em>backwards</em> through the string, starting from the second-to-last-symbol. We check the symbol <em>after</em> (<code>i + 1</code>) to determine whether the current symbol should be \"added\" or \"subtracted\".</p>\n<svg><path></path></svg>\n<p>Because we're starting at the second-to-last-index, we know that index <code>i + 1</code> always exists. We no longer need to handle its potential non-existence as a special case, and additionally we're able to (cleanly) use a <code>for</code> loop, as we're always moving along by 1 index at at time, unlike before where it could have been 1 or 2.</p>\n<p>Here is an animation of the above approach.</p>\n<p></p>\n<p><strong>Algorithm</strong></p>\n<pre><code>import java.util.HashMap;\nimport java.util.Map;\n\nclass Solution {\n    private static final Map&lt;Character, Integer&gt; values = new HashMap&lt;&gt;();\n\n    static {\n        values.put('M', 1000);\n        values.put('D', 500);\n        values.put('C', 100);\n        values.put('L', 50);\n        values.put('X', 10);\n        values.put('V', 5);\n        values.put('I', 1);\n    }\n\n    public int romanToInt(String s) {\n        int lastValue = values.get(s.charAt(s.length() - 1));\n        int total = lastValue;\n\n        for (int i = s.length() - 2; i &gt;= 0; i--) {\n            int currentValue = values.get(s.charAt(i));\n            if (currentValue &lt; lastValue) {\n                total -= currentValue;\n            } else {\n                total += currentValue;\n            }\n            lastValue = currentValue;\n        }\n\n        return total;\n    }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : O(1).</p>\n<p>Same as Approach 1.</p>\n</li>\n<li>\n<p>Space complexity : O(1).</p>\n<p>Same as Approach 1.</p>\n</li>\n</ul>\n<br/>"}