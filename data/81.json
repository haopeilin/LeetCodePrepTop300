{"id":"81","title":"Search in Rotated Sorted Array II","difficulty":"Medium","content":"<p>There is an integer array <code>nums</code> sorted in non-decreasing order (not necessarily with <strong>distinct</strong> values).</p>\n\n<p>Before being passed to your function, <code>nums</code> is <strong>rotated</strong> at an unknown pivot index <code>k</code> (<code>0 &lt;= k &lt; nums.length</code>) such that the resulting array is <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code> (<strong>0-indexed</strong>). For example, <code>[0,1,2,4,4,4,5,6,6,7]</code> might be rotated at pivot index <code>5</code> and become <code>[4,5,6,6,7,0,1,2,4,4]</code>.</p>\n\n<p>Given the array <code>nums</code> <strong>after</strong> the rotation and an integer <code>target</code>, return <code>true</code><em> if </em><code>target</code><em> is in </em><code>nums</code><em>, or </em><code>false</code><em> if it is not in </em><code>nums</code><em>.</em></p>\n\n<p>You must decrease the overall operation steps as much as possible.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> nums = [2,5,6,0,0,1,2], target = 0\n<strong>Output:</strong> true\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> nums = [2,5,6,0,0,1,2], target = 3\n<strong>Output:</strong> false\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 5000</code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>nums</code> is guaranteed to be rotated at some pivot.</li>\n\t<li><code>-10<sup>4</sup> &lt;= target &lt;= 10<sup>4</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> This problem is similar to&nbsp;<a href=\"/problems/search-in-rotated-sorted-array/description/\" target=\"_blank\">Search in Rotated Sorted Array</a>, but&nbsp;<code>nums</code> may contain <strong>duplicates</strong>. Would this affect the runtime complexity? How and why?</p>\n","tags":["Array","Binary Search"],"java_snippet":"class Solution {\n    public boolean search(int[] nums, int target) {\n        \n    }\n}","solution":"<div class=\"flex flex-col w-full\" style=\"position: relative;\"><div class=\"mYe_l WRmCx\"><h2 class=\"group/heading relative\" id=\"solution\" level=\"2\"><a aria-hidden=\"true\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" href=\"#solution\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" data-icon=\"link\" data-prefix=\"fas\" focusable=\"false\" role=\"img\" spacing=\"square\" viewbox=\"0 0 640 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\" fill=\"currentColor\"></path></svg></div></a>Solution</h2>\n<hr/>\n<h3 class=\"group/heading relative\" id=\"approach-1-binary-search\" level=\"3\"><a aria-hidden=\"true\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" href=\"#approach-1-binary-search\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" data-icon=\"link\" data-prefix=\"fas\" focusable=\"false\" role=\"img\" spacing=\"square\" viewbox=\"0 0 640 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\" fill=\"currentColor\"></path></svg></div></a>Approach 1: Binary Search</h3>\n<p>This problem is an extension to <a href=\"https://leetcode.com/problems/search-in-rotated-sorted-array/\" target=\"_blank\">33. Search in Rotated Sorted Array</a>. The only difference is that this problem allows duplicate elements.</p>\n<p><strong>Intuition</strong></p>\n<p>Recall that after rotating a sorted array, what we get is two sorted arrays appended to each other.</p>\n<p></p>\n<p>Let's refer to the first sorted array as <code>F</code> and second as <code>S</code>.</p>\n<p></p>\n<p>Also, we can observe that all the elements of the second array <code>S</code> will be smaller or equal to the first element <code>start</code> of <code>F</code>.</p>\n<p></p>\n<p>With this observation in mind, we can easily tell which of the 2 arrays (<code>F</code> or <code>S</code>) does a <code>target</code> element lie in by just comparing it with the first element of the array.</p>\n<p>Let's say we are looking for element <code>target</code> in array <code>arr</code>:</p>\n<ul>\n<li>Case 1: If <code>target &gt; arr[start]</code>: <code>target</code> exists in the first array <code>F</code>.</li>\n</ul>\n<p></p>\n<ul>\n<li>Case 2: If <code>target &lt; arr[start]</code>: <code>target</code> exists in the second array <code>S</code>.</li>\n</ul>\n<p></p>\n<ul>\n<li>Case 3: If <code>target == arr[start]</code>: <code>target</code> obviously exists in the first array <code>F</code>, but it might also be present in the second array <code>S</code>.</li>\n</ul>\n<p></p>\n<p>Let's define a helper function that tells us which array a target element might be present in:</p>\n<pre><code>// returns true if element exists in first array, false if it exists in second\nbool existsInFirst(vector&lt;int&gt;&amp; nums, int start, int element) {\n    return nums[start] &lt;= element;\n}</code></pre>\n<p><strong>Algorithm</strong></p>\n<p>Recall that in standard binary search, we keep two pointers (i.e. <code>start</code> and <code>end</code>) to track the search scope in an <code>arr</code> array. We then divide the search space in three parts <code>[start, mid)</code>, <code>[mid, mid]</code>, <code>(mid, end]</code>. Now, we continue to look for our <code>target</code> element in one of these search spaces.</p>\n<p>By identifying the positions of both <code>arr[mid]</code> and <code>target</code> in <code>F</code> and <code>S</code>, we can reduce search space in the very same way as in standard binary search:</p>\n<ul>\n<li>Case 1: <code>arr[mid]</code> lies in <code>F</code>, <code>target</code> lies in <code>S</code>: Since <code>S</code> starts after <code>F</code> ends, we know that element lies here:<code>(mid, end]</code>.</li>\n</ul>\n<p></p>\n<ul>\n<li>Case 2: <code>arr[mid]</code> lies in the <code>S</code>, <code>target</code> lies in <code>F</code>: Similarly, we know that element lies here: <code>[start, mid)</code>.</li>\n</ul>\n<p></p>\n<ul>\n<li>Case 3: Both <code>arr[mid]</code> and <code>target</code> lie in <code>F</code>: since both of them are in same sorted array, we can compare <code>arr[mid]</code> and <code>target</code> in order to decide how to reduce search space.</li>\n</ul>\n<p></p>\n<ul>\n<li>Case 4: Both <code>arr[mid]</code> and <code>target</code> lie in <code>S</code>: Again, since both of them are in same sorted array, we can compare <code>arr[mid]</code> and <code>target</code> in order to decide how to reduce search space.</li>\n</ul>\n<p></p>\n<p>But there is a catch, if <code>arr[mid]</code> equals <code>arr[start]</code>, then we know that <code>arr[mid]</code> might belong to both <code>F</code> and <code>S</code> and hence we cannot find the relative position of <code>target</code> from it.</p>\n<p></p>\n<pre><code>// returns true if we can reduce the search space in current binary search space\nbool isBinarySearchHelpful(vector&lt;int&gt;&amp; nums, int start, int element) {\n    return nums[start] != element;\n}</code></pre>\n<p>In this case, we have no option but to move to next search space iteratively. Hence, there are certain search spaces that allow a binary search, and some search spaces that don't.</p>\n<pre><code>class Solution {\npublic:\n    bool search(vector&lt;int&gt;&amp; nums, int target) {\n        int n = nums.size();\n        if (n == 0) return false;\n        int end = n - 1;\n        int start = 0;\n​\n        while (start &lt;= end) {\n            int mid = start + (end - start) / 2;\n​\n            if (nums[mid] == target) {\n                return true;\n            }\n​\n            if (!isBinarySearchHelpful(nums, start, nums[mid])) {\n                start++;\n                continue;\n            }\n​\n            // which array does pivot belong to.\n            bool pivotArray = existsInFirst(nums, start, nums[mid]);\n​\n            // which array does target belong to.\n            bool targetArray = existsInFirst(nums, start, target);\n            if (pivotArray ^\n                targetArray) {  // If pivot and target exist in different sorted\n                                // arrays, recall that xor is true only when\n                                // both the operands are distinct\n                if (pivotArray) {\n                    start =\n                        mid + 1;  // pivot in the first, target in the second\n                } else {\n                    end = mid - 1;  // target in the first, pivot in the second\n                }\n            } else {  // If pivot and target exist in same sorted array\n                if (nums[mid] &lt; target) {\n                    start = mid + 1;\n                } else {\n                    end = mid - 1;\n                }\n            }\n        }\n        return false;\n    }\n​\n    // returns true if we can reduce the search space in current binary search\n    // space\n    bool isBinarySearchHelpful(vector&lt;int&gt;&amp; nums, int start, int element) {\n        return nums[start] != element;\n    }\n​\n    // returns true if element exists in first array, false if it exists in\n    // second\n    bool existsInFirst(vector&lt;int&gt;&amp; nums, int start, int element) {\n        return nums[start] &lt;= element;\n    }\n};</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span></span> worst case, <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mop\">lo<span style=\"margin-right: 0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right: 0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span></span> best case, where <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span></span></span></span></span> is the length of the input array.</p>\n<p>Worst case: This happens when all the elements are the same and we search for some different element. At each step, we will only be able to reduce the search space by 1 since <code>arr[mid]</code> equals <code>arr[start]</code> and it's not possible to decide the relative position of <code>target</code> from <code>arr[mid]</code>.<br/>\nExample: [1, 1, 1, 1, 1, 1, 1], target = 2.</p>\n<p>Best case: This happens when all the elements are distinct. At each step, we will be able to divide our search space into half just like a normal binary search.</p>\n</li>\n</ul>\n<p>This also answers the following follow-up question:</p>\n<ol>\n<li data-length=\"1\">Would this (having duplicate elements) affect the run-time complexity? How and why?</li>\n</ol>\n<p>As we can see, by having duplicate elements in the array, we often miss the opportunity to apply binary search in certain search spaces. Hence, we get <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span></span> worst case (with duplicates) vs <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mop\">lo<span style=\"margin-right: 0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right: 0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span></span> best case complexity (without duplicates).</p>\n<ul>\n<li>Space complexity : <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></span>.</li>\n</ul></div><span style=\"font-size: 0px; line-height: 0;\"> </span></div>"}