{"id":"140","title":"Word Break II","difficulty":"Hard","content":"<p>Given a string <code>s</code> and a dictionary of strings <code>wordDict</code>, add spaces in <code>s</code> to construct a sentence where each word is a valid dictionary word. Return all such possible sentences in <strong>any order</strong>.</p>\n\n<p><strong>Note</strong> that the same word in the dictionary may be reused multiple times in the segmentation.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;catsanddog&quot;, wordDict = [&quot;cat&quot;,&quot;cats&quot;,&quot;and&quot;,&quot;sand&quot;,&quot;dog&quot;]\n<strong>Output:</strong> [&quot;cats and dog&quot;,&quot;cat sand dog&quot;]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;pineapplepenapple&quot;, wordDict = [&quot;apple&quot;,&quot;pen&quot;,&quot;applepen&quot;,&quot;pine&quot;,&quot;pineapple&quot;]\n<strong>Output:</strong> [&quot;pine apple pen apple&quot;,&quot;pineapple pen apple&quot;,&quot;pine applepen apple&quot;]\n<strong>Explanation:</strong> Note that you are allowed to reuse a dictionary word.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;,&quot;dog&quot;,&quot;sand&quot;,&quot;and&quot;,&quot;cat&quot;]\n<strong>Output:</strong> []\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 20</code></li>\n\t<li><code>1 &lt;= wordDict.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= wordDict[i].length &lt;= 10</code></li>\n\t<li><code>s</code> and <code>wordDict[i]</code> consist of only lowercase English letters.</li>\n\t<li>All the strings of <code>wordDict</code> are <strong>unique</strong>.</li>\n\t<li>Input is generated in a way that the length of the answer doesn&#39;t exceed&nbsp;10<sup>5</sup>.</li>\n</ul>\n","tags":["Array","Hash Table","String","Dynamic Programming","Backtracking","Trie","Memoization"],"java_snippet":"class Solution {\n    public List<String> wordBreak(String s, List<String> wordDict) {\n        \n    }\n}","solution":"<h2><a href=\"#solution\"><svg><path></path></svg></a>Solution</h2>\n<hr/>\n<h3><a href=\"#overview\"><svg><path></path></svg></a>Overview</h3>\n<p>We have a string <code>s</code> and a dictionary of strings <code>wordDict</code>. The task is to add spaces in <code>s</code> to construct valid sentences where each word is present in <code>wordDict</code> and return all possible valid sentences. The same word from the dictionary can be reused multiple times.</p>\n<p>This problem is an extension of <a href=\"https://leetcode.com/problems/word-break/description/\">Problem 139. Word Break I</a>, where the goal was to determine if a word could be segmented into other words from a given dictionary. In this problem, however, we need to find all possible ways to split the word into valid statements. To understand this problem, it is beneficial to be familiar with <a href=\"https://leetcode.com/problems/word-break/description/\">Problem 139. Word Break I</a> as well as <a href=\"https://leetcode.com/problems/implement-trie-prefix-tree/\">Problem 208. Implement Trie Prefix Tree</a>, as those questions provide the foundational concepts and intuition necessary for solving this problem.</p>\n<p>Here, we will focus on the applications of recursion, dynamic programming, and tries, rather than on understanding their underlying mechanisms.</p>\n<p>To gain an understanding of their underlying mechanisms, we suggest you check out these explore cards:</p>\n<ol>\n<li><a href=\"https://leetcode.com/explore/learn/card/recursion-ii/472/backtracking/\">Backtracking Explore Card</a>.</li>\n<li><a href=\"https://leetcode.com/explore/learn/card/dynamic-programming/\">Dynamic Programming Explore Card</a>.</li>\n<li><a href=\"https://leetcode.com/explore/learn/card/trie/\">Trie Explore Card</a>.</li>\n</ol>\n<hr/>\n<h3><a href=\"#approach-1-backtracking\"><svg><path></path></svg></a>Approach 1: Backtracking</h3>\n<h4>Intuition</h4>\n<p>Initially, we might think of a brute-force approach where we systematically explore all possible ways to break the string into words from the dictionary. This leads us to the backtracking strategy, where we recursively try to form words from the string and add them to a current sentence if they are in the dictionary. If the current prefix doesn't lead to a valid solution, we backtrack by removing the last added word and trying the next possible word. This ensures we explore all possible segmentations of the string.</p>\n<p>At each step, we consider all possible end indices for substrings starting from the current index. For each substring, we check if it exists in the dictionary. If the substring is a valid word, we append it to the current sentence and recursively call the function with the updated index, which is the end index of the substring plus one.</p>\n<p>If we reach the end of the string, it means we have found a valid segmentation, and we can add the current sentence to the results. However, if we encounter a substring that is not a valid word, we backtrack by returning from that recursive call and trying the next possible end index.</p>\n<p>The backtracking approach will be inefficient due to the large number of recursive calls, especially for longer strings. To increase efficiency, we will convert the word dictionary into a set for constant-time lookups. However, the overall time complexity remains high because we explore all possible partitions.</p>\n<p>The process is visualized below:</p>\n<p></p>\n<h4>Algorithm</h4>\n<p><strong><code>wordBreak</code> Function:</strong></p>\n<ul>\n<li>Convert the <code>wordDict</code> array into a hash set <code>wordSet</code> for efficient lookups.</li>\n<li>Initialize an empty list <code>results</code> to store valid sentences.</li>\n<li>Initialize an empty string <code>currentSentence</code> to keep track of the sentence being constructed.</li>\n<li>Call the <code>backtrack</code> function with the input string <code>s</code>, <code>wordSet</code>, <code>currentSentence</code>, <code>results</code>, and a starting index set to 0, the beginning of the input string.</li>\n<li>Return <code>results</code>.</li>\n</ul>\n<p><strong><code>backtrack</code> Function:</strong></p>\n<ul>\n<li>Base Case: If the <code>startIndex</code> is equal to the length of the string, add the <code>currentSentence</code> to <code>results</code> and return as it means that <code>currentSentence</code> represents a valid sentence.</li>\n<li>Iterate over possible <code>endIndex</code> values from <code>startIndex + 1</code> to the end of the string.\n<ul>\n<li>Extract the substring <code>word</code> from <code>startIndex</code> to <code>endIndex - 1</code>.</li>\n<li>If <code>word</code> is found in <code>wordSet</code>:\n<ul>\n<li>Store the current <code>currentSentence</code> in <code>originalSentence</code>.</li>\n<li>Append <code>word</code> to <code>currentSentence</code> (with a space if needed).</li>\n<li>Recursively call <code>backtrack</code> with the updated <code>currentSentence</code> and <code>endIndex</code>.</li>\n<li>Reset <code>currentSentence</code> to its original value (<code>originalSentence</code>) to backtrack and try the next <code>endIndex</code>.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Return from the <code>backtrack</code> function.</li>\n</ul>\n<h4>Implementation</h4>\n<pre><code>class Solution {\n    public List&lt;String&gt; wordBreak(String s, List&lt;String&gt; wordDict) {\n        Set&lt;String&gt; wordSet = new HashSet&lt;&gt;(wordDict);\n        List&lt;String&gt; results = new ArrayList&lt;&gt;();\n        backtrack(s, wordSet, new StringBuilder(), results, 0);\n        return results;\n    }\n\n    private void backtrack(String s, Set&lt;String&gt; wordSet,\n                           StringBuilder currentSentence,\n                           List&lt;String&gt; results,\n                           int startIndex) {\n        if (startIndex == s.length()) {\n            results.add(currentSentence.toString());\n            return;\n        }\n\n        for (int endIndex = startIndex + 1; endIndex &lt;= s.length(); endIndex++) {\n            String word = s.substring(startIndex, endIndex);\n            if (wordSet.contains(word)) {\n                int originalLength = currentSentence.length();\n                if (originalLength &gt; 0) currentSentence.append(\" \");\n                currentSentence.append(word);\n                backtrack(s, wordSet, currentSentence, results, endIndex);\n                currentSentence.setLength(originalLength);\n            }\n        }\n    }\n}</code></pre>\n<h4>Complexity Analysis</h4>\n<p>Let n be the length of the input string.</p>\n<ul>\n<li>\n<p>Time complexity: O(n⋅2n)</p>\n<p>The algorithm explores all possible ways to break the string into words. In the worst case, where each character can be treated as a word, the recursion tree has 2n leaf nodes, resulting in an exponential time complexity. For each leaf node, O(n) work is performed, so the overall complexity is O(n⋅2n).</p>\n</li>\n<li>\n<p>Space complexity: O(2n)</p>\n<p>The recursion stack can grow up to a depth of n, where each recursive call consumes additional space for storing the current state.</p>\n<p>Since each position in the string can be a split point or not, and for n positions, there are 2n possible combinations of splits. Thus, in the worst case, each combination generates a different sentence that needs to be stored, leading to exponential space complexity.</p>\n</li>\n</ul>\n<hr/>\n<h3><a href=\"#approach-2-dynamic-programming---memoization\"><svg><path></path></svg></a>Approach 2: Dynamic Programming - Memoization</h3>\n<h4>Intuition</h4>\n<p>We can improve the efficiency of the backtracking method by using Memoization, which stores the results of subproblems to avoid recalculating them.</p>\n<p>We use a depth-first search (DFS) function that recursively breaks the string into words. However, before performing a recursive call, we check if the results for the current substring have already been computed and stored in a memoization map (typically a map or hash table).</p>\n<p>If the results of the current substring are found in the memoization map, we can directly return them without further computation. If not, we proceed with the recursive call, computing the results and storing them in the memoization map before returning them.</p>\n<p>By memoizing the results, we can reduce the number of computations by ensuring that each substring is processed only once in average cases.</p>\n<h4>Algorithm</h4>\n<p><strong><code>wordBreak</code> Function:</strong></p>\n<ul>\n<li>Convert the <code>wordDict</code> array into a hash set <code>wordSet</code> for efficient lookups.</li>\n<li>Initialize an empty hash map <code>memoization</code> to store the results of subproblems.</li>\n<li>Call the <code>dfs</code> function with the input string <code>s</code>, <code>wordSet</code>, and <code>memoization</code>.</li>\n</ul>\n<p><strong><code>dfs</code> Function:</strong></p>\n<ul>\n<li>Check if the answer for the current <code>remainingStr</code> (the remaining part of the string to be processed) is already in <code>memoization</code>. If so, return it.</li>\n<li>Base Case: If <code>remainingStr</code> is empty, return a list containing the empty string.</li>\n<li>Initialize an empty list <code>results</code>.</li>\n<li>Iterate from 1 to the length of <code>remainingStr</code>:\n<ul>\n<li>Extract the substring <code>currentWord</code> from 0 to <code>i</code>.</li>\n<li>If <code>currentWord</code> is found in <code>wordSet</code>:\n<ul>\n<li>Recursively call <code>dfs</code> with the remaining substring.</li>\n<li>Append <code>currentWord</code> and the recursive results to <code>results</code>.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Store the <code>results</code> for <code>remainingStr</code> in <code>memoization</code>.</li>\n<li>Return <code>results</code>.</li>\n</ul>\n<h4>Implementation</h4>\n<pre><code>class Solution {\n    public List&lt;String&gt; wordBreak(String s, List&lt;String&gt; wordDict) {\n        Set&lt;String&gt; wordSet = new HashSet&lt;&gt;(wordDict);\n        Map&lt;String, List&lt;String&gt;&gt; memoization = new HashMap&lt;&gt;();\n        return dfs(s, wordSet, memoization);\n    }\n\n    private List&lt;String&gt; dfs(String remainingStr,\n                             Set&lt;String&gt; wordSet,\n                             Map&lt;String, List&lt;String&gt;&gt; memoization) {\n        if (memoization.containsKey(remainingStr)) {\n            return memoization.get(remainingStr);\n        }\n\n        if (remainingStr.isEmpty()) {\n            return Arrays.asList(\"\");\n        }\n\n        List&lt;String&gt; results = new ArrayList&lt;&gt;();\n\n        for (int i = 1; i &lt;= remainingStr.length(); i++) {\n            String currentWord = remainingStr.substring(0, i);\n            if (wordSet.contains(currentWord)) {\n                List&lt;String&gt; nextWords = dfs(remainingStr.substring(i), wordSet, memoization);\n                for (String nextWord : nextWords) {\n                    results.add(currentWord + (nextWord.isEmpty() ? \"\" : \" \") + nextWord);\n                }\n            }\n        }\n\n        memoization.put(remainingStr, results);\n        return results;\n    }\n}</code></pre>\n<h4>Complexity Analysis</h4>\n<p>Let n be the length of the input string.</p>\n<ul>\n<li>\n<p>Time complexity: O(n⋅2n)</p>\n<p>While memoization avoids redundant computations, it does not change the overall number of subproblems that need to be solved. In the worst case, there are still 2n possible partitions that need to be explored, leading to an exponential time complexity. For each subproblem, O(n) work is performed, so the overall complexity is O(n⋅2n).</p>\n</li>\n<li>\n<p>Space complexity: O(n⋅2n)</p>\n<p>The recursion stack can grow up to a depth of n.</p>\n<p>The memoization map needs to store the results for all possible substrings, which can be exponential in the worst case, resulting in exponential space complexity.</p>\n</li>\n</ul>\n<hr/>\n<h3><a href=\"#approach-3-dynamic-programming---tabulation\"><svg><path></path></svg></a>Approach 3: Dynamic Programming - Tabulation</h3>\n<h4>Intuition</h4>\n<p>While memoization improves the backtracking approach, we might consider an alternative approach using dynamic programming principles. This leads us to the tabulation method, which builds a table of valid sentences for each starting index in the string.</p>\n<p>The tabulation approach works in a bottom-up manner, iterating from the end of the string towards the beginning.</p>\n<h4>Algorithm</h4>\n<ul>\n<li>Initialize a hash map <code>dp</code> to store results.</li>\n<li>Iterate from the end of the string to the beginning.</li>\n<li>Build valid sentences using previously computed results.</li>\n<li>Return <code>dp[0]</code>.</li>\n</ul>\n<h4>Implementation</h4>\n<pre><code>class Solution {\n    public List&lt;String&gt; wordBreak(String s, List&lt;String&gt; wordDict) {\n        Set&lt;String&gt; wordSet = new HashSet&lt;&gt;(wordDict);\n        Map&lt;Integer, List&lt;String&gt;&gt; dp = new HashMap&lt;&gt;();\n\n        for (int startIdx = s.length(); startIdx &gt;= 0; startIdx--) {\n            List&lt;String&gt; validSentences = new ArrayList&lt;&gt;();\n            for (int endIdx = startIdx; endIdx &lt; s.length(); endIdx++) {\n                String currentWord = s.substring(startIdx, endIdx + 1);\n                if (wordSet.contains(currentWord)) {\n                    if (endIdx == s.length() - 1) {\n                        validSentences.add(currentWord);\n                    } else {\n                        for (String sentence : dp.getOrDefault(endIdx + 1, new ArrayList&lt;&gt;())) {\n                            validSentences.add(currentWord + \" \" + sentence);\n                        }\n                    }\n                }\n            }\n            dp.put(startIdx, validSentences);\n        }\n\n        return dp.get(0);\n    }\n}</code></pre>\n<h4>Complexity Analysis</h4>\n<p>Let n be the length of the input string.</p>\n<ul>\n<li>\n<p>Time complexity: O(n⋅2n)</p>\n</li>\n<li>\n<p>Space complexity: O(n⋅2n)</p>\n</li>\n</ul>\n<hr/>\n<h3><a href=\"#approach-4-trie-optimization\"><svg><path></path></svg></a>Approach 4: Trie Optimization</h3>\n<h4>Intuition</h4>\n<p>This approach leverages a trie data structure to optimize word lookup and prefix matching.</p>\n<h4>Implementation</h4>\n<pre><code>class TrieNode {\n    boolean isEnd;\n    TrieNode[] children = new TrieNode[26];\n}\n\nclass Trie {\n    TrieNode root = new TrieNode();\n\n    void insert(String word) {\n        TrieNode node = root;\n        for (char c : word.toCharArray()) {\n            int idx = c - 'a';\n            if (node.children[idx] == null) {\n                node.children[idx] = new TrieNode();\n            }\n            node = node.children[idx];\n        }\n        node.isEnd = true;\n    }\n}\n\nclass Solution {\n    public List&lt;String&gt; wordBreak(String s, List&lt;String&gt; wordDict) {\n        Trie trie = new Trie();\n        for (String word : wordDict) {\n            trie.insert(word);\n        }\n\n        Map&lt;Integer, List&lt;String&gt;&gt; dp = new HashMap&lt;&gt;();\n\n        for (int startIdx = s.length(); startIdx &gt;= 0; startIdx--) {\n            List&lt;String&gt; validSentences = new ArrayList&lt;&gt;();\n            TrieNode currentNode = trie.root;\n\n            for (int endIdx = startIdx; endIdx &lt; s.length(); endIdx++) {\n                int idx = s.charAt(endIdx) - 'a';\n                if (currentNode.children[idx] == null) break;\n                currentNode = currentNode.children[idx];\n\n                if (currentNode.isEnd) {\n                    String currentWord = s.substring(startIdx, endIdx + 1);\n                    if (endIdx == s.length() - 1) {\n                        validSentences.add(currentWord);\n                    } else {\n                        for (String sentence : dp.getOrDefault(endIdx + 1, new ArrayList&lt;&gt;())) {\n                            validSentences.add(currentWord + \" \" + sentence);\n                        }\n                    }\n                }\n            }\n\n            dp.put(startIdx, validSentences);\n        }\n\n        return dp.get(0);\n    }\n}</code></pre>\n<h4>Complexity Analysis</h4>\n<p>Let n be the length of the input string.</p>\n<ul>\n<li>\n<p>Time complexity: O(n⋅2n)</p>\n</li>\n<li>\n<p>Space complexity: O(n⋅2n)</p>\n</li>\n</ul>\n<hr/>\n<p><strong>Further Thoughts On Complexity Analysis:</strong></p>\n<p>The complexity of this problem cannot be reduced from n⋅2n; the worst-case scenario will still be (n⋅2n). However, using dynamic programming (DP) will make it a bit more efficient than backtracking overall because of the below test case.</p>\n<p>Consider the input <code>\"aaaaaa\"</code>, with <code>wordDict = [\"a\", \"aa\", \"aaa\", \"aaaa\", \"aaaaa\", \"aaaaa\"]</code>.<br/>\nEvery possible partition is a valid sentence, and there are 2n−1 such partitions.</p>\n<p>Overall, this question is interesting because of the nature of this complexity. In an interview setting, if an interviewer asks this question, the most expected solutions would be Backtracking and Trie, as they become natural choices for the conditions and outputs we need.</p>"}