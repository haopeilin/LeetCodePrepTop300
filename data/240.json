{"id":"240","title":"Search a 2D Matrix II","difficulty":"Medium","content":"<p>Write an efficient algorithm that searches for a value <code>target</code> in an <code>m x n</code> integer matrix <code>matrix</code>. This matrix has the following properties:</p>\n\n<ul>\n\t<li>Integers in each row are sorted in ascending from left to right.</li>\n\t<li>Integers in each column are sorted in ascending from top to bottom.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/24/searchgrid2.jpg\" style=\"width: 300px; height: 300px;\" />\n<pre>\n<strong>Input:</strong> matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/24/searchgrid.jpg\" style=\"width: 300px; height: 300px;\" />\n<pre>\n<strong>Input:</strong> matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == matrix.length</code></li>\n\t<li><code>n == matrix[i].length</code></li>\n\t<li><code>1 &lt;= n, m &lt;= 300</code></li>\n\t<li><code>-10<sup>9</sup> &lt;= matrix[i][j] &lt;= 10<sup>9</sup></code></li>\n\t<li>All the integers in each row are <strong>sorted</strong> in ascending order.</li>\n\t<li>All the integers in each column are <strong>sorted</strong> in ascending order.</li>\n\t<li><code>-10<sup>9</sup> &lt;= target &lt;= 10<sup>9</sup></code></li>\n</ul>\n","tags":["Array","Binary Search","Divide and Conquer","Matrix"],"java_snippet":"class Solution {\n    public boolean searchMatrix(int[][] matrix, int target) {\n        \n    }\n}","solution":"<h2><a href=\"#solution\"><svg><path></path></svg></a>Solution</h2>\n<hr/>\n<h3><a href=\"#approach-1-brute-force\"><svg><path></path></svg></a>Approach 1: Brute Force</h3>\n<p><strong>Intuition</strong></p>\n<p>As a baseline, we can search the 2D array the same way we might search an<br/>\nunsorted 1D array -- by examining each element.</p>\n<p><strong>Algorithm</strong></p>\n<p>The algorithm doesn't really do anything more clever than what is explained<br/>\nby the intuition; we loop over the array, checking each element in turn. If<br/>\nwe find it, we return <code>true</code>. Otherwise, if we reach the end of the nested<br/>\n<code>for</code> loop without returning, we return <code>false</code>. The algorithm must return<br/>\nthe correct answer in all cases because we exhaust the entire search space.</p>\n<pre><code>class Solution {\n    public boolean searchMatrix(int[][] matrix, int target) {\n        for (int i = 0; i &lt; matrix.length; i++) {\n            for (int j = 0; j &lt; matrix[0].length; j++) {\n                if (matrix[i][j] == target) {\n                    return true;\n                }\n            }\n        }\n​\n        return false;\n    }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : O(nm)</p>\n<p>Becase we perform a constant time operation for each element of an<br/>\nn×m element matrix, the overall time complexity is equal to the<br/>\nsize of the matrix.</p>\n</li>\n<li>\n<p>Space complexity : O(1)</p>\n<p>The brute force approach does not allocate more additional space than a<br/>\nhandful of pointers, so the memory footprint is constant.</p>\n<br/>\n</li>\n</ul>\n<br/>\n<hr/>\n<h3><a href=\"#approach-2-binary-search\"><svg><path></path></svg></a>Approach 2: Binary Search</h3>\n<p><strong>Intuition</strong></p>\n<p>The fact that the matrix is sorted suggests that there must be some way to use<br/>\nbinary search to speed up our algorithm.</p>\n<p><strong>Algorithm</strong></p>\n<p>First, we ensure that <code>matrix</code> is not <code>null</code> and not empty. Then, if we<br/>\niterate over the matrix diagonals, we can maintain an invariant that the<br/>\nslice of the row and column beginning at the current (row,col) pair is<br/>\nsorted. Therefore, we can always binary search these row and column slices<br/>\nfor <code>target</code>. We proceed in a logical fashion, iterating over the diagonals,<br/>\nbinary searching the rows and columns until we either run out of diagonals<br/>\n(meaning we can return <code>False</code>) or find <code>target</code> (meaning we can return<br/>\n<code>True</code>). The <code>binarySearch</code> function works just like normal binary search,<br/>\nbut is made ugly by the need to search both rows and columns of a<br/>\ntwo-dimensional array.</p>\n<pre><code>class Solution {\n    private boolean binarySearch(int[][] matrix, int target, int start, boolean vertical) {\n        int lo = start;\n        int hi = vertical ? matrix[0].length-1 : matrix.length-1;\n​\n        while (hi &gt;= lo) {\n            int mid = (lo + hi)/2;\n            if (vertical) { // searching a column\n                if (matrix[start][mid] &lt; target) {\n                    lo = mid + 1;\n                } else if (matrix[start][mid] &gt; target) {\n                    hi = mid - 1;\n                } else {\n                    return true;\n                }\n            } else { // searching a row\n                if (matrix[mid][start] &lt; target) {\n                    lo = mid + 1;\n                } else if (matrix[mid][start] &gt; target) {\n                    hi = mid - 1;\n                } else {\n                    return true;\n                }\n            }\n        }\n​\n        return false;\n    }\n​\n    public boolean searchMatrix(int[][] matrix, int target) {\n        // an empty matrix obviously does not contain `target`\n        if (matrix == null || matrix.length == 0) {\n            return false;\n        }\n​\n        // iterate over matrix diagonals\n        int shorterDim = Math.min(matrix.length, matrix[0].length);\n        for (int i = 0; i &lt; shorterDim; i++) {\n            boolean verticalFound = binarySearch(matrix, target, i, true);\n            boolean horizontalFound = binarySearch(matrix, target, i, false);\n            if (verticalFound || horizontalFound) {\n                return true;\n            }\n        }\n        \n        return false; \n    }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : O(log(n!))</p>\n<p>It's not super obvious how O(log(n!)) time complexity arises<br/>\nfrom this algorithm, so let's analyze it step-by-step. The<br/>\nasymptotically-largest amount of work performed is in the main loop,<br/>\nwhich runs for min(m,n) iterations, where m denotes the number<br/>\nof rows and n denotes the number of columns. On each iteration, we<br/>\nperform two binary searches on array slices of length m−i and<br/>\nn−i. Therefore, each iteration of the loop runs in<br/>\nO(log(m−i)+log(n−i)) time, where i denotes the current<br/>\niteration. We can simplify this to O(2⋅log(n−i))=O(log(n−i))<br/>\nby seeing that, in the worst case, n≈m. To see why, consider<br/>\nwhat happens when n≪m (without loss of generality); n will<br/>\ndominate m in the asymptotic analysis. By summing the runtimes of all<br/>\niterations, we get the following expression:</p>\n<p>(1)O(log(n)+log(n−1)+log(n−2)+…+log(1))</p>\n<p>Then, we can leverage the log multiplication rule (log(a)+log(b)=log(ab))<br/>\nto rewrite the complexity as:</p>\n(2)O(log(n)+log(n−1)+log(n−2)+…+log(1))​=O(log(n⋅(n−1)⋅(n−2)⋅…⋅1))=O(log(1⋅…⋅(n−2)⋅(n−1)⋅n))=O(log(n!))​\n<p>Because this time complexity is fairly uncommon, it is worth thinking about<br/>\nits relation to the usual analyses. For one, log(n!)=O(nlogn).<br/>\nTo see why, recall step 1 from the analysis above; there are n terms, each no<br/>\ngreater than log(n). Therefore, the asymptotic runtime is certainly no worse than<br/>\nthat of an O(nlogn) algorithm.</p>\n</li>\n<li>\n<p>Space complexity : O(1)</p>\n<p>Because our binary search implementation does not literally slice out<br/>\ncopies of rows and columns from <code>matrix</code>, we can avoid allocating<br/>\ngreater-than-constant memory.</p>\n<br/>\n</li>\n</ul>\n<br/>\n<hr/>\n<h3><a href=\"#approach-3-divide-and-conquer\"><svg><path></path></svg></a>Approach 3: Divide and Conquer</h3>\n<p><strong>Intuition</strong></p>\n<p>We can partition a sorted two-dimensional matrix into four sorted submatrices,<br/>\ntwo of which might contain <code>target</code> and two of which definitely do not.</p>\n<p><strong>Algorithm</strong></p>\n<p>Because this algorithm operates recursively, its correctness can be asserted<br/>\nvia the correctness of its base and recursive cases.</p>\n<p><em>Base Case</em></p>\n<p>For a sorted two-dimensional array, there are two ways to determine in<br/>\nconstant time whether an arbitrary element <code>target</code> can appear in it. First,<br/>\nif the array has zero area, it contains no elements and therefore cannot<br/>\ncontain <code>target</code>. Second, if <code>target</code> is smaller than the array's smallest<br/>\nelement (found in the top-left corner) or larger than the array's largest<br/>\nelement (found in the bottom-right corner), then it definitely is not<br/>\npresent.</p>\n<p><em>Recursive Case</em></p>\n<p>If the base case conditions have not been met, then the array has positive<br/>\narea and <code>target</code> could potentially be present. Therefore, we seek along the<br/>\nmatrix's middle column for an index <code>row</code> such that<br/>\nmatrix[row−1][mid]&lt;target&lt;matrix[row][mid] (obviously, if we find<br/>\n<code>target</code> during this process, we immediately return <code>true</code>). The existing<br/>\nmatrix can be partitioned into four submatrice around this index; the<br/>\ntop-left and bottom-right submatrice cannot contain <code>target</code> (via the<br/>\nargument outlined in <em>Base Case</em> section), so we can prune them from the<br/>\nsearch space. Additionally, the bottom-left and top-right submatrice are<br/>\nsorted two-dimensional matrices, so we can recursively apply this algorithm<br/>\nto them.</p>\n<pre><code>class Solution {\n    private int[][] matrix;\n    private int target;\n​\n    private boolean searchRec(int left, int up, int right, int down) {\n        // this submatrix has no height or no width.\n        if (left &gt; right || up &gt; down) {\n            return false;\n        // `target` is already larger than the largest element or smaller\n        // than the smallest element in this submatrix.\n        } else if (target &lt; matrix[up][left] || target &gt; matrix[down][right]) {\n            return false;\n        }\n​\n        int mid = left + (right-left)/2;\n​\n        // Locate `row` such that matrix[row-1][mid] &lt; target &lt; matrix[row][mid]\n        int row = up;\n        while (row &lt;= down &amp;&amp; matrix[row][mid] &lt;= target) {\n            if (matrix[row][mid] == target) {\n                return true;\n            }\n            row++;\n        }\n​\n        return searchRec(left, row, mid-1, down) || searchRec(mid+1, up, right, row-1);\n    }\n​\n    public boolean searchMatrix(int[][] mat, int targ) {\n        // cache input values in object to avoid passing them unnecessarily\n        // to `searchRec`\n        matrix = mat;\n        target = targ;\n​\n        // an empty matrix obviously does not contain `target`\n        if (matrix == null || matrix.length == 0) {\n            return false;\n        }\n​\n        return searchRec(0, 0, matrix[0].length-1, matrix.length-1);\n    }\n}</code></pre>\n<p>Here is a visualization for the above code.</p>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : O(nlogn)</p>\n<p>First, for ease of analysis, assume that n≈m, as in the<br/>\nanalysis of approach 2. Also, assign x=n2=∣matrix∣; this will make<br/>\nthe <a href=\"https://en.wikipedia.org/wiki/Master_theorem_(analysis_of_algorithms)\">master method</a><br/>\neasier to apply. Now, let's model the runtime of the<br/>\ndivide &amp; conquer approach as a recurrence relation:</p>\n<p>T(x)=2⋅T(4x​)+x<svg><path></path></svg>​</p>\n<p>The first term (2⋅T(4x​)) arises from the fact that we<br/>\nrecurse on two submatrices of roughly one-quarter size, while<br/>\nx<svg><path></path></svg>​ comes from the time spent seeking along a O(n)-length<br/>\ncolumn for the partition point. After binding the master method variables<br/>\n(a=2;b=4;c=0.5) we notice that logb​a=c. Therefore, this<br/>\nrecurrence falls under case 2 of the master method, and the following<br/>\nfalls out:</p>\nT(x)​=O(xc⋅logx)=O(x0.5⋅logx)=O((n2)0.5⋅log(n2))=O(n⋅log(n2))=O(2n⋅logn)=O(n⋅logn)​\n<p>Extension: what would happen to the complexity if we binary searched for<br/>\nthe partition point, rather than used a linear scan?</p>\n</li>\n<li>\n<p>Space complexity : O(logn)</p>\n<p>Although this approach does not fundamentally require<br/>\ngreater-than-constant addition memory, its use of recursion means that it<br/>\nwill use memory proportional to the height of its recursion tree. Because<br/>\nthis approach discards half of <code>matrix</code> on each level of recursion (and<br/>\nmakes two recursive calls), the height of the tree is bounded by logn.</p>\n<br/>\n</li>\n</ul>\n<br/>\n<hr/>\n<h3><a href=\"#approach-4-search-space-reduction\"><svg><path></path></svg></a>Approach 4: Search Space Reduction</h3>\n<p><strong>Intuition</strong></p>\n<p>Because the rows and columns of the matrix are sorted (from left-to-right and<br/>\ntop-to-bottom, respectively), we can prune O(m) or<br/>\nO(n) elements when looking at any particular value.</p>\n<p><strong>Algorithm</strong></p>\n<p>First, we initialize a (row,col) pointer to the bottom-left of the<br/>\nmatrix.<sup><a href=\"#user-content-fn-1\">1</a></sup> Then, until we find <code>target</code> and return <code>true</code> (or the pointer<br/>\npoints to a (row,col) that lies outside of the dimensions of the<br/>\nmatrix), we do the following: if the currently-pointed-to value is larger<br/>\nthan <code>target</code> we can move one row \"up\". Otherwise, if the<br/>\ncurrently-pointed-to value is smaller than <code>target</code>, we can move one column<br/>\n\"right\". It is not too tricky to see why doing this will never prune the<br/>\ncorrect answer; because the rows are sorted from left-to-right, we know that<br/>\nevery value to the right of the current value is larger. Therefore, if the<br/>\ncurrent value is already larger than <code>target</code>, we know that every value to<br/>\nits right will also be too large. A very similar argument can be made for the<br/>\ncolumns, so this manner of search will always find <code>target</code> in the matrix (if<br/>\nit is present).</p>\n<p>Check out some sample runs of the algorithm in the animation below:</p>\n<p></p>\n<pre><code>class Solution {\n    public boolean searchMatrix(int[][] matrix, int target) {\n        // start our \"pointer\" in the bottom-left\n        int row = matrix.length-1;\n        int col = 0;\n​\n        while (row &gt;= 0 &amp;&amp; col &lt; matrix[0].length) {\n            if (matrix[row][col] &gt; target) {\n                row--;\n            } else if (matrix[row][col] &lt; target) {\n                col++;\n            } else { // found it\n                return true;\n            }\n        }\n​\n        return false;\n    }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : O(n+m)</p>\n<p>The key to the time complexity analysis is noticing that, on every<br/>\niteration (during which we do not return <code>true</code>) either <code>row</code> or <code>col</code> is<br/>\nis decremented/incremented exactly once. Because <code>row</code> can only be<br/>\ndecremented m times and <code>col</code> can only be incremented n times<br/>\nbefore causing the <code>while</code> loop to terminate, the loop cannot run for<br/>\nmore than n+m iterations. Because all other work is constant, the<br/>\noverall time complexity is linear in the sum of the dimensions of the<br/>\nmatrix.</p>\n</li>\n<li>\n<p>Space complexity : O(1)</p>\n<p>Because this approach only manipulates a few pointers, its memory<br/>\nfootprint is constant.</p>\n<br/>\n</li>\n</ul>\n<h3><a href=\"#footnotes\"><svg><path></path></svg></a>Footnotes</h3>\n<h2><a href=\"#user-content-footnote-label\"><svg><path></path></svg></a>Footnotes</h2>\n<ol>\n<li>\n<p>This would work equally well with a pointer initialized to the<br/>\ntop-right. Neither of the other two corners would work, as pruning a<br/>\nrow/column might prevent us from achieving the correct answer. <a href=\"#user-content-fnref-1\">↩</a></p>\n</li>\n</ol>"}