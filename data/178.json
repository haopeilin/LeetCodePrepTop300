{"id":"178","title":"Rank Scores","difficulty":"Medium","content":"<p>Table: <code>Scores</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| id          | int     |\n| score       | decimal |\n+-------------+---------+\nid is the primary key (column with unique values) for this table.\nEach row of this table contains the score of a game. Score is a floating point value with two decimal places.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to find the rank of the scores. The ranking should be calculated according to the following rules:</p>\n\n<ul>\n\t<li>The scores should be ranked from the highest to the lowest.</li>\n\t<li>If there is a tie between two scores, both should have the same ranking.</li>\n\t<li>After a tie, the next ranking number should be the next consecutive integer value. In other words, there should be no holes between ranks.</li>\n</ul>\n\n<p>Return the result table ordered by <code>score</code> in descending order.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nScores table:\n+----+-------+\n| id | score |\n+----+-------+\n| 1  | 3.50  |\n| 2  | 3.65  |\n| 3  | 4.00  |\n| 4  | 3.85  |\n| 5  | 4.00  |\n| 6  | 3.65  |\n+----+-------+\n<strong>Output:</strong> \n+-------+------+\n| score | rank |\n+-------+------+\n| 4.00  | 1    |\n| 4.00  | 1    |\n| 3.85  | 2    |\n| 3.65  | 3    |\n| 3.65  | 3    |\n| 3.50  | 4    |\n+-------+------+\n</pre>\n","tags":["Database"],"java_snippet":"","solution":"<h1><a href=\"#solution\"><svg><path></path></svg></a>Solution</h1>\n<hr/>\n<h2><a href=\"#pandas\"><svg><path></path></svg></a>pandas</h2>\n<h3><a href=\"#approach-1-dense_rank\"><svg><path></path></svg></a>Approach 1: DENSE_RANK</h3>\n<h4>Algorithm</h4>\n<p>Ideally, we could group rows together based on <code>score</code> value, assign the same<br/>\nranking to each member/row of a group, and then return all rows sorted by<br/>\nranking in decreasing order. But conventional usage of aggregate functions<br/>\nrelies on grouping query rows into a <em>single</em> result row, something we do not<br/>\nwant to do in this problem. We need to return <em>all</em> rows in a ranked fashion,<br/>\nnot just distinct or grouped <code>score</code> values ranked in descending order.</p>\n<p>For example, conventional usage of aggregate functions would give us the<br/>\nfollowing result set for the example input:</p>\n<table><thead><tr><th>score</th><th>rank</th></tr></thead><tbody><tr><td>4.00</td><td>1</td></tr><tr><td>3.85</td><td>2</td></tr><tr><td>3.65</td><td>3</td></tr><tr><td>3.50</td><td>4</td></tr></tbody></table>\n<br/>\n<p>But we want <em>all</em> rows:</p>\n<table><thead><tr><th>score</th><th>rank</th></tr></thead><tbody><tr><td>4.00</td><td>1</td></tr><tr><td>4.00</td><td>1</td></tr><tr><td>3.85</td><td>2</td></tr><tr><td>3.65</td><td>3</td></tr><tr><td>3.65</td><td>3</td></tr><tr><td>3.50</td><td>4</td></tr></tbody></table>\n<br/>\n<p>Pandas provides the function <code>rank()</code> to help compute numerical data ranks along an axis, we can set the method parameter <code>method</code> as <code>dense</code> to assign dense ranks. Dense ranks mean that when there are ties (scores that have the same value), the next rank is not skipped. Instead, the same rank is assigned to all tied scores, and the next rank is incremented by one. This ensures that there are no gaps in the ranks, and each score gets a unique rank, which is also exactly what the question requires.</p>\n<p>Therefore, we apply dense rank on the column <code>score</code>,</p>\n<pre><code>// Dense rank over 'score' by descending order\nList&lt;Double&gt; distinctScores = scores.stream()\n    .map(Score::getScore)\n    .distinct()\n    .sorted(Comparator.reverseOrder())\n    .collect(Collectors.toList());\n\nMap&lt;Double, Integer&gt; rankMap = new HashMap&lt;&gt;();\nfor (int i = 0; i &lt; distinctScores.size(); i++) {\n    rankMap.put(distinctScores.get(i), i + 1);\n}\n\nscores.forEach(s -&gt; s.setRank(rankMap.get(s.getScore())));</code></pre><svg><path></path></svg>\n<p>We will have the following DataFrame:</p>\n<table><thead><tr><th>id</th><th>score</th><th>rank</th></tr></thead><tbody><tr><td>1</td><td>3.50</td><td>4</td></tr><tr><td>2</td><td>3.65</td><td>3</td></tr><tr><td>3</td><td>4.00</td><td>1</td></tr><tr><td>4</td><td>3.85</td><td>2</td></tr><tr><td>5</td><td>4.00</td><td>1</td></tr><tr><td>6</td><td>3.65</td><td>3</td></tr></tbody></table>\n<br/>\n<p>Next, we need to return the required columns, sorted by <code>score</code> in ascending order, the complete code is as follows:</p>\n<h4>Implementation</h4>\n<pre><code>import java.util.*;\nimport java.util.stream.Collectors;\n\npublic class ScoreRanking {\n\n    public static List&lt;Score&gt; orderScores(List&lt;Score&gt; scores) {\n        List&lt;Double&gt; distinctScores = scores.stream()\n            .map(Score::getScore)\n            .distinct()\n            .sorted(Comparator.reverseOrder())\n            .collect(Collectors.toList());\n\n        Map&lt;Double, Integer&gt; rankMap = new HashMap&lt;&gt;();\n        for (int i = 0; i &lt; distinctScores.size(); i++) {\n            rankMap.put(distinctScores.get(i), i + 1);\n        }\n\n        scores.forEach(s -&gt; s.setRank(rankMap.get(s.getScore())));\n\n        return scores.stream()\n            .sorted(Comparator.comparingDouble(Score::getScore).reversed())\n            .collect(Collectors.toList());\n    }\n}</code></pre>\n<hr/>\n<h2><a href=\"#database\"><svg><path></path></svg></a>Database</h2>\n<h3><a href=\"#approach-1-using-dense_rank-window-function-for-ranking\"><svg><path></path></svg></a>Approach 1: Using DENSE_RANK() Window Function for Ranking</h3>\n<h4>Algorithm</h4>\n<p>For SQL users, familiarity with <a href=\"https://dev.mysql.com/doc/refman/8.0/en/window-functions-usage.html\">window functions</a> proves to be useful here (as with most more advanced SQL problems):</p>\n<blockquote>\n<p>A window function performs an aggregate-like operation on a set of query<br/>\nrows. However, whereas an aggregate operation groups query rows into a single<br/>\nresult row, a window function produces a result for each query row.</p>\n</blockquote>\n<p>So far so good. Is there a window function that might concern ranking purposes?<br/>\nThe<br/>\n<a href=\"https://dev.mysql.com/doc/refman/8.0/en/window-function-descriptions.html#function_dense-rank\"><code>DENSE_RANK()</code></a><br/>\nwindow function turns out to be just what we need for this problem:</p>\n<blockquote>\n<p>Returns the rank of the current row within its partition, without gaps. Peers<br/>\nare considered ties and receive the same rank. This function assigns<br/>\nconsecutive ranks to peer groups; the result is that groups of size greater<br/>\nthan one do not produce noncontiguous rank numbers.</p>\n</blockquote>\n<p>It seems likely we could use the <code>DENSE_RANK()</code> window function to great<br/>\neffect here.</p>\n<h4>Implementation</h4>\n<pre><code>String sql =\n    \"SELECT \" +\n    \"  S.score, \" +\n    \"  DENSE_RANK() OVER (ORDER BY S.score DESC) AS rank \" +\n    \"FROM Scores S\";\n\nPreparedStatement stmt = connection.prepareStatement(sql);\nResultSet rs = stmt.executeQuery();</code></pre><svg><path></path></svg>\n<p><strong>Note:</strong> MySQL did not support window functions until version 8.0 (April 19,<br/>\n2018). In general, window functions were not introduced into SQL until<br/>\nSQL:2003, as noted in the MariaDB <a href=\"https://mariadb.com/kb/en/window-functions-overview/#scope\">window functions<br/>\noverview</a> article.</p>\n<hr/>\n<h3><a href=\"#approach-2-correlated-subquery-with-countdistinct-\"><svg><path></path></svg></a>Approach 2: Correlated subquery with <code>COUNT(DISTINCT ...)</code></h3>\n<h4>Intuition</h4>\n<p>If we could count, for each score <code>S1.score</code>, the number of <em>distinct</em> scores<br/>\n<code>S2.score</code> that are greater than or equal to this score, then this would<br/>\neffectively give us the ranking of <code>S1.score</code>. We could then order our result<br/>\nset by <code>S1.score</code> to comply with the problem's ranking rules.</p>\n<h4>Algorithm</h4>\n<p>A <a href=\"https://dev.mysql.com/doc/refman/8.0/en/correlated-subqueries.html\">correlated subquery</a> can be used to do the counting referred to above.</p>\n<ol>\n<li>For each score from the <code>Scores</code> table, select the number of distinct scores<br/>\nin the <code>Scores</code> table that are greater than or equal to this score.</li>\n<li>Order the result set by <code>score</code>.</li>\n</ol>\n<h4>Implementation</h4>\n<pre><code>String sql =\n    \"SELECT S1.score, \" +\n    \"  (SELECT COUNT(DISTINCT S2.score) \" +\n    \"   FROM Scores S2 \" +\n    \"   WHERE S2.score &gt;= S1.score) AS rank \" +\n    \"FROM Scores S1 \" +\n    \"ORDER BY S1.score DESC\";\n\nPreparedStatement stmt = connection.prepareStatement(sql);\nResultSet rs = stmt.executeQuery();</code></pre><svg><path></path></svg>\n<hr/>\n<h3><a href=\"#approach-3-inner-join-with-countdistinct-\"><svg><path></path></svg></a>Approach 3: <code>INNER JOIN</code> with <code>COUNT(DISTINCT ...)</code></h3>\n<h4>Intuition</h4>\n<p>The intuition for this approach is fundamentally the same as that for Approach<br/>\n2, but the manner of implementation is completely different.</p>\n<h4>Algorithm</h4>\n<ol>\n<li>Join the <code>Scores</code> table to itself in such a manner that for each score we<br/>\nget all rows having a score greater than or equal to this score.</li>\n<li>Group query rows by <code>id</code> and <code>score</code> value.</li>\n<li>Count the number of distinct scores greater than or equal to the score used<br/>\nin the join condition (this is the ranking).</li>\n<li>Order the result set by the <code>score</code> value.</li>\n</ol>\n<h4>Implementation</h4>\n<pre><code>String sql =\n    \"SELECT S.score, COUNT(DISTINCT T.score) AS rank \" +\n    \"FROM Scores S \" +\n    \"INNER JOIN Scores T ON S.score &lt;= T.score \" +\n    \"GROUP BY S.id, S.score \" +\n    \"ORDER BY S.score DESC\";\n\nPreparedStatement stmt = connection.prepareStatement(sql);\nResultSet rs = stmt.executeQuery();</code></pre><svg><path></path></svg>\n<p>The solution above is effective because of how the items are <em>grouped</em> -- the<br/>\n<code>COUNT()</code> aggregate works on the groupings to give us the desired results. To<br/>\nmore clearly see how the query above works, we can inspect the output of the<br/>\nfollowing query:</p>\n<pre><code>String sql =\n    \"SELECT S.id AS S_ID, S.score AS S_score, \" +\n    \"       T.id AS T_ID, T.score AS T_score \" +\n    \"FROM Scores S \" +\n    \"INNER JOIN Scores T ON S.score &lt;= T.score \" +\n    \"ORDER BY S.id, T.score\";\n\nPreparedStatement stmt = connection.prepareStatement(sql);\nResultSet rs = stmt.executeQuery();</code></pre><svg><path></path></svg>\n<p>If we apply this query to the sample data given in the problem description,<br/>\nthen we will get the following result set:</p>\n<pre><code>// Example output processing in Java\nwhile (rs.next()) {\n    int sId = rs.getInt(\"S_ID\");\n    double sScore = rs.getDouble(\"S_score\");\n    int tId = rs.getInt(\"T_ID\");\n    double tScore = rs.getDouble(\"T_score\");\n}</code></pre><svg><path></path></svg>\n<p>Note how this provides us with the desired result set when we use<br/>\n<code>COUNT(DISTINCT ...)</code> in conjunction with proper grouping:</p>\n<pre><code>// Final ranked results processed from ResultSet\nList&lt;Score&gt; result = new ArrayList&lt;&gt;();\nwhile (rs.next()) {\n    result.add(new Score(rs.getDouble(\"score\"), rs.getInt(\"rank\")));\n}</code></pre><svg><path></path></svg>\n<ul>\n<li><code>S_ID = 1</code>; <code>S_score = 3.50</code>: There are <code>4</code> distinct <code>T_score</code> values<br/>\n(<code>3.50</code>, <code>3.65</code>, <code>3.85</code>, and <code>4.00</code>).</li>\n<li><code>S_ID = 2</code>; <code>S_score = 3.65</code>: There are <code>3</code> distinct <code>T_score</code> values<br/>\n(<code>3.65</code>, <code>3.85</code>, and <code>4.00</code>).</li>\n<li>...</li>\n</ul>\n<hr/>\n<h3><a href=\"#conclusion\"><svg><path></path></svg></a>Conclusion</h3>\n<p>We prefer Approach 1 for a variety of reasons, most notably its simplicity,<br/>\nperformance, and contextual appropriateness. Few problems will call for such an<br/>\nappropriate direct application of <code>DENSE_RANK()</code> as this problem. But, as noted<br/>\nat the end of Approach 1, window functions are fairly recent in their arrival<br/>\non the SQL landscape, especially in regards to how they are used in modern<br/>\ndevelopment environments.</p>\n<p>In an interview setting, Approach 1 is optimal. But it should not be a surprise<br/>\nif an interviewer asked for a solution that does not rely on modern SQL tools<br/>\nsuch as window functions. Approach 2 or Approach 3 would be appropriate<br/>\nstrategies in such a situtation. Approach 2 may convey a deeper understanding<br/>\nof how SQL processes queries while Approach 3 may convey creativity in<br/>\nproblem-solving. In either case though, something positive and desirable is<br/>\nbeing conveyed.</p>"}