{"id":"166","title":"Fraction to Recurring Decimal","difficulty":"Medium","content":"<p>Given two integers representing the <code>numerator</code> and <code>denominator</code> of a fraction, return <em>the fraction in string format</em>.</p>\n\n<p>If the fractional part is repeating, enclose the repeating part in parentheses</p>\n\n<p>If multiple answers are possible, return <strong>any of them</strong>.</p>\n\n<p>It is <strong>guaranteed</strong> that the length of the answer string is less than <code>10<sup>4</sup></code> for all the given inputs.</p>\n\n<p><strong>Note</strong> that if the fraction can be represented as a <em>finite length string</em>, you <strong>must</strong> return it.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> numerator = 1, denominator = 2\n<strong>Output:</strong> &quot;0.5&quot;\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> numerator = 2, denominator = 1\n<strong>Output:</strong> &quot;2&quot;\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> numerator = 4, denominator = 333\n<strong>Output:</strong> &quot;0.(012)&quot;\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>-2<sup>31</sup> &lt;=&nbsp;numerator, denominator &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li><code>denominator != 0</code></li>\n</ul>\n","tags":["Hash Table","Math","String"],"java_snippet":"class Solution {\n    public String fractionToDecimal(int numerator, int denominator) {\n        \n    }\n}","solution":"<h2><a href=\"#summary\"><svg><path></path></svg></a>Summary</h2>\n<p>This is a straight forward coding problem but with a fair amount of details to get right.</p>\n<h2><a href=\"#hints\"><svg><path></path></svg></a>Hints</h2>\n<ol>\n<li>No scary math, just apply elementary math knowledge. Still remember how to perform a <i>long division</i>?</li>\n<li>Try a long division on 94​, the repeating part is obvious. Now try 3334​. Do you see a pattern?</li>\n<li>Be wary of edge cases! List out as many test cases as you can think of and test your code thoroughly.</li>\n</ol>\n<h2><a href=\"#solution\"><svg><path></path></svg></a>Solution</h2>\n<hr/>\n<h3><a href=\"#approach-long-division\"><svg><path></path></svg></a>Approach: Long Division</h3>\n<p><strong>Intuition</strong></p>\n<p>The key insight here is to notice that once the remainder starts repeating, so does the divided result.</p>\n<p>0.166)1.000.00​1.00060​040036​00400​​⇐remainder = 1, mark 1 as seen at position = 0.⇐remainder = 4, mark 4 as seen at position = 1.⇐remainder = 4 was seen before at position = 1,so the fractional part starts repeating at position = 1⇒1(6).​</p>\n<br/>\n<p><strong>Algorithm</strong></p>\n<p>You will need a hash table that maps from the remainder to its position of the fractional part. Once you found a repeating remainder, you may enclose the reoccurring fractional part with parentheses by consulting the position from the table.</p>\n<p>The remainder could be zero while doing the division. That means there is no repeating fractional part and you should stop right away.</p>\n<p>Just like the question <a href=\"https://leetcode.com/problems/divide-two-integers/\">Divide Two Integers</a>, be wary of edge cases such as negative fractions and nasty extreme case such as −1−2147483648​.</p>\n<p>Here are some good test cases:</p>\n<table><thead><tr><th>Test case</th><th>Explanation</th></tr></thead><tbody><tr><td>10​</td><td>Numerator is zero.</td></tr><tr><td>01​</td><td>Divisor is 0, should handle it by throwing an exception but here we ignore for simplicity sake.</td></tr><tr><td>420​</td><td>Answer is a whole integer, should not contain the fractional part.</td></tr><tr><td>21​</td><td>Answer is 0.5, no recurring decimal.</td></tr><tr><td>4−1​ or −41​</td><td>One of the numerator or denominator is negative, fraction is negative.</td></tr><tr><td>−4−1​</td><td>Both numerator and denominator are negative, should result in positive fraction.</td></tr><tr><td>−1−2147483648​</td><td>Beware of overflow if you cast to positive.</td></tr></tbody></table>\n<br/>\n<pre><code>class Solution {\n    public String fractionToDecimal(int numerator, int denominator) {\n        if (numerator == 0) {\n            return \"0\";\n        }\n        StringBuilder fraction = new StringBuilder();\n        // If either one is negative (not both)\n        if ((numerator &lt; 0) ^ (denominator &lt; 0)) {\n            fraction.append(\"-\");\n        }\n        // Convert to long to prevent overflow\n        long dividend = Math.abs((long) numerator);\n        long divisor = Math.abs((long) denominator);\n        fraction.append(dividend / divisor);\n        long remainder = dividend % divisor;\n        if (remainder == 0) {\n            return fraction.toString();\n        }\n        fraction.append(\".\");\n        java.util.Map<long, integer=\"\"> map = new java.util.HashMap&lt;&gt;();\n        while (remainder != 0) {\n            if (map.containsKey(remainder)) {\n                fraction.insert(map.get(remainder), \"(\");\n                fraction.append(\")\");\n                break;\n            }\n            map.put(remainder, fraction.length());\n            remainder *= 10;\n            fraction.append(remainder / divisor);\n            remainder %= divisor;\n        }\n        return fraction.toString();\n    }\n}</long,></code></pre>\n<h4>Complexity Analysis</h4>\n<p>Let n be the number of digits in the repeating decimal representation of the fraction formed by <code>numerator / denominator</code>.</p>\n<ul>\n<li>\n<p>Time complexity: O(n)</p>\n<p>We perform integer division and remainder operations iteratively until the remainder becomes <code>0</code> or a repeating pattern is detected.</p>\n<p>Each unique remainder can appear at most once before a repetition occurs because once a remainder repeats, the decimal starts looping.</p>\n<p>Therefore, we process at most <code>n</code> distinct remainders, and each iteration involves constant-time operations like division, modulus, lookup, and insertion in the hash map (<code>HashMap</code>). Hence, the total time complexity is O(n).</p>\n</li>\n<li>\n<p>Space complexity: O(n)</p>\n<p>The hash map <code>map</code> stores each distinct remainder and its corresponding index in the result string. In the worst case, every remainder before repetition is unique, so we may store up to <code>n</code> entries. Additionally, the <code>fraction</code> string stores up to <code>n</code> digits for the decimal part. Therefore, the total space complexity is O(n).</p>\n</li>\n</ul>\n<hr/>"}