{"id":"125","title":"Valid Palindrome","difficulty":"Easy","content":"<p>A phrase is a <strong>palindrome</strong> if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.</p>\n\n<p>Given a string <code>s</code>, return <code>true</code><em> if it is a <strong>palindrome</strong>, or </em><code>false</code><em> otherwise</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;A man, a plan, a canal: Panama&quot;\n<strong>Output:</strong> true\n<strong>Explanation:</strong> &quot;amanaplanacanalpanama&quot; is a palindrome.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;race a car&quot;\n<strong>Output:</strong> false\n<strong>Explanation:</strong> &quot;raceacar&quot; is not a palindrome.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot; &quot;\n<strong>Output:</strong> true\n<strong>Explanation:</strong> s is an empty string &quot;&quot; after removing non-alphanumeric characters.\nSince an empty string reads the same forward and backward, it is a palindrome.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 2 * 10<sup>5</sup></code></li>\n\t<li><code>s</code> consists only of printable ASCII characters.</li>\n</ul>\n","tags":["Two Pointers","String"],"java_snippet":"class Solution {\n    public boolean isPalindrome(String s) {\n        \n    }\n}","solution":"<h2><a href=\"#solution\"><svg><path></path></svg></a>Solution</h2>\n<hr/>\n<h3><a href=\"#approach-1-compare-with-reverse\"><svg><path></path></svg></a>Approach 1: Compare with Reverse</h3>\n<p><strong>Intuition</strong></p>\n<p>A palindrome is a word, phrase, or sequence that reads the same backwards as forwards. e.g. <code>madam</code></p>\n<p>A palindrome, and its reverse, are identical to each other.</p>\n<p><strong>Algorithm</strong></p>\n<p>We'll reverse the given string and compare it with the original. If those are equivalent, it's a palindrome.</p>\n<p>Since only alphanumeric characters are considered, we'll filter out all other types of characters before we apply our algorithm.</p>\n<p>Additionally, because we're treating letters as case-insensitive, we'll convert the remaining letters to lower case. The digits will be left the same.</p>\n<pre><code>class Solution {\n    public boolean isPalindrome(String s) {\n        StringBuilder filtered = new StringBuilder();\n\n        for (char ch : s.toCharArray()) {\n            if (Character.isLetterOrDigit(ch)) {\n                filtered.append(Character.toLowerCase(ch));\n            }\n        }\n\n        String filteredString = filtered.toString();\n        String reversedString = filtered.reverse().toString();\n\n        return filteredString.equals(reversedString);\n    }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : O(n), in length n of the string.</p>\n<p>We need to iterate thrice through the string:</p>\n<ol>\n<li>When we filter out non-alphanumeric characters, and convert the remaining characters to lower-case.</li>\n<li>When we reverse the string.</li>\n<li>When we compare the original and the reversed strings.</li>\n</ol>\n<p>Each iteration runs linear in time (since each character operation completes in constant time). Thus, the effective run-time complexity is linear.</p>\n</li>\n<li>\n<p>Space complexity : O(n), in length n of the string. We need O(n) additional space to stored the filtered string and the reversed string.</p>\n</li>\n</ul>\n<br/>\n<hr/>\n<h3><a href=\"#approach-2-two-pointers\"><svg><path></path></svg></a>Approach 2: Two Pointers</h3>\n<p><strong>Intuition</strong></p>\n<p>If you take any ordinary string, and concatenate its reverse to it, you'll get a palindrome. This leads to an interesting insight about the converse: every palindrome half is reverse of the other half.</p>\n<p>Simply speaking, if one were to start in the middle of a palindrome, and traverse outwards, they'd encounter the same characters, in the exact same order, in both halves!</p>\n<p></p>\n<p><strong>Algorithm</strong></p>\n<p>Since the input string contains characters that we need to ignore in our palindromic check, it becomes tedious to figure out the real middle point of our palindromic input.</p>\n<blockquote>\n<p>Instead of going outwards from the middle, we could just go inwards towards the middle!</p>\n</blockquote>\n<p>So, if we start traversing inwards, from both ends of the input string, we can expect to <em>see</em> the same characters, in the same order.</p>\n<p>The resulting algorithm is simple:</p>\n<ul>\n<li>Set two pointers, one at each end of the input string</li>\n<li>If the input is palindromic, both the pointers should point to equivalent characters, <em>at all times</em>. <sup><a href=\"#user-content-fn-note-1\">1</a></sup>\n<ul>\n<li>If this condition is not met at any point of time, we break and return early.  <sup><a href=\"#user-content-fn-note-2\">2</a></sup></li>\n</ul>\n</li>\n<li>We can simply ignore non-alphanumeric characters by continuing to traverse further.</li>\n<li>Continue traversing inwards until the pointers meet in the middle.</li>\n</ul>\n<pre><code>class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n\n        while (i &lt; j) {\n            while (i &lt; j &amp;&amp; !Character.isLetterOrDigit(s.charAt(i))) i++;\n            while (i &lt; j &amp;&amp; !Character.isLetterOrDigit(s.charAt(j))) j--;\n\n            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) {\n                return false;\n            }\n\n            i++;\n            j--;\n        }\n\n        return true;\n    }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : O(n), in length n of the string. We traverse over each character at-most once, until the two pointers meet in the middle, or when we break and return early.</p>\n</li>\n<li>\n<p>Space complexity : O(1). No extra space required, at all.</p>\n</li>\n</ul>\n<h2><a href=\"#user-content-footnote-label\"><svg><path></path></svg></a>Footnotes</h2>\n<ol>\n<li>\n<p>Such a property is formally known as a <a href=\"https://en.wikipedia.org/wiki/Loop_invariant\">loop invariant</a>. <a href=\"#user-content-fnref-note-1\">↩</a></p>\n</li>\n<li>\n<p>Such a property is often called a <em>loop termination condition</em>. It is one of several used in this solution. Can you identify the others? <a href=\"#user-content-fnref-note-2\">↩</a></p>\n</li>\n</ol>"}