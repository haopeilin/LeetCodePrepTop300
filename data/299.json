{"id":"299","title":"Bulls and Cows","difficulty":"Medium","content":"<p>You are playing the <strong><a href=\"https://en.wikipedia.org/wiki/Bulls_and_Cows\" target=\"_blank\">Bulls and Cows</a></strong> game with your friend.</p>\n\n<p>You write down a secret number and ask your friend to guess what the number is. When your friend makes a guess, you provide a hint with the following info:</p>\n\n<ul>\n\t<li>The number of &quot;bulls&quot;, which are digits in the guess that are in the correct position.</li>\n\t<li>The number of &quot;cows&quot;, which are digits in the guess that are in your secret number but are located in the wrong position. Specifically, the non-bull digits in the guess that could be rearranged such that they become bulls.</li>\n</ul>\n\n<p>Given the secret number <code>secret</code> and your friend&#39;s guess <code>guess</code>, return <em>the hint for your friend&#39;s guess</em>.</p>\n\n<p>The hint should be formatted as <code>&quot;xAyB&quot;</code>, where <code>x</code> is the number of bulls and <code>y</code> is the number of cows. Note that both <code>secret</code> and <code>guess</code> may contain duplicate digits.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> secret = &quot;1807&quot;, guess = &quot;7810&quot;\n<strong>Output:</strong> &quot;1A3B&quot;\n<strong>Explanation:</strong> Bulls are connected with a &#39;|&#39; and cows are underlined:\n&quot;1807&quot;\n  |\n&quot;<u>7</u>8<u>10</u>&quot;</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> secret = &quot;1123&quot;, guess = &quot;0111&quot;\n<strong>Output:</strong> &quot;1A1B&quot;\n<strong>Explanation:</strong> Bulls are connected with a &#39;|&#39; and cows are underlined:\n&quot;1123&quot;        &quot;1123&quot;\n  |      or     |\n&quot;01<u>1</u>1&quot;        &quot;011<u>1</u>&quot;\nNote that only one of the two unmatched 1s is counted as a cow since the non-bull digits can only be rearranged to allow one 1 to be a bull.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= secret.length, guess.length &lt;= 1000</code></li>\n\t<li><code>secret.length == guess.length</code></li>\n\t<li><code>secret</code> and <code>guess</code> consist of digits only.</li>\n</ul>\n","tags":["Hash Table","String","Counting"],"java_snippet":"class Solution {\n    public String getHint(String secret, String guess) {\n        \n    }\n}","solution":"<h2><a href=\"#solution\"><svg><path></path></svg></a>Solution</h2>\n<hr/>\n<h3><a href=\"#overview\"><svg><path></path></svg></a>Overview</h3>\n<p>At first glance, this popular Google question seems to be easy. The only difficulty here is to define how to count.</p>\n<ul>\n<li>To count bulls, one could parse both strings and count the matches, and that's the correct way to do things.</li>\n</ul>\n<p><br/>\n<em>Figure 1. Count bulls.</em></p>\n<ul>\n<li>To count cows, one could parse <code>guess</code> string and count the characters which are present in the string <code>secret</code> but located in the wrong positions. Though the cows are more complicated creatures than bulls. For some test cases, it might work.</li>\n</ul>\n<p><br/>\n<em>Figure 2. Count cows.</em></p>\n<ul>\n<li>Although, in general, one has to count the characters as well. For example, if <code>secret</code> contains just one digit \"4\" then the maximum number of 4-cows is 1. Even if <code>guess</code> contains many \"4\"s. In the following example, only one of two \"4\"s should be counted as a cow.</li>\n</ul>\n<p><br/>\n<em>Figure 3. Only one of two \"4\"s should be counted as \"4-cow\".</em></p>\n<p>To figure out these three points is enough to solve the problem.</p>\n<p>In this article, we start from a straightforward two-pass solution that already has the best time (O(N)) and space complexity (O(1)).</p>\n<p>As a follow-up, we implement a one-pass solution and discuss some Java-related optimizations in approach 2.</p>\n<h3><a href=\"#approach-1-hashmap-two-passes\"><svg><path></path></svg></a>Approach 1: HashMap: Two Passes</h3>\n<p><strong>Algorithm</strong></p>\n<ul>\n<li>\n<p>Initialize the number of bulls and cows to zero.</p>\n</li>\n<li>\n<p>Initialize the hashmap <code>character -&gt; its frequency</code> for the string <code>secret</code>. This hashmap could be later used during the iteration over the string <code>guess</code> to keep the available characters.</p>\n</li>\n<li>\n<p>It's time to iterate over the string <code>guess</code>.</p>\n<ul>\n<li>\n<p>If the current character <code>ch</code> of the string <code>guess</code> is in the string <code>secret</code>: <code>if ch in h</code>, then there could be two situations.</p>\n<ul>\n<li>\n<p>The corresponding characters of two strings match: <code>ch == secret[idx]</code>.</p>\n<ul>\n<li>\n<p>Then it's time to update the bulls: <code>bulls += 1</code>.</p>\n</li>\n<li>\n<p>The update of the cows is needed if the count for the current character in the hashmap is negative or equal to zero. That means that before it was already used for cows, and the cows counter should be decreased: <code>cows -= int(h[ch] &lt;= 0)</code>.</p>\n</li>\n</ul>\n</li>\n<li>\n<p>The corresponding characters of two strings don't match: <code>ch != secret[idx]</code>. Then increase the cows counter: <code>cows += int(h[ch] &gt; 0)</code>.</p>\n</li>\n<li>\n<p>In both cases, one has to update the hashmap, marking the current character as used: <code>h[ch] -= 1</code>.</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>Return the number of bulls and cows.</p>\n</li>\n</ul>\n<p></p>\n<p><strong>Implementation</strong></p>\n<pre><code>class Solution {\n    public String getHint(String secret, String guess) {\n        HashMap&lt;Character, Integer&gt; h = new HashMap();\n        for (char s : secret.toCharArray()) {\n            h.put(s, h.getOrDefault(s, 0) + 1);\n        }\n            \n        int bulls = 0, cows = 0;\n        int n = guess.length();\n        for (int idx = 0; idx &lt; n; ++idx) {\n            char ch = guess.charAt(idx);\n            if (h.containsKey(ch)) {\n                // corresponding characters match\n                if (ch == secret.charAt(idx)) {\n                    // update the bulls\n                    bulls++;\n                    // update the cows \n                    // if all ch characters from secret \n                    // were used up\n                    if (h.get(ch) &lt;= 0)\n                        cows--;    \n                // corresponding characters don't match\n                } else {\n                    // update the cows\n                    if (h.get(ch) &gt; 0)\n                        cows++;     \n                }\n                // ch character was used\n                h.put(ch, h.get(ch) - 1); \n            }\n        }\n                \n        return Integer.toString(bulls) + \"A\" + Integer.toString(cows) + \"B\";\n    }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity: O(N), we pass over the strings two times.</p>\n</li>\n<li>\n<p>Space complexity: O(1) to keep hashmap <code>h</code> which contains at most 10 elements.</p>\n</li>\n</ul>\n<br/>\n<br/>\n<hr/>\n<h3><a href=\"#approach-2-one-pass\"><svg><path></path></svg></a>Approach 2: One Pass</h3>\n<p><strong>Intuition</strong></p>\n<p>Let's optimize approach 1 by building the hashmap during the strings' parsing. That would allow us to reduce the number of passes to one.</p>\n<p><strong>Algorithm</strong></p>\n<ul>\n<li>\n<p>Initialize the number of bulls and cows to zero.</p>\n</li>\n<li>\n<p>Initialize the hashmap to count characters. During the iteration, <code>secret</code> string gives a positive contribution, and <code>guess</code> - negative contribution.</p>\n</li>\n<li>\n<p>Iterate over the strings: <code>s</code> is the current character in the string <code>secret</code> and <code>g</code> - the current character in the string <code>guess</code>.</p>\n<ul>\n<li>\n<p>If <code>s == g</code>, update bulls counter: <code>bulls += 1</code>.</p>\n</li>\n<li>\n<p>Otherwise, if <code>s != g</code>:</p>\n<ul>\n<li>\n<p>Update <code>cows</code> by adding 1 if so far <code>guess</code> contains more <code>s</code> characters than <code>secret</code>: <code>h[s] &lt; 0</code>.</p>\n</li>\n<li>\n<p>Update <code>cows</code> by adding 1 if so far <code>secret</code> contains more <code>g</code> characters than <code>guess</code>: <code>h[g] &gt; 0</code>.</p>\n</li>\n<li>\n<p>Update the hashmap by marking the presence of <code>s</code> character in the string <code>secret</code>: <code>h[s] += 1</code>.</p>\n</li>\n<li>\n<p>Update the hashmap by marking the presence of <code>g</code> character in the string <code>guess</code>: <code>h[g] -= 1</code>.</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>Return the number of bulls and cows.</p>\n</li>\n</ul>\n<p><strong>Implementation</strong></p>\n<pre><code>class Solution {\n    public String getHint(String secret, String guess) {\n        HashMap&lt;Character, Integer&gt; h = new HashMap();\n            \n        int bulls = 0, cows = 0;\n        int n = guess.length();\n        for (int idx = 0; idx &lt; n; ++idx) {\n            char s = secret.charAt(idx);\n            char g = guess.charAt(idx);\n            if (s == g) {\n                bulls++;    \n            } else {\n                if (h.getOrDefault(s, 0) &lt; 0) \n                    cows++;\n                if (h.getOrDefault(g, 0) &gt; 0)\n                    cows++;\n                h.put(s, h.getOrDefault(s, 0) + 1);\n                h.put(g, h.getOrDefault(g, 0) - 1);\n            }\n        } \n                \n        return Integer.toString(bulls) + \"A\" + Integer.toString(cows) + \"B\";\n    }\n}</code></pre>\n<p>To further optimize the Java solution, one could use an array instead of a hashmap because there are known problems with <a href=\"https://github.com/vavr-io/vavr/issues/571\">Java HashMap performance</a>. Another small improvement is to replace string concatenation with a StringBuilder.</p>\n<pre><code>class Solution {\n    public String getHint(String secret, String guess) {\n        int[] h = new int[10];\n            \n        int bulls = 0, cows = 0;\n        int n = guess.length();\n        for (int idx = 0; idx &lt; n; ++idx) {\n            char s = secret.charAt(idx);\n            char g = guess.charAt(idx);\n            if (s == g) {\n                bulls++;    \n            } else {\n                if (h[s - '0'] &lt; 0) \n                    cows++;\n                if (h[g - '0'] &gt; 0)\n                    cows++;\n                h[s - '0']++;\n                h[g - '0']--;\n            }\n        } \n                \n        StringBuilder sb = new StringBuilder();\n        sb.append(bulls); \n        sb.append(\"A\"); \n        sb.append(cows); \n        sb.append(\"B\");\n        return sb.toString();\n    }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity: O(N), we do one pass over the strings.</p>\n</li>\n<li>\n<p>Space complexity: O(1) to keep hashmap (or array) <code>h</code> which contains at most 10 elements.</p>\n</li>\n</ul>\n<br/>\n<br/>\n<hr/>"}