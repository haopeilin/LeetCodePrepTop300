{"id":"241","title":"Different Ways to Add Parentheses","difficulty":"Medium","content":"<p>Given a string <code>expression</code> of numbers and operators, return <em>all possible results from computing all the different possible ways to group numbers and operators</em>. You may return the answer in <strong>any order</strong>.</p>\n\n<p>The test cases are generated such that the output values fit in a 32-bit integer and the number of different results does not exceed <code>10<sup>4</sup></code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> expression = &quot;2-1-1&quot;\n<strong>Output:</strong> [0,2]\n<strong>Explanation:</strong>\n((2-1)-1) = 0 \n(2-(1-1)) = 2\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> expression = &quot;2*3-4*5&quot;\n<strong>Output:</strong> [-34,-14,-10,-10,10]\n<strong>Explanation:</strong>\n(2*(3-(4*5))) = -34 \n((2*3)-(4*5)) = -14 \n((2*(3-4))*5) = -10 \n(2*((3-4)*5)) = -10 \n(((2*3)-4)*5) = 10\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= expression.length &lt;= 20</code></li>\n\t<li><code>expression</code> consists of digits and the operator <code>&#39;+&#39;</code>, <code>&#39;-&#39;</code>, and <code>&#39;*&#39;</code>.</li>\n\t<li>All the integer values in the input expression are in the range <code>[0, 99]</code>.</li>\n\t<li>The integer values in the input expression do not have a leading <code>&#39;-&#39;</code> or <code>&#39;+&#39;</code> denoting the sign.</li>\n</ul>\n","tags":["Math","String","Dynamic Programming","Recursion","Memoization"],"java_snippet":"class Solution {\n    public List<Integer> diffWaysToCompute(String expression) {\n        \n    }\n}","solution":"<div class=\"flex flex-col w-full\" style=\"position: relative;\"><div class=\"mYe_l WRmCx\"><h2 class=\"group/heading relative\" id=\"solution\" level=\"2\"><a aria-hidden=\"true\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" href=\"#solution\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" data-icon=\"link\" data-prefix=\"fas\" focusable=\"false\" role=\"img\" spacing=\"square\" viewbox=\"0 0 640 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\" fill=\"currentColor\"></path></svg></div></a>Solution</h2>\n<hr/>\n<h3 class=\"group/heading relative\" id=\"overview\" level=\"3\"><a aria-hidden=\"true\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" href=\"#overview\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" data-icon=\"link\" data-prefix=\"fas\" focusable=\"false\" role=\"img\" spacing=\"square\" viewbox=\"0 0 640 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\" fill=\"currentColor\"></path></svg></div></a>Overview</h3>\n<p>We are given a string <code>expression</code> containing:</p>\n<ol>\n<li data-length=\"1\">Numbers from 0 - 99.</li>\n<li data-length=\"1\">Operators (+, -, *)</li>\n</ol>\n<p>Our task is to determine all possible results obtainable by grouping the numbers and operators in various ways.</p>\n<hr/>\n<h3 class=\"group/heading relative\" id=\"approach-1-recursion\" level=\"3\"><a aria-hidden=\"true\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" href=\"#approach-1-recursion\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" data-icon=\"link\" data-prefix=\"fas\" focusable=\"false\" role=\"img\" spacing=\"square\" viewbox=\"0 0 640 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\" fill=\"currentColor\"></path></svg></div></a>Approach 1: Recursion</h3>\n<h4 id=\"intuition\">Intuition</h4>\n<p>When we add parentheses to an expression, they group parts of the expression, telling us to evaluate those parts first. To decide where to place these parentheses, we look at each operator in the expression. Each operator offers a chance to split the expression into two smaller parts: everything before the operator and everything after it. These smaller parts are similar to our original problem, so we use recursion to solve them.</p>\n<p>We start by defining our base cases, where we can return a result without further recursion:</p>\n<ol>\n<li data-length=\"1\">If the expression is empty, return an empty list.</li>\n<li data-length=\"1\">If the expression is a single digit, return a list with that number.</li>\n<li data-length=\"1\">If the expression has two characters and the first is a digit, the second must also be a digit. We convert the expression to a number and return it in a list.</li>\n</ol>\n<p>For longer expressions, we find operators to split the expression. We iterate through each character, and when we find an operator, we recursively evaluate the parts before and after it. We store the results of these evaluations in separate lists. Then, we combine the results from the left and right parts using the operator and store the final values in a list.</p>\n<p>Here’s a visual example of how a recursion subtree might look:</p>\n<p></p>\n<p>By the end of the process, the <code>results</code> list will contain all possible results from grouping the numbers and operators in the expression.</p>\n<h4 id=\"algorithm\">Algorithm</h4>\n<ul>\n<li>Initialize a list <code>results</code> to store the possible outcomes.</li>\n<li>If the input string is empty, return the empty <code>results</code> list.</li>\n<li>Check if <code>expression</code> is a single character:\n<ul>\n<li>If so, convert it to an integer and add it to <code>results</code>.</li>\n<li>Return <code>results</code>.</li>\n</ul>\n</li>\n<li>Check if <code>expression</code> has only two characters and starts with a digit:\n<ul>\n<li>If so, convert the entire string to an integer and add it to <code>results</code>.</li>\n<li>Return <code>results</code>.</li>\n</ul>\n</li>\n<li>Iterate through each character of <code>expression</code>:\n<ul>\n<li>Set the current character as <code>currentChar</code>.</li>\n<li>If <code>currentChar</code> is a digit, continue to the next iteration.</li>\n<li>Recursively call <code>diffWaysToCompute</code> for the left part of <code>expression</code> (from indices <code>0</code> to <code>i-1</code>) and set it to a list <code>leftResults</code>.</li>\n<li>Recursively call <code>diffWaysToCompute</code> for the right part of <code>expression</code> (from indices <code>i+1</code> to the end) and set it to a list <code>rightResults</code>.</li>\n<li>Iterate through <code>leftValue</code> in <code>leftResults</code>:\n<ul>\n<li>For each <code>leftValue</code>, iterate through each <code>rightValue</code> in the <code>rightResults</code>:\n<ul>\n<li>Initialize a variable <code>computedResult</code> to store the result of the current operation.</li>\n<li>Perform the operation (addition, subtraction, or multiplication) based on the current character.</li>\n<li>Add the <code>computedResult</code> to the <code>results</code> list.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Return <code>results</code> as our answer.</li>\n</ul>\n<h4 id=\"implementation\">Implementation</h4>\n<pre><code>class Solution {\npublic:\n    vector&lt;int&gt; diffWaysToCompute(string expression) {\n        vector&lt;int&gt; results;\n​\n        // Base case: if the string is empty, return an empty list\n        if (expression.length() == 0) return results;\n​\n        // Base case: if the string is a single character, treat it as a number\n        // and return it\n        if (expression.length() == 1) {\n            results.push_back(stoi(expression));\n            return results;\n        }\n​\n        // If the string has only two characters and the first character is a\n        // digit, parse it as a number\n        if (expression.length() == 2 &amp;&amp; isdigit(expression[0])) {\n            results.push_back(stoi(expression));\n            return results;\n        }\n​\n        // Recursive case: iterate through each character\n        for (int i = 0; i &lt; expression.length(); i++) {\n            char currentChar = expression[i];\n​\n            // Skip if the current character is a digit\n            if (isdigit(currentChar)) continue;\n​\n            // Split the expression into left and right parts\n            vector&lt;int&gt; leftResults =\n                diffWaysToCompute(expression.substr(0, i));\n            vector&lt;int&gt; rightResults =\n                diffWaysToCompute(expression.substr(i + 1));\n​\n            // Combine results from left and right parts\n            for (int leftValue : leftResults) {\n                for (int rightValue : rightResults) {\n                    int computedResult = 0;\n​\n                    // Perform the operation based on the current character\n                    switch (currentChar) {\n                        case '+':\n                            computedResult = leftValue + rightValue;\n                            break;\n                        case '-':\n                            computedResult = leftValue - rightValue;\n                            break;\n                        case '*':\n                            computedResult = leftValue * rightValue;\n                            break;\n                    }\n​\n                    results.push_back(computedResult);\n                }\n            }\n        }\n​\n        return results;\n    }\n};</code></pre>\n<h4 id=\"complexity-analysis\">Complexity Analysis</h4>\n<p>Let <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></span> be the the length of the input string <code>expression</code>.</p>\n<ul>\n<li>\n<p>Time complexity: <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.6644em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p>For each sub-expression, we iterate through the string to identify the operators, which takes <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span> time. However, the key aspect is the recursive combination of results from the left and right sub-expressions. The number of results grows exponentially because each sub-expression produces multiple results, and combining these results takes <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right: 0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.01968em;\">l</span><span class=\"mclose\">)</span></span></span></span></span>, where <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.03148em;\">k</span></span></span></span></span> and <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.01968em;\">l</span></span></span></span></span> are the numbers of results from the left and right sub-problems, respectively.</p>\n<p>There were some suggestions to model the number of results using Catalan numbers which we deemed as incorrect. Catalan numbers apply when counting distinct ways to fully parenthesize an expression or structure. In this problem, however, we're not just counting valid ways to split the expression but also calculating and combining all possible results. This introduces exponential growth in the number of possible results, not the polynomial growth typical of Catalan numbers. The number of combinations grows exponentially with the depth of recursive splitting, which means the overall complexity is driven by the exponential growth in results.</p>\n<p>Thus, the time complexity of the algorithm is <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.6644em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span>, where the <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.6644em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span> factor reflects the exponential growth in the number of ways to combine results from sub-expressions.</p>\n</li>\n<li>\n<p>Space complexity: <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.6644em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p>The algorithm stores the intermediate results at each step. Since the total number of results can be equal to the <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.6644em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span>, the space complexity of the algorithm is <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.6644em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n</li>\n</ul>\n<hr/>\n<h3 class=\"group/heading relative\" id=\"approach-2-memoization\" level=\"3\"><a aria-hidden=\"true\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" href=\"#approach-2-memoization\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" data-icon=\"link\" data-prefix=\"fas\" focusable=\"false\" role=\"img\" spacing=\"square\" viewbox=\"0 0 640 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\" fill=\"currentColor\"></path></svg></div></a>Approach 2: Memoization</h3>\n<h4 id=\"intuition-1\">Intuition</h4>\n<p>When dealing with complex expressions, we often find ourselves repeating the same calculations. Take the expression <code>2 + 2 - 2 - 2 - 2</code>. You could group it in different ways:</p>\n<ol>\n<li data-length=\"1\"><code>((2 + 2) - (2 - 2) - 2)</code></li>\n<li data-length=\"1\"><code>((2 + 2) - 2 - (2 - 2))</code></li>\n</ol>\n<p>As you can see, the sub-expression (2 + 2) is evaluated more than once.</p>\n<p>To avoid this, we can store the results of these sub-calculations. This way, if we hit the same sub-problem again, we can use the stored result instead of recalculating it, which speeds things up.</p>\n<p>Another issue with the previous method was that it repeatedly created substrings of the expression. Since creating a substring takes <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span> time, where <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></span> is the length of the string, this can be quite slow. Instead, we’ll pass the entire <code>expression</code> to each recursive call and use <code>start</code> and <code>end</code> indices to specify the part we're interested in. This avoids the costly substring operations.</p>\n<p>In our updated approach, each state in the recursion is defined by the <code>start</code> and <code>end</code> indices. We use a 2D array for memoization, where each cell <code>memo[i][j]</code> holds the list of possible results for the sub-expression from index <code>i</code> to index <code>j</code>.</p>\n<blockquote>\n<p>Note: There is an alternative way to apply memoization in this problem. Consider the expression \"2-2-2\". This can be grouped in two ways: <code>(2 - 2) - 2</code> and <code>2 - (2 - 2)</code>. As you can see, the expression \"2 - 2\" is being evaluated repeatedly, even though the instances do not share the same indices.</p>\n<p>To memoize this, we need to store the substring itself as the state of the sub-problem. This can be achieved by using a map with the substring as the key and the list of results as the value. Whenever we encounter the same substring, we can return the result from the map.</p>\n<p>While this approach leads us to identify and cache more sub-problems, it forces us to use substrings in our recursion. In an interview setting, you can highlight both approaches and discuss their advantages and disadvantages for extra credit.</p>\n</blockquote>\n<h4 id=\"algorithm-1\">Algorithm</h4>\n<p>Main method <code>diffWaysToCompute</code>:</p>\n<ul>\n<li>Initialize a 2D array <code>memo</code> to store computed results for sub-expressions.</li>\n<li>Call the <code>computeResults</code> method with the full expression range and return the result.</li>\n</ul>\n<p>Helper method <code>computeResults(expression, memo, start, end)</code>:</p>\n<ul>\n<li>Check if the result for the range <code>[start, end]</code> is memoized. If so, return the memoized result.</li>\n<li>Initialize a list <code>results</code> to store computed values for the current sub-expression.</li>\n<li>Check if the current range is a single digit:\n<ul>\n<li>\n<ul>\n<li>If so, convert <code>expression</code> to an integer and add it to <code>results</code>.</li>\n</ul>\n</li>\n<li>Return <code>results</code>.</li>\n</ul>\n</li>\n<li>Check if the current range is a two-digit number:\n<ul>\n<li>If so, compute its value and add it to <code>results</code>.</li>\n<li>Return <code>results</code>.</li>\n</ul>\n</li>\n<li>Iterate through each character in the current range of the expression:\n<ul>\n<li>Skip the current iteration if the character is a digit.</li>\n<li>Recursively call <code>computeResults</code> for the left part of the expression up to the current character (from <code>start</code> to <code>i-1</code>). Store the result in <code>leftResults</code>.</li>\n<li>Recursively call <code>computeResults</code> for the right part of the expression after the current character (from <code>i+1</code> to <code>end</code>). Store the result in <code>rightResults</code>.</li>\n<li>Iterate through each <code>leftValue</code> in the <code>leftResults</code>:\n<ul>\n<li>For each <code>leftValue</code>, iterate through each <code>rightValue</code> in <code>rightResults</code>:\n<ul>\n<li>Perform the operation (addition, subtraction, or multiplication) based on the current character.</li>\n<li>Add the computed result to the <code>results</code> list.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Store the result in <code>memo</code> for the range <code>[start, end]</code>.</li>\n</ul>\n</li>\n<li>Return the <code>results</code> list.</li>\n</ul>\n<h4 id=\"implementation-1\">Implementation</h4>\n<pre><code>class Solution {\npublic:\n    vector&lt;int&gt; diffWaysToCompute(string expression) {\n        // Initialize memoization vector to store results of subproblems\n        vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; memo(\n            expression.length(), vector&lt;vector&lt;int&gt;&gt;(expression.length()));\n        // Solve for the entire expression\n        return computeResults(expression, memo, 0, expression.length() - 1);\n    }\n​\nprivate:\n    vector&lt;int&gt; computeResults(string&amp; expression,\n                               vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt;&amp; memo, int start,\n                               int end) {\n        // If result is already memoized, return it\n        if (!memo[start][end].empty()) {\n            return memo[start][end];\n        }\n​\n        vector&lt;int&gt; results;\n​\n        // Base case: single digit\n        if (start == end) {\n            results.push_back(expression[start] - '0');\n            return results;\n        }\n​\n        // Base case: two-digit number\n        if (end - start == 1 &amp;&amp; isdigit(expression[start])) {\n            int tens = expression[start] - '0';\n            int ones = expression[end] - '0';\n            results.push_back(10 * tens + ones);\n            return results;\n        }\n​\n        // Recursive case: split the expression at each operator\n        for (int i = start; i &lt;= end; i++) {\n            char currentChar = expression[i];\n            if (isdigit(currentChar)) {\n                continue;\n            }\n​\n            vector&lt;int&gt; leftResults =\n                computeResults(expression, memo, start, i - 1);\n            vector&lt;int&gt; rightResults =\n                computeResults(expression, memo, i + 1, end);\n​\n            // Combine results from left and right subexpressions\n            for (int leftValue : leftResults) {\n                for (int rightValue : rightResults) {\n                    switch (currentChar) {\n                        case '+':\n                            results.push_back(leftValue + rightValue);\n                            break;\n                        case '-':\n                            results.push_back(leftValue - rightValue);\n                            break;\n                        case '*':\n                            results.push_back(leftValue * rightValue);\n                            break;\n                    }\n                }\n            }\n        }\n​\n        // Memoize the result for this subproblem\n        memo[start][end] = results;\n​\n        return results;\n    }\n};</code></pre>\n<h4 id=\"complexity-analysis-1\">Complexity Analysis</h4>\n<p>Let <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></span> be the the length of the input string <code>expression</code>.</p>\n<ul>\n<li>\n<p>Time complexity: <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.6644em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p>The algorithm uses memoization to store the results of sub-problems, ensuring that each sub-problem is evaluated exactly once. There are at most <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1.0641em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.8141em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span> possible sub-problems, as each sub-problem is defined by its start and end indices, both ranging from <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6444em;\"></span><span class=\"mord\">0</span></span></span></span></span> to <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6667em; vertical-align: -0.0833em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.6444em;\"></span><span class=\"mord\">1</span></span></span></span></span>.</p>\n<p>Despite the efficiency gains from memoization, the time complexity is still dominated by the recursive nature of the algorithm. The recursion tree expands exponentially, with a growth factor of <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.6644em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n<p>Thus, the overall time complexity remains <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.6644em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n</li>\n<li>\n<p>Space complexity: <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1.0641em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.8141em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.6644em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p>The space complexity is <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1.0641em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.8141em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.6644em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span>, where <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1.0641em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.8141em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span> comes from the memoization table storing results for all sub-problems, and <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.6644em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span> accounts for the space required to store the exponentially growing number of results for each sub-problem. The recursion stack depth is at most <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span>, which is dominated by the exponential complexity and can therefore be omitted from the overall space complexity analysis.</p>\n</li>\n</ul>\n<hr/>\n<h3 class=\"group/heading relative\" id=\"approach-3-tabulation\" level=\"3\"><a aria-hidden=\"true\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" href=\"#approach-3-tabulation\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" data-icon=\"link\" data-prefix=\"fas\" focusable=\"false\" role=\"img\" spacing=\"square\" viewbox=\"0 0 640 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\" fill=\"currentColor\"></path></svg></div></a>Approach 3: Tabulation</h3>\n<h4 id=\"intuition-2\">Intuition</h4>\n<p>Recursive solutions can use up a lot of stack space, which might lead to stack overflow errors. To avoid this, we'll switch to an iterative approach and build our solution step by step.</p>\n<p>We’ll use a 2-D array, called <code>dp</code>, to keep track of intermediate results. This table will have dimensions <code>n x n</code>, where <code>n</code> is the length of our input <code>expression</code>. Each cell <code>dp[i][j]</code> will store all possible results for the sub-expression starting at index <code>i</code> and ending at index <code>j</code>. For instance, <code>dp[0][2]</code> will hold all possible results for the first three characters of the expression.</p>\n<p>First, we need to fill in our base cases. We loop through the <code>expression</code> to identify all single-digit and double-digit numbers.</p>\n<ol>\n<li data-length=\"1\">For single-digit numbers, add the digit's value to <code>dp[i][i]</code>.</li>\n<li data-length=\"1\">For double-digit numbers, add the number's value to <code>dp[i][i+1]</code>.</li>\n</ol>\n<p>Next, we handle longer sub-expressions. We start with lengths of 3 and go up to the length of the <code>expression</code>. For each length, we consider all possible starting points in the expression. This double loop structure ensures we consider all possible substrings of <code>expression</code>. For each sub-expression, we try different ways to split it. We go through each character and, when we find an operator, split the expression at that point. We then combine the results from the left and right parts using the operator.</p>\n<p>After we've filled our entire <code>dp</code> table, the cell <code>dp[0][n-1]</code> contains all possible results for the entire expression. We can return this list as our final answer.</p>\n<h4 id=\"algorithm-2\">Algorithm</h4>\n<p>Main method <code>diffWaysToCompute</code>:</p>\n<ul>\n<li>Initialize a variable <code>n</code> to store the length of the input string <code>expression</code>.</li>\n<li>Create a 2D array <code>dp</code> of lists to store the results of sub-problems.</li>\n<li>Initialize the base cases using the <code>initializeBaseCases</code> method.</li>\n<li>Iterate through all possible sub-expression lengths, starting from <code>3</code> up to <code>n</code>.\n<ul>\n<li>For each length, iterate through all possible <code>start</code> positions of the sub-expression.</li>\n<li>Set <code>end</code> as <code>start + length - 1</code>.</li>\n<li>Calculate the results for the sub-expression <code>[start, end]</code> using the <code>processSubexpression</code> method.</li>\n</ul>\n</li>\n<li>Return <code>dp[0][n-1]</code>, which contains all possible results for the entire <code>expression</code>.</li>\n</ul>\n<p>Helper method <code>initializeBaseCases(expression, dp)</code>:</p>\n<ul>\n<li>Initialize the <code>dp</code> array.</li>\n<li>Handle base cases by iterating through the <code>expression</code>:\n<ul>\n<li>For single digits, add the digit value to <code>dp[i][i]</code>.</li>\n<li>For two-digit numbers, add the number value to <code>dp[i][i+1]</code>.</li>\n</ul>\n</li>\n</ul>\n<p>Helper method <code>processSubexpression(expression, dp, start, end)</code>:</p>\n<ul>\n<li>Try all possible <code>split</code> positions from <code>start</code> to <code>end</code>:\n<ul>\n<li>If the character is numeric, continue to the next iteration</li>\n<li>If not, retrieve the results of the left sub-expression from <code>dp[start][split-1]</code> and assign it to <code>leftResults</code>.</li>\n<li>Retrieve the results of the right sub-expression from <code>dp[split+1][end]</code> and assign it to <code>rightResults</code>.</li>\n<li>Call <code>computeResults</code> with <code>leftResults</code>, <code>rightResults</code>, and the operator at the <code>split</code> position.</li>\n</ul>\n</li>\n</ul>\n<p>Helper method <code>computeResults(op, leftResults, rightResults, results)</code>:</p>\n<ul>\n<li>For each combination of <code>leftResults</code> and <code>rightResults</code>:\n<ul>\n<li>Perform the operation specified by <code>op</code>.</li>\n<li>Add the result to <code>results</code>.</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"implementation-2\">Implementation</h4>\n<pre><code>class Solution {\npublic:\n    vector&lt;int&gt; diffWaysToCompute(string expression) {\n        int n = expression.length();\n        // Create a 2D array of lists to store results of subproblems\n        vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; dp(n, vector&lt;vector&lt;int&gt;&gt;(n));\n​\n        initializeBaseCases(expression, dp);\n​\n        // Fill the dp table for all possible subexpressions\n        for (int length = 3; length &lt;= n; length++) {\n            for (int start = 0; start + length - 1 &lt; n; start++) {\n                int end = start + length - 1;\n                processSubexpression(expression, dp, start, end);\n            }\n        }\n​\n        // Return the results for the entire expression\n        return dp[0][n - 1];\n    }\n​\nprivate:\n    void initializeBaseCases(string&amp; expression,\n                             vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt;&amp; dp) {\n        int n = expression.length();\n        // Handle base cases: single digits and two-digit numbers\n        for (int i = 0; i &lt; n; i++) {\n            if (isdigit(expression[i])) {\n                // Check if it's a two-digit number\n                int dig1 = expression[i] - '0';\n                if (i + 1 &lt; n &amp;&amp; isdigit(expression[i + 1])) {\n                    int dig2 = expression[i + 1] - '0';\n                    int number = dig1 * 10 + dig2;\n                    dp[i][i + 1].push_back(number);\n                }\n                // Single digit case\n                dp[i][i].push_back(dig1);\n            }\n        }\n    }\n​\n    void processSubexpression(string&amp; expression,\n                              vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt;&amp; dp, int start,\n                              int end) {\n        // Try all possible positions to split the expression\n        for (int split = start; split &lt;= end; split++) {\n            if (isdigit(expression[split])) continue;\n​\n            vector&lt;int&gt; leftResults = dp[start][split - 1];\n            vector&lt;int&gt; rightResults = dp[split + 1][end];\n​\n            computeResults(expression[split], leftResults, rightResults,\n                           dp[start][end]);\n        }\n    }\n​\n    void computeResults(char op, vector&lt;int&gt;&amp; leftResults,\n                        vector&lt;int&gt;&amp; rightResults, vector&lt;int&gt;&amp; results) {\n        // Compute results based on the operator at position 'split'\n        for (int leftValue : leftResults) {\n            for (int rightValue : rightResults) {\n                switch (op) {\n                    case '+':\n                        results.push_back(leftValue + rightValue);\n                        break;\n                    case '-':\n                        results.push_back(leftValue - rightValue);\n                        break;\n                    case '*':\n                        results.push_back(leftValue * rightValue);\n                        break;\n                }\n            }\n        }\n    }\n};</code></pre>\n<h4 id=\"complexity-analysis-2\">Complexity Analysis</h4>\n<p>Let <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></span> be the the length of the input string <code>expression</code>.</p>\n<ul>\n<li>\n<p>Time complexity: <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.6644em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p>Similar to the memoization approach, the algorithm evaluates each sub-problem exactly once. Thus, the time complexity remains the same as Approach 2: <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.6644em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n</li>\n<li>\n<p>Space complexity: <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1.0641em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.8141em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.6644em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p>The space complexity is similar to the previous approach, with one key difference: the absence of the recursive stack space.</p>\n<p>However, the <code>dp</code> table dominates the space complexity anyway, keeping the overall space complexity as <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1.0641em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.8141em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.6644em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n</li>\n</ul>\n<hr/></div><span style=\"font-size: 0px; line-height: 0;\"> </span></div>"}