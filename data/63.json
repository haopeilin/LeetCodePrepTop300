{"id":"63","title":"Unique Paths II","difficulty":"Medium","content":"<p>You are given an <code>m x n</code> integer array <code>grid</code>. There is a robot initially located at the <b>top-left corner</b> (i.e., <code>grid[0][0]</code>). The robot tries to move to the <strong>bottom-right corner</strong> (i.e., <code>grid[m - 1][n - 1]</code>). The robot can only move either down or right at any point in time.</p>\n\n<p>An obstacle and space are marked as <code>1</code> or <code>0</code> respectively in <code>grid</code>. A path that the robot takes cannot include <strong>any</strong> square that is an obstacle.</p>\n\n<p>Return <em>the number of possible unique paths that the robot can take to reach the bottom-right corner</em>.</p>\n\n<p>The testcases are generated so that the answer will be less than or equal to <code>2 * 10<sup>9</sup></code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/04/robot1.jpg\" style=\"width: 242px; height: 242px;\" />\n<pre>\n<strong>Input:</strong> obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> There is one obstacle in the middle of the 3x3 grid above.\nThere are two ways to reach the bottom-right corner:\n1. Right -&gt; Right -&gt; Down -&gt; Down\n2. Down -&gt; Down -&gt; Right -&gt; Right\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/04/robot2.jpg\" style=\"width: 162px; height: 162px;\" />\n<pre>\n<strong>Input:</strong> obstacleGrid = [[0,1],[0,0]]\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == obstacleGrid.length</code></li>\n\t<li><code>n == obstacleGrid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 100</code></li>\n\t<li><code>obstacleGrid[i][j]</code> is <code>0</code> or <code>1</code>.</li>\n</ul>\n","tags":["Array","Dynamic Programming","Matrix"],"java_snippet":"class Solution {\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\n        \n    }\n}","solution":"<div class=\"flex flex-col w-full\" style=\"position: relative;\"><div class=\"mYe_l WRmCx\"><h2 class=\"group/heading relative\" id=\"solution\" level=\"2\"><a aria-hidden=\"true\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" href=\"#solution\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" data-icon=\"link\" data-prefix=\"fas\" focusable=\"false\" role=\"img\" spacing=\"square\" viewbox=\"0 0 640 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\" fill=\"currentColor\"></path></svg></div></a>Solution</h2>\n<hr/>\n<h3 class=\"group/heading relative\" id=\"approach-1-dynamic-programming\" level=\"3\"><a aria-hidden=\"true\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" href=\"#approach-1-dynamic-programming\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" data-icon=\"link\" data-prefix=\"fas\" focusable=\"false\" role=\"img\" spacing=\"square\" viewbox=\"0 0 640 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\" fill=\"currentColor\"></path></svg></div></a>Approach 1: Dynamic Programming</h3>\n<p><strong>Intuition</strong></p>\n<p>The robot can only move either down or right.<br/>\nHence any cell in the first row can only be reached from the cell left to it.</p>\n<p></p>\n<p>And, any cell in the first column can only be reached from the cell above it.</p>\n<p></p>\n<p>For any other cell in the grid, we can reach it either from the cell to left of it or the cell above it.</p>\n<p>If any cell has an obstacle, we won't let that cell contribute to any path.</p>\n<p>We will be iterating the array from left-to-right and top-to-bottom. Thus, before reaching any cell we would have the number of ways of reaching the predecessor cells. This is what makes it a <code>Dynamic Programming</code> problem. We will be using the <code>obstacleGrid</code> array as the DP array thus not utilizing any additional space.</p>\n<p><code>Note:</code> As per the question, cell with an obstacle has a value <code>1</code>. We would use this value to make sure if a cell needs to be included in the path or not. After that we can use the same cell to store the number of ways to reach that cell.</p>\n<p><strong>Algorithm</strong></p>\n<ol>\n<li data-length=\"1\">If the first cell i.e. <code>obstacleGrid[0,0]</code> contains <code>1</code>, this means there is an obstacle in the first cell. Hence the robot won't be able to make any move and we would return the number of ways as <code>0</code>.</li>\n<li data-length=\"1\">Otherwise, if <code>obstacleGrid[0,0]</code> has a <code>0</code> originally we set it to <code>1</code> and move ahead.</li>\n<li data-length=\"1\">Iterate the first row. If a cell originally contains a <code>1</code>, this means the current cell has an obstacle and shouldn't contribute to any path. Hence, set the value of that cell to <code>0</code>. Otherwise, set it to the value of previous cell i.e. <code>obstacleGrid[i,j] = obstacleGrid[i,j-1]</code></li>\n<li data-length=\"1\">Iterate the first column. If a cell originally contains a <code>1</code>, this means the current cell has an obstacle and shouldn't contribute to any path. Hence, set the value of that cell to <code>0</code>. Otherwise, set it to the value of previous cell i.e. <code>obstacleGrid[i,j] = obstacleGrid[i-1,j]</code></li>\n<li data-length=\"1\">Now, iterate through the array starting from cell <code>obstacleGrid[1,1]</code>. If a cell originally doesn't contain any obstacle then the number of ways of reaching that cell would be the sum of number of ways of reaching the cell above it and number of ways of reaching the cell to the left of it.\n <pre> obstacleGrid[i,j] = obstacleGrid[i-1,j] + obstacleGrid[i,j-1]</pre>\n</li>\n<li data-length=\"1\">If a cell contains an obstacle set it to <code>0</code> and continue. This is done to make sure it doesn't contribute to any other path.</li>\n</ol>\n<p>Following is the animation to explain the algorithm's steps:</p>\n<p></p>\n<br/>\n<pre><code>class Solution {\npublic:\n    int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) {\n        int R = obstacleGrid.size();\n        int C = obstacleGrid[0].size();\n        // If the starting cell has an obstacle, then simply return as there\n        // would be no paths to the destination.\n        if (obstacleGrid[0][0] == 1) {\n            return 0;\n        }\n        // Number of ways of reaching the starting cell = 1.\n        obstacleGrid[0][0] = 1;\n        // Filling the values for the first column\n        for (int i = 1; i &lt; R; i++) {\n            obstacleGrid[i][0] =\n                (obstacleGrid[i][0] == 0 &amp;&amp; obstacleGrid[i - 1][0] == 1) ? 1\n                                                                         : 0;\n        }\n        // Filling the values for the first row\n        for (int i = 1; i &lt; C; i++) {\n            obstacleGrid[0][i] =\n                (obstacleGrid[0][i] == 0 &amp;&amp; obstacleGrid[0][i - 1] == 1) ? 1\n                                                                         : 0;\n        }\n        // Starting from cell(1,1) fill up the values\n        // No. of ways of reaching cell[i][j] = cell[i - 1][j] + cell[i][j - 1]\n        // i.e. From above and left.\n        for (int i = 1; i &lt; R; i++) {\n            for (int j = 1; j &lt; C; j++) {\n                if (obstacleGrid[i][j] == 0) {\n                    obstacleGrid[i][j] =\n                        obstacleGrid[i - 1][j] + obstacleGrid[i][j - 1];\n                } else {\n                    obstacleGrid[i][j] = 0;\n                }\n            }\n        }\n        // Return value stored in rightmost bottommost cell. That is the\n        // destination.\n        return obstacleGrid[R - 1][C - 1];\n    }\n};</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time Complexity: <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span></span>. The rectangular grid given to us is of size <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.7667em; vertical-align: -0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span></span></span></span></span> and we process each cell just once.</li>\n<li>Space Complexity: <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></span>. We are utilizing the <code>obstacleGrid</code> as the DP array. Hence, no extra space.</li>\n</ul>\n<p><br/><br/></p></div><span style=\"font-size: 0px; line-height: 0;\"> </span></div>"}