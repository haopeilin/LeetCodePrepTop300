{"id":"137","title":"Single Number II","difficulty":"Medium","content":"<p>Given an integer array <code>nums</code> where&nbsp;every element appears <strong>three times</strong> except for one, which appears <strong>exactly once</strong>. <em>Find the single element and return it</em>.</p>\n\n<p>You must&nbsp;implement a solution with a linear runtime complexity and use&nbsp;only constant&nbsp;extra space.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> nums = [2,2,3,2]\n<strong>Output:</strong> 3\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> nums = [0,1,0,1,0,1,99]\n<strong>Output:</strong> 99\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li>Each element in <code>nums</code> appears exactly <strong>three times</strong> except for one element which appears <strong>once</strong>.</li>\n</ul>\n","tags":["Array","Bit Manipulation"],"java_snippet":"class Solution {\n    public int singleNumber(int[] nums) {\n        \n    }\n}","solution":"<h2><a href=\"#solution\"><svg><path></path></svg></a>Solution</h2>\n<hr/>\n<h3><a href=\"#overview\"><svg><path></path></svg></a>Overview</h3>\n<p>We are given an integer array <code>nums</code> where</p>\n<ul>\n<li>one integer appears <strong>exactly once</strong> and</li>\n<li>all the other integers appear <strong>exactly three times</strong>.</li>\n</ul>\n<p>We are supposed to find the lone integer and return it. For complexity analysis, we will use N to denote the length of <code>nums</code>.</p>\n<p>The problem description expects us to come up with an algorithm with linear time complexity and constant space complexity. In other words, the time complexity should be O(N), and the space complexity should be O(1).</p>\n<p>The very naïve approach is to count the frequency of every integer in <code>nums</code>. If the frequency of any integer is 1, we can return it. It will take O(N<sup>2</sup>) time and hence is slow.</p>\nPseudocode<svg><path></path></svg>\n<p>The article presents a diverse set of approaches to solving this problem. Approaches from <a href=\"#approach-4-bit-manipulation\">Approach 4</a> onwards satisfy both the time and space complexity requirements asked for in the problem description. Readers can jump to <a href=\"#approach-4-bit-manipulation\">Approach 4</a> directly if they are only interested in the O(N) time and O(1) space complexity solution.</p>\n<hr/>\n<h3><a href=\"#approach-1-sorting\"><svg><path></path></svg></a>Approach 1: Sorting</h3>\n<h4>Intuition</h4>\n<p>Let <code>nums</code> be <code>[20, .........., 20, 20]</code>. To conclude <code>20</code> is not the loner, if we follow the naïve approach given in the <a href=\"#overview\">Overview</a> section, we have to traverse till the very end of the array.</p>\n<p>What if all <code>20</code>s were clustered together? Then we can compare the first occurrence of <code>20</code> with the element present at the next index. If they are the same, we can conclude that <code>20</code> is not the loner. We don't need to traverse till the very end of the array.</p>\n<p>The integers can be clustered together by <a href=\"https://leetcode.com/explore/learn/card/sorting/\">sorting</a> the array.</p>\n<p>After sorting, we can <strong>check every integer with its next integer</strong> starting from the zeroth index.</p>\n<ul>\n<li>\n<p>If they are the same, we can conclude that the integer is not the loner. We will jump three indices ahead. This is because we are given that <strong>if an integer is not the loner, it appears exactly three times</strong>. So, we can skip the next two indices.</p>\n</li>\n<li>\n<p>Otherwise, we can conclude that the integer is the loner. We will return it.</p>\n</li>\n</ul>\n<p>Now, the last index doesn't have any next index. Thus, if till the last index, we don't find any loner, we can conclude that the last integer is the loner because <code>nums</code> has exactly one loner.</p>\n<h4>Algorithm</h4>\n<ol>\n<li>\n<p>Sort the array <code>nums</code>.</p>\n</li>\n<li>\n<p>Iterate using the <code>for</code> loop from index <code>0</code> to index <code>nums.length - 2</code> (both inclusive) with a step size of <code>3</code>. All these indices will have a next index.</p>\n<ul>\n<li>\n<p>If the integer at the current index is the same as the integer at the next index, then continue to the next iteration. This can be checked by <code>nums[i] == nums[i + 1]</code>.</p>\n</li>\n<li>\n<p>Otherwise, return the integer at the current index.</p>\n</li>\n</ul>\n</li>\n<li>\n<p>Return the integer at the last index, which is <code>nums[nums.length - 1]</code>.</p>\n</li>\n</ol>\n<h4>Implementation</h4>\n<pre><code>class Solution {\n    public int singleNumber(int[] nums) {\n        Arrays.sort(nums);\n        for (int i = 0; i &lt; nums.length - 1; i += 3) {\n            if (nums[i] == nums[i + 1]) {\n                continue;\n            } else {\n                return nums[i];\n            }\n        }\n        return nums[nums.length - 1];\n    }\n}</code></pre>\n<h4>Complexity Analysis</h4>\n<p>Let N be the length of <code>nums</code></p>\n<ul>\n<li>\n<p>Time complexity: O(NlogN)</p>\n<p>Sorting can be optimally done in O(NlogN) time.</p>\n<p>After sorting, we are traversing the array once. It may take O(N) time.</p>\n<p>Thus, the overall time complexity is O(N+NlogN) which is O(NlogN).</p>\n</li>\n<li>\n<p>Space complexity: O(N).</p>\n<p>It depends on the sorting algorithm. Depending on the programming language, sorting algorithms may need O(N) or O(logN) space.</p>\n</li>\n</ul>\n<hr/>\n<h3><a href=\"#approach-2-hash-map\"><svg><path></path></svg></a>Approach 2: Hash Map</h3>\n<h4>Intuition</h4>\n<p>The naïve approach discussed in the <a href=\"#overview\">Overview</a> was based on counting the frequency of integers. It turns out we can use a <strong>counter</strong> to count and store the frequency of integers.</p>\n<blockquote>\n<p><strong>Counter</strong> is a key-value pair where the key is the element and the value is the frequency of the element in a sequence.</p>\n<p>The following diagram illustrates the counter of an arbitrary array. It is not <code>nums</code> because <code>nums</code> can have only two frequencies: 1 and 3.</p>\n<p></p>\n</blockquote>\n<br/>\n<p>We can build a counter from <code>nums</code> and then iterate over it to find the loner.</p>\n<blockquote>\n<p>Counter can be built in O(N) time using a hash map. Iterate over the array</p>\n<ul>\n<li>If this is the first occurrence of the integer, then save it in the counter as a key, with value as 1.</li>\n<li>Otherwise, increment the value of the key by 1.</li>\n</ul>\n</blockquote>\n<p>Then we can iterate over the counter to find the key which has a value of 1.</p>\n<h4>Algorithm</h4>\n<ol>\n<li>\n<p>Initialize a key-value pair <code>freq</code>. Its key will be the integer and its value will be the frequency of the integer in <code>nums</code>.</p>\n</li>\n<li>\n<p>Iterate over <code>nums</code> using the <code>for</code> loop.</p>\n<ul>\n<li>\n<p>If this is the first occurrence of the integer, then save it in <code>freq</code> as the key, with value as 1.</p>\n</li>\n<li>\n<p>Otherwise, increment the value of the key by 1.</p>\n</li>\n</ul>\n</li>\n<li>\n<p>Iterate over key-value pairs of <code>freq</code> using the <code>for</code> loop. If the value is 1, then return the key.</p>\n</li>\n</ol>\n<h4>Implementation</h4>\n<pre><code>class Solution {\n    public int singleNumber(int[] nums) {\n        Map<integer, integer=\"\"> freq = new HashMap&lt;&gt;();\n        for (int num : nums) {\n            freq.put(num, freq.getOrDefault(num, 0) + 1);\n        }\n\n        int loner = 0;\n        for (Map.Entry<integer, integer=\"\"> entry : freq.entrySet()) {\n            if (entry.getValue() == 1) {\n                loner = entry.getKey();\n                break;\n            }\n        }\n        return loner;\n    }\n}</integer,></integer,></code></pre>\n<p><strong>Note :</strong> Java offers a built-in class <code>HashMap</code> to build a counter.</p>\n<h4>Complexity Analysis</h4>\n<p>Let N be the length of <code>nums</code></p>\n<ul>\n<li>\n<p>Time complexity: O(N)</p>\n<p>Building counter from <code>nums</code> can be done in O(N) time.</p>\n<p>Iterating over the counter can be done in O(N) time.</p>\n<p>Thus, overall time complexity is O(N+N) which is O(N).</p>\n</li>\n<li>\n<p>Space complexity: O(N).</p>\n<p>We are using a counter to store the frequency of integers. There will be approximately 3N such integers. So, the space complexity is O(3N) which is O(N).</p>\n</li>\n</ul>\n<hr/>\n<h3><a href=\"#approach-3-mathematics\"><svg><path></path></svg></a>Approach 3: Mathematics</h3>\n<h4>Intuition</h4>\n<p>Given an array, its set counterpart <code>num_set</code> will have all the integers of the array, but without duplicates.</p>\n<p>Let there be k integers that have three occurrences in the array. These integers can be enumerated as x1,x2,…,xk. Let y be the loner.</p>\n<p>Then, our <code>nums</code> will be [x1,x1,x1,x2,x2,x2,…,xk,xk,xk,y].</p>\n<p>And our <code>num_set</code> will be {x1,x2,…,xk,y}.</p>\n<p>The sum of the <code>num_set</code> will be<br/>\nSset=x1+x2+⋯+xk+y, or<br/>\nSset−y=x1+x2+⋯+xk</p>\n<p>The sum of <code>nums</code> will be<br/>\nSnums=3x1+3x2+⋯+3xk+y<br/>\nSnums=3(Sset−y)+y<br/>\nSnums=3Sset−2y</p>\n<p>Therfore, our loner y will be<br/>\ny=(3Sset−Snums)/2</p>\n<p>And hence we can find the loner!</p>\n<h4>Algorithm</h4>\n<ol>\n<li>\n<p>Prepare a set from <code>nums</code>. Let's call it <code>nums_set</code>.</p>\n</li>\n<li>\n<p>Compute the sum of <code>nums_set</code>. Let's call it <code>s_set</code>.</p>\n</li>\n<li>\n<p>Compute sum of <code>nums</code>. Let's call it <code>s_nums</code>.</p>\n</li>\n<li>\n<p>Return <code>((3 * s_set) - s_nums) / 2</code>. This is backed by the mathematical proof above.</p>\n</li>\n</ol>\n<h4>Implementation</h4>\n<pre><code>class Solution {\n    public int singleNumber(int[] nums) {\n        Set<long> numsSet = new HashSet&lt;&gt;();\n        long sumNums = 0;\n        for (int num : nums) {\n            numsSet.add((long) num);\n            sumNums += num;\n        }\n\n        long sumSet = 0;\n        for (long num : numsSet) {\n            sumSet += num;\n        }\n\n        return (int) ((3 * sumSet - sumNums) / 2);\n    }\n}</long></code></pre>\n<p><strong>Implementation Note:</strong> Observe constraints given in the problem description carefully.</p>\n<p>It is given that the integers are in the range [−2<sup>31</sup>,2<sup>31</sup>−1]. So, the sum of integers can be very large. Thus, we need to use <code>long</code> to avoid integer overflow.</p>\n<p>Also, all previous approaches can be used if instead of integer, we have string or any other data type. But this approach can only be used if we have integers since we are using mathematical operations.</p>\n<h4>Complexity Analysis</h4>\n<p>Let N be the length of <code>nums</code></p>\n<ul>\n<li>\n<p>Time complexity: O(N)</p>\n</li>\n<li>\n<p>Space complexity: O(N).</p>\n</li>\n</ul>\n<hr/>\n<h3><a href=\"#approach-4-bit-manipulation\"><svg><path></path></svg></a>Approach 4: Bit Manipulation</h3>\n<h4>Implementation</h4>\n<pre><code>class Solution {\n    public int singleNumber(int[] nums) {\n        int loner = 0;\n        for (int shift = 0; shift &lt; 32; shift++) {\n            int bitSum = 0;\n            for (int num : nums) {\n                bitSum += (num &gt;&gt; shift) &amp; 1;\n            }\n            int lonerBit = bitSum % 3;\n            loner |= (lonerBit &lt;&lt; shift);\n        }\n        return loner;\n    }\n}</code></pre>\n<hr/>\n<h3><a href=\"#approach-5-equation-for-bitmask\"><svg><path></path></svg></a>Approach 5: Equation for Bitmask</h3>\n<h4>Implementation</h4>\n<pre><code>class Solution {\n    public int singleNumber(int[] nums) {\n        int seenOnce = 0, seenTwice = 0;\n        for (int num : nums) {\n            seenOnce = (seenOnce ^ num) &amp; (~seenTwice);\n            seenTwice = (seenTwice ^ num) &amp; (~seenOnce);\n        }\n        return seenOnce;\n    }\n}</code></pre>\n<p><strong>Implementation Notes:</strong> Different programming languages have different notations of bitwise operators. For example, for the bitwise NOT operator, Java uses <code>~</code>.</p>\n<hr/>\n<h3><a href=\"#approach-6-boolean-algebra-and-karnaugh-map\"><svg><path></path></svg></a>Approach 6: Boolean Algebra and Karnaugh Map</h3>\n<h4>Implementation</h4>\n<pre><code>class Solution {\n    public int singleNumber(int[] nums) {\n        int msb = 0, lsb = 0;\n        for (int num : nums) {\n            int new_lsb = (~msb &amp; ~lsb &amp; num) | (lsb &amp; ~num);\n            int new_msb = (lsb &amp; num) | (msb &amp; ~num);\n            lsb = new_lsb;\n            msb = new_msb;\n        }\n        return lsb;\n    }\n}</code></pre>\n<hr/>"}