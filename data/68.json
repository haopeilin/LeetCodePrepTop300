{"id":"68","title":"Text Justification","difficulty":"Hard","content":"<p>Given an array of strings <code>words</code> and a width <code>maxWidth</code>, format the text such that each line has exactly <code>maxWidth</code> characters and is fully (left and right) justified.</p>\n\n<p>You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces <code>&#39; &#39;</code> when necessary so that each line has exactly <code>maxWidth</code> characters.</p>\n\n<p>Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line does not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.</p>\n\n<p>For the last line of text, it should be left-justified, and no extra space is inserted between words.</p>\n\n<p><strong>Note:</strong></p>\n\n<ul>\n\t<li>A word is defined as a character sequence consisting of non-space characters only.</li>\n\t<li>Each word&#39;s length is guaranteed to be greater than <code>0</code> and not exceed <code>maxWidth</code>.</li>\n\t<li>The input array <code>words</code> contains at least one word.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;This&quot;, &quot;is&quot;, &quot;an&quot;, &quot;example&quot;, &quot;of&quot;, &quot;text&quot;, &quot;justification.&quot;], maxWidth = 16\n<strong>Output:</strong>\n[\n&nbsp; &nbsp;&quot;This &nbsp; &nbsp;is &nbsp; &nbsp;an&quot;,\n&nbsp; &nbsp;&quot;example &nbsp;of text&quot;,\n&nbsp; &nbsp;&quot;justification. &nbsp;&quot;\n]</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;What&quot;,&quot;must&quot;,&quot;be&quot;,&quot;acknowledgment&quot;,&quot;shall&quot;,&quot;be&quot;], maxWidth = 16\n<strong>Output:</strong>\n[\n&nbsp; &quot;What &nbsp; must &nbsp; be&quot;,\n&nbsp; &quot;acknowledgment &nbsp;&quot;,\n&nbsp; &quot;shall be &nbsp; &nbsp; &nbsp; &nbsp;&quot;\n]\n<strong>Explanation:</strong> Note that the last line is &quot;shall be    &quot; instead of &quot;shall     be&quot;, because the last line must be left-justified instead of fully-justified.\nNote that the second line is also left-justified because it contains only one word.</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;Science&quot;,&quot;is&quot;,&quot;what&quot;,&quot;we&quot;,&quot;understand&quot;,&quot;well&quot;,&quot;enough&quot;,&quot;to&quot;,&quot;explain&quot;,&quot;to&quot;,&quot;a&quot;,&quot;computer.&quot;,&quot;Art&quot;,&quot;is&quot;,&quot;everything&quot;,&quot;else&quot;,&quot;we&quot;,&quot;do&quot;], maxWidth = 20\n<strong>Output:</strong>\n[\n&nbsp; &quot;Science &nbsp;is &nbsp;what we&quot;,\n  &quot;understand &nbsp; &nbsp; &nbsp;well&quot;,\n&nbsp; &quot;enough to explain to&quot;,\n&nbsp; &quot;a &nbsp;computer. &nbsp;Art is&quot;,\n&nbsp; &quot;everything &nbsp;else &nbsp;we&quot;,\n&nbsp; &quot;do &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&quot;\n]</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 300</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 20</code></li>\n\t<li><code>words[i]</code> consists of only English letters and symbols.</li>\n\t<li><code>1 &lt;= maxWidth &lt;= 100</code></li>\n\t<li><code>words[i].length &lt;= maxWidth</code></li>\n</ul>\n","tags":["Array","String","Simulation"],"java_snippet":"class Solution {\n    public List<String> fullJustify(String[] words, int maxWidth) {\n        \n    }\n}","solution":"<div class=\"flex flex-col w-full\" style=\"position: relative;\"><div class=\"mYe_l WRmCx\"><h2 class=\"group/heading relative\" id=\"solution\" level=\"2\"><a aria-hidden=\"true\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" href=\"#solution\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" data-icon=\"link\" data-prefix=\"fas\" focusable=\"false\" role=\"img\" spacing=\"square\" viewbox=\"0 0 640 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\" fill=\"currentColor\"></path></svg></div></a>Solution</h2>\n<hr/>\n<h3 class=\"group/heading relative\" id=\"overview\" level=\"3\"><a aria-hidden=\"true\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" href=\"#overview\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" data-icon=\"link\" data-prefix=\"fas\" focusable=\"false\" role=\"img\" spacing=\"square\" viewbox=\"0 0 640 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\" fill=\"currentColor\"></path></svg></div></a>Overview</h3>\n<p>Unlike most problems on LeetCode, this is one that can be solved by just doing exactly what the problem statement is telling us to do.</p>\n<p>You don't need any data structures or algorithmic tricks to solve this problem. The point of this problem is to test your ability to quickly write clean code while navigating edge cases.</p>\n<p>The solution we will present in this article is only one of many ways to approach this problem.</p>\n<hr/>\n<h3 class=\"group/heading relative\" id=\"approach\" level=\"3\"><a aria-hidden=\"true\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" href=\"#approach\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" data-icon=\"link\" data-prefix=\"fas\" focusable=\"false\" role=\"img\" spacing=\"square\" viewbox=\"0 0 640 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\" fill=\"currentColor\"></path></svg></div></a>Approach:</h3>\n<p><strong>Intuition</strong></p>\n<p>This problem falls into a class of problems that are rare on LeetCode - not algorithmic, but more representative of a real-life task. Another good example of a problem in this class is <a href=\"https://leetcode.com/problems/valid-number/\" target=\"_blank\">Valid Number</a>.</p>\n<p>These problems are more annoying than difficult because there are multiple moving parts that sometimes aren't really related to each other. It can be frustrating managing everything without running into errors.</p>\n<p>One of the most important principles in software engineering is <a href=\"https://en.wikipedia.org/wiki/Modular_programming\" target=\"_blank\">modularity</a>. We can increase modularity by splitting the overall problem into subtasks and then allocating sections of code (like with a helper function) to accomplish these subtasks independently.</p>\n<p>In this problem, a natural approach would be to create one line of length <code>maxWidth</code> at a time. We can split creating a line into two subtasks:</p>\n<ol>\n<li data-length=\"1\">Determine which words should be on the line.</li>\n<li data-length=\"1\">Take the words from the first task and create a line.</li>\n</ol>\n<p>We will look at these subtasks separately.</p>\n<hr/>\n<p><strong>Determine which words should be on a line</strong></p>\n<p>Let's create a helper method <code>getWords(int i)</code>. It takes an integer <code>i</code> that indicates the index of the first word in <code>words</code> that we are considering. It returns a list of words that will be included on a line. This list should be a subarray of <code>words</code> starting with <code>words[i]</code>. The problem description says to \"pack as many words as you can in each line\". Therefore, the length of this subarray should be maximized without the length of the line exceeding <code>maxWidth</code>.</p>\n<p>On a line, every word except the final one must be followed by a space. Therefore, each <code>word</code> contributes <code>word.length + 1</code> to the line's length, except for the final word. We want to add as many words as possible without exceeding <code>maxWidth</code>.</p>\n<p>Let's use an integer <code>currLength</code> to indicate the current minimum length of our line. To determine if we should add <code>words[i]</code> to the current line, we can check the condition: <code>currLength + words[i].length &lt;= maxWidth</code>. We don't need the <code>+ 1</code> in this condition because <code>words[i]</code> could be the final word, which doesn't need a space after it.</p>\n<p>If the condition passes, then we can add <code>words[i]</code> to the current line. We should increment <code>currLength</code> by <code>words[i].length + 1</code>.</p>\n<p>You may be thinking: why can we do the <code>+ 1</code> here? What if <code>words[i]</code> is the final word that can fit? Won't that <code>+ 1</code> be inaccurate since we aren't adding a space?</p>\n<p>The reason we can do <code>+ 1</code> here is that we aren't actually building the line yet. We are just trying to determine how many words can fit. Think about the above condition <code>currLength + words[i].length &lt;= maxWidth</code>, but with <code>words[i + 1]</code> instead. If we can add <code>words[i + 1]</code>, then there must have been a space after <code>words[i]</code>.</p>\n<blockquote>\n<p>The <code>+ 1</code> is necessary when we add <code>words[i]</code> to \"prepare\" the condition check for <code>words[i + 1]</code>.</p>\n</blockquote>\n<p>We can use a while loop to add words to the current line until adding another word would violate the condition.</p>\n<pre><code>vector&lt;string&gt; getWords(int i, vector&lt;string&gt;&amp; words, int maxWidth) {\n    vector&lt;string&gt; currentLine;\n    int currLength = 0;\n    while (i &lt; words.size() &amp;&amp; currLength + words[i].size() &lt;= maxWidth) {\n        currentLine.push_back(words[i]);\n        currLength += words[i].size() + 1;\n        i++;\n    }\n    return currentLine;\n}</code></pre>\n<hr/>\n<p><strong>Take the words from the first task and create a line</strong></p>\n<p>We have a list of words <code>line</code>. Now, we need to convert it to a string according to the problem description:</p>\n<ol>\n<li data-length=\"1\">The string must have a length of <code>maxWidth</code>. Use extra spaces to reach this length.</li>\n<li data-length=\"1\">The extra spaces should be distributed between the words as evenly as possible.</li>\n<li data-length=\"1\">If the number of extra spaces does not evenly divide between words, the words on the left should have more spaces than the ones on the right.</li>\n<li data-length=\"1\">The final line should only be left justified with only one space between words.</li>\n</ol>\n<p>The first step is to figure out how many extra spaces are needed to force the line to have a length of <code>maxWidth</code>.</p>\n<p>As we know from before, each <code>word</code> contributes <code>word[i].length + 1</code> to the line length except the last one, which only contributes <code>word[i].length</code>. The <code>+ 1</code> was due to the mandatory spaces between the words.</p>\n<p>We can start by finding this minimum <code>baseLength</code>. Iterate over the words in <code>line</code> and add <code>word.length + 1</code> for each word. To account for the final word not having a space after it, we can initialize <code>baseLength = -1</code>.</p>\n<p>Now that we know <code>baseLength</code>, we can find how many extra spaces we need as <code>extraSpaces = maxWidth - baseLength</code>.</p>\n<p>Next, we need to distribute <code>extraSpaces</code> evenly. Let's consider how many extra spaces should go after each word. Because the final word does not have any spaces after it, we set <code>wordCount = line.length - 1</code>. This is the number of words in the line that need spaces after it.</p>\n<p>To evenly distribute <code>extraSpaces</code>, we find the number of spaces between each word as <code>spacesPerWord = extraSpaces / wordCount</code> (floor division). The problem says that if <code>extraSpaces</code> does not evenly divide, then the leftover spaces should go to the leftmost words.</p>\n<p>We can find how many words on the left need an additional space by finding the remainder as <code>needsExtraSpaces = extraSpaces % wordCount</code> (modulo/remainder operator).</p>\n<p>We finally have all the information we need. Now we can add the spaces between the words. First, let's iterate over the <code>needsExtraSpaces</code> leftmost words and add a space <code>\" \"</code> to each string. Next, we iterate over all words except the last one and add <code>spacesPerWord</code> spaces to each string.</p>\n<p>Finally, don't forget about the mandatory space between each word - we can add that by joining the strings in <code>line</code> with <code>\" \"</code> as a delimiter.</p>\n<p>That's the full process for a normal line. But we have two special cases to handle as well. First, the final line is handled separately. Second, if a line contains only one word, it needs to be handled the same as the final line. This is because the only word is also the final word, and the process we described above makes it so that the final word does not have any spaces after it.</p>\n<p>Notice that we set <code>wordCount = line.length - 1</code> to ignore the final word. If a line has only one word, we would have <code>wordCount = 0</code>, and then run into division-by-zero when trying to calculate <code>spacesPerWord</code>.</p>\n<p>Before going through the full process, we first check if the line contains only one word or if we are dealing with the final line. We can check if we are dealing with the final line by checking if we have used all the words from the input.</p>\n<p>To check for this, we will define our helper function as: <code>createLine(string[] lines, int i)</code>. We will pass <code>i</code> which is an integer that we will use to go through the input. If <code>i == words.length</code>, that means we have iterated over all the words in the <code>getWords</code> helper function we designed above, and we know we are dealing with the last line.</p>\n<p>To deal with the special case, we can just join <code>line</code> with <code>\" \"</code> as a delimiter, and then add <code>extraSpaces</code> spaces at the end of the string. If <code>line</code> only has one string, then the delimiter-join will do nothing, and we just fill the string with spaces. If we are dealing with the last line which has multiple words, then the delimiter-join will put the mandatory space between each word, and then we fill the string with spaces to meet the length requirement.</p>\n<pre><code>string createLine(vector&lt;string&gt;&amp; line, int i, vector&lt;string&gt;&amp; words,\n                  int maxWidth) {\n    int baseLength = -1;\n    for (const string&amp; word : line) {\n        baseLength += word.size() + 1;\n    }\n    int extraSpaces = maxWidth - baseLength;\n    if (line.size() == 1 || i == words.size()) {\n        string res = join(line, \" \");\n        res += string(extraSpaces, ' ');\n        return res;\n    }\n    int wordCount = line.size() - 1;\n    int spacesPerWord = extraSpaces / wordCount;\n    int needsExtraSpace = extraSpaces % wordCount;\n    for (int j = 0; j &lt; needsExtraSpace; j++) {\n        line[j] += \" \";\n    }\n    for (int j = 0; j &lt; wordCount; j++) {\n        line[j] += string(spacesPerWord, ' ');\n    }\n    return join(line, \" \");\n}\nstring join(vector&lt;string&gt;&amp; line, const string&amp; delimeter) {\n    if (line.empty()) {\n        return \"\";\n    }\n    string res(line[0]);\n    for (int i = 1; i &lt; line.size(); i++) {\n        res += delimeter + line[i];\n    }\n    return res;\n}</code></pre>\n<hr/>\n<p><strong>Algorithm</strong></p>\n<p>This brings us to our final solution.</p>\n<ol>\n<li data-length=\"1\">\n<p>Create two helper methods <code>getWords</code> and <code>createLine</code> that we described above.</p>\n</li>\n<li data-length=\"1\">\n<p>Initialize an answer list <code>ans</code> and an integer <code>i</code> to iterate over the input.</p>\n</li>\n<li data-length=\"1\">\n<p>Use a while loop to iterate over the input. Each iteration in the while loop will handle one line in the answer.</p>\n<ul>\n<li>While <code>i &lt; words.length</code>, do the following steps:</li>\n<li>Get the words that should be in the current line as <code>currentLine = getWords(i)</code>.</li>\n<li>Increment <code>i</code> by <code>currentLine.length</code>.</li>\n<li>Create the line by calling <code>createLine(line, i)</code> and add it to <code>ans</code>.</li>\n</ul>\n</li>\n<li data-length=\"1\">\n<p>Return <code>ans</code>.</p>\n</li>\n</ol>\n<hr/>\n<p><strong>Implementation</strong></p>\n<pre><code>class Solution {\npublic:\n    vector&lt;string&gt; fullJustify(vector&lt;string&gt;&amp; words, int maxWidth) {\n        vector&lt;string&gt; ans;\n        int i = 0;\n        while (i &lt; words.size()) {\n            vector&lt;string&gt; currentLine = getWords(i, words, maxWidth);\n            i += currentLine.size();\n            ans.push_back(createLine(currentLine, i, words, maxWidth));\n        }\n        return ans;\n    }\n​\nprivate:\n    vector&lt;string&gt; getWords(int i, vector&lt;string&gt;&amp; words, int maxWidth) {\n        vector&lt;string&gt; currentLine;\n        int currLength = 0;\n        while (i &lt; words.size() &amp;&amp; currLength + words[i].size() &lt;= maxWidth) {\n            currentLine.push_back(words[i]);\n            currLength += words[i].size() + 1;\n            i++;\n        }\n        return currentLine;\n    }\n    string createLine(vector&lt;string&gt;&amp; line, int i, vector&lt;string&gt;&amp; words,\n                      int maxWidth) {\n        int baseLength = -1;\n        for (const string&amp; word : line) {\n            baseLength += word.size() + 1;\n        }\n        int extraSpaces = maxWidth - baseLength;\n        if (line.size() == 1 || i == words.size()) {\n            string res = join(line, \" \");\n            res += string(extraSpaces, ' ');\n            return res;\n        }\n        int wordCount = line.size() - 1;\n        int spacesPerWord = extraSpaces / wordCount;\n        int needsExtraSpace = extraSpaces % wordCount;\n        for (int j = 0; j &lt; needsExtraSpace; j++) {\n            line[j] += \" \";\n        }\n        for (int j = 0; j &lt; wordCount; j++) {\n            line[j] += string(spacesPerWord, ' ');\n        }\n        return join(line, \" \");\n    }\n    string join(vector&lt;string&gt;&amp; line, const string&amp; delimeter) {\n        if (line.empty()) {\n            return \"\";\n        }\n        string res(line[0]);\n        for (int i = 1; i &lt; line.size(); i++) {\n            res += delimeter + line[i];\n        }\n        return res;\n    }\n};</code></pre>\n<hr/>\n<p><strong>Complexity Analysis</strong></p>\n<p>Let <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></span> be <code>words.length</code>, <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.03148em;\">k</span></span></span></span></span> be the average length of a word, and <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.4306em;\"></span><span class=\"mord mathnormal\">m</span></span></span></span></span> be <code>maxWidth</code>.</p>\n<p>Here, we are assuming that you are using immutable strings. A language like C++ has mutable strings and thus the complexity analysis will be slightly different.</p>\n<ul>\n<li>\n<p>Time complexity: <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.03148em;\">k</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p><code>getWords</code></p>\n<p>The work done in each while loop iteration is <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></span>. Thus the cost of each call is equal to the number of times the while loop runs in each call. This is amortized throughout the runtime of the algorithm - each index of <code>words</code> can only be iterated over once throughout all calls, so the time complexity of all calls to <code>getWords</code> is <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n<p><code>createLine</code></p>\n<p>First, we iterate over the words in <code>line</code> to calculate <code>baseLength</code>. Again, this is amortized over the runtime of the algorithm as each word in the input can only be iterated over once here. Therefore, this loop contributes <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span> over all calls to <code>createLine</code>.</p>\n<p>If we are dealing with the special case (one word line or last lane), we create a string of length <code>maxWidth</code>. This costs <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">m</span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n<p>Otherwise, we iterate over the words in <code>line</code> and perform string operations on each. The first for loop which adds the mandatory space costs <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right: 0.03148em;\">k</span><span class=\"mclose\">)</span></span></span></span></span> per iteration. In the worst-case scenario, we won't have any lines with only one word and the final line has only one word. In this scenario, over the runtime of the algorithm, this for loop will iterate over every word except for the final one, which would cost <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.03148em;\">k</span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n<p>The second for loop which adds the extra spaces is harder to analyze. At a minimum, each operation will cost <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right: 0.03148em;\">k</span><span class=\"mclose\">)</span></span></span></span></span>. The amount of spaces we add is a function of <code>maxWidth</code> and the number of words in <code>line</code>, as well as the sum of their lengths. One thing is for certain though: on a given call, the strings we create in this for loop cannot exceed <code>maxWidth</code> in length combined. Therefore, we can say that this for loop costs <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">m</span><span class=\"mclose\">)</span></span></span></span></span> per call to <code>createLine</code>.</p>\n<p>Finally, we join the line with a delimiter, which costs <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">m</span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n<p>Overall, this function contributes <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.03148em;\">k</span><span class=\"mclose\">)</span></span></span></span></span> to the overall runtime, and <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">m</span><span class=\"mclose\">)</span></span></span></span></span> per call.</p>\n<p>Main section</p>\n<p>We already determined that all calls to <code>getWords</code> contribute <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span> in total, so we don't have to worry about that.</p>\n<p>Each call to <code>createLine</code> costs <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">m</span><span class=\"mclose\">)</span></span></span></span></span>. We call it in each while loop iteration. The number of while loop iterations is a function of <code>n</code>, <code>k</code>, and <code>m</code>. On average, we can fit <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1.0404em; vertical-align: -0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.6954em;\"><span style=\"top: -2.655em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right: 0.03148em;\">k</span></span></span></span><span style=\"top: -3.23em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width: 0.04em;\"></span></span><span style=\"top: -3.394em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">m</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span></span> words per line. Because we have <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></span> words, that implies <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1.3358em; vertical-align: -0.5858em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.6954em;\"><span style=\"top: -2.655em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mopen nulldelimiter sizing reset-size3 size6\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.6915em;\"><span style=\"top: -2.656em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right: 0.03148em;\">k</span></span></span></span><span style=\"top: -3.2255em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"frac-line mtight\" style=\"border-bottom-width: 0.049em;\"></span></span><span style=\"top: -3.384em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">m</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.344em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter sizing reset-size3 size6\"></span></span></span></span></span><span style=\"top: -3.23em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width: 0.04em;\"></span></span><span style=\"top: -3.394em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.5858em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1.2251em; vertical-align: -0.345em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.8801em;\"><span style=\"top: -2.655em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">m</span></span></span></span><span style=\"top: -3.23em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width: 0.04em;\"></span></span><span style=\"top: -3.394em;\"><span class=\"pstrut\" style=\"height: 3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">⋅</span><span class=\"mord mathnormal mtight\" style=\"margin-right: 0.03148em;\">k</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mclose\">)</span></span></span></span></span> iterations. Each iteration costs <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">m</span><span class=\"mclose\">)</span></span></span></span></span>, so this gives us <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.03148em;\">k</span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n<p>Summing it all up and canceling constants, we have a time complexity of <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.03148em;\">k</span><span class=\"mclose\">)</span></span></span></span></span> - the sum of the characters in all the words.</p>\n</li>\n<li>\n<p>Space complexity: <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">m</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p>We don't count the answer as part of the space complexity.</p>\n<p>We handle one line at a time and each line has a length of <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.4306em;\"></span><span class=\"mord mathnormal\">m</span></span></span></span></span>. The intermediate arrays we use like <code>currentLine</code> hold strings, but the sum of the lengths of these strings cannot exceed <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.4306em;\"></span><span class=\"mord mathnormal\">m</span></span></span></span></span> either.</p>\n</li>\n</ul>\n<br/>\n<hr/></div><span style=\"font-size: 0px; line-height: 0;\"> </span></div>"}