{"id":"187","title":"Repeated DNA Sequences","difficulty":"Medium","content":"<p>The <strong>DNA sequence</strong> is composed of a series of nucleotides abbreviated as <code>&#39;A&#39;</code>, <code>&#39;C&#39;</code>, <code>&#39;G&#39;</code>, and <code>&#39;T&#39;</code>.</p>\n\n<ul>\n\t<li>For example, <code>&quot;ACGAATTCCG&quot;</code> is a <strong>DNA sequence</strong>.</li>\n</ul>\n\n<p>When studying <strong>DNA</strong>, it is useful to identify repeated sequences within the DNA.</p>\n\n<p>Given a string <code>s</code> that represents a <strong>DNA sequence</strong>, return all the <strong><code>10</code>-letter-long</strong> sequences (substrings) that occur more than once in a DNA molecule. You may return the answer in <strong>any order</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\"\n<strong>Output:</strong> [\"AAAAACCCCC\",\"CCCCCAAAAA\"]\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> s = \"AAAAAAAAAAAAA\"\n<strong>Output:</strong> [\"AAAAAAAAAA\"]\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s[i]</code> is either <code>&#39;A&#39;</code>, <code>&#39;C&#39;</code>, <code>&#39;G&#39;</code>, or <code>&#39;T&#39;</code>.</li>\n</ul>\n","tags":["Hash Table","String","Bit Manipulation","Sliding Window","Rolling Hash","Hash Function"],"java_snippet":"class Solution {\n    public List<String> findRepeatedDnaSequences(String s) {\n        \n    }\n}","solution":"<h2><a href=\"#solution\"><svg><path></path></svg></a>Solution</h2>\n<hr/>\n<h3><a href=\"#overview\"><svg><path></path></svg></a>Overview</h3>\n<p>The follow-up here is to solve the same problem for arbitrary sequence length L, and to check the situation when L is quite large. Hence let's use L=10 notation everywhere to ease the problem generalization.</p>\n<blockquote>\n<p>We will discuss three different ideas on how to proceed. They are all based on sliding window + hashset. The key point is how to implement a window slice.</p>\n</blockquote>\n<p>Linear-time window slice O(L) is simple, just take a substring. Overall that would result in O((N−L)L) time complexity and huge space consumption in the case of large sequences.</p>\n<p>Constant-time slice O(1) is where the fun starts because the way you choose will show your actual background.There are two ways to proceed:</p>\n<ul>\n<li>\n<p>Rabin-Karp = constant-time slice using a rolling hash algorithm.</p>\n</li>\n<li>\n<p>Bit manipulation = constant-time slice using bitmasks.</p>\n</li>\n</ul>\n<p>Last two approaches have O(N−L) time complexity and moderate space consumption even in the case of large sequences.</p>\n<p><br/>\n<br/><br/>\n<br/></p>\n<hr/>\n<h3><a href=\"#approach-1-linear-time-slice-using-substring--hashset\"><svg><path></path></svg></a>Approach 1: Linear-time Slice Using Substring + HashSet</h3>\n<p>The idea is straightforward :</p>\n<ul>\n<li>\n<p>Move a sliding window of length L along the string of length N.</p>\n</li>\n<li>\n<p>Check if the sequence in the sliding window is in the hashset of already seen sequences.</p>\n<ul>\n<li>\n<p>If yes, the repeated sequence is right here. Update the output.</p>\n</li>\n<li>\n<p>If not, save the sequence in the sliding window in the hashset.</p>\n</li>\n</ul>\n</li>\n</ul>\n<p></p>\n<pre><code>class Solution {\n    public List&lt;String&gt; findRepeatedDnaSequences(String s) {\n        int L = 10, n = s.length();\n        Set&lt;String&gt; seen = new HashSet&lt;&gt;();\n        Set&lt;String&gt; output = new HashSet&lt;&gt;();\n\n        // iterate over all sequences of length L\n        for (int start = 0; start &lt; n - L + 1; ++start) {\n            String tmp = s.substring(start, start + L);\n            if (seen.contains(tmp)) output.add(tmp);\n            seen.add(tmp);\n        }\n        return new ArrayList&lt;&gt;(output);\n    }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : O((N−L)L), that is O(N) for the constant L=10. In the loop executed N−L+1, one builds a substring of length L. Overall that results in O((N−L)L) time complexity.</p>\n</li>\n<li>\n<p>Space complexity : O((N−L)L) to keep the hashset, that results in O(N) for the constant L=10.</p>\n<br/>\n</li>\n</ul>\n<br/>\n<hr/>\n<h3><a href=\"#approach-2-rabin-karp-constant-time-slice-using-rolling-hash\"><svg><path></path></svg></a>Approach 2: Rabin-Karp: Constant-time Slice Using Rolling Hash</h3>\n<p>Rabin-Karp algorithm is used to perform a multiple pattern search. It's used for plagiarism detection and in bioinformatics to look for similarities in two or more proteins.</p>\n<p>Detailed implementation of the Rabin-Karp algorithm for quite a complex case you could find in the article <a href=\"https://leetcode.com/articles/longest-duplicate-substring/\">Longest Duplicate Substring</a>, we do a very basic implementation.</p>\n<blockquote>\n<p>The idea is to slice over the string and to compute the hash of the sequence in the sliding window, both in a constant time.</p>\n</blockquote>\n<p>Let's use the string <code>AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT</code> as an example. First, convert the string to an integer array:</p>\n<ul>\n<li>'A' -&gt; 0, 'C' -&gt; 1, 'G' -&gt; 2, 'T' -&gt; 3</li>\n</ul>\n<p><code>AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT</code> -&gt; <code>00000111110000011111100000222333</code>. Time to compute the hash for the first sequence of length L: <code>0000011111</code>. The sequence could be considered as a number in a <a href=\"https://en.wikipedia.org/wiki/Numeral_system\">numeral system</a> with the base 4 and hashed as</p>\n<p>h0​=∑i=0L−1​ci​4L−1−i</p>\n<p>Here c0..4​=0 and c5..9​=1 are digits of <code>0000011111</code>.</p>\n<p>Now let's consider the slice <code>AAAAACCCCC</code> -&gt; <code>AAAACCCCCA</code>. For int arrays that means <code>0000011111</code> -&gt; <code>0000111110</code>, to remove one leading 0 and add one trailing 0. One integer in, and one out, let's recompute the hash:</p>\n<p>h1​=(h0​×4−c0​4L)+cL+1​.</p>\n<p>Voila, window slice, and hash recomputation are both done in a constant time.</p>\n<p><strong>Algorithm</strong></p>\n<ul>\n<li>\n<p>Iterate over the start position of the sequence: from 1 to N−L.</p>\n<ul>\n<li>\n<p>If <code>start == 0</code>, compute the hash of the first sequence <code>s[0: L]</code>.</p>\n</li>\n<li>\n<p>Otherwise, compute the rolling hash from the previous hash value.</p>\n</li>\n<li>\n<p>If the hash is in the hashset, one met a repeated sequence, time to update the output.</p>\n</li>\n<li>\n<p>Otherwise, add hash in the hashset.</p>\n</li>\n</ul>\n</li>\n<li>\n<p>Return output list.</p>\n</li>\n</ul>\n<p><strong>Implementation</strong></p>\n<pre><code>class Solution {\n    public List&lt;String&gt; findRepeatedDnaSequences(String s) {\n        int L = 10, n = s.length();\n        if (n &lt;= L) return new ArrayList&lt;&gt;();\n\n        // rolling hash parameters: base a\n        int a = 4;\n        int aL = (int) Math.pow(a, L);\n\n        // convert string to array of integers\n        Map&lt;Character, Integer&gt; toInt = new HashMap&lt;&gt;();\n        toInt.put('A', 0);\n        toInt.put('C', 1);\n        toInt.put('G', 2);\n        toInt.put('T', 3);\n\n        int[] nums = new int[n];\n        for (int i = 0; i &lt; n; ++i) nums[i] = toInt.get(s.charAt(i));\n\n        int h = 0;\n        Set&lt;Integer&gt; seen = new HashSet&lt;&gt;();\n        Set&lt;String&gt; output = new HashSet&lt;&gt;();\n\n        // iterate over all sequences of length L\n        for (int start = 0; start &lt; n - L + 1; ++start) {\n            // compute hash of the current sequence in O(1) time\n            if (start != 0) {\n                h = h * a - nums[start - 1] * aL + nums[start + L - 1];\n            }\n            // compute hash of the first sequence in O(L) time\n            else {\n                for (int i = 0; i &lt; L; ++i) h = h * a + nums[i];\n            }\n\n            // update output and hashset of seen sequences\n            if (seen.contains(h)) output.add(s.substring(start, start + L));\n            seen.add(h);\n        }\n        return new ArrayList&lt;&gt;(output);\n    }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : O(N−L), that is O(N) for the constant L=10. In the loop executed N−L+1 one builds a hash in a constant time, that results in O(N−L) time complexity.</p>\n</li>\n<li>\n<p>Space complexity : O(N−L) to keep the hashset, that results in O(N) for the constant L=10.</p>\n<br/>\n</li>\n</ul>\n<br/>\n<hr/>\n<h3><a href=\"#approach-3-bit-manipulation-constant-time-slice-using-bitmask\"><svg><path></path></svg></a>Approach 3: Bit Manipulation: Constant-time Slice Using Bitmask</h3>\n<blockquote>\n<p>The idea is to slice over the string and to compute the bitmask of the sequence in the sliding window, both in a constant time.</p>\n</blockquote>\n<p>As for Rabin-Karp, let's start with conversion of the string to a 2-bits integer array:</p>\n<p>A−&gt;0=002​,C−&gt;1=012​,G−&gt;2=102​,T−&gt;3=112​</p>\n<p><code>GAAAAACCCCCAAAAACCCCCCAAAAAGGGTTT</code> -&gt; <code>200000111110000011111100000222333</code>.</p>\n<p>Time to compute bitmask for the first sequence of length L: <code>2000001111</code>. Each digit in the sequence (0, 1, 2, or 3) takes not more than 2 bits:</p>\n<p>0=002​,1=012​,2=102​,3=112​</p>\n<p>Hence the bitmask could be computed in the loop:</p>\n<ul>\n<li>\n<p>Do the left shift to free the last two bits: <code>bitmask &lt;&lt;= 2</code></p>\n</li>\n<li>\n<p>Save the current digit from <code>2000001111</code> in these last two bits: <code>bitmask |= nums[i]</code></p>\n</li>\n</ul>\n<p></p>\n<p>Now let's consider the slice <code>GAAAAACCCCC</code> -&gt; <code>AAAAACCCCC</code>. For int arrays that means <code>20000011111</code> -&gt; <code>0000011111</code>, to remove leading 2 and add trailing 1.</p>\n<p></p>\n<p>To add trailing 1 is simple, the same idea as just above:</p>\n<ul>\n<li>\n<p>Do the left shift to free the last two bits: <code>bitmask &lt;&lt;= 2</code></p>\n</li>\n<li>\n<p>Save 1 into these last two bits: <code>bitmask |= 1</code></p>\n</li>\n</ul>\n<p>Now the problem is to remove two leading bits, which contain 2. In other words, the problem is to set 2L-bit and (2L + 1)-bit to zero.</p>\n<blockquote>\n<p>Let's use a bitwise trick to unset the n-th bit: <code>bitmask &amp;= ~(1 &lt;&lt; n)</code>.</p>\n</blockquote>\n<p>This trick is very simple:</p>\n<ul>\n<li>\n<p><code>1 &lt;&lt; n</code> is to set n-th bit equal to 1.</p>\n</li>\n<li>\n<p><code>~(1 &lt;&lt; n)</code> is to set n-th bit equal to 0, and all lower bits to 1.</p>\n</li>\n<li>\n<p><code>bitmask &amp;= ~(1 &lt;&lt; n)</code> is to set n-th bit of bitmask equal to 0.</p>\n</li>\n</ul>\n<p>Straightforward trick usage is to unset first 2L-bit and then (2L + 1)-bit: <code>bitmask &amp;= ~(1 &lt;&lt; 2 * L) &amp; ~(1 &lt;&lt; (2 * L + 1)</code>. That could be simplified as <code>bitmask &amp;= ~(3 &lt;&lt; 2 * L)</code>:</p>\n<ul>\n<li>\n<p>3=(11)2​, and hence <code>3 &lt;&lt; 2 * L</code> would set 2L-bit and (2L + 1)-bit equal to 1.</p>\n</li>\n<li>\n<p><code>~(3 &lt;&lt; 2 * L)</code> would set 2L-bit and (2L + 1)-bit equal to 0, and all lower bits to 1.</p>\n</li>\n<li>\n<p><code>bitmask &amp;= ~(3 &lt;&lt; 2 * L)</code> would set 2L-bit and (2L + 1)-bit of bitmask equal to 0.</p>\n</li>\n</ul>\n<p></p>\n<p>Voila, window slice, and bitmask recomputation are both done in a constant time.</p>\n<p><strong>Algorithm</strong></p>\n<ul>\n<li>\n<p>Iterate over the start position of sequence: from 1 to N−L.</p>\n<ul>\n<li>\n<p>If <code>start == 0</code>, compute the bitmask of the first sequence <code>s[0: L]</code>.</p>\n</li>\n<li>\n<p>Otherwise, compute the bitmask from the previous bitmask.</p>\n</li>\n<li>\n<p>If bitmask is in the hashset, one met a repeated sequence, time to update the output.</p>\n</li>\n<li>\n<p>Otherwise, add bitmask in the hashset.</p>\n</li>\n</ul>\n</li>\n<li>\n<p>Return output list.</p>\n</li>\n</ul>\n<p><strong>Implementation</strong></p>\n<pre><code>class Solution {\n    public List&lt;String&gt; findRepeatedDnaSequences(String s) {\n        int L = 10, n = s.length();\n        if (n &lt;= L) return new ArrayList&lt;&gt;();\n\n        // convert string to array of integers\n        Map&lt;Character, Integer&gt; toInt = new HashMap&lt;&gt;();\n        toInt.put('A', 0);\n        toInt.put('C', 1);\n        toInt.put('G', 2);\n        toInt.put('T', 3);\n\n        int[] nums = new int[n];\n        for (int i = 0; i &lt; n; ++i) nums[i] = toInt.get(s.charAt(i));\n\n        int bitmask = 0;\n        Set&lt;Integer&gt; seen = new HashSet&lt;&gt;();\n        Set&lt;String&gt; output = new HashSet&lt;&gt;();\n\n        // iterate over all sequences of length L\n        for (int start = 0; start &lt; n - L + 1; ++start) {\n            // compute bitmask of the current sequence in O(1) time\n            if (start != 0) {\n                // left shift to free the last 2 bit\n                bitmask &lt;&lt;= 2;\n                // add a new 2-bits number in the last two bits\n                bitmask |= nums[start + L - 1];\n                // unset first two bits: 2L-bit and (2L + 1)-bit\n                bitmask &amp;= ~(3 &lt;&lt; (2 * L));\n            }\n            // compute bitmask of the first sequence in O(L) time\n            else {\n                for (int i = 0; i &lt; L; ++i) {\n                    bitmask &lt;&lt;= 2;\n                    bitmask |= nums[i];\n                }\n            }\n            // update output and hashset of seen sequences\n            if (seen.contains(bitmask))\n                output.add(s.substring(start, start + L));\n            seen.add(bitmask);\n        }\n        return new ArrayList&lt;&gt;(output);\n    }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : O(N−L), that is O(N) for the constant L=10. In the loop executed N−L+1 one builds a bitmask in a constant time, that results in O(N−L) time complexity.</p>\n</li>\n<li>\n<p>Space complexity : O(N−L) to keep the hashset, that results in O(N) for the constant L=10.</p>\n</li>\n</ul>"}