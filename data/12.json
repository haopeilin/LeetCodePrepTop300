{"id":"12","title":"Integer to Roman","difficulty":"Medium","content":"<p>Seven different symbols represent Roman numerals with the following values:</p>\n\n<table>\n\t<thead>\n\t\t<tr>\n\t\t\t<th>Symbol</th>\n\t\t\t<th>Value</th>\n\t\t</tr>\n\t</thead>\n\t<tbody>\n\t\t<tr>\n\t\t\t<td>I</td>\n\t\t\t<td>1</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>V</td>\n\t\t\t<td>5</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>X</td>\n\t\t\t<td>10</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>L</td>\n\t\t\t<td>50</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>C</td>\n\t\t\t<td>100</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>D</td>\n\t\t\t<td>500</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>M</td>\n\t\t\t<td>1000</td>\n\t\t</tr>\n\t</tbody>\n</table>\n\n<p>Roman numerals are formed by appending&nbsp;the conversions of&nbsp;decimal place values&nbsp;from highest to lowest. Converting a decimal place value into a Roman numeral has the following rules:</p>\n\n<ul>\n\t<li>If the value does not start with 4 or&nbsp;9, select the symbol of the maximal value that can be subtracted from the input, append that symbol to the result, subtract its value, and convert the remainder to a Roman numeral.</li>\n\t<li>If the value starts with 4 or 9 use the&nbsp;<strong>subtractive form</strong>&nbsp;representing&nbsp;one symbol subtracted from the following symbol, for example,&nbsp;4 is 1 (<code>I</code>) less than 5 (<code>V</code>): <code>IV</code>&nbsp;and 9 is 1 (<code>I</code>) less than 10 (<code>X</code>): <code>IX</code>.&nbsp;Only the following subtractive forms are used: 4 (<code>IV</code>), 9 (<code>IX</code>),&nbsp;40 (<code>XL</code>), 90 (<code>XC</code>), 400 (<code>CD</code>) and 900 (<code>CM</code>).</li>\n\t<li>Only powers of 10 (<code>I</code>, <code>X</code>, <code>C</code>, <code>M</code>) can be appended consecutively at most 3 times to represent multiples of 10. You cannot append 5&nbsp;(<code>V</code>), 50 (<code>L</code>), or 500 (<code>D</code>) multiple times. If you need to append a symbol&nbsp;4 times&nbsp;use the <strong>subtractive form</strong>.</li>\n</ul>\n\n<p>Given an integer, convert it to a Roman numeral.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">num = 3749</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">&quot;MMMDCCXLIX&quot;</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<pre>\n3000 = MMM as 1000 (M) + 1000 (M) + 1000 (M)\n 700 = DCC as 500 (D) + 100 (C) + 100 (C)\n  40 = XL as 10 (X) less of 50 (L)\n   9 = IX as 1 (I) less of 10 (X)\nNote: 49 is not 1 (I) less of 50 (L) because the conversion is based on decimal places\n</pre>\n</div>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">num = 58</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">&quot;LVIII&quot;</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<pre>\n50 = L\n 8 = VIII\n</pre>\n</div>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">num = 1994</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">&quot;MCMXCIV&quot;</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<pre>\n1000 = M\n 900 = CM\n  90 = XC\n   4 = IV\n</pre>\n</div>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num &lt;= 3999</code></li>\n</ul>\n","tags":["Hash Table","Math","String"],"java_snippet":"class Solution {\n    public String intToRoman(int num) {\n        \n    }\n}","solution":"<h2><a href=\"#solution-article\"><svg><path></path></svg></a>Solution Article</h2>\n<hr/>\n<h3><a href=\"#overview\"><svg><path></path></svg></a>Overview</h3>\n<p>In a lot of countries, Roman Numerals are taught in elementary school-level math. This has made them a somewhat popular \"easy\" interview question. Unfortunately though, this ignores the fact that <em>not everybody learned them in school</em>, and therefore a big advantage has been given to those who did. I suspect it's also difficult for a lot of us who <em>have</em> learned them previously to fully appreciate how much easier prior experience makes this question. While this is very unfair, and possibly very frustrating, keep in mind that the best thing you can do is work through this question and the related question <a href=\"https://leetcode.com/problems/roman-to-integer/\">Roman to Integer</a> so that you don't get caught out by it in a real interview. In short, if you're here reading this, you've saved yourself from getting caught out by it! Thankfully, questions that rely on this kind of prior knowledge are few and far between.</p>\n<p><strong>Have a go at Roman to Integer first</strong></p>\n<p>The problem of converting a <a href=\"https://leetcode.com/problems/roman-to-integer/\">Roman Numeral to an Integer</a> is simpler. Therefore, we suggest that you have a go at it first if you're finding this question difficult. This will allow you to become more familiar with the concept of Roman Numerals without the \"ambiguity\" issue that comes up in converting an integer to a Roman Numeral. When converting a Roman Numeral to an integer, there's only one sensible conversion.</p>\n<p><strong>Roman Numeral Symbols</strong></p>\n<p>Roman Numerals are made with <code>7</code> single-letter symbols, each with its own value. Additionally, the subtractive rules (as explained in the problem description) give an additional <code>6</code> symbols. This gives us a total of <code>13</code> unique symbols (each symbol is made of either 1 letter or 2).</p>\n<p></p>\n<p>An integer is represented as a Roman Numeral by finding symbols that add to its value.</p>\n<p><strong>Handling Ambiguity</strong></p>\n<p>One thing that can be a bit confusing if you're not familiar with Roman Numerals is knowing which representation is the \"correct\" one for a particular integer. For example, consider these possible ways of representing <code>140</code>. Which of these is correct?</p>\n<p></p>\n<p><strong>The system we use to decide</strong> is to select the representation with the largest possible symbols, working from left to right. For example, the representations above with the largest symbol at the start are the ones starting with <code>C</code>.</p>\n<p></p>\n<p>To decide which of these to go with, we look at the next symbol. Two of them have an <code>X</code>, which is worth <code>10</code>, and one of them has an <code>XL</code>, which is worth <code>40</code>. Because the <code>XL</code> is worth more, we go with that representation. Therefore, the representation for <code>140</code> is <code>CXL</code>.</p>\n<p>This definition of Roman Numerals is, these days, the \"most accepted\". Interestingly, it still isn't an absolute standard, and throughout history, there have been many variants. If you're interested in math and history, we recommend checking out the <a href=\"https://en.wikipedia.org/wiki/Roman_numerals\">Wikipedia article</a> for your own interest.</p>\n<br/>\n<hr/>\n<h3><a href=\"#approach-1-greedy\"><svg><path></path></svg></a>Approach 1: Greedy</h3>\n<p><strong>Intuition</strong></p>\n<p>Representing a given integer as a Roman Numeral requires finding a sequence of the above 13 symbols, where their corresponding values add up to the integer. This sequence must be in order from largest to smallest, based on symbol value. To remind you, these are the symbol values.</p>\n<p></p>\n<p>As explained in the overview, the representation should use the largest possible symbols, working from the left. Therefore, it makes sense to use a <strong>Greedy</strong> algorithm. A Greedy algorithm is an algorithm that makes the best possible decision at the current time; in this case taking out the largest possible symbol it can.</p>\n<p>So to represent a given integer, we look for the <em>largest</em> symbol that fits into it. We subtract that, and then look for the largest symbol that fits into the remainder, and so on until the remainder is 0. Each of the symbols we take out are appended onto the output Roman Numeral string.</p>\n<p>For example, suppose we need to make the number <code>671</code>.</p>\n<p>The largest symbol that fits into <code>671</code> is <code>D</code> (which is worth <code>500</code>). The next symbol up, <code>CM</code>, is worth <code>900</code> and so is too big to fit. Therefore, we now have the following.</p>\n<svg><path></path></svg>\n<p>We now repeat the process with <code>171</code>. The largest symbol that fits into it is <code>C</code> (worth <code>100</code>).</p>\n<svg><path></path></svg>\n<p>Repeating this with <code>71</code>, we find the largest symbol that fits in is <code>L</code> (worth <code>50</code>).</p>\n<svg><path></path></svg>\n<p>For <code>21</code>, the largest symbol that fits in is <code>X</code> (worth <code>10</code>).</p>\n<svg><path></path></svg>\n<p>For <code>11</code>, the largest symbol that fits in is again <code>X</code>.</p>\n<svg><path></path></svg>\n<p>Finally, the <code>1</code> is represented with a <code>I</code> and we're done.</p>\n<svg><path></path></svg>\n<p>In pseudocode, this algorithm is as follows.</p>\n<svg><path></path></svg>\n<p>The cleanest way to implement this in code is to loop over each symbol, from largest to smallest, checking <em>how many</em> copies of the current symbol fit into the remaining integer.</p>\n<svg><path></path></svg>\n<p>Here's an animation showing this algorithm run on the number <code>478</code>.</p>\n<p></p>\n<p><strong>Algorithm</strong></p>\n<pre><code>class Solution {\n    public String intToRoman(int num) {\n        int[] values = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n        String[] symbols = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\",\n                            \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\n        StringBuilder roman = new StringBuilder();\n        // Loop through each symbol, stopping if num becomes 0.\n        for (int i = 0; i &lt; values.length &amp;&amp; num &gt; 0; i++) {\n            // Repeat while the current symbol still fits into num.\n            while (values[i] &lt;= num) {\n                num -= values[i];\n                roman.append(symbols[i]);\n            }\n        }\n        return roman.toString();\n    }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : O(1).</p>\n<p>As there is a finite set of roman numerals, there is a hard upper limit on how many times the loop can iterate. This upper limit is <code>15</code> times, and it occurs for the number <code>3888</code>, which has a representation of <code>MMMDCCCLXXXVIII</code>. Therefore, we say the time complexity is constant, i.e. O(1).</p>\n</li>\n<li>\n<p>Space complexity : O(1).</p>\n<p>The amount of memory used does not change with the size of the input integer, and is therefore constant.</p>\n</li>\n</ul>\n<hr/>\n<h3><a href=\"#approach-2-hardcode-digits\"><svg><path></path></svg></a>Approach 2: Hardcode Digits</h3>\n<p><strong>Intuition</strong></p>\n<p><em>Please don't panic and assume you need to memorize the values in this approach. The first approach should be fine, and in-fact has the added bonus of being more flexible if we were to extend the Roman Numeral symbol set to have symbols over 1000. This second approach is only included for completeness. Do try to understand how we derived this approach, though.</em></p>\n<p>An interesting observation that can be made is that each of the digits in the integer's decimal representation can be treated <em>independently</em> when converting the integer into a Roman Numeral. Notice that all of the symbols can be split into groups based on their highest factor out of <code>1000</code>, <code>100</code>, <code>10</code>, and <code>1</code>.</p>\n<p></p>\n<p>While the number is at least <code>1000</code>, an <code>M (1000)</code> will be appended to the output and <code>1000</code> will be subtracted from the integer. The other symbols won't even be considered until the number is below <code>1000</code>. Additionally, the <code>M (1000)</code>s cannot represent any lower part of the number. Therefore, we can represent the thousands digit of the integer entirely with <code>M (1000)</code>s.</p>\n<p>Now, assume we have a remainder of between <code>100</code> and <code>999</code>. The next symbols considered are those in the hundreds row. The highest symbol that could fit in right now is <code>CM (900)</code>, and the lowest is <code>C (100)</code>. None of the symbols in this range can possibly modify the tens or ones. As long as the remainder is still above <code>100</code>, we can still take at least <code>C (100)</code> out of it. This means that we'll only be subtracting symbols from the hundreds row for as long as the number is at least <code>100</code>.</p>\n<p>The same argument applies for the tens, and then the ones.</p>\n<p>We can, therefore, work out what the representation for each digit, in each place, is. There are only 34 of them; <code>0</code>, <code>1</code>, <code>2</code>, <code>3</code> and <code>4</code> for the thousands column, and <code>0</code>, <code>1</code>, <code>2</code>, <code>3</code>, <code>4</code>, <code>5</code>, <code>6</code>, <code>7</code>, <code>8</code> and <code>9</code> for each of the hundreds, tens, and ones. So with a pencil, paper, and some patience, you can hopefully work out the representation for each of these possibilities and hardcode them. Then, converting an integer to a Roman Numeral will require breaking the integer into digits and appending the relevant representation for each digit.</p>\n<p></p>\n<p>Getting each digit of the number can be done using the modulus and division operators. The division operator removes the digits <em>below</em> the place we want, and the modulus operator removes the digits from <em>above</em>. This simply leaves the digit we want.</p>\n<svg><path></path></svg>\n<p>Then, we can simply look these up in the hardcoded table, and append the results together!</p>\n<p><strong>Algorithm</strong></p>\n<p>The cleanest way to go about it in code is to have 4 separate arrays; one for each place value. Then, extract the digits, look up their symbols in the relevant array, and append them all together.</p>\n<pre><code>class Solution {\n    public String intToRoman(int num) {\n        String[] thousands = {\"\", \"M\", \"MM\", \"MMM\"};\n        String[] hundreds = {\"\", \"C\", \"CC\", \"CCC\", \"CD\",\n                              \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"};\n        String[] tens = {\"\", \"X\", \"XX\", \"XXX\", \"XL\",\n                          \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"};\n        String[] ones = {\"\", \"I\", \"II\", \"III\", \"IV\",\n                          \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"};\n        return thousands[num / 1000]\n                + hundreds[(num % 1000) / 100]\n                + tens[(num % 100) / 10]\n                + ones[num % 10];\n    }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : O(1).</p>\n<p>The same number of operations is done, regardless of the size of the input. Therefore, the time complexity is constant.</p>\n</li>\n<li>\n<p>Space complexity : O(1).</p>\n<p>While we have Arrays, they are the same size, <em>regardless of the size of the input</em>. Therefore, they are constant for the purpose of space-complexity analysis.</p>\n</li>\n</ul>\n<p>The downside of this approach is that it is inflexible if Roman Numerals were to be extended (which is an interesting follow-up question). For example, what if we said the symbol <code>H</code> now represents <code>5000</code>, and <code>P</code> now represents <code>10000</code>, allowing us to represent numbers up to <code>39999</code>? Approach 1 will be a lot quicker to modify, as you simply need to add these 2 values to the code without doing any calculations. But for Approach 2, you'll need to calculate and hardcode ten new representations. What if we then added symbols to be able to go up to <code>399,999,999</code>? Approach 2 becomes more and more difficult to manage, the more symbols we add.</p>\n<br/>"}