{"id":"87","title":"Scramble String","difficulty":"Hard","content":"<p>We can scramble a string s to get a string t using the following algorithm:</p>\n\n<ol>\n\t<li>If the length of the string is 1, stop.</li>\n\t<li>If the length of the string is &gt; 1, do the following:\n\t<ul>\n\t\t<li>Split the string into two non-empty substrings at a random index, i.e., if the string is <code>s</code>, divide it to <code>x</code> and <code>y</code> where <code>s = x + y</code>.</li>\n\t\t<li><strong>Randomly</strong>&nbsp;decide to swap the two substrings or to keep them in the same order. i.e., after this step, <code>s</code> may become <code>s = x + y</code> or <code>s = y + x</code>.</li>\n\t\t<li>Apply step 1 recursively on each of the two substrings <code>x</code> and <code>y</code>.</li>\n\t</ul>\n\t</li>\n</ol>\n\n<p>Given two strings <code>s1</code> and <code>s2</code> of <strong>the same length</strong>, return <code>true</code> if <code>s2</code> is a scrambled string of <code>s1</code>, otherwise, return <code>false</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s1 = &quot;great&quot;, s2 = &quot;rgeat&quot;\n<strong>Output:</strong> true\n<strong>Explanation:</strong> One possible scenario applied on s1 is:\n&quot;great&quot; --&gt; &quot;gr/eat&quot; // divide at random index.\n&quot;gr/eat&quot; --&gt; &quot;gr/eat&quot; // random decision is not to swap the two substrings and keep them in order.\n&quot;gr/eat&quot; --&gt; &quot;g/r / e/at&quot; // apply the same algorithm recursively on both substrings. divide at random index each of them.\n&quot;g/r / e/at&quot; --&gt; &quot;r/g / e/at&quot; // random decision was to swap the first substring and to keep the second substring in the same order.\n&quot;r/g / e/at&quot; --&gt; &quot;r/g / e/ a/t&quot; // again apply the algorithm recursively, divide &quot;at&quot; to &quot;a/t&quot;.\n&quot;r/g / e/ a/t&quot; --&gt; &quot;r/g / e/ a/t&quot; // random decision is to keep both substrings in the same order.\nThe algorithm stops now, and the result string is &quot;rgeat&quot; which is s2.\nAs one possible scenario led s1 to be scrambled to s2, we return true.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s1 = &quot;abcde&quot;, s2 = &quot;caebd&quot;\n<strong>Output:</strong> false\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s1 = &quot;a&quot;, s2 = &quot;a&quot;\n<strong>Output:</strong> true\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>s1.length == s2.length</code></li>\n\t<li><code>1 &lt;= s1.length &lt;= 30</code></li>\n\t<li><code>s1</code> and <code>s2</code> consist of lowercase English letters.</li>\n</ul>\n","tags":["String","Dynamic Programming"],"java_snippet":"class Solution {\n    public boolean isScramble(String s1, String s2) {\n        \n    }\n}","solution":"<div class=\"flex flex-col w-full\" style=\"position: relative;\"><div class=\"mYe_l WRmCx\"><h2 class=\"group/heading relative\" id=\"solution\" level=\"2\"><a aria-hidden=\"true\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" href=\"#solution\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" data-icon=\"link\" data-prefix=\"fas\" focusable=\"false\" role=\"img\" spacing=\"square\" viewbox=\"0 0 640 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\" fill=\"currentColor\"></path></svg></div></a>Solution</h2>\n<hr/>\n<h3 class=\"group/heading relative\" id=\"approach-dynamic-programming\" level=\"3\"><a aria-hidden=\"true\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" href=\"#approach-dynamic-programming\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" data-icon=\"link\" data-prefix=\"fas\" focusable=\"false\" role=\"img\" spacing=\"square\" viewbox=\"0 0 640 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\" fill=\"currentColor\"></path></svg></div></a>Approach: Dynamic Programming</h3>\n<h4 id=\"intuition\">Intuition</h4>\n<p>We have a recursive definition of scrambling a string <code>s</code>. First, we divide <code>s</code> into <code>x</code> and <code>y</code>. Then we either keep <code>s</code> as <code>x + y</code> or swap them and get <code>y + x</code>. After that, we scramble <code>x</code> and <code>y</code> independently. Let <code>x'</code> denote the scrambled <code>x</code> and <code>y'</code> denote the scrambled <code>y</code>. <code>s</code> will eventually become <code>x' + y'</code> or <code>y' + x'</code>.</p>\n<p></p>\n<p>How do we check whether a given string <code>t</code> is a scrambled string of <code>s</code>? First, we choose an index and cut <code>s</code> into <code>x</code> and <code>y</code> (<code>s = x + y</code>). Then, we see if we can cut <code>t</code> into <code>x'</code> and <code>y'</code> (<code>t = x' + y'</code> if we do not swap or <code>t = y' + x'</code> if we do). Since verifying that <code>x'</code> is a scrambled <code>x</code> and <code>y'</code> is scrambled <code>y</code> are smaller subproblems, we will solve the problem using dynamic programming.</p>\n<p>We have two strings <code>s1</code> and <code>s2</code>.</p>\n<p>For each given dp state, we need 3 variables: <code>length</code>, <code>i</code>, and <code>j</code>.</p>\n<p>Each state will focus on two substrings. The first one will be a substring of <code>s1</code>, starting at index <code>i</code> with length equal to <code>length</code> - let's call this substring <code>s</code>. The second one will be a substring of <code>s2</code>, starting at index <code>j</code> with <code>length</code> - let's call this substring <code>t</code>.</p>\n<p>Let <code>dp[length][i][j]</code> be a boolean representing whether <code>t</code> is a scrambled version of <code>s</code>.</p>\n<p>The base case, as defined by the problem is when <code>length = 1</code>. Here we do not have to split strings into smaller ones, so we can easily compare the corresponding characters: <code>dp[1][i][j]</code> is <code>true</code> when <code>s1[i]</code> equals <code>s2[j]</code>, and <code>false</code> otherwise.</p>\n<p>Now we need to write down the transitions of <code>dp</code>. We will use the following image as an example during the explanations.</p>\n<p></p>\n<p>At each state, we need to perform a split on <code>s1</code>. We will consider all possible splits. If we are currently considering a substring with a length of <code>length</code>, then we could perform a split at any index <code>newLength</code>, where <code>0 &lt; newLength &lt; length</code>. (Here, <code>newLength</code> represents the length of the left string after the split). A split gives us two new strings:</p>\n<ul>\n<li>\n<p>A substring of <code>s1</code> starting at index <code>i</code> and ending with index <code>i + newLength - 1</code>. This string has a length of <code>newLength</code> (Blue in the picture)</p>\n</li>\n<li>\n<p>A substring of <code>s1</code> starting at index <code>i + newLength</code> and ending at index <code>i + length - 1</code>. This string has a length of <code>length - newLength</code>. (Yellow in the picture)</p>\n</li>\n</ul>\n<p>For each split, we have two cases:</p>\n<ul>\n<li>Do not swap the blue and yellow parts. The corresponding substrings of <code>s2</code> must be scrambled versions of the substrings we just created by splitting <code>s1</code>. This means both <code>dp[newLength][i][j]</code> (representing the blue parts) and <code>dp[length - newLength][i + newLength][j + newLength]</code> (representing the yellow parts) must be true.</li>\n<li>Swap the blue and yellow parts. As you can see in the image, this misaligns the blue and yellow parts between <code>s1</code> and <code>s2</code>, but we still need the parts to match (we still need the blue part of <code>s1</code> to be a scrambled version of the blue part of <code>s2</code>, same with the yellow part). What are the new starting indices? For blue, it's <code>s1</code> starting with <code>i</code> and <code>s2</code> starting with <code>j + length - newLength</code>. For yellow, it's <code>s1</code> starting with <code>i + newLength</code> and <code>s2</code> starting with <code>j</code>. Thus, we need both <code>dp[newLength][i][j+length-newLength]</code> and <code>dp[length-newLength][i+newLength][j]</code> to be <code>true</code>.</li>\n</ul>\n<p>Now we can formally write down the transitions. For <code>length &gt; 1</code>, <code>dp[length][i][j]</code> is <code>true</code> if and only if for at least one <code>newLength</code> where <code>0 &lt; newLength &lt; length</code>:</p>\n<p><code>(dp[newLength][i][j] &amp;&amp; dp[length-newLength][i+newLength][j+newLength]) || (dp[newLength][i][j+length-newLength] &amp;&amp; dp[length-newLength][i+newLength][j])</code> is <code>true</code>.</p>\n<p>Let <code>n</code> denote the length of the input strings. The answer to the problem is <code>dp[n][0][0]</code>, as starting at index <code>0</code> with length <code>n</code> is considering the entire input string.</p>\n<h4 id=\"algorithm\">Algorithm</h4>\n<ol>\n<li data-length=\"1\">Iterate <code>i</code> from <code>0</code> to <code>n-1</code>.\n<ul>\n<li>Iterate <code>j</code> from <code>0</code> to <code>n-1</code>.\n<ul>\n<li>Set <code>dp[1][i][j]</code> to the boolean value of <code>s1[i] == s2[j]</code>. (The base case of the DP).</li>\n</ul>\n</li>\n</ul>\n</li>\n<li data-length=\"1\">Iterate <code>length</code> from <code>2</code> to <code>n</code>.\n<ul>\n<li>Iterate <code>i</code> from <code>0</code> to <code>n + 1 - length</code>.\n<ul>\n<li>Iterate <code>j</code> from <code>0</code> to <code>n + 1 - length</code>.\n<ul>\n<li>Iterate <code>newLength</code> from <code>1</code> to <code>length - 1</code>.\n<ul>\n<li>If <code>dp[newLength][i][j] &amp;&amp; dp[length-newLength][i+newLength][j+newLength]) || (dp[newLength][i][j+l-newLength] &amp;&amp; dp[l-newLength][i+newLength][j]</code> is <code>true</code>, set <code>dp[length][i][j]</code> to <code>true</code>.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li data-length=\"1\">Return <code>dp[n][0][0]</code>.</li>\n</ol>\n<h4 id=\"implementation\">Implementation</h4>\n<pre><code>class Solution {\npublic:\n    bool isScramble(string s1, string s2) {\n        int n = s1.size();\n        vector dp(n + 1, vector(n, vector&lt;int&gt;(n)));\n        for (int i = 0; i &lt; n; i++) {\n            for (int j = 0; j &lt; n; j++) {\n                dp[1][i][j] = s1[i] == s2[j];\n            }\n        }\n        for (int length = 2; length &lt;= n; length++) {\n            for (int i = 0; i &lt; n + 1 - length; i++) {\n                for (int j = 0; j &lt; n + 1 - length; j++) {\n                    for (int newLength = 1; newLength &lt; length; newLength++) {\n                        const vector&lt;int&gt;&amp; dp1 = dp[newLength][i];\n                        const vector&lt;int&gt;&amp; dp2 =\n                            dp[length - newLength][i + newLength];\n                        dp[length][i][j] |= dp1[j] &amp;&amp; dp2[j + newLength];\n                        dp[length][i][j] |=\n                            dp1[j + length - newLength] &amp;&amp; dp2[j];\n                    }\n                }\n            }\n        }\n        return dp[n][0][0];\n    }\n};</code></pre>\n<h4 id=\"complexity-analysis\">Complexity Analysis</h4>\n<ul>\n<li>Time complexity: <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1.0641em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.8141em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">4</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span>.</li>\n</ul>\n<p>We have four nested for loops (for <code>length</code>, <code>i</code>, <code>j</code>, <code>newLength</code>), each doing <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span> iterations.</p>\n<ul>\n<li>Space complexity: <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1.0641em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.8141em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span>.</li>\n</ul>\n<p>We store the matrix <code>dp[n+1][n][n]</code> for dynamic programming.</p></div><span style=\"font-size: 0px; line-height: 0;\"> </span></div>"}