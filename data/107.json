{"id":"107","title":"Binary Tree Level Order Traversal II","difficulty":"Medium","content":"<p>Given the <code>root</code> of a binary tree, return <em>the bottom-up level order traversal of its nodes&#39; values</em>. (i.e., from left to right, level by level from leaf to root).</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg\" style=\"width: 277px; height: 302px;\" />\n<pre>\n<strong>Input:</strong> root = [3,9,20,null,null,15,7]\n<strong>Output:</strong> [[15,7],[9,20],[3]]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [1]\n<strong>Output:</strong> [[1]]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = []\n<strong>Output:</strong> []\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 2000]</code>.</li>\n\t<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n","tags":["Tree","Breadth-First Search","Binary Tree"],"java_snippet":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public List<List<Integer>> levelOrderBottom(TreeNode root) {\n        \n    }\n}","solution":"<h2><a href=\"#solution\"><svg><path></path></svg></a>Solution</h2>\n<hr/>\n<h3><a href=\"#how-to-traverse-the-tree\"><svg><path></path></svg></a>How to traverse the tree</h3>\n<p>There are two general strategies to traverse a tree:</p>\n<ul>\n<li>\n<p><em>Depth First Search</em> (<code>DFS</code>)</p>\n<p>In this strategy, we adopt the <code>depth</code> as the priority, so that one<br/>\nwould start from a root and reach all the way down to a certain leaf,<br/>\nand then back to root to reach another branch.</p>\n<p>The DFS strategy can further be distinguished as<br/>\n<code>preorder</code>, <code>inorder</code>, and <code>postorder</code> depending on the relative order<br/>\namong the root node, left node, and right node.</p>\n</li>\n<li>\n<p><em>Breadth First Search</em> (<code>BFS</code>)</p>\n<p>We scan through the tree level by level, following the order of height,<br/>\nfrom top to bottom. The nodes on a higher level would be visited before the ones<br/>\non lower levels.</p>\n</li>\n</ul>\n<p>In the following figure the nodes are enumerated in the order you visit them,<br/>\nplease follow <code>1-2-3-4-5</code> to compare different strategies.</p>\n<p></p>\n<p>Here the problem is to implement split-level BFS traversal : <code>[[4, 5], [2, 3], [1]]</code>.<br/>\nThat means we could use one of the <code>Node-&gt;Left-&gt;Right</code> techniques: BFS or DFS Preorder.</p>\n<p>We already discussed <a href=\"https://leetcode.com/articles/binary-tree-right-side-view/\">three different ways</a><br/>\nto implement iterative BFS traversal with the queue, and compared<br/>\n<a href=\"https://leetcode.com/problems/deepest-leaves-sum/solution/\">iterative BFS vs. iterative DFS</a>.<br/>\nLet's use this article to discuss the two most simple and fast techniques:</p>\n<ul>\n<li>\n<p>Recursive DFS.</p>\n</li>\n<li>\n<p>Iterative BFS with two queues.</p>\n</li>\n</ul>\n<blockquote>\n<p>Note, that both approaches are root-to-bottom traversals, and we're asked to provide<br/>\nbottom-up output. To achieve that, the final result should be reversed.</p>\n</blockquote>\n<br/>\n<br/>\n<hr/>\n<h3><a href=\"#approach-1-recursion-dfs-preorder-traversal\"><svg><path></path></svg></a>Approach 1: Recursion: DFS Preorder Traversal</h3>\n<p><strong>Intuition</strong></p>\n<p>The first step is to ensure that the tree is not empty.<br/>\nThe second step is to implement the recursive function<br/>\n<code>helper(node, level)</code>, which takes the current node and its level as the arguments.</p>\n<p><strong>Algorithm for the Recursive Function</strong></p>\n<p>Here is its implementation:</p>\n<ul>\n<li>\n<p>Initialize the output list <code>levels</code>.<br/>\nThe length of this list determines which level is currently updated.<br/>\nYou should compare this level <code>len(levels)</code> with a node level <code>level</code>,<br/>\nto ensure that you add the node on the correct level.<br/>\nIf you're still on the previous level -<br/>\nadd the new level by adding a new list into <code>levels</code>.</p>\n</li>\n<li>\n<p>Append the node value to the last level in <code>levels</code>.</p>\n</li>\n<li>\n<p>Process recursively child nodes if they are not <code>None</code>:<br/>\n<code>helper(node.left / node.right, level + 1)</code>.</p>\n</li>\n</ul>\n<p><strong>Implementation</strong></p>\n<p></p>\n<pre><code>class Solution {\n    private List&lt;List&lt;Integer&gt;&gt; levels = new ArrayList&lt;&gt;();\n\n    private void helper(TreeNode node, int level) {\n        // start the current level\n        if (levels.size() == level) {\n            levels.add(new ArrayList&lt;Integer&gt;());\n        }\n        // append the current node value\n        levels.get(level).add(node.val);\n        // process child nodes for the next level\n        if (node.left != null) helper(node.left, level + 1);\n        if (node.right != null) helper(node.right, level + 1);\n    }\n\n    public List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) {\n        if (root == null) return levels;\n        helper(root, 0);\n        Collections.reverse(levels);\n        return levels;\n    }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity: O(N) since each node is processed<br/>\nexactly once.</p>\n</li>\n<li>\n<p>Space complexity: O(N) to keep the output structure<br/>\nwhich contains N node values.</p>\n<br/>\n</li>\n</ul>\n<br/>\n<hr/>\n<h3><a href=\"#approach-2-iteration-bfs-traversal\"><svg><path></path></svg></a>Approach 2: Iteration: BFS Traversal</h3>\n<p><strong>Algorithm</strong></p>\n<p>The recursion above could be rewritten in the iteration form.</p>\n<p>Let's keep each tree level in the <em>queue</em> structure,<br/>\nwhich typically orders elements in a FIFO (first-in-first-out) manner.<br/>\nIn Java one could use <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/ArrayDeque.html\"><code>ArrayDeque</code> implementation of the <code>Queue</code> interface</a>.<br/>\nIn Python using <a href=\"https://docs.python.org/3/library/queue.html\"><code>Queue</code> structure</a><br/>\nwould be an overkill since it's designed for a safe exchange between multiple threads<br/>\nand hence requires locking which leads to a performance downgrade.<br/>\nIn Python the queue implementation with a fast atomic <code>append()</code><br/>\nand <code>popleft()</code> is <a href=\"https://docs.python.org/3/library/collections.html#collections.deque\"><code>deque</code></a>.</p>\n<p><strong>Algorithm</strong></p>\n<ul>\n<li>\n<p>Initialize two queues: one for the current level,<br/>\nand one for the next. Add root into <code>nextLevel</code> queue.</p>\n</li>\n<li>\n<p>While <code>nextLevel</code> queue is not empty:</p>\n<ul>\n<li>\n<p>Initialize the current level <code>currLevel = nextLevel</code>,<br/>\nand empty the next level <code>nextLevel</code>.</p>\n</li>\n<li>\n<p>Iterate over the current level queue:</p>\n<ul>\n<li>\n<p>Append the node value to the last level in <code>levels</code>.</p>\n</li>\n<li>\n<p>Add first <em>left</em> and then <em>right</em> child node into <code>nextLevel</code><br/>\nqueue.</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>Return reversed <code>levels</code>.</p>\n</li>\n</ul>\n<p><strong>Implementation</strong></p>\n<pre><code>class Solution {\n    public List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) {\n        List&lt;List&lt;Integer&gt;&gt; levels = new ArrayList&lt;&gt;();\n        if (root == null) return levels;\n\n        Queue&lt;TreeNode&gt; nextLevel = new ArrayDeque&lt;&gt;();\n        nextLevel.offer(root);\n\n        while (!nextLevel.isEmpty()) {\n            Queue&lt;TreeNode&gt; currLevel = new ArrayDeque&lt;&gt;(nextLevel);\n            nextLevel.clear();\n            levels.add(new ArrayList&lt;Integer&gt;());\n\n            for (TreeNode node : currLevel) {\n                // append the current node value\n                levels.get(levels.size() - 1).add(node.val);\n                // process child nodes for the next level\n                if (node.left != null) nextLevel.offer(node.left);\n                if (node.right != null) nextLevel.offer(node.right);\n            }\n        }\n\n        Collections.reverse(levels);\n        return levels;\n    }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity: O(N) since each node is processed<br/>\nexactly once.</p>\n</li>\n<li>\n<p>Space complexity: O(N) to keep the output structure which<br/>\ncontains N node values.</p>\n</li>\n</ul>"}