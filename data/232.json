{"id":"232","title":"Implement Queue using Stacks","difficulty":"Easy","content":"<p>Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (<code>push</code>, <code>peek</code>, <code>pop</code>, and <code>empty</code>).</p>\n\n<p>Implement the <code>MyQueue</code> class:</p>\n\n<ul>\n\t<li><code>void push(int x)</code> Pushes element x to the back of the queue.</li>\n\t<li><code>int pop()</code> Removes the element from the front of the queue and returns it.</li>\n\t<li><code>int peek()</code> Returns the element at the front of the queue.</li>\n\t<li><code>boolean empty()</code> Returns <code>true</code> if the queue is empty, <code>false</code> otherwise.</li>\n</ul>\n\n<p><strong>Notes:</strong></p>\n\n<ul>\n\t<li>You must use <strong>only</strong> standard operations of a stack, which means only <code>push to top</code>, <code>peek/pop from top</code>, <code>size</code>, and <code>is empty</code> operations are valid.</li>\n\t<li>Depending on your language, the stack may not be supported natively. You may simulate a stack using a list or deque (double-ended queue) as long as you use only a stack&#39;s standard operations.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;MyQueue&quot;, &quot;push&quot;, &quot;push&quot;, &quot;peek&quot;, &quot;pop&quot;, &quot;empty&quot;]\n[[], [1], [2], [], [], []]\n<strong>Output</strong>\n[null, null, null, 1, 1, false]\n\n<strong>Explanation</strong>\nMyQueue myQueue = new MyQueue();\nmyQueue.push(1); // queue is: [1]\nmyQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)\nmyQueue.peek(); // return 1\nmyQueue.pop(); // return 1, queue is [2]\nmyQueue.empty(); // return false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= x &lt;= 9</code></li>\n\t<li>At most <code>100</code>&nbsp;calls will be made to <code>push</code>, <code>pop</code>, <code>peek</code>, and <code>empty</code>.</li>\n\t<li>All the calls to <code>pop</code> and <code>peek</code> are valid.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow-up:</strong> Can you implement the queue such that each operation is <strong><a href=\"https://en.wikipedia.org/wiki/Amortized_analysis\" target=\"_blank\">amortized</a></strong> <code>O(1)</code> time complexity? In other words, performing <code>n</code> operations will take overall <code>O(n)</code> time even if one of those operations may take longer.</p>\n","tags":["Stack","Design","Queue"],"java_snippet":"class MyQueue {\n\n    public MyQueue() {\n        \n    }\n    \n    public void push(int x) {\n        \n    }\n    \n    public int pop() {\n        \n    }\n    \n    public int peek() {\n        \n    }\n    \n    public boolean empty() {\n        \n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */","solution":"<h2><a href=\"#summary\"><svg><path></path></svg></a>Summary</h2>\n<p>This article is for beginners. It introduces the following ideas:<br/>\nQueue, Stack.</p>\n<h2><a href=\"#solution\"><svg><path></path></svg></a>Solution</h2>\n<p>Queue is <strong>FIFO</strong> (first in - first out) data structure, in which the elements are inserted from one side - <code>rear</code> and removed from the other - <code>front</code>.<br/>\nThe most intuitive way to implement it is with linked lists, but this article will introduce another approach  using stacks.<br/>\nStack is <strong>LIFO</strong> (last in - first out) data structure, in which elements are added and removed from the same end, called <code>top</code>.<br/>\nTo satisfy <strong>FIFO</strong> property of a queue we need to keep two stacks. They serve to reverse arrival order of the  elements and one of them store the queue elements in their final order.</p>\n<hr/>\n<h3><a href=\"#approach-1-two-stacks-push---on-per-operation-pop---o1-per-operation\"><svg><path></path></svg></a>Approach #1 (Two Stacks) Push - O(n) per operation, Pop - O(1) per operation.</h3>\n<h4>Push</h4>\n<p>A queue is FIFO (first-in-first-out) but a stack is LIFO (last-in-first-out). This means the newest element must be pushed to the bottom of the stack. To do so we first transfer all <code>s1</code> elements to auxiliary stack <code>s2</code>. Then the newly arrived element is pushed on top of <code>s2</code> and all its elements are popped and pushed to <code>s1</code>.</p>\n<p></p>\n<p><em>Figure 1. Push an element in queue</em></p>\n<pre><code>private int front;\n​\npublic void push(int x) {\n    if (s1.empty())\n        front = x;\n    while (!s1.isEmpty())\n        s2.push(s1.pop());\n    s2.push(x);\n    while (!s2.isEmpty())\n        s1.push(s2.pop());\n}</code></pre>\n<h4>Complexity Analysis**</h4>\n<ul>\n<li>Time complexity : O(n).</li>\n</ul>\n<p>Each element, with the exception of the newly arrived, is pushed and popped twice. The last inserted element is popped and pushed once. Therefore this gives  4n+2  operations where n is the queue size. The  <code>push</code> and <code>pop</code> operations have O(1) time complexity.</p>\n<ul>\n<li>Space complexity : O(n).<br/>\nWe need additional memory to store the queue elements</li>\n</ul>\n<h4>Pop</h4>\n<p>The algorithm pops an element from  the stack <code>s1</code>, because <code>s1</code> stores always on its top the first inserted element in the queue.<br/>\nThe front element of the queue is kept as <code>front</code>.</p>\n<p></p>\n<p><em>Figure 2. Pop an element from queue</em></p>\n<pre><code>public int pop() {\n    int res = s1.pop();\n    if (!s1.empty())\n        front = s1.peek();\n    return res;\n}</code></pre>\n<h4>Complexity Analysis</h4>\n<ul>\n<li>Time complexity : O(1).</li>\n<li>Space complexity : O(1).</li>\n</ul>\n<h4>Empty</h4>\n<p>Stack <code>s1</code> contains all stack elements, so the algorithm checks <code>s1</code> size to return if the queue is empty.</p>\n<pre><code>// Return whether the queue is empty.\npublic boolean empty() {\n    return s1.isEmpty();\n}</code></pre>\n<h4>Complexity Analysis</h4>\n<ul>\n<li>Time complexity : O(1).</li>\n<li>Space complexity : O(1).</li>\n</ul>\n<h4>Peek</h4>\n<p>The <code>front</code> element is kept in constant memory and is modified when we push or pop an element.</p>\n<pre><code>// Get the front element.\npublic int peek() {\n  return front;\n}</code></pre>\n<h4>Complexity Analysis</h4>\n<ul>\n<li>Time complexity : O(1). The <code>front</code> element has been calculated in advance and only returned in <code>peek</code> operation.</li>\n<li>Space complexity : O(1).</li>\n</ul>\n<hr/>\n<h3><a href=\"#approach-2-two-stacks-push---o1-per-operation-pop---amortized-o1-per-operation\"><svg><path></path></svg></a>Approach #2 (Two Stacks) Push - O(1) per operation, Pop - Amortized O(1) per operation.</h3>\n<h4>Push</h4>\n<p>The newly arrived element is always added on top of stack <code>s1</code> and the first element is kept as <code>front</code> queue element</p>\n<p></p>\n<p><em>Figure 3. Push an element in queue</em></p>\n<pre><code>​\nprivate Stack&lt;Integer&gt; s1 = new Stack&lt;&gt;();\nprivate Stack&lt;Integer&gt; s2 = new Stack&lt;&gt;();\n​\n// Push element x to the back of queue.\npublic void push(int x) {\n    if (s1.empty())\n        front = x;\n    s1.push(x);\n}</code></pre>\n<h4>Complexity Analysis</h4>\n<ul>\n<li>\n<p>Time complexity : O(1). Аppending an element to a stack is an O(1) operation.</p>\n</li>\n<li>\n<p>Space complexity : O(n). We need additional memory to store the queue elements</p>\n</li>\n</ul>\n<h4>Pop</h4>\n<p>We have to remove element in front of the queue. This is the first inserted element in the stack <code>s1</code> and it is positioned at the bottom of the stack because of stack's <code>LIFO (last in - first out)</code> policy. To remove the bottom element  from  <code>s1</code>, we have to pop all elements from <code>s1</code> and to push them on to an additional stack <code>s2</code>, which helps us to store the elements of <code>s1</code> in reversed order. This way  the bottom element of <code>s1</code> will be positioned on top of <code>s2</code> and we can simply pop it from stack <code>s2</code>. Once <code>s2</code> is empty, the algorithm transfer data from <code>s1</code> to <code>s2</code> again.</p>\n<p></p>\n<p><em>Figure 4. Pop an element from stack</em></p>\n<pre><code>    public int pop() {\n        if (s2.isEmpty()) {\n            while (!s1.isEmpty())\n                s2.push(s1.pop());\n        }\n        return s2.pop();\n    }</code></pre>\n<h4>Complexity Analysis</h4>\n<ul>\n<li>\n<p>Time complexity: Amortized O(1), Worst-case O(n). In the worst case scenario when stack <code>s2</code> is empty, the algorithm pops n elements from stack s1 and pushes n elements to <code>s2</code>, where n is the queue size. This gives 2n operations, which is O(n). But when stack <code>s2</code> is not empty the algorithm has O(1) time complexity. So what does it mean by Amortized O(1)? Please see the next section on Amortized Analysis for more information.</p>\n</li>\n<li>\n<p>Space complexity : O(1).</p>\n</li>\n</ul>\n<h4>Amortized Analysis</h4>\n<p>Amortized analysis gives the average performance (over time) of each operation in the worst case. The basic idea is that a worst case operation can alter the state in such a way that the worst case cannot occur again for a long time, thus amortizing its cost.</p>\n<p>Consider this example where we start with an empty queue with the following sequence of operations applied:</p>\n<p>push1​,push2​,…,pushn​,pop1​,pop2​…,popn​</p>\n<p>The worst case time complexity of a single pop operation is O(n). Since we have n pop operations, using the worst-case per operation analysis gives us a total of O(n2) time.</p>\n<p>However, in a sequence of operations the worst case does not occur often in each operation - some operations may be cheap, some may be expensive. Therefore, a traditional worst-case per operation analysis can give overly pessimistic bound. For example, in a dynamic array only some inserts take a linear time, though others - a constant time.</p>\n<p>In the example above, the number of times pop operation can be called is limited by the number of push operations before it. Although a single pop operation could be expensive, it is expensive only once per <code>n</code> times (queue size), when <code>s2</code> is empty and there is a need for data transfer between <code>s1</code> and <code>s2</code>. Hence the total time complexity of the sequence is : <code>n</code> (for push operations) + <code>2*n</code> (for first pop operation) + <code>n - 1</code> ( for pop operations) which is O(2∗n).This gives O(2n/2n) = O(1) average time per operation.</p>\n<h4>Empty</h4>\n<p>Both stacks <code>s1</code> and <code>s2</code> contain all stack elements, so the algorithm checks <code>s1</code> and <code>s2</code> size to return if the queue is empty.</p>\n<pre><code>​\n// Return whether the queue is empty.\npublic boolean empty() {\n    return s1.isEmpty() &amp;&amp; s2.isEmpty();\n}</code></pre>\n<h4>Complexity Analysis</h4>\n<ul>\n<li>Time complexity : O(1).</li>\n<li>Space complexity : O(1).</li>\n</ul>\n<h4>Peek</h4>\n<p>The <code>front</code> element is kept in constant memory and is modified when we push an element. When <code>s2</code> is not empty, front element is positioned on the top of <code>s2</code></p>\n<pre><code>// Get the front element.\npublic int peek() {\n    if (!s2.isEmpty()) {\n            return s2.peek();\n    }\n    return front;\n}</code></pre>\n<h4>Complexity Analysis</h4>\n<ul>\n<li>Time complexity : O(1). The <code>front</code> element was either previously calculated or returned as a top element of stack <code>s2</code>. Therefore complexity is O(1)</li>\n<li>Space complexity : O(1).</li>\n</ul>"}