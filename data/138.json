{"id":"138","title":"Copy List with Random Pointer","difficulty":"Medium","content":"<p>A linked list of length <code>n</code> is given such that each node contains an additional random pointer, which could point to any node in the list, or <code>null</code>.</p>\n\n<p>Construct a <a href=\"https://en.wikipedia.org/wiki/Object_copying#Deep_copy\" target=\"_blank\"><strong>deep copy</strong></a> of the list. The deep copy should consist of exactly <code>n</code> <strong>brand new</strong> nodes, where each new node has its value set to the value of its corresponding original node. Both the <code>next</code> and <code>random</code> pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state. <strong>None of the pointers in the new list should point to nodes in the original list</strong>.</p>\n\n<p>For example, if there are two nodes <code>X</code> and <code>Y</code> in the original list, where <code>X.random --&gt; Y</code>, then for the corresponding two nodes <code>x</code> and <code>y</code> in the copied list, <code>x.random --&gt; y</code>.</p>\n\n<p>Return <em>the head of the copied linked list</em>.</p>\n\n<p>The linked list is represented in the input/output as a list of <code>n</code> nodes. Each node is represented as a pair of <code>[val, random_index]</code> where:</p>\n\n<ul>\n\t<li><code>val</code>: an integer representing <code>Node.val</code></li>\n\t<li><code>random_index</code>: the index of the node (range from <code>0</code> to <code>n-1</code>) that the <code>random</code> pointer points to, or <code>null</code> if it does not point to any node.</li>\n</ul>\n\n<p>Your code will <strong>only</strong> be given the <code>head</code> of the original linked list.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/12/18/e1.png\" style=\"width: 700px; height: 142px;\" />\n<pre>\n<strong>Input:</strong> head = [[7,null],[13,0],[11,4],[10,2],[1,0]]\n<strong>Output:</strong> [[7,null],[13,0],[11,4],[10,2],[1,0]]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/12/18/e2.png\" style=\"width: 700px; height: 114px;\" />\n<pre>\n<strong>Input:</strong> head = [[1,1],[2,1]]\n<strong>Output:</strong> [[1,1],[2,1]]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/12/18/e3.png\" style=\"width: 700px; height: 122px;\" /></strong></p>\n\n<pre>\n<strong>Input:</strong> head = [[3,null],[3,0],[3,null]]\n<strong>Output:</strong> [[3,null],[3,0],[3,null]]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= n &lt;= 1000</code></li>\n\t<li><code>-10<sup>4</sup> &lt;= Node.val &lt;= 10<sup>4</sup></code></li>\n\t<li><code>Node.random</code> is <code>null</code> or is pointing to some node in the linked list.</li>\n</ul>\n","tags":["Hash Table","Linked List"],"java_snippet":"/*\n// Definition for a Node.\nclass Node {\n    int val;\n    Node next;\n    Node random;\n\n    public Node(int val) {\n        this.val = val;\n        this.next = null;\n        this.random = null;\n    }\n}\n*/\n\nclass Solution {\n    public Node copyRandomList(Node head) {\n        \n    }\n}","solution":"<h2><a href=\"#solution\"><svg><path></path></svg></a>Solution</h2>\n<hr/>\n<p>Lets first look at how the linked list looks like</p>\n<p>In the above diagram, for a given node the <code>next</code> pointer points to the next node in the linked list. The <code>next</code> pointer is something standard for a linked list and this is what <em><strong>links</strong></em> the nodes together. What is interesting about the diagram and this problem is the <code>random</code> pointer which, as the name suggests can point to any node in the linked list or can be a null.</p>\n<h3><a href=\"#approach-1-recursive\"><svg><path></path></svg></a>Approach 1: Recursive</h3>\n<p><strong>Intuition</strong></p>\n<p>The basic idea behind the recursive solution is to consider the linked list like a graph. Every node of the Linked List has 2 pointers (edges in a graph). Since, random pointers add the randomness to the structure we might visit the same node again leading to cycles.</p>\n<p>In the diagram above we can see the random pointer points back to the previously seen node hence leading to a cycle. We need to take care of these cycles in the implementation.</p>\n<p>All we do in this approach is to just traverse the graph and clone it. Cloning essentially means creating a new node for every unseen node you encounter. The traversal part will happen recursively in a depth first manner. Note that we have to keep track of nodes already processed because, as pointed out earlier, we can have cycles because of the random pointers.</p>\n<p><strong>Algorithm</strong></p>\n<ol>\n<li>\n<p>Start traversing the graph from <code>head</code> node.</p>\n<p>Lets see the linked structure as a graph. Below is the graph representation of the above linked list example.</p>\n<p>In the above example <code>head</code> is where we begin our graph traversal.</p>\n</li>\n<li>\n<p>If we already have a cloned copy of the current node in the visited dictionary, we use the cloned node reference.</p>\n</li>\n<li>\n<p>If we don't have a cloned copy in the visited dictionary, we create a new node and add it to the visited dictionary.<br/>\n<code>visited_dictionary[current_node] = cloned_node_for_current_node.</code></p>\n</li>\n<li>\n<p>We then make two recursive calls, one using the <code>random</code> pointer and the other using <code>next</code> pointer. The diagram from step 1, shows <code>random</code> and <code>next</code> pointers in red and blue color respectively. Essentially we are making recursive calls for the children of the current node. In this implementation, the children are the nodes pointed by the <code>random</code> and the <code>next</code> pointers.</p>\n</li>\n</ol>\n\n<br/>\n<pre><code>/*\n // Definition for a Node.\n class Node {\n     int val;\n     Node next;\n     Node random;\n\n     Node(int _val, Node _next, Node _random) {\n         val = _val;\n         next = _next;\n         random = _random;\n     }\n }\n*/\nclass Solution {\n\n    // HashMap which holds old nodes as keys and new nodes as its values.\n    private Map&lt;Node, Node&gt; visitedHash = new HashMap&lt;&gt;();\n\n    public Node copyRandomList(Node head) {\n        if (head == null) {\n            return null;\n        }\n\n        // If we have already processed the current node, then we simply return\n        // the cloned version of it.\n        if (visitedHash.containsKey(head)) {\n            return visitedHash.get(head);\n        }\n\n        // Create a new node with the value same as old node. (i.e. copy the node)\n        Node node = new Node(head.val, null, null);\n\n        // Save this value in the hash map. This is needed since there might be\n        // loops during traversal due to randomness of random pointers and this\n        // would help us avoid them.\n        visitedHash.put(head, node);\n\n        // Recursively copy the remaining linked list starting once from the\n        // next pointer and then from the random pointer.\n        node.next = copyRandomList(head.next);\n        node.random = copyRandomList(head.random);\n\n        return node;\n    }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time Complexity: O(N) where N is the number of nodes in the linked list.</li>\n<li>Space Complexity: O(N). If we look closely, we have the recursion stack and we also have the space complexity to keep track of nodes already cloned i.e. using the visited dictionary. But asymptotically, the complexity is O(N).</li>\n</ul>\n<hr/>\n<h3><a href=\"#approach-2-iterative-with-on-space\"><svg><path></path></svg></a>Approach 2: Iterative with O(N) Space</h3>\n<p><strong>Intuition</strong></p>\n<p>The iterative solution to this problem does not model it as a graph, instead simply treats it as a LinkedList.<br/>\nWhen we are iterating over the list, we can create new nodes via the random pointer or the next pointer whichever points to a node that doesn't exist in our old --&gt; new dictionary.</p>\n<p><strong>Algorithm</strong></p>\n<ol>\n<li>\n<p>Traverse the linked list starting at <code>head</code> of the linked list.</p>\n<p>In the above diagram we create a new cloned <code>head</code> node. The cloned node is shown using dashed lines. In the implementation we would even store the reference of this newly created node in a visited dictionary.</p>\n</li>\n<li>\n<p>Random Pointer</p>\n<ul>\n<li>If the <code>random</code> pointer of the current node i points to the a node j and a clone of j already exists in the visited dictionary, we will simply use the cloned node reference from the visited dictionary.</li>\n<li>If the <code>random</code> pointer of the current node i points to the a node j which has not been created yet, we create a new node corresponding to j and add it to the visited dictionary.</li>\n</ul>\n<p>In the above diagram the <code>random</code> pointer of node A points to a node C. Node C which was not visited yet as we can see from the previous diagram. Hence we create a new cloned C′ node corresponding to node C and add it to visited dictionary.</p>\n</li>\n<li>\n<p>Next Pointer</p>\n<ul>\n<li>If the <code>next</code> pointer of the current node i points to the a node j and a clone of j already exists in the visited dictionary, we will simply use the cloned node reference from the visited dictionary.</li>\n<li>If the <code>next</code> pointer of the current node i points to the a node j which has not been created yet, we create a new node corresponding to j and add it to the visited dictionary.</li>\n</ul>\n<p>In the above diagram the <code>next</code> pointer of node A points to a node B. Node B which was not visited yet as we can see from the previous diagram. Hence we create a new cloned B′ node corresponding to node B and add it to visited dictionary.</p>\n</li>\n<li>\n<p>We repeat steps 2 and 3 until we reach the end of the linked list.</p>\n<p>In the above diagram, the <code>random</code> pointer of node B points to an already visited node A. Hence in step 2, we don't create a new copy for the clone. Instead we point <code>random</code> pointer of cloned node B′ to already existing cloned node A′.</p>\n<p>Also, the <code>next</code> pointer of node B points to an already visited node C. Hence in step 3, we don't create a new copy for the clone. Instead we point <code>next</code> pointer of cloned node B′ to already existing cloned node C′.</p>\n</li>\n</ol>\n<pre><code>/*\n // Definition for a Node.\n class Node {\n     int val;\n     Node next;\n     Node random;\n\n     Node(int _val) {\n         val = _val;\n         next = null;\n         random = null;\n     }\n\n     Node(int _val, Node _next, Node _random) {\n         val = _val;\n         next = _next;\n         random = _random;\n     }\n }\n*/\nclass Solution {\n\n    // Visited dictionary to hold old node reference as key and new node\n    // reference as the value\n    private Map&lt;Node, Node&gt; visited = new HashMap&lt;&gt;();\n\n    private Node getClonedNode(Node node) {\n        if (node != null) {\n            if (visited.containsKey(node)) {\n                return visited.get(node);\n            } else {\n                Node newNode = new Node(node.val, null, null);\n                visited.put(node, newNode);\n                return newNode;\n            }\n        }\n        return null;\n    }\n\n    public Node copyRandomList(Node head) {\n        if (head == null) {\n            return null;\n        }\n\n        Node oldNode = head;\n        Node newNode = new Node(oldNode.val);\n        visited.put(oldNode, newNode);\n\n        while (oldNode != null) {\n            newNode.random = getClonedNode(oldNode.random);\n            newNode.next = getClonedNode(oldNode.next);\n\n            oldNode = oldNode.next;\n            newNode = newNode.next;\n        }\n\n        return visited.get(head);\n    }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time Complexity : O(N) because we make one pass over the original linked list.</li>\n<li>Space Complexity : O(N) as we have a dictionary containing mapping from old list nodes to new list nodes. Since there are N nodes, we have O(N) space complexity.</li>\n</ul>\n<hr/>\n<h3><a href=\"#approach-3-iterative-with-o1-space\"><svg><path></path></svg></a>Approach 3: Iterative with O(1) Space</h3>\n<p><strong>Intuition</strong></p>\n<p>Instead of a separate dictionary to keep the old node --&gt; new node mapping, we can tweak the original linked list and keep every cloned node next to its original node. This interleaving of old and new nodes allows us to solve this problem without any extra space. Lets look at how the algorithm works.</p>\n<p><strong>Algorithm</strong></p>\n<ol>\n<li>\n<p>Traverse the original list and clone the nodes as you go and place the cloned copy next to its original node. This new linked list is essentially a interweaving of original and cloned nodes.</p>\n<p>As you can see we just use the value of original node to create the cloned copy. The <code>next</code> pointer is used to create the weaving. Note that this operation ends up modifying the original linked list.</p>\n\n</li>\n<li>\n<p>Iterate the list having both the new and old nodes intertwined with each other and use the original nodes' random pointers to assign references to random pointers for cloned nodes. For eg. If <code>B</code> has a random pointer to <code>A</code>, this means <code>B'</code> has a random pointer to <code>A'</code>.</p>\n</li>\n<li>\n<p>Now that the <code>random</code> pointers are assigned to the correct node, the <code>next</code> pointers need to be correctly assigned to unweave the current linked list and get back the original list and the cloned list.</p>\n</li>\n</ol>\n<pre><code>class Solution {\n\n    public Node copyRandomList(Node head) {\n        if (head == null) {\n            return null;\n        }\n\n        // Creating a new weaved list of original and copied nodes.\n        Node ptr = head;\n        while (ptr != null) {\n            Node newNode = new Node(ptr.val, null, null);\n            newNode.next = ptr.next;\n            ptr.next = newNode;\n            ptr = newNode.next;\n        }\n\n        // Assign random pointers for the cloned nodes.\n        ptr = head;\n        while (ptr != null) {\n            ptr.next.random = (ptr.random != null) ? ptr.random.next : null;\n            ptr = ptr.next.next;\n        }\n\n        // Unweave the linked list to separate original and cloned lists.\n        Node ptrOldList = head;\n        Node ptrNewList = head.next;\n        Node headNew = head.next;\n\n        while (ptrOldList != null) {\n            ptrOldList.next = ptrOldList.next.next;\n            ptrNewList.next = (ptrNewList.next != null) ? ptrNewList.next.next : null;\n            ptrOldList = ptrOldList.next;\n            ptrNewList = ptrNewList.next;\n        }\n\n        return headNew;\n    }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time Complexity : O(N)</li>\n<li>Space Complexity : O(1)</li>\n</ul>"}