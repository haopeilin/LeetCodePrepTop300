{"id":"245","title":"Shortest Word Distance III","difficulty":"Medium","content":"<p>Given an array of strings <code>wordsDict</code> and two strings that already exist in the array <code>word1</code> and <code>word2</code>, return <em>the shortest distance between the occurrence of these two words in the list</em>.</p>\n\n<p><strong>Note</strong> that <code>word1</code> and <code>word2</code> may be the same. It is guaranteed that they represent <strong>two individual words</strong> in the list.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> wordsDict = [\"practice\", \"makes\", \"perfect\", \"coding\", \"makes\"], word1 = \"makes\", word2 = \"coding\"\n<strong>Output:</strong> 1\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> wordsDict = [\"practice\", \"makes\", \"perfect\", \"coding\", \"makes\"], word1 = \"makes\", word2 = \"makes\"\n<strong>Output:</strong> 3\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= wordsDict.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= wordsDict[i].length &lt;= 10</code></li>\n\t<li><code>wordsDict[i]</code> consists of lowercase English letters.</li>\n\t<li><code>word1</code> and <code>word2</code> are in <code>wordsDict</code>.</li>\n</ul>\n","tags":["Array","String"],"java_snippet":"class Solution {\n    public int shortestWordDistance(String[] wordsDict, String word1, String word2) {\n        \n    }\n}","solution":"<div class=\"flex flex-col w-full\" style=\"position: relative;\"><div class=\"mYe_l WRmCx\"><h2 class=\"group/heading relative\" id=\"solution\" level=\"2\"><a aria-hidden=\"true\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" href=\"#solution\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" data-icon=\"link\" data-prefix=\"fas\" focusable=\"false\" role=\"img\" spacing=\"square\" viewbox=\"0 0 640 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\" fill=\"currentColor\"></path></svg></div></a>Solution</h2>\n<hr/>\n<h3 class=\"group/heading relative\" id=\"overview\" level=\"3\"><a aria-hidden=\"true\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" href=\"#overview\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" data-icon=\"link\" data-prefix=\"fas\" focusable=\"false\" role=\"img\" spacing=\"square\" viewbox=\"0 0 640 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\" fill=\"currentColor\"></path></svg></div></a>Overview</h3>\n<p>We are given a list of strings <code>wordsDict</code> and two strings <code>word1</code> and <code>word2</code> present in this list. Both these strings will always represent two individual strings in the original list. We need to find the minimum distance between these two strings in the list, as there could be duplicates.</p>\n<p>The brute force approach would be to iterate over every pair of strings in the list. Considering the first string in the pair to be <code>word1</code> and the second to be the <code>word2</code> in the pair, we will find the difference between the indices and find the minimum of all. One crucial point to take note of here is that if both words <code>word1</code> and <code>word2</code> are the same, then we should only find the difference if the indices are different; otherwise, we would be assuming both words to be mapped to the same word in the original list which is not intended.</p>\n<p>The above approach will work but is not efficient enough, we will have two nested for loops to iterate over the words twice, and hence the time complexity would be <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1.0641em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.8141em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span> where <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span></span></span></span></span> is the size of the list. We will discuss some efficient approaches based on the observations we made here.<br/>\n<br/></p>\n<hr/>\n<h3 class=\"group/heading relative\" id=\"approach-1-binary-search\" level=\"3\"><a aria-hidden=\"true\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" href=\"#approach-1-binary-search\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" data-icon=\"link\" data-prefix=\"fas\" focusable=\"false\" role=\"img\" spacing=\"square\" viewbox=\"0 0 640 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\" fill=\"currentColor\"></path></svg></div></a>Approach 1: Binary Search</h3>\n<p><strong>Intuition</strong></p>\n<p>The words <code>word1</code> and <code>word2</code> would be present at some indices in the original list. If we fix one index, say <code>x</code> for the first word <code>word1</code>, then the shortest distance to the second word <code>word2</code> would be at the index closest to the index <code>x</code>. Now if we have indices for <code>word2</code> arranged in ascending order, we can apply binary search to find the closest index in <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mop\">lo<span style=\"margin-right: 0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right: 0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span></span> time instead of iterating over all indices.</p>\n<p>This is the observation that we can use to solve this problem. We will store indices of <code>word1</code> in the list <code>indices1</code> and indices for <code>word2</code> in the list <code>indices2</code>. Then we will iterate over the first list, <code>indices1</code>, and for each index, we will apply binary search on the second list <code>indices2</code> to find the closest index and store the minimum of all in the answer variable.</p>\n<p><strong>Algorithm</strong></p>\n<ol>\n<li data-length=\"1\">\n<p>Iterate over the list <code>wordsDict</code> and store the indices of <code>word1</code> in the list <code>indices1</code> and indices of <code>word2</code> in the list <code>indices2</code>.</p>\n</li>\n<li data-length=\"1\">\n<p>Initialize the answer variable <code>shortestDistance = INT_MAX</code>. This will store the minimum distance possible.</p>\n</li>\n<li data-length=\"1\">\n<p>Iterate over the indices in the list <code>indices1</code> and for each <code>index</code>:</p>\n<p>a. Find the <code>upper_bound</code> in the list <code>indices2</code> using binary search; the <code>upper_bound</code> will return the first index in the list <code>indices2</code> that is greater than <code>index</code> or will return next to the last index in case there is no greater index. Store this index in the variable <code>x</code>.</p>\n<p>b. Now that we have <code>x</code>, we must consider both <code>indices2[x]</code> and <code>indices[x - 1]</code>. If <code>indices[x]</code> is not out of bounds, then find the distance as <code>indices2[x] - index</code> and update the variable <code>shortestDistance</code> accordingly.</p>\n<p>c. If <code>x &gt; 0</code>, find the difference between <code>index</code> with <code>indices2[x - 1]</code> and if the indices are not the same, update the variable <code>shortestDistance</code>.</p>\n</li>\n<li data-length=\"1\">\n<p>Return <code>shortestDistance</code>.</p>\n</li>\n</ol>\n<p><strong>Implementation</strong></p>\n<pre><code>class Solution {\npublic:\n    int shortestWordDistance(vector&lt;string&gt;&amp; wordsDict, string word1, string word2) {\n        vector&lt;int&gt; indices1, indices2;\n        // Store the indices of word1 in the list indices1 and indices of word2 in the list indices2.\n        for (int i = 0; i &lt; wordsDict.size(); i++) {\n            if (wordsDict[i] == word1) {\n                indices1.push_back(i);\n            }\n            if (wordsDict[i] == word2) {\n                indices2.push_back(i);\n            }\n        }\n​\n        // Initialize it to maximum integer as it will store the minimum distance.\n        int shortestDistance = INT_MAX;\n        // Iterate over the indices of word1\n        for (int index : indices1) {\n            // Find the next greater index in the list indices2\n            int x = upper_bound(indices2.begin(), indices2.end(), index) - indices2.begin();\n                         \n            if (x != indices2.size()) {\n                // If x is not pointing to the last iterator, find the difference between these two indices\n                shortestDistance = min(shortestDistance, indices2[x] - index);\n            }\n            \n            if (x != 0 &amp;&amp; indices2[x - 1] != index) {\n                // Find difference betwee index and indices[x - 1], if x &gt; 0 and the indices are not the same.\n                shortestDistance = min(shortestDistance, index - indices2[x - 1]);\n            }\n        }\n        \n        return shortestDistance;\n    }\n};</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<p>Here, <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span></span></span></span></span> is the number of strings in the list <code>wordsDict</code>.</p>\n<ul>\n<li>\n<p>Time complexity: <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right: 0.1667em;\"></span><span class=\"mop\">lo<span style=\"margin-right: 0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right: 0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n<p>We iterate over the indices in the list <code>indices1</code> and, for each index, apply binary search over the second list. Since the size of both lists can be at-max <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span></span></span></span></span>. The total time complexity would equal <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right: 0.1667em;\"></span><span class=\"mop\">lo<span style=\"margin-right: 0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right: 0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n</li>\n<li>\n<p>Space complexity: <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n<p>We need two lists, <code>indices1</code> and <code>indices2</code>, the size of which could be <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span></span></span></span></span> in the worst case. Hence, the total space complexity would equal <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span></span>.<br/>\n<br/></p>\n</li>\n</ul>\n<hr/>\n<h3 class=\"group/heading relative\" id=\"approach-2-merging-lists\" level=\"3\"><a aria-hidden=\"true\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" href=\"#approach-2-merging-lists\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" data-icon=\"link\" data-prefix=\"fas\" focusable=\"false\" role=\"img\" spacing=\"square\" viewbox=\"0 0 640 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\" fill=\"currentColor\"></path></svg></div></a>Approach 2: Merging Lists</h3>\n<p><strong>Intuition</strong></p>\n<p>As we mentioned in the previous approach, for a particular index of the first word, <code>word1</code>, the shortest distance to <code>word2</code> will be the index closest to the <code>word1</code> index. We have two lists of indices for each word, <code>word1</code> and <code>word2</code>. In this approach, we will merge these two lists in ascending order as pairs by keeping another integer (<code>0</code> or <code>1</code>) to differentiate if the index corresponds to <code>word1</code> or <code>word2</code>.</p>\n<p>After merging the lists in ascending order, we will check every two consecutive pairs and find the difference between them. We can only consider pairs that have both values different. The first value of the pair is the index - this cannot be the same because then we would be using the same word in the input twice. The second value of the pair is the ID. This must be different so we know we are using both <code>word1</code> and <code>word2</code>.</p>\n<p><strong>Algorithm</strong></p>\n<ol>\n<li data-length=\"1\">Iterate over the strings in the list <code>wordsDict</code>, and for each string in the list which is either <code>word1</code> or <code>word2</code>, insert an entry as <code>{i, 0}</code> or <code>{i, 1}</code> into the list <code>indices</code>, where <code>i</code> is the index of string and the second integer represents whether the string corresponds to <code>word1</code> or <code>word2</code>.</li>\n<li data-length=\"1\">Initialize the answer variable <code>shortestDistance = INT_MAX</code>. This will store the minimum distance possible.</li>\n<li data-length=\"1\">Iterate over the list <code>indices</code> from the position <code>0</code> to the second last index, compare every pair with the next pair in the list, and if both values in the pair are different, then find the difference between the indices in these two pairs and update <code>shortestDistance</code> accordingly.</li>\n<li data-length=\"1\">Return <code>shortestDistance</code>.</li>\n</ol>\n<p><strong>Implementation</strong></p>\n<pre><code>class Solution {\npublic:\n    int shortestWordDistance(vector&lt;string&gt;&amp; wordsDict, string word1, string word2) {\n        vector&lt;pair&lt;int, int&gt;&gt; indices;\n        // Store the indices of word1 or word2 and an extra integer in the pair\n        // as 0 if the string is word1 or 1 if the string is word2.\n        for (int i = 0; i &lt; wordsDict.size(); i++) {\n            if (wordsDict[i] == word1) {\n                indices.push_back({i, 0});\n            }\n            if (wordsDict[i] == word2) {\n                indices.push_back({i, 1});\n            }\n        }\n​\n        // Initialize it to maximum integer as it will store the minimum distance.\n        int shortestDistance = INT_MAX;\n        for (int i = 0; i &lt; indices.size() - 1; i++) {\n            // If the two consecutive pairs have both different values\n            if (indices[i].second != indices[i + 1].second &amp;&amp; indices[i].first != indices[i + 1].first) {\n                // Find the difference between indices and update shortestDistance\n                shortestDistance = min(shortestDistance, indices[i + 1].first - indices[i].first);\n            }\n        }\n        return shortestDistance;\n    }\n};</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<p>Here, <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span></span></span></span></span> is the number of strings in the list <code>wordsDict</code>.</p>\n<ul>\n<li>\n<p>Time complexity: <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n<p>We iterate over the list <code>wordsDict</code> and store the pairs in the list <code>indices</code>. Then we iterate over the list <code>indices</code> to find the minimum distance. Thus, the time complexity equals <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n</li>\n<li>\n<p>Space complexity: <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n<p>We need a list <code>indices</code> to store the pairs; the list size can be at max <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6444em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span></span></span></span></span> if <code>word1</code> and <code>word2</code> are the same and all the strings in the list <code>wordsDict</code> are identical as well. Hence, the total space complexity equals <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span></span>.<br/>\n<br/></p>\n</li>\n</ul>\n<hr/>\n<h3 class=\"group/heading relative\" id=\"approach-3-two-pointer\" level=\"3\"><a aria-hidden=\"true\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" href=\"#approach-3-two-pointer\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" data-icon=\"link\" data-prefix=\"fas\" focusable=\"false\" role=\"img\" spacing=\"square\" viewbox=\"0 0 640 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\" fill=\"currentColor\"></path></svg></div></a>Approach 3: Two Pointer</h3>\n<p><strong>Intuition</strong></p>\n<blockquote>\n<p>Let's call a string <strong>interesting</strong> if it is either <code>word1</code> or <code>word2</code>.</p>\n</blockquote>\n<p>In this approach, instead of storing the indices for interesting words in a list and then comparing the consecutive entries, we can keep two pointers. One points to the most recently seen interesting word and the other is used to iterate over the input. Then, similar to the previous approach, we can compare these two entries and update the variable <code>shortestDistance</code> accordingly.</p>\n<p>While comparing the two pointers, we need to check for two things; either the two pointers are pointing to two different strings, or if they are pointing to the same string, then <code>word1</code> should be equal to <code>word2</code>.</p>\n<p><strong>Note:</strong> The <code>prevIndex</code> in the below slideshow represents the index of the previous interesting string, and we initialize it as <code>-1</code>.</p>\n<p> <br/></p>\n<p><strong>Algorithm</strong></p>\n<ol>\n<li data-length=\"1\">\n<p>Initialize the answer variable <code>shortestDistance = INT_MAX</code>, this will store the minimum distance possible.</p>\n</li>\n<li data-length=\"1\">\n<p>Initialize <code>prevIndex</code> to <code>-1</code>; this variable will be pointing to the previous index where we have an interesting string.</p>\n</li>\n<li data-length=\"1\">\n<p>Iterate over the list <code>wordsDict</code> from <code>0</code> to the last index, and for each index <code>i</code>, if the string at this index is interesting:</p>\n<p>a. First, check if <code>prevIndex != -1</code>. Then, check if either <code>word1</code> and <code>word2</code> are equal, or the index <code>prevIndex</code> and <code>i</code> are pointing to different strings in the list. If yes, find the difference between <code>prevIndex</code> and <code>i</code> and update<code>shortestDistance</code> accordingly.</p>\n<p>b. Set <code>prevIndex = i</code>.</p>\n</li>\n<li data-length=\"1\">\n<p>Return <code>shortestDistance</code>.</p>\n</li>\n</ol>\n<p><strong>Implementation</strong></p>\n<pre><code>class Solution {\npublic:\n    int shortestWordDistance(vector&lt;string&gt;&amp; wordsDict, string word1, string word2) {\n        // Initialize it to maximum integer as it will store the minimum distance.\n        int shortestDistance = INT_MAX;\n        \n        // Initialize it to -1 as it's not pointing to any index yet.\n        int prevIndex = -1;\n        for (int i = 0; i &lt; wordsDict.size(); i++) {\n            // If the string at this index is either word1 or word2\n            if (wordsDict[i] == word1 || wordsDict[i] == word2) {\n                // If prevIndex is present and pointing to a different string than the string at the current index\n                // Or if both word1 and word2 are the same.\n                if (prevIndex != -1 &amp;&amp; (wordsDict[prevIndex] != wordsDict[i] || word1 == word2)) {\n                    shortestDistance = min(shortestDistance, i - prevIndex);\n                }\n                // Update the prevIndex to point it to the current index.\n                prevIndex = i;\n            }\n        }  \n        return shortestDistance;\n    }\n}; </code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<p>Here, <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span></span></span></span></span> is the number of strings in the list <code>wordsDict</code>.</p>\n<ul>\n<li>\n<p>Time complexity: <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n<p>We iterate over the strings in the list <code>wordsDict</code> and perform <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></span> work at each iteration. Therefore, the time complexity equals <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n</li>\n<li>\n<p>Space complexity: <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n<p>We don't need any extra space other than the variable <code>prevIndex</code> and <code>shortestDistance</code>; hence the space complexity is constant.<br/>\n<br/></p>\n</li>\n</ul>\n<hr/></div><span style=\"font-size: 0px; line-height: 0;\"> </span></div>"}