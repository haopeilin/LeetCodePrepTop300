{"id":"259","title":"3Sum Smaller","difficulty":"Medium","content":"<p>Given an array of <code>n</code> integers <code>nums</code> and an integer&nbsp;<code>target</code>, find the number of index triplets <code>i</code>, <code>j</code>, <code>k</code> with <code>0 &lt;= i &lt; j &lt; k &lt; n</code> that satisfy the condition <code>nums[i] + nums[j] + nums[k] &lt; target</code>.</p>\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [-2,0,1,3], target = 2\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> Because there are two triplets which sums are less than 2:\n[-2,0,1]\n[-2,0,3]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [], target = 0\n<strong>Output:</strong> 0\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [0], target = 0\n<strong>Output:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>0 &lt;= n &lt;= 3500</code></li>\n\t<li><code>-100 &lt;= nums[i] &lt;= 100</code></li>\n\t<li><code>-100 &lt;= target &lt;= 100</code></li>\n\t<li>The input is generated such that the answer is less than or equal to 10<sup>9</sup>.</li>\n</ul>\n","tags":["Array","Two Pointers","Binary Search","Sorting"],"java_snippet":"class Solution {\n    public int threeSumSmaller(int[] nums, int target) {\n        \n    }\n}","solution":"<h2><a href=\"#solution\"><svg><path></path></svg></a>Solution</h2>\n<hr/>\n<h3><a href=\"#approach-1-brute-force\"><svg><path></path></svg></a>Approach 1: Brute Force</h3>\n<p><strong>Intuition</strong></p>\n<p>Find every possible set of triplets (i,j,k) such that i&lt;j&lt;k and test for the condition.</p>\n<p><strong>Complexity analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity: O(n3).<br/>\nThe total number of such triplets is (3n​), which is (n−3)!×3!n!​=6n×(n−1)×(n−2)​. Therefore, the time complexity of the brute force approach is O(n3).</p>\n</li>\n<li>\n<p>Space complexity: O(1).</p>\n</li>\n</ul>\n<hr/>\n<h3><a href=\"#approach-2-binary-search\"><svg><path></path></svg></a>Approach 2: Binary Search</h3>\n<p><strong>Intuition</strong></p>\n<p>Before we solve the <em>threeSum</em> problem, solve this simpler <em>twoSum</em> version:</p>\n<blockquote>\n<p>Given a nums array, find the number of index pairs i, j with 0≤i&lt;j&lt;n that satisfy the condition nums[i]+nums[j]&lt;target</p>\n</blockquote>\n<p>If we sort the array first, then we can apply binary search to find the largest index j such that nums[i]+nums[j]&lt;target for each i. Once we have found that largest index j, we know there must be j−i pairs that satisfy the above condition with i's value fixed.</p>\n<p>Finally, we can now apply the <em>twoSum</em> solution to <em>threeSum</em> directly by wrapping an outer for-loop around it.</p>\n<p><strong>Implementation</strong></p>\n<pre><code>class Solution {\n    public int threeSumSmaller(int[] nums, int target) {\n        Arrays.sort(nums);\n        int sum = 0;\n        for (int i = 0; i &lt; nums.length - 2; i++) {\n            sum += twoSumSmaller(nums, i + 1, target - nums[i]);\n        }\n        return sum;\n    }\n​\n    private int twoSumSmaller(int[] nums, int startIndex, int target) {\n        int sum = 0;\n        for (int i = startIndex; i &lt; nums.length - 1; i++) {\n            int j = binarySearch(nums, i, target - nums[i]);\n            sum += j - i;\n        }\n        return sum;\n    }\n​\n    private int binarySearch(int[] nums, int startIndex, int target) {\n        int left = startIndex;\n        int right = nums.length - 1;\n        while (left &lt; right) {\n            int mid = (left + right + 1) / 2;\n            if (nums[mid] &lt; target) {\n                left = mid;\n            } else {\n                right = mid - 1;\n            }\n        }\n        return left;\n    }\n}</code></pre>\n<p>Note that in the above binary search we choose the upper middle element (2left+right+1​) instead of the lower middle element (2left+right​). The reason is due to the terminating condition when there are two elements left. If we chose the lower middle element and the condition nums[mid]&lt;target evaluates to true, then the loop would never terminate. Choosing the upper middle element will guarantee termination.</p>\n<p><strong>Complexity analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity: O(n2logn).<br/>\nThe <em>binarySearch</em> function takes O(logn) time, therefore the <em>twoSumSmaller</em> takes O(nlogn) time. The <em>threeSumSmaller</em> wraps with another for-loop, and therefore is O(n2logn) time.</p>\n</li>\n<li>\n<p>Space complexity: O(1) because no additional data structures are used.</p>\n</li>\n</ul>\n<hr/>\n<h3><a href=\"#approach-3-two-pointers\"><svg><path></path></svg></a>Approach 3: Two Pointers</h3>\n<p><strong>Intuition</strong></p>\n<p>Let us try sorting the array first. For example, nums=[3,5,2,8,1] becomes [1,2,3,5,8].</p>\n<p>Let us look at an example nums=[1,2,3,5,8], and target=7.</p>\n<svg><path></path></svg>\n<p>Let us initialize two indices, left and right pointing to the first and last element respectively.</p>\n<p>When we look at the sum of first and last element, it is 1+8=9, which is ≥target. That tells us no index pair will ever contain the index right. So the next logical step is to move the right pointer one step to its left.</p>\n<svg><path></path></svg>\n<p>Now the pair sum is 1+5=6, which is less than target. How many pairs with one of the index=left that satisfy the condition? You can tell by the difference between right and left which is 3, namely (1,2),(1,3), and (1,5). Therefore, we move left one step to its right.</p>\n<p><strong>Implementation</strong></p>\n<pre><code>class Solution {\n    public int threeSumSmaller(int[] nums, int target) {\n        Arrays.sort(nums);\n        int sum = 0;\n        for (int i = 0; i &lt; nums.length - 2; i++) {\n            sum += twoSumSmaller(nums, i + 1, target - nums[i]);\n        }\n        return sum;\n    }\n​\n    private int twoSumSmaller(int[] nums, int startIndex, int target) {\n        int sum = 0;\n        int left = startIndex;\n        int right = nums.length - 1;\n        while (left &lt; right) {\n            if (nums[left] + nums[right] &lt; target) {\n                sum += right - left;\n                left++;\n            } else {\n                right--;\n            }\n        }\n        return sum;\n    }\n}</code></pre>\n<p><strong>Complexity analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity: O(n2).<br/>\n<em>twoSumSmaller</em> takes O(n) at most since it touches each element in the array once. It's parent function, <em>threeSumSmaller</em> takes O(nlogn) to sort the array, then runs a loop that touches (n−2) elements, invoking <em>twoSumSmaller</em> at each iteration. Therefore, the overall time complexity is O(nlogn+n2), which boils down to O(n2).</p>\n</li>\n<li>\n<p>Space complexity: O(1) because no additional data structures are used.</p>\n</li>\n</ul>"}