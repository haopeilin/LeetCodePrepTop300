{"id":"111","title":"Minimum Depth of Binary Tree","difficulty":"Easy","content":"<p>Given a binary tree, find its minimum depth.</p>\n\n<p>The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</p>\n\n<p><strong>Note:</strong>&nbsp;A leaf is a node with no children.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/12/ex_depth.jpg\" style=\"width: 432px; height: 302px;\" />\n<pre>\n<strong>Input:</strong> root = [3,9,20,null,null,15,7]\n<strong>Output:</strong> 2\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [2,null,3,null,4,null,5,null,6]\n<strong>Output:</strong> 5\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 10<sup>5</sup>]</code>.</li>\n\t<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n","tags":["Tree","Depth-First Search","Breadth-First Search","Binary Tree"],"java_snippet":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int minDepth(TreeNode root) {\n        \n    }\n}","solution":"<h2><a href=\"#solution\"><svg><path></path></svg></a>Solution</h2>\n<h3><a href=\"#approach-1-depth-first-search-dfs\"><svg><path></path></svg></a>Approach 1: Depth-First Search (DFS)</h3>\n<p><strong>Intuition</strong></p>\n<blockquote>\n<p>If you're not familiar with DFS, check out our <a href=\"https://leetcode.com/explore/learn/card/graph/619/depth-first-search-in-graph/\">Explore Card</a>.</p>\n</blockquote>\n<p>We are given a binary tree; we must return the minimum number of nodes between the root and any leaf node, including both. Let's try to break this problem into subproblems; we need to return the answer from the root of the current tree; what if we know the answer considering the left and right child of the root node? If the minimum depth for the root node's left child is <code>x</code> and the minimum depth for the root node's right child is <code>y</code>, then the minimum depth for the whole tree with the root node will be <code>1 + min(x, y)</code>. The additional <code>+1</code> is for the current root node.</p>\n<p>This way, we can divide the current problem into subproblems and then solve them using recursion. The base condition of this recursion would be when the node is <code>NULL</code>, in which case we should return <code>0</code>. One tricky thing that we need to consider is when one of the children is <code>NULL</code> and the other one isn't. We shouldn't move forward with recursion on the <code>NULL</code> child; if we do, we would return <code>0</code> due to the base condition and the count of nodes from the leaf node on the other side would be discarded as we are taking the minimum of the two. In case both children are <code>NULL</code>, it's fine to go into recursion as both would return <code>0</code>, and the minimum of the two won't cause an issue.</p>\n<p>If we observe closely, we are first traversing to the deepest node and then backtracking to the parent node to find the minimum depth for it; hence, this process is actually Depth-First Search (DFS).</p>\n<p></p>\n<p><strong>Algorithm</strong></p>\n<ol>\n<li>We will use the <code>dfs</code> method with <code>root</code> as an argument.</li>\n<li>The base condition of the recursion would be for the <code>NULL</code> node, in which case we should return <code>0</code>.</li>\n<li>If the left child of <code>root</code> is <code>NULL</code>, then we should return <code>1</code> + minimum depth for the right child of the root node, which is <code>1 + dfs(root.right)</code>.</li>\n<li>If the right child of <code>root</code> is <code>NULL</code>, then we should return <code>1</code> + minimum depth for the left child of the root node, which is <code>1 + dfs(root.left)</code>.</li>\n<li>If both child are non-null, then return <code>1 + min(dfs(root.left), dfs(root.right))</code>.</li>\n</ol>\n<p><strong>Implementation</strong></p>\n<pre><code>class Solution {\n    private int dfs(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n\n        // If only one of child is non-null, then go into that recursion.\n        if (root.left == null) {\n            return 1 + dfs(root.right);\n        } else if (root.right == null) {\n            return 1 + dfs(root.left);\n        }\n\n        // Both children are non-null, hence call for both children.\n        return 1 + Math.min(dfs(root.left), dfs(root.right));\n    }\n\n    public int minDepth(TreeNode root) {\n        return dfs(root);\n    }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<p>Here, N is the number of nodes in the binary tree.</p>\n<ul>\n<li>\n<p>Time complexity: O(N)</p>\n<p>We will traverse each node in the tree only once; hence, the total time complexity would be O(N).</p>\n</li>\n<li>\n<p>Space complexity: O(N)</p>\n<p>The only space required is the stack space; the maximum number of active stack calls would equal the maximum depth of the tree, which could equal the total number of nodes in the tree. Hence, the space complexity would equal O(N).<br/>\n<br/></p>\n</li>\n</ul>\n<hr/>\n<h3><a href=\"#approach-2-breadth-first-search-bfs\"><svg><path></path></svg></a>Approach 2: Breadth-First Search (BFS)</h3>\n<p><strong>Intuition</strong></p>\n<blockquote>\n<p>If you're not familiar with BFS, check out our <a href=\"https://leetcode.com/explore/learn/card/graph/620/breadth-first-search-in-graph/\">Explore Card</a>.</p>\n</blockquote>\n<p>We traversed the tree depth-wise in the previous approach; the other way to iterate it is in a breadth-wise manner using BFS. BFS uses FIFO, i.e. first in, first out approach using a queue, and hence we are able to traverse all the nodes at a level first before going further down.</p>\n<p>We will use a queue to store all the nodes that are there at the same level. Starting with the root node, we will store the root node in the queue. Then we will iterate over all the current nodes in the queue and for each node we will add its left and right child to the queue. The important point to note here is that since we are traversing nodes level-wise, the first node which is a leaf, i.e. both left and right children are null; We will know that this is the node with the minimum depth.</p>\n<p><strong>Algorithm</strong></p>\n<ol>\n<li>\n<p>Return <code>0</code> if the root is <code>NULL</code>.</p>\n</li>\n<li>\n<p>Initialize the queue <code>q</code> with the root node and <code>depth</code> to <code>1</code>.</p>\n</li>\n<li>\n<p>Do the following while the queue isn't empty:</p>\n<p>i. Iterate over all the nodes that are currently in the queue.</p>\n<p>ii. Skip the node if it's null; otherwise, if it's a leaf node, then return <code>depth</code>.</p>\n<p>iii. For each node, add the left and right child to the queue.</p>\n<p>iv. Increment the <code>depth</code> once the level is fully iterated.</p>\n</li>\n<li>\n<p>Ideally, our code shouldn't reach here, so return any value once the queue is empty.</p>\n</li>\n</ol>\n<p><strong>Implementation</strong></p>\n<pre><code>import java.util.LinkedList;\nimport java.util.Queue;\n\nclass Solution {\n    public int minDepth(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n\n        Queue<treenode> q = new LinkedList&lt;&gt;();\n        q.offer(root);\n        int depth = 1;\n\n        while (!q.isEmpty()) {\n            int qSize = q.size();\n\n            while (qSize-- &gt; 0) {\n                TreeNode node = q.poll();\n                // Since we added nodes without checking null, we need to skip\n                // them here.\n                if (node == null) {\n                    continue;\n                }\n\n                // The first leaf would be at minimum depth, hence return it.\n                if (node.left == null &amp;&amp; node.right == null) {\n                    return depth;\n                }\n\n                q.offer(node.left);\n                q.offer(node.right);\n            }\n\n            depth++;\n        }\n        return -1;\n    }\n}</treenode></code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<p>Here, N is the number of nodes in the binary tree.</p>\n<ul>\n<li>\n<p>Time complexity: O(N)</p>\n<p>We will be iterating over each node in the tree only once; therefore, the total time complexity would be O(N).</p>\n</li>\n<li>\n<p>Space complexity: O(N)</p>\n<p>The only space required is the queue; the maximum number of nodes in the queue would be N. Hence, the space complexity would equal O(N).<br/>\n<br/></p>\n</li>\n</ul>\n<hr/>"}