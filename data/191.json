{"id":"191","title":"Number of 1 Bits","difficulty":"Easy","content":"<p>Given a positive integer <code>n</code>, write a function that returns the number of <span data-keyword=\"set-bit\">set bits</span> in its binary representation (also known as the <a href=\"http://en.wikipedia.org/wiki/Hamming_weight\" target=\"_blank\">Hamming weight</a>).</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">n = 11</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">3</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p>The input binary string <strong>1011</strong> has a total of three set bits.</p>\n</div>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">n = 128</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">1</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p>The input binary string <strong>10000000</strong> has a total of one set bit.</p>\n</div>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">n = 2147483645</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">30</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p>The input binary string <strong>1111111111111111111111111111101</strong> has a total of thirty set bits.</p>\n</div>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> If this function is called many times, how would you optimize it?","tags":["Divide and Conquer","Bit Manipulation"],"java_snippet":"class Solution {\n    public int hammingWeight(int n) {\n        \n    }\n}","solution":"<h2><a href=\"#solution\"><svg><path></path></svg></a>Solution</h2>\n<hr/>\n<h3><a href=\"#approach-1-loop-and-flip\"><svg><path></path></svg></a>Approach 1: Loop and Flip</h3>\n<p><strong>Algorithm</strong></p>\n<p>The solution is straight-forward. We check each of the 32 bits of the number. If the bit is 1, we add one to the number of 1-bits.</p>\n<p>We can check the ith bit of a number using a <em>bit mask</em>. We start with a mask m=1, because the binary representation of 1 is,</p>\n<p>0000 0000 0000 0000 0000 0000 0000 0001<br/>\nClearly, a logical AND between any number and the mask 1 gives us the least significant bit of this number. To check the next bit, we shift the mask to the left by one.</p>\n<p>0000 0000 0000 0000 0000 0000 0000 0010</p>\n<p>And so on.</p>\n<p><strong>Implementation</strong></p>\n<pre><code>public int hammingWeight(int n) {\n    int bits = 0;\n    int mask = 1;\n    for (int i = 0; i &lt; 32; i++) {\n        if ((n &amp; mask) != 0) {\n            bits++;\n        }\n        mask &lt;&lt;= 1;\n    }\n    return bits;\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<p>The run time depends on the number of bits in n. Because n in this piece of code is a 32-bit integer, the time complexity is O(1).</p>\n<p>The space complexity is O(1), since no additional space is allocated.</p>\n<hr/>\n<h3><a href=\"#approach-2-bit-manipulation\"><svg><path></path></svg></a>Approach 2: Bit Manipulation</h3>\n<p><strong>Algorithm</strong></p>\n<p>We can make the previous algorithm simpler and a little faster. Instead of checking every bit of the number, we repeatedly flip the least-significant 1-bit of the number to 0, and add 1 to the sum. As soon as the number becomes 0, we know that it does not have any more 1-bits, and we return the sum.</p>\n<p>The key idea here is to realize that for any number n, doing a bit-wise AND of n and n−1 flips the least-significant 1-bit in n to 0. Why? Consider the binary representations of n and n−1.</p>\n<p></p>\n<p><em>Figure 1. AND-ing n and n−1 flips the least-significant 1-bit to 0.</em></p>\n<p>In the binary representation, the least significant 1-bit in n always corresponds to a 0-bit in n−1. Therefore, anding the two numbers n and n−1 always flips the least significant 1-bit in n to 0, and keeps all other bits the same.</p>\n<p>Using this trick, the code becomes very simple.</p>\n<p><strong>Implementation</strong></p>\n<pre><code>public int hammingWeight(int n) {\n    int sum = 0;\n    while (n != 0) {\n        sum++;\n        n &amp;= (n - 1);\n    }\n    return sum;\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<p>The run time depends on the number of 1-bits in n. In the worst case, all bits in n are 1-bits. In case of a 32-bit integer, the run time is O(1).</p>\n<p>The space complexity is O(1), since no additional space is allocated.</p>\n<br/>"}