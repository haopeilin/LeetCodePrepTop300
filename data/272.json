{"id":"272","title":"Closest Binary Search Tree Value II","difficulty":"Hard","content":"<p>Given the <code>root</code> of a binary search tree, a <code>target</code> value, and an integer <code>k</code>, return <em>the </em><code>k</code><em> values in the BST that are closest to the</em> <code>target</code>. You may return the answer in <strong>any order</strong>.</p>\n\n<p>You are <strong>guaranteed</strong> to have only one unique set of <code>k</code> values in the BST that are closest to the <code>target</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/12/closest1-1-tree.jpg\" style=\"width: 292px; height: 302px;\" />\n<pre>\n<strong>Input:</strong> root = [4,2,5,1,3], target = 3.714286, k = 2\n<strong>Output:</strong> [4,3]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [1], target = 0.000000, k = 1\n<strong>Output:</strong> [1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is <code>n</code>.</li>\n\t<li><code>1 &lt;= k &lt;= n &lt;= 10<sup>4</sup></code>.</li>\n\t<li><code>0 &lt;= Node.val &lt;= 10<sup>9</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= target &lt;= 10<sup>9</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Assume that the BST is balanced. Could you solve it in less than <code>O(n)</code> runtime (where <code>n = total nodes</code>)?</p>\n","tags":["Two Pointers","Stack","Tree","Depth-First Search","Binary Search Tree","Heap (Priority Queue)","Binary Tree"],"java_snippet":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public List<Integer> closestKValues(TreeNode root, double target, int k) {\n        \n    }\n}","solution":"<h2><a href=\"#solution\"><svg><path></path></svg></a>Solution</h2>\n<hr/>\n<h3><a href=\"#approach-1-sort-with-custom-comparator\"><svg><path></path></svg></a>Approach 1: Sort With Custom Comparator</h3>\n<h4>Intuition</h4>\n<p>Do exactly as the problem asks. First, traverse the tree and put all values in an array. Then sort the array according to distance from <code>target</code> and return the first <code>k</code> values.</p>\n<h4>Algorithm</h4>\n<ol>\n<li>Perform a DFS on <code>root</code> and put all values in an array.</li>\n<li>Sort the array using a custom comparator: distance from <code>target</code>.</li>\n<li>Return the first <code>k</code> values of the sorted array.</li>\n</ol>\n<h4>Implementation</h4>\n<pre><code>class Solution {\n    public List&lt;Integer&gt; closestKValues(TreeNode root, double target, int k) {\n        List&lt;Integer&gt; arr = new ArrayList&lt;&gt;();\n        dfs(root, arr);\n        \n        Collections.sort(arr, (o1, o2) -&gt; Math.abs(o1 - target) &lt;= Math.abs(o2 - target) ? -1 : 1);\n        \n        return arr.subList(0, k);\n        \n    }\n    \n    public void dfs(TreeNode node, List&lt;Integer&gt; arr) {\n        if (node == null) {\n            return;\n        }\n        \n        arr.add(node.val);\n        dfs(node.left, arr);\n        dfs(node.right, arr);\n    }\n}</code></pre>\n<h4>Complexity Analysis</h4>\n<p>Given n as the number of nodes in the tree,</p>\n<ul>\n<li>\n<p>Time complexity: O(n⋅logn)</p>\n<p>We traverse the tree and collect all values in O(n). Then, we sort the values which costs O(n⋅logn).</p>\n</li>\n<li>\n<p>Space complexity: O(n)</p>\n<p>Both <code>arr</code> and the recursion call stack use O(n) space. Depending on the language, some space is also used for sorting, but not more than O(n).</p>\n</li>\n</ul>\n<br/>\n<hr/>\n<h3><a href=\"#approach-2-traverse-with-heap\"><svg><path></path></svg></a>Approach 2: Traverse With Heap</h3>\n<h4>Intuition</h4>\n<p>\"Find the K best elements\" is a common type of problem. The most common way to solve these problems is by using a heap that eliminates \"worse\" elements (according to whatever criteria the problem description gives). If we limit the size of this heap to <code>k</code>, then the heap will hold the answer after we process all elements.</p>\n<p>We can perform a traversal over the tree and push all values onto a max heap. We will use a value's distance from <code>target</code> as the key in the heap. Because we are using a max heap, larger distances will be popped.</p>\n<h4>Algorithm</h4>\n<ol>\n<li>Declare a max <code>heap</code> that judges elements based on their distance from <code>target</code>.</li>\n<li>Perform a DFS on the tree:\n<ul>\n<li>At each <code>node</code>, push <code>node.val</code> onto the <code>heap</code>.</li>\n<li>If the heap's size exceeds <code>k</code>, pop from <code>heap</code>.</li>\n</ul>\n</li>\n<li>Return the elements in <code>heap</code>.</li>\n</ol>\n<h4>Implementation</h4>\n<blockquote>\n<p>Note: Python's <code>heapq</code> module only implements min heaps, so we will make the keys negative to emulate a max heap.</p>\n</blockquote>\n<pre><code>class Solution {\n    public List&lt;Integer&gt; closestKValues(TreeNode root, double target, int k) {\n        Queue&lt;Integer&gt; heap = new PriorityQueue&lt;&gt;((a, b) -&gt; Math.abs(a - target) &gt; Math.abs(b - target) ? -1: 1);\n        dfs(root, heap, k);\n        \n        return new ArrayList&lt;&gt;(heap);\n    }\n    \n    public void dfs(TreeNode node, Queue&lt;Integer&gt; heap, int k) {\n        if (node == null) {\n            return;\n        }\n        \n        heap.add(node.val);\n        if (heap.size() &gt; k) {\n            heap.remove();\n        }\n        \n        dfs(node.left, heap, k);\n        dfs(node.right, heap, k);\n    }\n}</code></pre>\n<h4>Complexity Analysis</h4>\n<p>Given n as the number of nodes in the tree,</p>\n<ul>\n<li>\n<p>Time complexity: O(n⋅logk)</p>\n<p>A heap operation's cost is a function of the size of the heap. We are limiting the size of our heap to k, so heap operations will cost O(logk).</p>\n<p>We visit each node once. At each node, we perform up to two heap operations. Therefore, we perform a maximum of 2n heap operations, giving us a time complexity of O(n⋅logk).</p>\n</li>\n<li>\n<p>Space complexity: O(n+k)</p>\n<p>We need O(n) space for the recursion call stack, and O(k) space for the heap.</p>\n</li>\n</ul>\n<br/>\n<hr/>\n<h3><a href=\"#approach-3-inorder-traversal--sliding-window\"><svg><path></path></svg></a>Approach 3: Inorder Traversal + Sliding Window</h3>\n<h4>Intuition</h4>\n<p>The previous two approaches didn't take advantage of the fact that the given tree is a binary search tree. Both approaches would have worked given any arbitrary binary tree.</p>\n<p>An important thing to know is that an inorder traversal on a BST handles the nodes in sorted order. This is because in a BST, at a given <code>node</code>, all nodes in the left subtree have a value less than <code>node</code>, and all values in the right subtree have a value greater than <code>node</code>. Inorder traversal handles all nodes in the left subtree, then <code>node</code>, then all nodes in the right subtree, and thus nodes will be handled in sorted order.</p>\n<p>In the previous two approaches, we performed DFS solely to collect the values. In this approach, we will do an in-order traversal so that the values will be collected in sorted order. How does having the values in sorted order help us?</p>\n<p>In a sorted array, all answer values would form a subarray.</p>\n<p> <br/></p>\n<p>We can find this subarray efficiently by first identifying the element closest to <code>target</code>. Naturally, this element must be in the answer. The next element in the answer must be a neighbor of this element - we check both left and right and add the one that is closer to <code>target</code>. We continue this sliding window process until the window has a size of k, at which point we can return the elements in the window.</p>\n<p> <br/></p>\n<p>The initial (closest) element can be found using binary search, although you could also do a linear scan since we need O(n) to traverse the tree anyways, and thus a binary search would not improve the complexity (although it is still a good optimization to consider in an interview).</p>\n<h4>Algorithm</h4>\n<ol>\n<li>Perform an inorder DFS on the tree to obtain the sorted values in <code>arr</code>.</li>\n<li>Identify the element closest to <code>target</code>. Initialize two pointers <code>left</code> and <code>right</code> at this location.</li>\n<li>While the window has less than <code>k</code> elements:\n<ul>\n<li>If <code>arr[left]</code> is closer to <code>target</code> than <code>arr[right]</code>, add <code>arr[left]</code> to the window and decrement <code>left</code>.</li>\n<li>Otherwise, add <code>arr[right]</code> to the window and increment <code>right</code>.</li>\n<li>Be careful not to go out of bounds.</li>\n</ul>\n</li>\n<li>Return the window.</li>\n</ol>\n<h4>Implementation</h4>\n<pre><code>class Solution {\n    public List&lt;Integer&gt; closestKValues(TreeNode root, double target, int k) {\n        List&lt;Integer&gt; arr = new ArrayList&lt;&gt;();\n        dfs(root, arr);\n        \n        int start = 0;\n        double minDiff = Double.MAX_VALUE;\n        \n        for (int i = 0; i &lt; arr.size(); i++) {\n            if (Math.abs(arr.get(i) - target) &lt; minDiff) {\n                minDiff = Math.abs(arr.get(i) - target);\n                start = i;\n            }\n        }\n        \n        int left = start;\n        int right = start + 1;\n        \n        while (right - left - 1 &lt; k) {\n            // Be careful to not go out of bounds\n            if (left &lt; 0) {\n                right += 1;\n                continue;\n            }\n​\n            if (right == arr.size() || Math.abs(arr.get(left) - target) &lt;= Math.abs(arr.get(right) - target)) {\n                left -= 1;\n            } else {\n                right += 1;\n            }\n        }\n        \n        return arr.subList(left + 1, right);\n    }\n    \n    public void dfs(TreeNode node, List&lt;Integer&gt; arr) {\n        if (node == null) {\n            return;\n        }\n        \n        dfs(node.left, arr);\n        arr.add(node.val);\n        dfs(node.right, arr);\n    }\n}</code></pre>\n<h4>Complexity Analysis</h4>\n<p>Given n as the number of nodes in the tree,</p>\n<ul>\n<li>\n<p>Time complexity: O(n+k)</p>\n<p>First, we perform a DFS on the tree to build <code>arr</code> which costs O(n).</p>\n<p>Next, we perform either a binary search or linear scan on <code>arr</code> which costs O(logn) or O(n). Neither will change the complexity.</p>\n<p>Finally, we perform a sliding window process that costs O(k) since we add an element to the window at each iteration and stop when the window has a size of <code>k</code>.</p>\n</li>\n<li>\n<p>Space complexity: O(n)</p>\n<p>Both <code>arr</code> and the recursion call stack use O(n) space.</p>\n</li>\n</ul>\n<br/>\n<hr/>\n<h3><a href=\"#approach-4-binary-search-the-left-bound\"><svg><path></path></svg></a>Approach 4: Binary Search The Left Bound</h3>\n<h4>Intuition</h4>\n<p>In approach 3, we first created a sorted <code>arr</code> and then did a sliding window process that cost O(k).</p>\n<p>We can identify the window without the sliding window process, and independent of <code>k</code>!</p>\n<p>Binary search is typically used to find if an element exists or where an element belongs in a sorted array. However, we can use it in a different manner here with some clever thinking. We will try to find the left bound of the window using binary search. If we know the left bound, we also know the right bound since we know the window's size must be k.</p>\n<p>What is the biggest index the left bound could be? It is <code>arr.length - k</code>. If it were any greater, then there wouldn't be room for the window to have k elements, you would go out of bounds. The smallest index is <code>0</code>, so this is where we will begin our binary search bounds.</p>\n<p>Consider indices <code>mid = (left + right) / 2</code> and <code>mid + k</code>. Why do we care about <code>mid + k</code>? Because indices <code>mid</code> and <code>mid + k</code> <strong>cannot both be in the answer</strong>. We already established that the answer must be a subarray, and indices <code>mid</code> and <code>mid + k</code> are too far apart.</p>\n<p> <br/></p>\n<p>If the element at <code>arr[mid]</code> is closer to <code>target</code> than <code>arr[mid + k]</code>, there is no chance <code>arr[mid + k]</code> could be in the answer while <code>arr[mid]</code> isn't. Therefore, we can discard <code>arr[mid + k]</code> and every element to the right of it (move the right pointer).</p>\n<p>Vice-versa, if the element at <code>arr[mid + k]</code> is closer to <code>target</code>, then we can discard <code>arr[mid]</code> and every element to the left of it (move the left pointer).</p>\n<p>This binary search will find the left bound of the answer. We can find the answer as the subarray of <code>arr</code> starting at <code>left</code> with a length of <code>k</code>.</p>\n<h4>Algorithm</h4>\n<ol>\n<li>Perform an inorder DFS on the tree to obtain the sorted values in <code>arr</code>.</li>\n<li>Perform a binary search. Initialize <code>left = 0</code> and <code>right = arr.length - k</code>.</li>\n<li>While <code>left &lt; right</code>:\n<ul>\n<li>Calculate <code>mid = (left + right) / 2</code>.</li>\n<li>If <code>arr[mid + k]</code> is closer to <code>target</code> than <code>arr[mid]</code>, move <code>left</code>.</li>\n<li>Otherwise, move <code>right</code>.</li>\n</ul>\n</li>\n<li>Return the subarray of <code>arr</code> starting at <code>left</code> of length <code>k</code>.</li>\n</ol>\n<h4>Implementation</h4>\n<pre><code>class Solution {\n    public List&lt;Integer&gt; closestKValues(TreeNode root, double target, int k) {\n        List&lt;Integer&gt; arr = new ArrayList&lt;&gt;();\n        dfs(root, arr);\n        \n        int left = 0;\n        int right = arr.size() - k;\n        \n        while (left &lt; right) {\n            int mid = (left + right) / 2;\n            if (Math.abs(target - arr.get(mid + k)) &lt; Math.abs(target - arr.get(mid))) {\n                left = mid + 1;\n            } else {\n                right = mid;\n            }\n        }\n        \n        return arr.subList(left, left + k);\n    }\n    \n    public void dfs(TreeNode node, List&lt;Integer&gt; arr) {\n        if (node == null) {\n            return;\n        }\n        \n        dfs(node.left, arr);\n        arr.add(node.val);\n        dfs(node.right, arr);\n    }\n}</code></pre>\n<h4>Complexity Analysis</h4>\n<p>Given n as the number of nodes in the tree,</p>\n<ul>\n<li>\n<p>Time complexity: O(n) in Java, O(n+k) in Python</p>\n<p>First, we perform a DFS on the tree to build <code>arr</code> which costs O(n).</p>\n<p>Next, we perform a binary search on <code>arr</code> which costs O(log(n−k)).</p>\n<p>Finally, we return the answer. In Java, <code>arr.subList()</code> is an O(1) operation. In Python, we spend O(k) to create the answer.</p>\n<p>Note that an interviewer may find it reasonable to ignore the O(k) to build the answer, thus giving this algorithm a time complexity of O(n).</p>\n</li>\n<li>\n<p>Space complexity: O(n)</p>\n<p>Both <code>arr</code> and the recursion call stack use O(n) space.</p>\n</li>\n</ul>\n<br/>\n<hr/>\n<h3><a href=\"#approach-5-build-the-window-with-deque\"><svg><path></path></svg></a>Approach 5: Build The Window With Deque</h3>\n<h4>Intuition</h4>\n<p>This approach combines ideas from approaches 2 and 3. We will build the window during the traversal.</p>\n<p>When we used the heap, we could visit the nodes in any order - we didn't take advantage of the tree being a BST. Here, we will again use an in-order traversal to handle the nodes in sorted order.</p>\n<p>During the traversal, we can build the window using a deque (double-ended queue). Because we visit the nodes in sorted order, values will be added to the deque in ascending order. When the deque's size exceeds <code>k</code>, we need to remove either the first or last element. We will remove the one that is farther from <code>target</code>.</p>\n<blockquote>\n<p>Why do we need to remove the first or last element? It's the exact same idea as the previous approach! Elements at indices <code>i</code> and <code>i + k</code> cannot both exist in a subarray of size <code>k</code>. Because the deque currently has a size greater than <code>k</code>, one of the edges must be removed.</p>\n</blockquote>\n<p>If we find that the last element (the most recently added one) is farther, then all future elements will be even larger. This means that the window is currently positioned correctly, and we can end the DFS early.</p>\n<p>This approach is similar to approach 3 because the deque represents a sliding window. It slides along the sorted values, growing until it reaches a size of <code>k</code>. Once it reaches a size of <code>k</code>, we remove it from the left so that we can continue sliding if the left element is farther than the right element. If the right element is farther, we find our window.</p>\n<h4>Algorithm</h4>\n<ol>\n<li>Initialize a double-ended queue <code>queue</code>.</li>\n<li>Perform an inorder traversal on the tree. To handle each <code>node</code>:\n<ul>\n<li>Add <code>node.val</code> to the end of <code>queue</code>.</li>\n<li>If the size of <code>queue</code> exceeds <code>k</code>:\n<ul>\n<li>Compare the first and last value.</li>\n<li>If the last value is farther from <code>target</code>, remove it and end the DFS with <code>return</code>.</li>\n<li>Otherwise, remove the first element.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Return the <code>queue</code>.</li>\n</ol>\n<h4>Implementation</h4>\n<pre><code>class Solution {\n    public List&lt;Integer&gt; closestKValues(TreeNode root, double target, int k) {\n        Deque&lt;Integer&gt; queue = new LinkedList&lt;&gt;();\n        dfs(root, queue, k, target);\n        return new ArrayList&lt;&gt;(queue);\n    }\n    \n    public void dfs(TreeNode node, Deque&lt;Integer&gt; queue, int k, double target) {\n        if (node == null) {\n            return;\n        }\n        \n        dfs(node.left, queue, k, target);\n        queue.add(node.val);\n        if (queue.size() &gt; k) {\n            if (Math.abs(target - queue.peekFirst()) &lt;= Math.abs(target - queue.peekLast())) {\n                queue.removeLast();\n                return;\n            } else {\n                queue.removeFirst();\n            }\n        }\n​\n        dfs(node.right, queue, k, target);\n    }\n}</code></pre>\n<h4>Complexity Analysis</h4>\n<p>Given n as the number of nodes in the tree,</p>\n<ul>\n<li>\n<p>Time complexity: O(n)</p>\n<p>We visit each node at most once during the traversal. With an efficient <code>deque</code> implementation, the work done at each node is O(1).</p>\n</li>\n<li>\n<p>Space complexity: O(n+k)</p>\n<p>We use O(n) space for the recursion call stack and O(k) space for <code>queue</code>.</p>\n</li>\n</ul>\n<br/>\n<hr/>"}