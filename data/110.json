{"id":"110","title":"Balanced Binary Tree","difficulty":"Easy","content":"<p>Given a binary tree, determine if it is <span data-keyword=\"height-balanced\"><strong>height-balanced</strong></span>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg\" style=\"width: 342px; height: 221px;\" />\n<pre>\n<strong>Input:</strong> root = [3,9,20,null,null,15,7]\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/06/balance_2.jpg\" style=\"width: 452px; height: 301px;\" />\n<pre>\n<strong>Input:</strong> root = [1,2,2,3,3,null,null,4,4]\n<strong>Output:</strong> false\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = []\n<strong>Output:</strong> true\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 5000]</code>.</li>\n\t<li><code>-10<sup>4</sup> &lt;= Node.val &lt;= 10<sup>4</sup></code></li>\n</ul>\n","tags":["Tree","Depth-First Search","Binary Tree"],"java_snippet":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public boolean isBalanced(TreeNode root) {\n        \n    }\n}","solution":"<h2><a href=\"#solution\"><svg><path></path></svg></a>Solution</h2>\n<hr/>\n<h3><a href=\"#overview\"><svg><path></path></svg></a>Overview</h3>\n<p>Given the definition of a balanced tree<br/>\nwe know that a tree T is <em>not</em> balanced if and only if there is some node<br/>\np∈T such that ∣height(p.left)−height(p.right)∣&gt;1.<br/>\nThe tree below has each node labeled by its height,<br/>\nas well as the unbalanced subtree highlighted.</p>\n<p></p>\n<blockquote>\n<p>The balanced subtree definition hints at the fact that we should treat each<br/>\nsubtree as a subproblem. The question is: in which order should we solve the<br/>\nsubproblems?</p>\n</blockquote>\n<hr/>\n<h3><a href=\"#approach-1-top-down-recursion\"><svg><path></path></svg></a>Approach 1: Top-down recursion</h3>\n<h4>Algorithm</h4>\n<p>First we define a function height such that for any node p∈T</p>\n<p>height(p)={−11+max(height(p.left),height(p.right))​p is an empty subtree i.e. null otherwise​</p>\n<p>Now that we have a method for determining the height of a tree,<br/>\nall that remains is to compare the height of every node's children. A tree T<br/>\nrooted at r is balanced if and only if the height of its two children are within<br/>\n1 of each other and the subtrees at each child are also balanced. Therefore, we can<br/>\ncompare the two child subtrees' heights then recurse on each one.</p>\n<svg><path></path></svg>\n<h4>Implementation</h4>\n<pre><code>class Solution {\n\n    // Recursively obtain the height of a tree. An empty tree has -1 height\n    private int height(TreeNode root) {\n        // An empty tree has height -1\n        if (root == null) {\n            return -1;\n        }\n        return 1 + Math.max(height(root.left), height(root.right));\n    }\n\n    public boolean isBalanced(TreeNode root) {\n        // An empty tree satisfies the definition of a balanced tree\n        if (root == null) {\n            return true;\n        }\n\n        // Check if subtrees have height within 1. If they do, check if the\n        // subtrees are balanced\n        return Math.abs(height(root.left) - height(root.right)) &lt; 2\n                &amp;&amp; isBalanced(root.left)\n                &amp;&amp; isBalanced(root.right);\n    }\n}</code></pre>\n<p></p>\n<h4>Complexity Analysis</h4>\n<ul>\n<li>\n<p>Time complexity : O(nlogn)</p>\n<ul>\n<li>\n<p>For a node p at depth d, height(p) will be called d times.</p>\n</li>\n<li>\n<p>We first need to obtain a bound on the height of a balanced tree. Let<br/>\nf(h) represent the minimum number of nodes in a balanced tree with height h.<br/>\nWe have the relation</p>\n</li>\n</ul>\n<p>f(h)=f(h−1)+f(h−2)+1</p>\n<p>which looks nearly identical to the Fibonacci recurrence relation. In<br/>\nfact, the complexity analysis for f(h) is similar and we claim that the lower<br/>\nbound is f(h)=Ω((23​)h).</p>\nf(h+1)​=f(h)+f(h−1)+1&gt;f(h)+f(h−1)(obviously, since we added 1)This is the Fibonacci recurrence, so≥(23​)h+(23​)h−1(via our claim)=(23​)h−1(23​+1)=(23​)h−1⋅25​&gt;(23​)h−1⋅49​(since 25​&gt;49​)=(23​)h+1​\n<p>Therefore, the height h of a balanced tree<br/>\nis bounded by O(log1.5​(n)). With this bound we can guarantee that<br/>\nheight will be called<br/>\non each node O(logn) times.</p>\n<ul>\n<li>If our algorithm didn't have any early-stopping, we may end up having<br/>\nO(n2) complexity if our tree is skewed since height is bounded by O(n).<br/>\nHowever, it is important to note that we stop recursion as soon as the<br/>\nheight of a node's children are not within 1. In fact, in the skewed-tree<br/>\ncase our algorithm is bounded by O(n), as it only checks the height of<br/>\nthe first two subtrees.</li>\n</ul>\n</li>\n<li>\n<p>Space complexity : O(n). The recursion stack may contain all nodes if the<br/>\ntree is skewed.</p>\n</li>\n</ul>\n<p><strong>Fun fact</strong>: f(n)=f(n−1)+f(n−2)+1 is known as a <a href=\"http://oeis.org/wiki/User:Peter_Luschny/FibonacciMeanders\">Fibonacci meanders</a><br/>\nsequence.</p>\n<br/>\n<hr/>\n<h3><a href=\"#approach-2-bottom-up-recursion\"><svg><path></path></svg></a>Approach 2: Bottom-up recursion</h3>\n<h4>Intuition</h4>\n<p>In approach 1, we perform redundant calculations when computing height.<br/>\nIn each call to height, we require that the subtree's heights also be<br/>\ncomputed. Therefore, when working top down we will compute the height of a subtree<br/>\nonce for every parent. We can remove the redundancy by first recursing on the<br/>\nchildren of the current node and then using their computed height to determine<br/>\nwhether the current node is balanced.</p>\n<h4>Algorithm</h4>\n<p>We will use the same height defined in the first approach. The<br/>\nbottom-up approach is a reverse of the logic of the top-down approach<br/>\nsince we <em>first</em> check if the child subtrees are balanced <em>before</em><br/>\ncomparing their heights. The algorithm is as follows:</p>\n<blockquote>\n<p>Check if the child subtrees are balanced. If they are, use their<br/>\nheights to determine if the current subtree is balanced as well as to calculate<br/>\nthe current subtree's height.</p>\n</blockquote>\n<h4>Implementation</h4>\n<pre><code>class Solution {\n\n    // Return whether or not the tree at root is balanced while also storing\n    // the tree's height in an array (used to simulate pass-by-reference).\n    private boolean isBalancedTreeHelper(TreeNode root, int[] height) {\n        // An empty tree is balanced and has height = -1\n        if (root == null) {\n            height[0] = -1;\n            return true;\n        }\n\n        int[] left = new int[1];\n        int[] right = new int[1];\n\n        // Check subtrees to see if they are balanced. If they are, check if the\n        // current node is also balanced using the heights obtained from the\n        // recursive calls.\n        if (isBalancedTreeHelper(root.left, left)\n                &amp;&amp; isBalancedTreeHelper(root.right, right)\n                &amp;&amp; Math.abs(left[0] - right[0]) &lt; 2) {\n\n            // Store the current tree's height\n            height[0] = Math.max(left[0], right[0]) + 1;\n            return true;\n        }\n\n        return false;\n    }\n\n    public boolean isBalanced(TreeNode root) {\n        int[] height = new int[1];\n        return isBalancedTreeHelper(root, height);\n    }\n}</code></pre>\n<p></p>\n<h4>Complexity Analysis</h4>\n<ul>\n<li>\n<p>Time complexity : O(n)</p>\n<p>For every subtree, we compute its height in constant time as well as<br/>\ncompare the height of its children.</p>\n</li>\n<li>\n<p>Space complexity : O(n). The recursion stack may go up to O(n) if the tree is unbalanced.</p>\n</li>\n</ul>\n<br/>"}