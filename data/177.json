{"id":"177","title":"Nth Highest Salary","difficulty":"Medium","content":"<p>Table: <code>Employee</code></p>\n\n<pre>\n+-------------+------+\n| Column Name | Type |\n+-------------+------+\n| id          | int  |\n| salary      | int  |\n+-------------+------+\nid is the primary key (column with unique values) for this table.\nEach row of this table contains information about the salary of an employee.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to find the <code>n<sup>th</sup></code> highest <strong>distinct</strong> salary from the <code>Employee</code> table. If there are less than <code>n</code> distinct salaries, return&nbsp;<code>null</code>.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nEmployee table:\n+----+--------+\n| id | salary |\n+----+--------+\n| 1  | 100    |\n| 2  | 200    |\n| 3  | 300    |\n+----+--------+\nn = 2\n<strong>Output:</strong> \n+------------------------+\n| getNthHighestSalary(2) |\n+------------------------+\n| 200                    |\n+------------------------+\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nEmployee table:\n+----+--------+\n| id | salary |\n+----+--------+\n| 1  | 100    |\n+----+--------+\nn = 2\n<strong>Output:</strong> \n+------------------------+\n| getNthHighestSalary(2) |\n+------------------------+\n| null                   |\n+------------------------+\n</pre>\n","tags":["Database"],"java_snippet":"","solution":"<h1><a href=\"#solution\"><svg><path></path></svg></a>Solution</h1>\n<hr/>\n<h2><a href=\"#pandas\"><svg><path></path></svg></a>Java</h2>\n<h3><a href=\"#overview\"><svg><path></path></svg></a>Overview</h3>\n<p>Retrieve the nth highest salary from the <code>Employee</code> table. If there is no nth highest salary, we will return <code>null</code>.</p>\n<hr/>\n<h3><a href=\"#approach-rank-based-filtering\"><svg><path></path></svg></a>Approach: Rank-Based Filtering</h3>\n<h4>Algorithm</h4>\n<p>To identify the nth highest salary (after removing duplicates), we apply a <strong>ranking</strong> approach using Java. This is more flexible than sorting alone and handles ties automatically.</p>\n<p>Here is an example to help solidify the intuition behind the algorithm:</p>\n<p>The original table <code>employee</code> with <code>N = 2</code>:</p>\n<table><tbody><tr><th>id</th><th>salary</th></tr><tr><td>1</td><td>100</td></tr><tr><td>2</td><td>200</td></tr><tr><td>3</td><td>300</td></tr><tr><td>4</td><td>500</td></tr><tr><td>5</td><td>500</td></tr></tbody></table>\n<br/>\n<p><strong>Step 1: Remove Duplicate Salaries</strong><br/>\nWe only care about unique salaries, so we remove duplicate values from the list of salaries:</p>\n<pre><code>Set&lt;Integer&gt; distinctSalaries = employee.stream()\n    .map(Employee::getSalary)\n    .collect(Collectors.toSet());</code></pre><svg><path></path></svg>\n<table><tbody><tr><th>id</th><th>salary</th></tr><tr><td>1</td><td>100</td></tr><tr><td>2</td><td>200</td></tr><tr><td>3</td><td>300</td></tr><tr><td>4</td><td>500</td></tr></tbody></table>\n<br/>\n<p><strong>Step 2: Rank Salaries in Descending Order</strong><br/>\nWe sort the unique salaries in descending order and assign ranks based on position. This ensures:</p>\n<ul>\n<li>Higher salaries have lower rank values.</li>\n<li>Equal salaries receive the same rank.</li>\n<li>Gaps in ranks are avoided.</li>\n</ul>\n<pre><code>List&lt;Integer&gt; sortedSalaries = distinctSalaries.stream()\n    .sorted(Comparator.reverseOrder())\n    .collect(Collectors.toList());</code></pre><svg><path></path></svg>\n<table><tbody><tr><th>salary</th><th>rnk</th></tr><tr><td>500</td><td>1</td></tr><tr><td>300</td><td>2</td></tr><tr><td>200</td><td>3</td></tr><tr><td>100</td><td>4</td></tr></tbody></table>\n<br/>\n<p><strong>Step 3: Filter by Rank</strong><br/>\nWe then select the salary at index <code>N - 1</code>. If none exists, we return <code>null</code>.</p>\n<p>In this case <code>N = 2</code>, so after filtering we end up with:</p>\n<table><tbody><tr><th>salary</th></tr><tr><td>500</td></tr><tr><td>300</td></tr></tbody></table>\n<br/>\n<h4>Implementation</h4>\n<pre><code>public Integer getNthHighestSalary(List&lt;Employee&gt; employee, int N) {\n    Set&lt;Integer&gt; distinctSalaries = employee.stream()\n        .map(Employee::getSalary)\n        .collect(Collectors.toSet());\n\n    List&lt;Integer&gt; sortedSalaries = distinctSalaries.stream()\n        .sorted(Comparator.reverseOrder())\n        .collect(Collectors.toList());\n\n    if (sortedSalaries.size() &lt; N) {\n        return null;\n    }\n\n    return sortedSalaries.get(N - 1);\n}</code></pre>\n<hr/>\n<br/>\n<h2><a href=\"#database\"><svg><path></path></svg></a>Database</h2>\n<h3><a href=\"#approach-sort-and-limit\"><svg><path></path></svg></a>Approach: Sort and Limit</h3>\n<h4>Algorithm</h4>\n<p>In SQL, the query to find the nth highest salary involves sorting the distinct salaries in descending order and limiting the result to the nth row. Here we subtract 1 from N because SQL indexing starts from 0.</p>\n<p>This task requires to find the nth highest salary from the Employee table. If there is no nth highest salary, the query should return null. This implies that we have to order the salary column in descending order and pick the nth entry.</p>\n<p>Here is an example to help solidify the intuition behind the algorithm:</p>\n<p>Original Employee table with <code>N = 2</code>:</p>\n<table><tbody><tr><th>id</th><th>salary</th></tr><tr><td>1</td><td>100</td></tr><tr><td>2</td><td>200</td></tr><tr><td>3</td><td>300</td></tr><tr><td>4</td><td>500</td></tr><tr><td>5</td><td>500</td></tr></tbody></table>\n<br/>\n<p>Sub-Table after removing duplicates via <code>SELECT DISTINCT</code>:</p>\n<table><tbody><tr><th>id</th><th>salary</th></tr><tr><td>1</td><td>100</td></tr><tr><td>2</td><td>200</td></tr><tr><td>3</td><td>300</td></tr><tr><td>4</td><td>500</td></tr></tbody></table>\n<br/>\n<p>Sub-Table after sorting in descending order via <code>ORDER BY salary DESC</code>:</p>\n<table><tbody><tr><th>id</th><th>salary</th></tr><tr><td>4</td><td>500</td></tr><tr><td>3</td><td>300</td></tr><tr><td>2</td><td>200</td></tr><tr><td>1</td><td>100</td></tr></tbody></table>\n<br/>\n<p>And the 2nd highest salary is <code>300</code>, which can be found by taking the second row in the descendingly-ordered table! We do this with <code>LIMIT M, 1</code> which takes the next <code>1</code> row starting from the <code>M</code>th row (indexed from 0).</p>\n<p>Note that in SQL, the order of execution for the clauses in a query is generally as follows:</p>\n<ol>\n<li>FROM clause: This specifies the tables from which data will be retrieved.</li>\n<li>WHERE clause: This filters the rows based on a specified condition.</li>\n<li>GROUP BY clause: This groups rows based on a specified column or expression.</li>\n<li>HAVING clause: This filters the grouped rows based on a condition.</li>\n<li>SELECT clause: This selects the columns or expressions that will be returned in the result set.</li>\n<li>ORDER BY clause: This sorts the result set based on a specified column or expression.</li>\n<li>LIMIT/OFFSET clause: This limits the number of rows returned in the result set.</li>\n</ol>\n<p>Note: Your DBMS may execute a query in an equivalent but <em>different</em> order.</p>\n<h4>Implementation</h4>\n<pre><code>public Integer getNthHighestSalaryFromDatabase(int N, Connection connection) throws SQLException {\n    String sql = \"SELECT DISTINCT salary FROM Employee ORDER BY salary DESC LIMIT ?, 1\";\n    try (PreparedStatement ps = connection.prepareStatement(sql)) {\n        ps.setInt(1, N - 1);\n        ResultSet rs = ps.executeQuery();\n        if (rs.next()) {\n            return rs.getInt(\"salary\");\n        }\n        return null;\n    }\n}</code></pre><svg><path></path></svg>"}