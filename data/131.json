{"id":"131","title":"Palindrome Partitioning","difficulty":"Medium","content":"<p>Given a string <code>s</code>, partition <code>s</code> such that every <span data-keyword=\"substring-nonempty\">substring</span> of the partition is a <span data-keyword=\"palindrome-string\"><strong>palindrome</strong></span>. Return <em>all possible palindrome partitioning of </em><code>s</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> s = \"aab\"\n<strong>Output:</strong> [[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> s = \"a\"\n<strong>Output:</strong> [[\"a\"]]\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 16</code></li>\n\t<li><code>s</code> contains only lowercase English letters.</li>\n</ul>\n","tags":["String","Dynamic Programming","Backtracking"],"java_snippet":"class Solution {\n    public List<List<String>> partition(String s) {\n        \n    }\n}","solution":"<h2><a href=\"#solution\"><svg><path></path></svg></a>Solution</h2>\n<hr/>\n<h3><a href=\"#overview\"><svg><path></path></svg></a>Overview</h3>\n<p>The aim is to partition the string into all possible palindrome combinations. To achieve this, we must generate all possible substrings of a string by partitioning at every index until we reach the end of the string. Example, <code>abba</code> can be partitioned as <code>[\"a\",\"ab\",\"abb\",\"abba\"]</code>. Each generated substring is considered as a potential candidate if it a <a href=\"https://en.wikipedia.org/wiki/Palindrome\">palindrome</a>.</p>\n<p>Let's look at a few approaches to implement this idea.</p>\n<hr/>\n<h3><a href=\"#approach-1-backtracking\"><svg><path></path></svg></a>Approach 1: Backtracking</h3>\n<p><strong>Intuition</strong></p>\n<p>The first idea is to generate all possible substrings of a given string and expand each possibility if it is a potential candidate. The first thing that comes to mind is <a href=\"https://en.wikipedia.org/wiki/Depth-first_search\">Depth First Search</a>. In Depth First Search, we recursively expand potential candidates until the defined goal is achieved. After that, we backtrack to explore the next potential candidate.</p>\n<p><a href=\"https://en.wikipedia.org/wiki/Backtracking\">Backtracking</a> incrementally build the candidates for the solution and discards the candidates (backtrack) if they doesn't satisfy the condition.</p>\n<p>The backtracking algorithms consists of the following steps:</p>\n<ul>\n<li>\n<p><em>Choose</em>: Choose the potential candidate. Here, our potential candidates are all substrings that could be generated from the given string.</p>\n</li>\n<li>\n<p><em>Constraint</em>: Define a constraint that must be satisfied by the chosen candidate. In this case, the constraint is that the string must be a <em>palindrome</em>.</p>\n</li>\n<li>\n<p><em>Goal</em>: We must define the goal that determines if have found the required solution and we must backtrack. Here, our goal is achieved if we have reached the end of the string.</p>\n</li>\n</ul>\n<p><strong>Algorithm</strong></p>\n<p>In the backtracking algorithm, we recursively traverse over the string in depth-first search fashion. For each recursive call, the beginning index of the string is given as start.</p>\n<ol>\n<li>\n<p>Iteratively generate all possible substrings beginning at index start. The index end increments from start until the end of the string.</p>\n</li>\n<li>\n<p>For each of the substrings generated, check if it is a palindrome.</p>\n</li>\n<li>\n<p>If the substring is a palindrome, the substring is a potential candidate. Add the substring to the currentList and perform a depth-first search on the remaining substring. If the current substring ends at index end, end+1 becomes the start index for the next recursive call.</p>\n</li>\n<li>\n<p>Backtrack if start index is greater than or equal to the string length and add the currentList to the result.</p>\n</li>\n</ol>\n<p></p>\n<p><strong>Implementation</strong></p>\n<pre><code>import java.util.ArrayList;\nimport java.util.List;\n\nclass Solution {\n    public List&lt;List&lt;String&gt;&gt; partition(String s) {\n        List&lt;List&lt;String&gt;&gt; result = new ArrayList&lt;&gt;();\n        List&lt;String&gt; currentList = new ArrayList&lt;&gt;();\n        dfs(result, s, 0, currentList);\n        return result;\n    }\n\n    private void dfs(List&lt;List&lt;String&gt;&gt; result, String s, int start,\n                     List&lt;String&gt; currentList) {\n        if (start &gt;= s.length()) {\n            result.add(new ArrayList&lt;&gt;(currentList));\n            return;\n        }\n        for (int end = start; end &lt; s.length(); end++) {\n            if (isPalindrome(s, start, end)) {\n                // add current substring in the currentList\n                currentList.add(s.substring(start, end + 1));\n                dfs(result, s, end + 1, currentList);\n                // backtrack and remove the current substring from currentList\n                currentList.remove(currentList.size() - 1);\n            }\n        }\n    }\n\n    private boolean isPalindrome(String s, int low, int high) {\n        while (low &lt; high) {\n            if (s.charAt(low++) != s.charAt(high--)) return false;\n        }\n        return true;\n    }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time Complexity : O(N⋅2N), where N is the length of string s. This is the worst-case time complexity when all the possible substrings are palindrome.</li>\n</ul>\n<p>Example, if s is <code>aaa</code>, the recursive tree can be illustrated as follows:</p>\n<p></p>\n<p>Hence, there could be 2N possible substrings in the worst case. For each substring, it takes O(N) time to generate the substring and determine if it is a palindrome or not. This gives us a time complexity of O(N⋅2N)</p>\n<ul>\n<li>Space Complexity: O(N), where N is the length of the string s. This space will be used to store the recursion stack. For s = <code>aaa</code>, the maximum depth of the recursive call stack is 3 which is equivalent to N.</li>\n</ul>\n<hr/>\n<h3><a href=\"#approach-2-backtracking-with-dynamic-programming\"><svg><path></path></svg></a>Approach 2: Backtracking with Dynamic Programming</h3>\n<p><strong>Intuition</strong></p>\n<p>This approach uses a similar backtracking algorithm as discussed in <em>Approach 1</em>. But, the previous approach performs one extra iteration to determine if a given substring is a palindrome or not. Here, we are repeatedly iterating over the same substring multiple times and the result is always the same. There are <a href=\"https://en.wikipedia.org/wiki/Overlapping_subproblems\">overlapping subproblems</a> and we could further optimize the approach by using dynamic programming to determine if a string is a palindrome in constant time. Let's understand the algorithm in detail.</p>\n<p><strong>Algorithm</strong></p>\n<p>A given string s starting at index start and ending at index end is a palindrome if the following conditions are satisfied:</p>\n<ol>\n<li>The characters at start and end indexes are equal.</li>\n<li>The substring starting at index start+1 and ending at index end−1 is a palindrome.</li>\n</ol>\n<p></p>\n<p>Let N be the length of the string.<br/>\nTo determine if a substring starting at index start and ending at index end is a palindrome or not, we use a 2 Dimensional array dp of size N⋅N where,</p>\n<p>dp[start][end]=true, if the substring beginning at index start and ending at index end is a palindrome.</p>\n<p>Otherwise, dp[start][end] ==false.</p>\n<p>Also, we must update the dp array, if we find that the current string is a palindrome.</p>\n<p><strong>Implementation</strong></p>\n<pre><code>import java.util.ArrayList;\nimport java.util.List;\n\nclass Solution {\n    public List&lt;List&lt;String&gt;&gt; partition(String s) {\n        int len = s.length();\n        boolean[][] dp = new boolean[len][len];\n        List&lt;List&lt;String&gt;&gt; result = new ArrayList&lt;&gt;();\n        List&lt;String&gt; currentList = new ArrayList&lt;&gt;();\n        dfs(result, s, 0, currentList, dp);\n        return result;\n    }\n\n    private void dfs(List&lt;List&lt;String&gt;&gt; result, String s, int start,\n                     List&lt;String&gt; currentList, boolean[][] dp) {\n        if (start &gt;= s.length()) {\n            result.add(new ArrayList&lt;&gt;(currentList));\n            return;\n        }\n        for (int end = start; end &lt; s.length(); end++) {\n            if (s.charAt(start) == s.charAt(end) &amp;&amp;\n                (end - start &lt;= 2 || dp[start + 1][end - 1])) {\n                dp[start][end] = true;\n                currentList.add(s.substring(start, end + 1));\n                dfs(result, s, end + 1, currentList, dp);\n                currentList.remove(currentList.size() - 1);\n            }\n        }\n    }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity : O(N⋅2N), where N is the length of the string s. In the worst case, there could be 2N possible substrings and it will take O(N) to generate each substring using <code>substring</code> as in <em>Approach 1</em>. However, we are eliminating one additional iteration to check if the substring is a palindrome or not.</p>\n</li>\n<li>\n<p>Space Complexity: O(N⋅N), where N is the length of the string s. The recursive call stack would require N space as in <em>Approach 1</em>. Additionally we also use 2 dimensional array dp of size N⋅N .</p>\n</li>\n</ul>\n<p>This gives us a total space complexity of O(N⋅N) + O(N) = O(N⋅N)</p>"}