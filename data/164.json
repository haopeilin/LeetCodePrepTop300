{"id":"164","title":"Maximum Gap","difficulty":"Medium","content":"<p>Given an integer array <code>nums</code>, return <em>the maximum difference between two successive elements in its sorted form</em>. If the array contains less than two elements, return <code>0</code>.</p>\n\n<p>You must write an algorithm that runs in linear time and uses linear extra space.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,6,9,1]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> The sorted form of the array is [1,3,6,9], either (3,6) or (6,9) has the maximum difference 3.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [10]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> The array contains less than 2 elements, therefore return 0.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n","tags":["Array","Sorting","Bucket Sort","Radix Sort"],"java_snippet":"class Solution {\n    public int maximumGap(int[] nums) {\n        \n    }\n}","solution":"<h2><a href=\"#solution\"><svg><path></path></svg></a>Solution</h2>\n<hr/>\n<h3><a href=\"#approach-1-comparison-sorting\"><svg><path></path></svg></a>Approach 1: Comparison Sorting</h3>\n<h4>Intuition</h4>\n<p>Do what the question says.</p>\n<h4>Algorithm</h4>\n<p>Sort the entire array. Then iterate over it to find the maximum gap between two successive elements.</p>\n<pre><code>import java.util.*;\n\nclass Solution {\n    public int maximumGap(int[] nums) {\n        if (nums == null || nums.length &lt; 2) // check if array is empty or small sized\n            return 0;\n\n        Arrays.sort(nums); // sort the array\n\n        int maxGap = 0;\n\n        for (int i = 0; i &lt; nums.length - 1; i++)\n            maxGap = Math.max(nums[i + 1] - nums[i], maxGap);\n\n        return maxGap;\n    }\n}</code></pre>\n<h4>Complexity Analysis</h4>\n<ul>\n<li>\n<p>Time complexity: O(nlogn).</p>\n<p>Time taken to sort the array is O(nlogn) (average case). Time taken for linear iteration through the array is of O(n) complexity. Hence overall time complexity is O(nlogn).</p>\n</li>\n<li>\n<p>Space complexity: No extra space needed, other than the input array (since sorting can usually be done in-place).</p>\n<br/>\n</li>\n</ul>\n<br/>\n<hr/>\n<h3><a href=\"#approach-2-radix-sort\"><svg><path></path></svg></a>Approach 2: Radix Sort</h3>\n<h4>Algorithm</h4>\n<p>This approach is similar to <a href=\"#approach-1-comparison-sorting\">Approach 1</a>, except we use <a href=\"https://en.wikipedia.org/wiki/Radix_sort\">Radix Sort</a> instead of a traditional comparison sort.</p>\n<pre><code>import java.util.*;\n\nclass Solution {\n    public int maximumGap(int[] nums) {\n        if (nums == null || nums.length &lt; 2)\n            return 0;\n\n        int maxVal = 0;\n        for (int num : nums)\n            maxVal = Math.max(maxVal, num);\n\n        long exp = 1;   // 1, 10, 100, 1000 ...\n        int radix = 10; // base 10 system\n\n        int[] aux = new int[nums.length];\n\n        /* LSD Radix Sort */\n        while (maxVal / exp &gt; 0) { // Go through all digits from LSD to MSD\n            int[] count = new int[radix];\n\n            for (int i = 0; i &lt; nums.length; i++) // Counting sort\n                count[(int)((nums[i] / exp) % 10)]++;\n\n            for (int i = 1; i &lt; count.length; i++) // prefix sums\n                count[i] += count[i - 1];\n\n            for (int i = nums.length - 1; i &gt;= 0; i--)\n                aux[--count[(int)((nums[i] / exp) % 10)]] = nums[i];\n\n            for (int i = 0; i &lt; nums.length; i++)\n                nums[i] = aux[i];\n\n            exp *= 10;\n        }\n\n        int maxGap = 0;\n\n        for (int i = 0; i &lt; nums.length - 1; i++)\n            maxGap = Math.max(nums[i + 1] - nums[i], maxGap);\n\n        return maxGap;\n    }\n}</code></pre>\n<h4>Complexity Analysis</h4>\n<ul>\n<li>\n<p>Time complexity: O(d⋅(n+k))≈O(n).</p>\n<p>Since a linear iteration over the array (once it is sorted) is of linear (i.e. O(n)) complexity, the performance of this approach is limited by the performance of Radix sort.</p>\n<p>Radix sort uses <a href=\"https://en.wikipedia.org/wiki/Counting_sort\">Counting sort</a> as a subroutine.</p>\n<ul>\n<li>\n<p>Counting sort runs in O(n+k) time (where k is the radix or base of the digits comprising the n elements in the array). If k≤O(n), Counting sort would run in linear time. In our case, the radix is fixed (i.e. k=10). Hence our Counting sort subroutine runs in O(n) linear time.</p>\n</li>\n<li>\n<p>Radix sort works by running d passes of the Counting sort subroutine (where the elements are composed of, maximally, d digits). Hence effective runtime of Radix sort would be O(d⋅(n+k)). However, in our case an element can, maximally, be the maximum 32-bit signed integer <code>2,147,483,647</code>. Hence d≤10 is a constant.</p>\n</li>\n</ul>\n<p>Thus Radix sort has a runtime performance complexity of about O(n) for reasonably large input.</p>\n</li>\n<li>\n<p>Space complexity: O(n+k)≈O(n) extra space.</p>\n<p>Counting sort requires O(k) extra space. Radix sort requires an auxiliary array of the same size as input array. However given that k is a small fixed constant, the space required by Counting sort can be ignored for reasonably large input.</p>\n</li>\n</ul>\n<br/>\n<hr/>\n<h3><a href=\"#approach-3-buckets-and-the-pigeonhole-principle\"><svg><path></path></svg></a>Approach 3: Buckets and The Pigeonhole Principle</h3>\n<h4>Intuition</h4>\n<p>Sorting an entire array can be costly. At worst, it requires comparing each element with <em>every</em> other element.<br/>\nWhat if we didn't need to compare all pairs of elements? That would be possible if we could somehow divide the elements into representative groups, or rather, <em>buckets</em>. Then we would only need to compare these buckets.</p>\n<blockquote>\n<p><strong>Digression: The Pigeonhole Principle</strong><br/>\nThe <a href=\"https://en.wikipedia.org/wiki/Pigeonhole_principle\">Pigeonhole Principle</a> states that if n items are put into m containers, with n&gt;m, then at least one container must contain more than one item.</p>\n</blockquote>\n<p>Suppose for each of the n elements in our array, there was a bucket. Then each element would occupy one bucket. Now what if we reduced, the number of buckets? Some buckets would have to accommodate more than one element.</p>\n<p>Now let's talk about the gaps between the elements. Let's take the best case, where all elements of the array are sorted and have a uniform gap between them. This means every adjacent pair of elements differ by the same constant value. So for n elements of the array, there are n−1 gaps, each of width, say, t0​. It is trivial to deduce that t0​=(max−min)/(n−1) (where max and min are the minimum and maximum elements of the array). This width is the maximal width/gap between two adjacent elements in the array; precisely the quantity we are looking for!</p>\n<p>One can safely argue that this value of t0​, is in fact, the smallest value that t can ever accomplish of any array with the same number of elements (i.e. n) and the same range (i.e. (max−min)). To test this fact, you can start with a uniform width array (as described above) and try to reduce the gap between any two adjacent elements. If you reduce the gap between arr[i−1] and arr[i] to some value t−p, then you will notice that the gap between arr[i] and arr[i+1] would have increased to t+p. Hence the maximum attainable gap would have become t+p from t. Thus the value of the <strong>maximum gap</strong> t can only increase.</p>\n<p><strong>Buckets!</strong></p>\n<p>Coming back to our problem, we have already established by application of the Pigeonhole Principle, that if we used <em>buckets</em> instead of individual elements as our base for comparison, the number of comparisons would reduce if we could accommodate more than one element in a single bucket. That does not immediately solve the problem though. What if we had to compare elements <em>within</em> a bucket? We would end up no better.</p>\n<p>So the current motivation remains: somehow, if we only had to compare among the buckets, and <em>not</em> the elements <em>within</em> the buckets, we would be good. It would also solve our sorting problem: we would just distribute the elements to the right buckets. Since the buckets can be already ordered, and we only compare among buckets, we wouldn't have to compare all elements to sort them!</p>\n<p>But if we only had buckets to compare, we would have to <em>ensure</em>, that the gap between the buckets itself represent the maximal gap in the input array. How do we go about doing that?</p>\n<p>We could do that just by setting the buckets to be smaller than t0​=(max−min)/(n−1) (as described above). Since the gaps (between elements) within the same bucket would only be ≤t, we could deduce that the maximal gap would <em>indeed</em> occur <strong>only between two adjacent buckets</strong>.</p>\n<p>Hence by setting bucket size b to be 1&lt;b≤(max−min)/(n−1), we can ensure that at least one of the gaps between adjacent buckets would serve as the <strong>maximal gap.</strong></p>\n<p><strong>Clarifications</strong></p>\n<p>A few clarifications are in order:</p>\n<ul>\n<li>\n<p><strong>Would the buckets be of uniform size?</strong><br/>\nYes. Each bucket has a fixed size of b.</p>\n</li>\n<li>\n<p><strong>But, then wouldn't the gap between them be uniform and constant as well?</strong><br/>\nYes, the boundaries of the buckets are evenly spaced, with a fixed gap of 1 integer unit. That means two adjacent buckets of size 3 could hold integers in ranges like 3 to 6 and 7 to 9. We avoid overlapping buckets.</p>\n</li>\n<li>\n<p><strong>Then what do you mean when you say the gap between two adjacent buckets could be the maximal gap?</strong><br/>\nThe bucket size refers to its capacity, which is the range of values it <em>could</em> hold. However, the actual numbers that end up in a bucket depend on the input values. The <em>actual extent</em> of a bucket is determined by the maximum and minimum values it contains.<br/>\nFor example, a bucket of size 5 could theoretically hold values from 6 to 10. But if it only contains 7, 8, and 9, then its actual extent is (9−7)+1=3, which is smaller than its full capacity.<br/>\nThis is why the gap between two occupied buckets, meaning the difference between the maximum value in one bucket and the minimum value in the next occupied bucket, can be larger than the fixed boundary gap of 1.</p>\n</li>\n<li>\n<p><strong>Then how do you compare adjacent buckets?</strong><br/>\nWe do that by comparing their extents. Thus we compare the minimum element of the next bucket to the maximum element of the current bucket. For example: if we have two buckets of size 5 each, holding elements [1,2,3] and [9,10] respectively, then the gap between the buckets would essentially refer to the value 9−3=6 (which is larger than the size of either bucket).</p>\n</li>\n<li>\n<p><strong>But then aren't we comparing elements again?!</strong><br/>\nWe are, yes! But only compare about twice the elements as the number of buckets (i.e. the minimum and maximum elements of each bucket). If you followed the above, you would realize that this amount is certainly less than the actual number of elements in the array, given a suitable bucket size was chosen.</p>\n</li>\n</ul>\n<h4>Algorithm</h4>\n<ul>\n<li>\n<p>We choose a bucket size b such that 1&lt;b≤(max−min)/(n−1). Let's just choose b=⌊(max−min)/(n−1)⌋.</p>\n</li>\n<li>\n<p>Thus all the n elements would be divided among k=⌈(max−min)/b⌉ buckets.</p>\n</li>\n<li>\n<p>Hence the ith bucket would hold the range of values: [min+(i−1)∗b, min+i∗b) (<code>1</code>-based indexing).</p>\n</li>\n<li>\n<p>It is trivial to calculate the index of the bucket to which a particular element belongs. That is given by ⌊(num−min)/b⌋ (<code>0</code>-based indexing) where num is the element in question.</p>\n</li>\n<li>\n<p>Once all n elements have been distributed, we compare k−1 adjacent bucket pairs to find the maximum gap.</p>\n</li>\n</ul>\n<pre><code>import java.util.*;\n\nclass Bucket {\n    boolean used = false;\n    int minval = Integer.MAX_VALUE;\n    int maxval = Integer.MIN_VALUE;\n}\n\nclass Solution {\n    public int maximumGap(int[] nums) {\n        if (nums == null || nums.length &lt; 2) return 0;\n\n        int mini = nums[0], maxi = nums[0];\n        for (int num : nums) {\n            mini = Math.min(mini, num);\n            maxi = Math.max(maxi, num);\n        }\n\n        int bucketSize = Math.max(1, (maxi - mini) / (nums.length - 1)); // bucket size or capacity\n        int bucketNum = (maxi - mini) / bucketSize + 1; // number of buckets\n\n        Bucket[] buckets = new Bucket[bucketNum];\n        for (int i = 0; i &lt; bucketNum; i++)\n            buckets[i] = new Bucket();\n\n        for (int num : nums) {\n            int bucketIdx = (num - mini) / bucketSize; // locating correct bucket\n            Bucket bucket = buckets[bucketIdx];\n            bucket.used = true;\n            bucket.minval = Math.min(num, bucket.minval);\n            bucket.maxval = Math.max(num, bucket.maxval);\n        }\n\n        int prevBucketMax = mini, maxGap = 0;\n        for (Bucket bucket : buckets) {\n            if (!bucket.used) continue;\n\n            maxGap = Math.max(maxGap, bucket.minval - prevBucketMax);\n            prevBucketMax = bucket.maxval;\n        }\n\n        return maxGap;\n    }\n}</code></pre>\n<h4>Complexity Analysis</h4>\n<ul>\n<li>\n<p>Time complexity: O(n+k)≈O(n).</p>\n<p>Distributing the elements of the array takes one linear pass (i.e., O(n) complexity). Finding the maximum gap among the buckets takes a linear pass over the bucket storage (i.e., O(k) complexity). Since the number of buckets is at most the number of elements (i.e., k≤n), the overall process takes linear time: O(n+k)=O(n).</p>\n</li>\n<li>\n<p>Space complexity: O(2⋅k)≈O(k) extra space.</p>\n<p>Each bucket stores a maximum and a minimum element. Hence, extra space proportional to the number of buckets is required.</p>\n</li>\n</ul>"}