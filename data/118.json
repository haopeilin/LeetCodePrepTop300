{"id":"118","title":"Pascal's Triangle","difficulty":"Easy","content":"<p>Given an integer <code>numRows</code>, return the first numRows of <strong>Pascal&#39;s triangle</strong>.</p>\n\n<p>In <strong>Pascal&#39;s triangle</strong>, each number is the sum of the two numbers directly above it as shown:</p>\n<img alt=\"\" src=\"https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif\" style=\"height:240px; width:260px\" />\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> numRows = 5\n<strong>Output:</strong> [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> numRows = 1\n<strong>Output:</strong> [[1]]\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= numRows &lt;= 30</code></li>\n</ul>\n","tags":["Array","Dynamic Programming"],"java_snippet":"class Solution {\n    public List<List<Integer>> generate(int numRows) {\n        \n    }\n}","solution":"<h2><a href=\"#solution-article\"><svg><path></path></svg></a>Solution Article</h2>\n<h3><a href=\"#approach-1-dynamic-programming\"><svg><path></path></svg></a>Approach 1: Dynamic Programming</h3>\n<p><strong>Intuition</strong></p>\n<p>If we have the a row of Pascal's triangle, we can easily compute the next<br/>\nrow by each pair of adjacent values.</p>\n<p><strong>Algorithm</strong></p>\n<p>Although the algorithm is very simple, the iterative approach to constructing<br/>\nPascal's triangle can be classified as dynamic programming because we<br/>\nconstruct each row based on the previous row.</p>\n<p>First, we generate the overall <code>triangle</code> list, which will store each row as<br/>\na sublist. Then, we check for the special case of 0, as we would otherwise<br/>\nreturn [1]. Since numRows is always greater than 0, we can initialize <code>triangle</code> with [1]<br/>\nas its first row, and proceed to fill the rows as follows:</p>\n<p></p>\n<pre><code>class Solution {\n    // Return type is List&lt;List&lt;Integer&gt;&gt;.\n    public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) {\n        List&lt;List&lt;Integer&gt;&gt; triangle = new ArrayList&lt;&gt;();\n        // Base case; first row is always [1].\n        triangle.add(new ArrayList&lt;&gt;());\n        triangle.get(0).add(1);\n        for (int rowNum = 1; rowNum &lt; numRows; rowNum++) {\n            List&lt;Integer&gt; row = new ArrayList&lt;&gt;();\n            List&lt;Integer&gt; prevRow = triangle.get(rowNum - 1);\n            // The first row element is always 1.\n            row.add(1);\n            // Each triangle element (other than the first and last of each row)\n            // is equal to the sum of the elements above-and-to-the-left and\n            // above-and-to-the-right.\n            for (int j = 1; j &lt; rowNum; j++) {\n                row.add(prevRow.get(j - 1) + prevRow.get(j));\n            }\n            // The last row element is always 1.\n            row.add(1);\n            triangle.add(row);\n        }\n        return triangle;\n    }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity: O(numRows2)</p>\n<p>Although updating each value of <code>triangle</code> happens in constant time, it<br/>\nis performed O(numRows2) times. To see why, consider how many<br/>\noverall loop iterations there are. The outer loop obviously runs<br/>\nnumRows times, but for each iteration of the outer loop, the inner<br/>\nloop runs rowNum times. Therefore, the overall number of <code>triangle</code> updates<br/>\nthat occur is 1+2+3+…+numRows, which, according to Gauss' formula,<br/>\nis</p>\n2numRows(numRows+1)​​=2numRows2+numRows​=2numRows2​+2numRows​=O(numRows2)​\n</li>\n<li>\n<p>Space complexity: O(1)</p>\n<p>While O(numRows2) space is used to store the output, the input and output generally do not count towards the space complexity.</p>\n</li>\n</ul>"}