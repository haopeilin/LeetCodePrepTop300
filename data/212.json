{"id":"212","title":"Word Search II","difficulty":"Hard","content":"<p>Given an <code>m x n</code> <code>board</code>&nbsp;of characters and a list of strings <code>words</code>, return <em>all words on the board</em>.</p>\n\n<p>Each word must be constructed from letters of sequentially adjacent cells, where <strong>adjacent cells</strong> are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/07/search1.jpg\" style=\"width: 322px; height: 322px;\" />\n<pre>\n<strong>Input:</strong> board = [[&quot;o&quot;,&quot;a&quot;,&quot;a&quot;,&quot;n&quot;],[&quot;e&quot;,&quot;t&quot;,&quot;a&quot;,&quot;e&quot;],[&quot;i&quot;,&quot;h&quot;,&quot;k&quot;,&quot;r&quot;],[&quot;i&quot;,&quot;f&quot;,&quot;l&quot;,&quot;v&quot;]], words = [&quot;oath&quot;,&quot;pea&quot;,&quot;eat&quot;,&quot;rain&quot;]\n<strong>Output:</strong> [&quot;eat&quot;,&quot;oath&quot;]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/07/search2.jpg\" style=\"width: 162px; height: 162px;\" />\n<pre>\n<strong>Input:</strong> board = [[&quot;a&quot;,&quot;b&quot;],[&quot;c&quot;,&quot;d&quot;]], words = [&quot;abcb&quot;]\n<strong>Output:</strong> []\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == board.length</code></li>\n\t<li><code>n == board[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 12</code></li>\n\t<li><code>board[i][j]</code> is a lowercase English letter.</li>\n\t<li><code>1 &lt;= words.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 10</code></li>\n\t<li><code>words[i]</code> consists of lowercase English letters.</li>\n\t<li>All the strings of <code>words</code> are unique.</li>\n</ul>\n","tags":["Array","String","Backtracking","Trie","Matrix"],"java_snippet":"class Solution {\n    public List<String> findWords(char[][] board, String[] words) {\n        \n    }\n}","solution":"<div class=\"flex flex-col w-full\" style=\"position: relative;\"><div class=\"mYe_l WRmCx\">\n<h2 class=\"group/heading relative\" id=\"solution-article\" level=\"2\"><a aria-hidden=\"true\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" href=\"#solution-article\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" data-icon=\"link\" data-prefix=\"fas\" focusable=\"false\" role=\"img\" spacing=\"square\" viewbox=\"0 0 640 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\" fill=\"currentColor\"></path></svg></div></a>Solution Article</h2>\n<hr/>\n<h3 class=\"group/heading relative\" id=\"approach-1-backtracking-with-trie\" level=\"3\"><a aria-hidden=\"true\" class=\"!text-sd-muted-foreground absolute right-full top-1/2 -translate-y-1/2 cursor-pointer pr-0.5 text-xs opacity-0 group-hover/heading:opacity-100\" href=\"#approach-1-backtracking-with-trie\" tabindex=\"-1\"><div class=\"relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3\"><svg aria-hidden=\"true\" class=\"svg-inline--fa fa-link absolute left-1/2 top-1/2 h-[1em] -translate-x-1/2 -translate-y-1/2 align-[-0.125em]\" data-icon=\"link\" data-prefix=\"fas\" focusable=\"false\" role=\"img\" spacing=\"square\" viewbox=\"0 0 640 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z\" fill=\"currentColor\"></path></svg></div></a>Approach 1: Backtracking with Trie</h3>\n<p><strong>Intuition</strong></p>\n<p>The problem is actually a simplified crossword puzzle game, where the word solutions have been given on the board embedded with some noise letters. All we need to to do is to <em>cross</em> them out.</p>\n<blockquote>\n<p>Intuitively, in order to cross out all potential words, the overall strategy would be to iterate the cell one by one, and from each cell we walk along its neighbors in four potential directions to find matched words.<br/>\nWhile wandering around the board, we would stop the exploration when we know it would not lead to the discovery of new words.</p>\n</blockquote>\n<p>One might have guessed the paradigm that we would use for this problem. Yes, it is <strong>backtracking</strong>, which would be the backbone of the solution. It is fairly simply to construct a solution of backtracking. One could even follow a template given in our <a href=\"https://leetcode.com/explore/learn/card/recursion-ii/472/backtracking/2793/\" target=\"_blank\">Explore card of Recursion II</a>.</p>\n<p>The key of the solution lies on <em>how we find the matches of word from the dictionary</em>. Intuitively, one might resort to the hashset data structure (<em>e.g.</em> <code>set()</code> in Python). This could work.</p>\n<p>However, during the backtracking process, one would encounter more often the need to tell if there exists any word that contains certain prefix, rather than if a string exists as a word in the dictionary. Because if we know that there does not exist any match of word in the dictionary for a given prefix, then we would not need to further explore certain direction. And this, would greatly reduce the exploration space, therefore improve the performance of the backtracking algorithm.</p>\n<p>The capability of finding matching prefix is where the data structure called <a href=\"https://leetcode.com/explore/learn/card/trie/\" target=\"_blank\">Trie</a> would shine, comparing the hashset data structure. Not only can Trie tell the membership of a word, but also it can instantly find the words that share a given prefix. As it turns out, the choice of data structure (<code>Trie</code> <em>VS.</em> <code>hashset</code>), which could end with a solution that ranks either the top <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.8056em; vertical-align: -0.0556em;\"></span><span class=\"mord\">5%</span></span></span></span></span> or the bottom <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.8056em; vertical-align: -0.0556em;\"></span><span class=\"mord\">5%</span></span></span></span></span>.</p>\n<p>Here we show an example of Trie that is built from a list of words. As one can see from the following graph, at the node denoted <code>d</code>, we would know there are at least two words with the prefix <code>d</code> from the dictionary.</p>\n<p></p>\n<p>We have a problem about <a href=\"https://leetcode.com/problems/implement-trie-prefix-tree/\" target=\"_blank\">implementing a Trie data structure</a>. One can start with the Trie problem as warm up, and come back this problem later.</p>\n<p><strong>Algorithm</strong></p>\n<p>The overall workflow of the algorithm is intuitive, which consists of a loop over each cell in the board and a recursive function call starting from the cell. Here is the skeleton of the algorithm.</p>\n<ul>\n<li>\n<p>We build a Trie out of the words in the dictionary, which would be used for the matching process later.</p>\n</li>\n<li>\n<p>Starting from each cell, we start the backtracking exploration (<em>i.e.</em> <code>backtracking(cell)</code>), if there exists any word in the dictionary that starts with the letter in the cell.</p>\n</li>\n<li>\n<p>During the recursive function call <code>backtracking(cell)</code>, we explore the neighbor cells (<em>i.e.</em> <code>neighborCell</code>) around the current cell for the next recursive call <code>backtracking(neighborCell)</code>. At each call, we check if the sequence of letters that we traverse so far matches any word in the dictionary, with the help of the Trie data structure that we built at the beginning.</p>\n</li>\n</ul>\n<p>Here is an overall impression how the algorithm works. We give some sample implementation based on the rough idea above. And later, we detail some optimization that one could further apply to the algorithm.</p>\n<p></p>\n<pre><code>class TrieNode {\npublic:\n    unordered_map&lt;char, TrieNode*&gt; children;\n    string word;\n​\n    TrieNode() : word(\"\") {}\n};\n​\nclass Solution {\nprivate:\n    vector&lt;vector&lt;char&gt;&gt; _board;\n    vector&lt;string&gt; _result;\n​\npublic:\n    vector&lt;string&gt; findWords(vector&lt;vector&lt;char&gt;&gt;&amp; board,\n                             vector&lt;string&gt;&amp; words) {\n        // Step 1). Construct the Trie\n        TrieNode* root = new TrieNode();\n        for (string&amp; word : words) {\n            TrieNode* node = root;\n            for (char letter : word) {\n                if (node-&gt;children.find(letter) != node-&gt;children.end()) {\n                    node = node-&gt;children[letter];\n                } else {\n                    TrieNode* newNode = new TrieNode();\n                    node-&gt;children[letter] = newNode;\n                    node = newNode;\n                }\n            }\n            node-&gt;word = word;  // store words in Trie\n        }\n​\n        this-&gt;_board = board;\n        // Step 2). Backtracking starting for each cell in the board\n        for (int row = 0; row &lt; board.size(); ++row) {\n            for (int col = 0; col &lt; board[row].size(); ++col) {\n                if (root-&gt;children.find(board[row][col]) !=\n                    root-&gt;children.end()) {\n                    backtracking(row, col, root);\n                }\n            }\n        }\n​\n        return this-&gt;_result;\n    }\n​\nprivate:\n    void backtracking(int row, int col, TrieNode* parent) {\n        char letter = this-&gt;_board[row][col];\n        TrieNode* currNode = parent-&gt;children[letter];\n​\n        // check if there is any match\n        if (currNode-&gt;word != \"\") {\n            this-&gt;_result.push_back(currNode-&gt;word);\n            currNode-&gt;word = \"\";  // prevent duplicate entries\n        }\n​\n        // mark the current letter before the EXPLORATION\n        this-&gt;_board[row][col] = '#';\n​\n        // explore neighbor cells in around-clock directions: up, right, down,\n        // left\n        int rowOffset[] = {-1, 0, 1, 0};\n        int colOffset[] = {0, 1, 0, -1};\n        for (int i = 0; i &lt; 4; ++i) {\n            int newRow = row + rowOffset[i];\n            int newCol = col + colOffset[i];\n            if (newRow &lt; 0 || newRow &gt;= this-&gt;_board.size() || newCol &lt; 0 ||\n                newCol &gt;= this-&gt;_board[0].size()) {\n                continue;\n            }\n            if (currNode-&gt;children.find(this-&gt;_board[newRow][newCol]) !=\n                currNode-&gt;children.end()) {\n                backtracking(newRow, newCol, currNode);\n            }\n        }\n​\n        // End of EXPLORATION, restore the original letter in the board.\n        this-&gt;_board[row][col] = letter;\n​\n        // Optimization: incrementally remove the leaf nodes\n        if (currNode-&gt;children.empty()) {\n            parent-&gt;children.erase(letter);\n        }\n    }\n};</code></pre>\n<p>To better understand the backtracking process, we demonstrate how we find the match of <code>dog</code> along the Trie in the following animation.</p>\n<p></p>\n<h4 id=\"optimizations\">Optimizations</h4>\n<p>In the above implementation, we applied a few tricks to further speed up the running time, in addition to the application of the Trie data structure. In particular, the Python implementation could run faster than <code>98%</code> of the submissions. We detail the tricks as follows, ordered by their significance.</p>\n<blockquote>\n<p><em>Backtrack along the nodes in Trie.</em></p>\n</blockquote>\n<ul>\n<li>One could use Trie simply as a dictionary to quickly find the match of words and prefixes, <em>i.e.</em> at <em>each step</em> of backtracking, we start all over from the root of the Trie. This could work.</li>\n<li>However, a more efficient way would be to traverse the Trie together with the progress of backtracking, <em>i.e.</em> at each step of <code>backtracking(TrieNode)</code>, the depth of the <code>TrieNode</code> corresponds to the length of the prefix that we've matched so far. This measure could lift your solution out of the bottom <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.8056em; vertical-align: -0.0556em;\"></span><span class=\"mord\">5%</span></span></span></span></span> of submissions.</li>\n</ul>\n<blockquote>\n<p><em>Gradually <strong>prune</strong> the nodes in Trie during the backtracking.</em></p>\n</blockquote>\n<ul>\n<li>\n<p>The idea is motivated by the fact that the time complexity of the overall algorithm sort of depends on the size of the Trie. For a leaf node in Trie, once we traverse it (<em>i.e.</em> find a matched word), we would no longer need to traverse it again. As a result, we could prune it out from the Trie.</p>\n</li>\n<li>\n<p>Gradually, those non-leaf nodes could become leaf nodes later, since we trim their children leaf nodes. In the extreme case, the Trie would become empty, once we find a match for all the words in the dictionary. This pruning measure could reduce up to <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.8056em; vertical-align: -0.0556em;\"></span><span class=\"mord\">50%</span></span></span></span></span> of the running time for the test cases of the online judge.</p>\n</li>\n</ul>\n<p></p>\n<blockquote>\n<p><em>Keep words in the Trie</em>.</p>\n</blockquote>\n<ul>\n<li>One might use a flag in the Trie node to indicate if the path to the current code match any word in the dictionary. It is not necessary to keep the words in the Trie.</li>\n<li>However, doing so could improve the performance of the algorithm a bit. One benefit is that one would not need to pass the prefix as the parameter in the <code>backtracking()</code> call. And this could speed up a bit the recursive call. Similarly, one does not need to reconstruct the matched word from the prefix, if we keep the words in Trie.</li>\n</ul>\n<blockquote>\n<p><em>Remove the matched words from the Trie.</em></p>\n</blockquote>\n<ul>\n<li>In the problem, we are asked to return all the matched words, rather than the number of potential matches. Therefore, once we reach certain Trie node that contains a match of word, we could simply remove the match from the Trie.</li>\n<li>As a <em>side</em> benefit, we do not need to check if there is any duplicate in the result set. As a result, we could simply use a list instead of set to keep the results, which could speed up the solution a bit.\n<br/>\n</li>\n</ul>\n<p><strong>Complexity</strong></p>\n<ul>\n<li>\n<p>Time complexity: <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathcal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">M</span><span class=\"mopen\">(</span><span class=\"mord\">4</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 1.0913em; vertical-align: -0.25em;\"></span><span class=\"mord\"><span class=\"mord\">3</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.8413em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">L</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mclose\">))</span></span></span></span></span>, where <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">M</span></span></span></span></span> is the number of cells in the board and <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord mathnormal\">L</span></span></span></span></span> is the maximum length of words.</p>\n<ul>\n<li>\n<p>It is tricky is calculate the exact number of steps that a backtracking algorithm would perform. We provide a upper bound of steps for the worst scenario for this problem. The algorithm loops over all the cells in the board, therefore we have <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">M</span></span></span></span></span> as a factor in the complexity formula. It then boils down to the <em>maximum</em> number of steps we would need for each starting cell (<em>i.e.</em><span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6444em;\"></span><span class=\"mord\">4</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.8413em;\"></span><span class=\"mord\"><span class=\"mord\">3</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.8413em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">L</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span></span></span></span></span>).</p>\n</li>\n<li>\n<p>Assume the maximum length of word is <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord mathnormal\">L</span></span></span></span></span>, starting from a cell, initially we would have at most 4 directions to explore. Assume each direction is valid (<em>i.e.</em> worst case), during the following exploration, we have at most 3 neighbor cells (excluding the cell where we come from) to explore. As a result, we would traverse at most <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6444em;\"></span><span class=\"mord\">4</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.8413em;\"></span><span class=\"mord\"><span class=\"mord\">3</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height: 0.8413em;\"><span style=\"top: -3.063em; margin-right: 0.05em;\"><span class=\"pstrut\" style=\"height: 2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">L</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span></span></span></span></span> cells during the backtracking exploration.</p>\n</li>\n<li>\n<p>One might wonder what the worst case scenario looks like. Well, here is an example. Imagine, each of the cells in the board contains the letter <code>a</code>, and the word dictionary contains a single word <code>['aaaa']</code>. Voila. This is one of the worst scenarios that the algorithm would encounter.<br/>\n</p>\n</li>\n<li>\n<p>Note that, the above time complexity is estimated under the assumption that the Trie data structure would not change once built. If we apply the optimization trick to gradually remove the nodes in Trie, we could greatly improve the time complexity, since the cost of backtracking would reduced to zero once we match all the words in the dictionary, <em>i.e.</em> the Trie becomes empty.</p>\n</li>\n</ul>\n</li>\n</ul>\n<br/>\n<ul>\n<li>\n<p>Space Complexity: <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mord mathcal\" style=\"margin-right: 0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span></span>, where <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span></span></span></span></span> is the total number of letters in the dictionary.</p>\n<ul>\n<li>The main space consumed by the algorithm is the Trie data structure we build. In the worst case where there is no overlapping of prefixes among the words, the Trie would have as many nodes as the letters of all words. And optionally, one might keep a copy of words in the Trie as well. As a result, we might need <span class=\"math math-inline\"><span class=\"katex\"><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord\">2</span><span class=\"mord mathnormal\" style=\"margin-right: 0.10903em;\">N</span></span></span></span></span> space for the Trie.</li>\n</ul>\n</li>\n</ul></div><span style=\"font-size: 0px; line-height: 0;\"> </span></div>"}