{"id":"197","title":"Rising Temperature","difficulty":"Easy","content":"<p>Table: <code>Weather</code></p>\n\n<pre>\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| id            | int     |\n| recordDate    | date    |\n| temperature   | int     |\n+---------------+---------+\nid is the column with unique values for this table.\nThere are no different rows with the same recordDate.\nThis table contains information about the temperature on a certain day.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to find all dates&#39; <code>id</code> with higher temperatures compared to its previous dates (yesterday).</p>\n\n<p>Return the result table in <strong>any order</strong>.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nWeather table:\n+----+------------+-------------+\n| id | recordDate | temperature |\n+----+------------+-------------+\n| 1  | 2015-01-01 | 10          |\n| 2  | 2015-01-02 | 25          |\n| 3  | 2015-01-03 | 20          |\n| 4  | 2015-01-04 | 30          |\n+----+------------+-------------+\n<strong>Output:</strong> \n+----+\n| id |\n+----+\n| 2  |\n| 4  |\n+----+\n<strong>Explanation:</strong> \nIn 2015-01-02, the temperature was higher than the previous day (10 -&gt; 25).\nIn 2015-01-04, the temperature was higher than the previous day (20 -&gt; 30).\n</pre>\n","tags":["Database"],"java_snippet":"","solution":"<h1><a href=\"#solution\"><svg><path></path></svg></a>Solution</h1>\n<hr/>\n<h3><a href=\"#overview\"><svg><path></path></svg></a>Overview</h3>\n<p><strong>Problem Statement Reference</strong></p>\n<blockquote>\n<p>Write a solution to find all dates' Id with higher temperatures compared to its previous dates (yesterday). Return the result table in any order.</p>\n</blockquote>\n<p>Let's further elaborate on the given example to deepen our understanding of the problem at hand.</p>\n<p>If we conduct a time series analysis of the temperature data, we would notice distinct points where there is a rise in temperature compared to the previous day. This phenomenon is precisely what we are interested in identifying.</p>\n<p>By analyzing the given data:</p>\n<table><tbody><tr><th>id</th><th>recordDate</th><th>temperature</th></tr></tbody><tbody><tr><td>1</td><td>2015-01-01</td><td>10</td></tr><tr><td>2</td><td>2015-01-02</td><td>25</td></tr><tr><td>3</td><td>2015-01-03</td><td>20</td></tr><tr><td>4</td><td>2015-01-04</td><td>30</td></tr></tbody></table>\n<p>We can graphically represent the temperature readings across the consecutive dates. When we plot these points on a graph, with the <code>recordDate</code> on the X-axis and the <code>temperature</code> on the Y-axis, we observe a graphical representation of the temperature variations over the specified period.</p>\n<p></p>\n<p>From this graphical analysis, we notice two instances where there is a rise in the temperature compared to the day before:</p>\n<ol>\n<li>\n<p><strong>January 2, 2015 (id: 2)</strong>: On this day, the temperature is recorded to be 25, which is higher than the 10 recorded on January 1st.</p>\n</li>\n<li>\n<p><strong>January 4, 2015 (id: 4)</strong>: Here, the temperature escalated to 30, surpassing the temperature of 20 noted on January 3rd.</p>\n</li>\n</ol>\n<p>Thus, based on our criteria of identifying days with a temperature rise compared to the immediate preceding day, we should return the ids for January 2nd and January 4th, which are 2 and 4 respectively.</p>\n<hr/>\n<h2><a href=\"#pandas\"><svg><path></path></svg></a>Java</h2>\n<h3><a href=\"#approach-1-shifted-dataframe-merge-on-record-date\"><svg><path></path></svg></a>Approach 1: Shifted Collection Merge on Record Date</h3>\n<h4>Intuition</h4>\n<p>We are creating a new collection that represents the data shifted by one day and merging it with the original collection based on the <code>recordDate</code>. This way, for each record, we will have information on both the current day and the previous day in the same object, enabling easy comparison of temperatures across consecutive days.</p>\n<p>Let's break this down step by step:</p>\n<p><strong>Step 1: Converting <code>recordDate</code> to LocalDate Type</strong></p>\n<pre><code>// Ensure the recordDate is parsed as LocalDate\nLocalDate date = LocalDate.parse(record.getRecordDate());</code></pre><svg><path></path></svg>\n<ul>\n<li>Before working with date data, it is good practice to ensure that the date value is converted to a date-specific type to facilitate date-based operations correctly.</li>\n</ul>\n<p><strong>Step 2: Creating a Shifted Collection</strong></p>\n<pre><code>// Create a map with recordDate + 1 day as key\nMap&lt;LocalDate, WeatherRecord&gt; shiftedMap = new HashMap&lt;&gt;();\nfor (WeatherRecord r : weather) {\n    shiftedMap.put(r.getRecordDate().plusDays(1), r);\n}</code></pre><svg><path></path></svg>\n<ul>\n<li>A map is created where each record is indexed by its date shifted forward by one day. This allows us to later match each day with the previous day's data.</li>\n</ul>\n<p><strong>Step 3: Merging the Original and Shifted Data</strong></p>\n<pre><code>// Merge current day with previous day using the date key\nList&lt;WeatherRecord&gt; merged = new ArrayList&lt;&gt;();\nfor (WeatherRecord r : weather) {\n    if (shiftedMap.containsKey(r.getRecordDate())) {\n        merged.add(r);\n    }\n}</code></pre><svg><path></path></svg>\n<ul>\n<li>The original data is matched with the shifted data using the date as the key, effectively pairing consecutive days.</li>\n</ul>\n<p><strong>Step 4: Identifying Days with Higher Temperatures than the Previous Day</strong></p>\n<pre><code>// Collect IDs where today's temperature is higher than yesterday's\nList&lt;Integer&gt; result = new ArrayList&lt;&gt;();\nfor (WeatherRecord r : merged) {\n    WeatherRecord prev = shiftedMap.get(r.getRecordDate());\n    if (r.getTemperature() &gt; prev.getTemperature()) {\n        result.add(r.getId());\n    }\n}</code></pre><svg><path></path></svg>\n<ul>\n<li>We compare the temperature of the current day with that of the previous day and collect the IDs that satisfy the condition.</li>\n</ul>\n<p><strong>Step 5: Returning the Result</strong></p>\n<pre><code>return result;</code></pre><svg><path></path></svg>\n<ul>\n<li>The final step is to return the list containing the IDs of the days where the temperature was higher than on the previous day.</li>\n</ul>\n<h4>Implementation</h4>\n<pre><code>import java.time.LocalDate;\nimport java.util.*;\n\nclass WeatherRecord {\n    private int id;\n    private LocalDate recordDate;\n    private int temperature;\n\n    // getters and constructor omitted for brevity\n}\n\npublic List&lt;Integer&gt; risingTemperature(List&lt;WeatherRecord&gt; weather) {\n    Map&lt;LocalDate, WeatherRecord&gt; shiftedMap = new HashMap&lt;&gt;();\n    for (WeatherRecord r : weather) {\n        shiftedMap.put(r.getRecordDate().plusDays(1), r);\n    }\n\n    List&lt;Integer&gt; result = new ArrayList&lt;&gt;();\n    for (WeatherRecord r : weather) {\n        WeatherRecord prev = shiftedMap.get(r.getRecordDate());\n        if (prev != null &amp;&amp; r.getTemperature() &gt; prev.getTemperature()) {\n            result.add(r.getId());\n        }\n    }\n    return result;\n}</code></pre>\n<h3><a href=\"#approach-2-shift-function-with-precise-date-match\"><svg><path></path></svg></a>Approach 2: Shift Logic with Precise Date Match</h3>\n<h4>Intuition</h4>\n<p>In this approach, we sort the collection by <code>recordDate</code> and then compare each element with the previous one. We ensure that the dates are exactly one day apart before comparing temperatures.</p>\n<p>Let's break this down step by step:</p>\n<p><strong>Step 1: Sorting the Data</strong></p>\n<pre><code>weather.sort(Comparator.comparing(WeatherRecord::getRecordDate));</code></pre><svg><path></path></svg>\n<ul>\n<li>We sort the records chronologically so that each element can be compared with its immediate predecessor.</li>\n</ul>\n<p><strong>Step 2: Comparing with Previous Day</strong></p>\n<pre><code>List&lt;Integer&gt; result = new ArrayList&lt;&gt;();\nfor (int i = 1; i &lt; weather.size(); i++) {\n    WeatherRecord curr = weather.get(i);\n    WeatherRecord prev = weather.get(i - 1);\n\n    if (curr.getRecordDate().equals(prev.getRecordDate().plusDays(1))\n        &amp;&amp; curr.getTemperature() &gt; prev.getTemperature()) {\n        result.add(curr.getId());\n    }\n}</code></pre><svg><path></path></svg>\n<ul>\n<li>We ensure the dates are consecutive and then check whether the temperature has increased.</li>\n</ul>\n<p><strong>Step 3: Returning the Result</strong></p>\n<pre><code>return result;</code></pre><svg><path></path></svg>\n<ul>\n<li>The list of IDs where the temperature rose compared to the previous day is returned.</li>\n</ul>\n<h4>Implementation</h4>\n<pre><code>public List&lt;Integer&gt; risingTemperature(List&lt;WeatherRecord&gt; weather) {\n    weather.sort(Comparator.comparing(WeatherRecord::getRecordDate));\n    List&lt;Integer&gt; result = new ArrayList&lt;&gt;();\n\n    for (int i = 1; i &lt; weather.size(); i++) {\n        WeatherRecord curr = weather.get(i);\n        WeatherRecord prev = weather.get(i - 1);\n\n        if (curr.getRecordDate().equals(prev.getRecordDate().plusDays(1))\n            &amp;&amp; curr.getTemperature() &gt; prev.getTemperature()) {\n            result.add(curr.getId());\n        }\n    }\n    return result;\n}</code></pre>\n<hr/>\n<h2><a href=\"#database\"><svg><path></path></svg></a>Database</h2>\n<h3><a href=\"#approach-1-using-join-and-datediff\"><svg><path></path></svg></a>Approach 1: Using Join Logic in Java</h3>\n<h4>Intuition</h4>\n<p>This approach mimics a self-join by comparing every pair of records and selecting those that are one day apart and have rising temperatures.</p>\n<h4>Implementation</h4>\n<pre><code>public List&lt;Integer&gt; risingTemperature(List&lt;WeatherRecord&gt; weather) {\n    List&lt;Integer&gt; result = new ArrayList&lt;&gt;();\n\n    for (WeatherRecord w1 : weather) {\n        for (WeatherRecord w2 : weather) {\n            if (w1.getRecordDate().equals(w2.getRecordDate().plusDays(1))\n                &amp;&amp; w1.getTemperature() &gt; w2.getTemperature()) {\n                result.add(w1.getId());\n            }\n        }\n    }\n    return result;\n}</code></pre><svg><path></path></svg>\n<h3><a href=\"#approach-2-using-lag-function\"><svg><path></path></svg></a>Approach 2: Using Lag-like Logic</h3>\n<h4>Intuition</h4>\n<p>This approach simulates the behavior of a lag function by keeping track of the previous record while iterating through sorted data.</p>\n<h4>Implementation</h4>\n<pre><code>public List&lt;Integer&gt; risingTemperature(List&lt;WeatherRecord&gt; weather) {\n    weather.sort(Comparator.comparing(WeatherRecord::getRecordDate));\n    List&lt;Integer&gt; result = new ArrayList&lt;&gt;();\n\n    WeatherRecord prev = null;\n    for (WeatherRecord curr : weather) {\n        if (prev != null\n            &amp;&amp; curr.getRecordDate().equals(prev.getRecordDate().plusDays(1))\n            &amp;&amp; curr.getTemperature() &gt; prev.getTemperature()) {\n            result.add(curr.getId());\n        }\n        prev = curr;\n    }\n    return result;\n}</code></pre><svg><path></path></svg>\n<h3><a href=\"#approach-3-using-subquery\"><svg><path></path></svg></a>Approach 3: Using Nested Search</h3>\n<h4>Intuition</h4>\n<p>This approach mirrors a subquery by, for each record, explicitly searching for the previous day's record.</p>\n<h4>Implementation</h4>\n<pre><code>public List&lt;Integer&gt; risingTemperature(List&lt;WeatherRecord&gt; weather) {\n    Map&lt;LocalDate, Integer&gt; tempByDate = new HashMap&lt;&gt;();\n    for (WeatherRecord r : weather) {\n        tempByDate.put(r.getRecordDate(), r.getTemperature());\n    }\n\n    List&lt;Integer&gt; result = new ArrayList&lt;&gt;();\n    for (WeatherRecord r : weather) {\n        Integer prevTemp = tempByDate.get(r.getRecordDate().minusDays(1));\n        if (prevTemp != null &amp;&amp; r.getTemperature() &gt; prevTemp) {\n            result.add(r.getId());\n        }\n    }\n    return result;\n}</code></pre><svg><path></path></svg>\n<h3><a href=\"#approach-4-using-cartesian-product-and-where-clause\"><svg><path></path></svg></a>Approach 4: Using Cartesian Product Logic</h3>\n<h4>Intuition</h4>\n<p>This approach explicitly compares all pairs of records, equivalent to a Cartesian product with filtering conditions.</p>\n<h4>Implementation</h4>\n<pre><code>public List&lt;Integer&gt; risingTemperature(List&lt;WeatherRecord&gt; weather) {\n    List&lt;Integer&gt; result = new ArrayList&lt;&gt;();\n\n    for (WeatherRecord w1 : weather) {\n        for (WeatherRecord w2 : weather) {\n            if (w2.getRecordDate().equals(w1.getRecordDate().plusDays(1))\n                &amp;&amp; w2.getTemperature() &gt; w1.getTemperature()) {\n                result.add(w2.getId());\n            }\n        }\n    }\n    return result;\n}</code></pre><svg><path></path></svg>"}