{"id":"161","title":"One Edit Distance","difficulty":"Medium","content":"<p>Given two strings <code>s</code> and <code>t</code>, return <code>true</code> if they are both one edit distance apart, otherwise return <code>false</code>.</p>\n\n<p>A string <code>s</code> is said to be one distance apart from a string <code>t</code> if you can:</p>\n\n<ul>\n\t<li>Insert <strong>exactly one</strong> character into <code>s</code> to get <code>t</code>.</li>\n\t<li>Delete <strong>exactly one</strong> character from <code>s</code> to get <code>t</code>.</li>\n\t<li>Replace <strong>exactly one</strong> character of <code>s</code> with <strong>a different character</strong> to get <code>t</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;ab&quot;, t = &quot;acb&quot;\n<strong>Output:</strong> true\n<strong>Explanation:</strong> We can insert &#39;c&#39; into s&nbsp;to get&nbsp;t.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;&quot;, t = &quot;&quot;\n<strong>Output:</strong> false\n<strong>Explanation:</strong> We cannot get t from s by only one step.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= s.length, t.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>s</code> and <code>t</code> consist of lowercase letters, uppercase letters, and digits.</li>\n</ul>\n","tags":["Two Pointers","String"],"java_snippet":"class Solution {\n    public boolean isOneEditDistance(String s, String t) {\n        \n    }\n}","solution":"<h2><a href=\"#solution\"><svg><path></path></svg></a>Solution</h2>\n<hr/>\n<h3><a href=\"#approach-1-one-pass-algorithm\"><svg><path></path></svg></a>Approach 1: One pass algorithm</h3>\n<p><strong>Intuition</strong></p>\n<p>First of all, let's ensure that the string lengths are not too far from each other. If the length difference is 2 or more characters, then <code>s</code> and <code>t</code> couldn't be one edit away strings.</p>\n<p></p>\n<p>For the next let's assume that <code>s</code> is always shorter or the same length as <code>t</code>. If not, one could always call <code>isOneEditDistance(t, s)</code> to inverse the string order.</p>\n<p>Now it's time to pass along the strings and to look for the first different character.</p>\n<p>If there are no differences between the first <code>len(s)</code> characters, only two situations are possible :</p>\n<ul>\n<li>\n<p>The strings are equal.</p>\n</li>\n<li>\n<p>The strings are one edit away distance.</p>\n</li>\n</ul>\n<p></p>\n<p>Now what if there <em>is</em> a different character so that <code>s[i] != t[i]</code>?</p>\n<ul>\n<li>\n<p>If the strings are of the same length, <em>all</em> next characters should be equal to keep one edit away distance. To verify it, one has to compare the substrings of <code>s</code> and <code>t</code> both starting from the <code>i + 1</code>th character.</p>\n</li>\n<li>\n<p>If <code>t</code> is one character longer than <code>s</code>, the additional character <code>t[i]</code> should be the only difference between both strings. To verify it, one has to compare a substring of <code>s</code> starting from the <code>i</code>th character and a substring of <code>t</code> starting from the <code>i + 1</code>th character.</p>\n</li>\n</ul>\n<p></p>\n<p><strong>Implementation</strong></p>\n<pre><code>class Solution {\n    public boolean isOneEditDistance(String s, String t) {\n        int ns = s.length();\n        int nt = t.length();\n\n        // Ensure that s is shorter than t.\n        if (ns &gt; nt) return isOneEditDistance(t, s);\n\n        // The strings are NOT one edit away distance\n        // if the length diff is more than 1.\n        if (nt - ns &gt; 1) return false;\n\n        for (int i = 0; i &lt; ns; i++) {\n            if (s.charAt(i) != t.charAt(i)) {\n                // if strings have the same length\n                if (ns == nt) {\n                    return s.substring(i + 1).equals(t.substring(i + 1));\n                }\n                // If strings have different lengths\n                else {\n                    return s.substring(i).equals(t.substring(i + 1));\n                }\n            }\n        }\n\n        // If there are no diffs in ns distance\n        // The strings are one edit away only if\n        // t has one more character.\n        return (ns + 1 == nt);\n    }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity: O(N) in the worst case when string lengths are close enough <code>abs(ns - nt) &lt;= 1</code>, where <code>N</code> is a number of characters in the longest string. O(1) in the best case when <code>abs(ns - nt) &gt; 1</code>.</p>\n</li>\n<li>\n<p>Space complexity: O(N) because strings are immutable in Python and Java and create substring costs O(N) space.</p>\n</li>\n</ul>\n<p><strong>Problem generalization: Edit distance</strong></p>\n<p><a href=\"https://leetcode.com/articles/edit-distance/\">Given two words word1 and word2, find the minimum number of operations required to convert word1 to word2.</a></p>"}