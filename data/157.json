{"id":"157","title":"Read N Characters Given Read4","difficulty":"Easy","content":"<p>Given a <code>file</code> and assume that you can only read the file using a given method <code>read4</code>, implement a method to read <code>n</code> characters.</p>\n\n<p><strong>Method read4: </strong></p>\n\n<p>The API <code>read4</code> reads <strong>four consecutive characters</strong> from <code>file</code>, then writes those characters into the buffer array <code>buf4</code>.</p>\n\n<p>The return value is the number of actual characters read.</p>\n\n<p>Note that <code>read4()</code> has its own file pointer, much like <code>FILE *fp</code> in C.</p>\n\n<p><strong>Definition of read4:</strong></p>\n\n<pre>\n    Parameter:  char[] buf4\n    Returns:    int\n\nbuf4[] is a destination, not a source. The results from read4 will be copied to buf4[].\n</pre>\n\n<p>Below is a high-level example of how <code>read4</code> works:</p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/07/01/157_example.png\" style=\"width: 600px; height: 403px;\" />\n<pre>\nFile file(&quot;abcde<code>&quot;); // File is &quot;</code>abcde<code>&quot;, initially file pointer (fp) points to &#39;a&#39;\nchar[] buf4 = new char[4]; // Create buffer with enough space to store characters\nread4(buf4); // read4 returns 4. Now buf4 = &quot;abcd&quot;, fp points to &#39;e&#39;\nread4(buf4); // read4 returns 1. Now buf4 = &quot;e&quot;, fp points to end of file\nread4(buf4); // read4 returns 0. Now buf4 = &quot;&quot;, fp points to end of file</code>\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>Method read:</strong></p>\n\n<p>By using the <code>read4</code> method, implement the method read that reads <code>n</code> characters from <code>file</code> and store it in the buffer array <code>buf</code>. Consider that you cannot manipulate <code>file</code> directly.</p>\n\n<p>The return value is the number of actual characters read.</p>\n\n<p><strong>Definition of read: </strong></p>\n\n<pre>\n    Parameters:\tchar[] buf, int n\n    Returns:\tint\n\nbuf[] is a destination, not a source. You will need to write the results to buf[].\n</pre>\n\n<p><strong>Note:</strong></p>\n\n<ul>\n\t<li>Consider that you cannot manipulate the file directly. The file is only accessible for <code>read4</code> but not for <code>read</code>.</li>\n\t<li>The <code>read</code> function will only be called once for each test case.</li>\n\t<li>You may assume the destination buffer array, <code>buf</code>, is guaranteed to have enough space for storing <code>n</code> characters.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> file = &quot;abc&quot;, n = 4\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> After calling your read method, buf should contain &quot;abc&quot;. We read a total of 3 characters from the file, so return 3.\nNote that &quot;abc&quot; is the file&#39;s content, not buf. buf is the destination buffer that you will have to write the results to.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> file = &quot;abcde&quot;, n = 5\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> After calling your read method, buf should contain &quot;abcde&quot;. We read a total of 5 characters from the file, so return 5.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> file = &quot;abcdABCD1234&quot;, n = 12\n<strong>Output:</strong> 12\n<strong>Explanation:</strong> After calling your read method, buf should contain &quot;abcdABCD1234&quot;. We read a total of 12 characters from the file, so return 12.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= file.length &lt;= 500</code></li>\n\t<li><code>file</code> consist of English letters and digits.</li>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n</ul>\n","tags":["Array","Simulation","Interactive"],"java_snippet":"/**\n * The read4 API is defined in the parent class Reader4.\n *     int read4(char[] buf4);\n */\n\npublic class Solution extends Reader4 {\n    /**\n     * @param buf Destination buffer\n     * @param n   Number of characters to read\n     * @return    The number of actual characters read\n     */\n    public int read(char[] buf, int n) {\n        \n    }\n}","solution":"<h2><a href=\"#solution\"><svg><path></path></svg></a>Solution</h2>\n<hr/>\n<h3><a href=\"#overview\"><svg><path></path></svg></a>Overview</h3>\n<p><strong>Interview Tendencies: Google and Facebook</strong></p>\n<p>A long time ago, long ago, so long ago that no one can remember, algorithm interview questions were less popular. Ten years ago big companies mainly filtered the candidates by the university ranks, and the interview questions were like <a href=\"https://hexus.net/tech/tech-explained/ram/702-ddr-ii-how-it-works/\">please describe how DDR memory works</a>.</p>\n<p>Nowadays there are some tendencies to merge this \"old-style interview\" with the modern algorithm questions interview. The idea is to ask a question that<br/>\nsounds like algorithmic but checks your knowledge of how computers work: <a href=\"https://en.wikipedia.org/wiki/Round-robin_scheduling\">Round-robin CPU scheduling</a>, <a href=\"https://en.wikipedia.org/wiki/C10k_problem\">C10k problem first solved by nginx</a>, etc.</p>\n<blockquote>\n<p>Is it good or bad? That's a reality to deal with, especially if we speak about Google or Facebook interviews.</p>\n</blockquote>\n<p><strong>Read N Characters Given Read4</strong></p>\n<p>Back to the problem, the question is \"How does the memory work\":</p>\n<ul>\n<li>\n<p>Because of the physical implementation, loading 4 bytes in DDR is faster than loading 1 byte 4 times.</p>\n</li>\n<li>\n<p>On the majority of computers today, a collection of 4 bytes, or 32 bits, is called a <em>word</em>. Most modern CPUs are optimized for the operations with <em>words</em>.</p>\n</li>\n</ul>\n<p>To sum up, the problem is a practical low-level question. The standard approach (Approach 1) to solve it using the <em>internal</em> buffer of 4 characters:</p>\n<p>File -&gt; Internal Buffer of 4 Characters -&gt; Buffer of N Characters.</p>\n<p><br/>\n<em>Figure 1. Approach 1: solution with an internal buffer.</em></p>\n<p>Once it's done, and you show your understanding of memory operations, the follow-up question is how to speed up. The answer (Approach 2) is quite straightforward. If it's possible, do not use the internal buffer of 4 characters to avoid the double copy:</p>\n<p>File -&gt; Buffer of N Characters.</p>\n<p><br/>\n<em>Figure 2. Approach 2: solution without internal buffer.</em></p>\n<br/>\n<br/>\n<hr/>\n<h3><a href=\"#approach-1-use-internal-buffer-of-4-characters\"><svg><path></path></svg></a>Approach 1: Use Internal Buffer of 4 Characters</h3>\n<p><br/>\n<em>Figure 3. Solution with internal buffer.</em></p>\n<p><strong>Algorithm</strong></p>\n<p>Let's use an internal buffer of 4 characters to solve this problem:</p>\n<p>File -&gt; Internal Buffer of 4 Characters -&gt; Buffer of N Characters.</p>\n<ul>\n<li>\n<p>Initialize the number of copied characters <code>copiedChars = 0</code>, and the number of read characters: <code>readChars = 4</code>. It's convenient to initialize <code>readChars</code> to <code>4</code> and then use <code>readChars != 4</code> as EOF marker.</p>\n</li>\n<li>\n<p>Initialize an internal buffer of 4 characters: <code>buf4</code>.</p>\n</li>\n<li>\n<p>While the number of copied characters is less than N: <code>copiedChars &lt; n</code> and there are still characters in the file: <code>readChars == 4</code>:</p>\n<ul>\n<li>\n<p>Read from the file into the internal buffer: <code>readChars = read4(buf4)</code>.</p>\n</li>\n<li>\n<p>Copy the characters from internal buffer <code>buf4</code> into main buffer <code>buf</code> one by one. Increase <code>copiedChars</code> after each character. If the number of copied characters is equal to N: <code>copiedChars == n</code>, interrupt the copy process and return <code>copiedChars</code>.</p>\n</li>\n</ul>\n</li>\n</ul>\n<p><strong>Implementation</strong></p>\n<pre><code>class Solution {\n    public int read(char[] buf, int n) {\n        int copiedChars = 0;\n        int readChars = 4;\n        char[] buf4 = new char[4];\n\n        while (copiedChars &lt; n &amp;&amp; readChars == 4) {\n            readChars = read4(buf4);\n\n            for (int i = 0; i &lt; readChars; i++) {\n                if (copiedChars == n) return copiedChars;\n                buf[copiedChars] = buf4[i];\n                copiedChars++;\n            }\n        }\n        return copiedChars;\n    }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity: O(N) to copy N characters.</p>\n</li>\n<li>\n<p>Space complexity: O(1) to keep <code>buf4</code> of 4 elements.</p>\n</li>\n</ul>\n<br/>\n<br/>\n<hr/>\n<h3><a href=\"#approach-2-speed-up-no-internal-buffer\"><svg><path></path></svg></a>Approach 2: Speed Up: No Internal Buffer</h3>\n<p><br/>\n<em>Figure 4. Solution without internal buffer.</em></p>\n<p>This solution is mainly suitable for the languages (such as Java) where array offsets allow writing directly into the primary buffer <code>buf</code>.</p>\n<p><strong>Algorithm</strong></p>\n<ol>\n<li>Initialize:\n<ul>\n<li>The number of copied characters <code>copiedChars</code> as <code>0</code>.</li>\n<li>The number of read characters <code>readChars</code> as <code>4</code>.</li>\n<li>The number of remaining characters that we want to read <code>remainingChars</code> as <code>n</code>.</li>\n</ul>\n</li>\n<li>While number of remaining characters that we want to read is greater than or equal to 4 and the number of read characters equals 4:\n<ul>\n<li>Read from the file directly into the buffer starting at the current offset.</li>\n<li>Increase the count of <code>copiedChars</code> by the number of characters read.</li>\n</ul>\n</li>\n<li>We break from the while loop either when we run out of characters to read (<code>readChars != 4</code>) or when there are less than <code>4</code> characters left that we want to read. Why break when <code>remainingChars</code> is less than <code>4</code>? Because if we only want to read say <code>2</code> more characters, and there are <code>3</code> or more characters remaining in the given file, then we will end up writing more than <code>n</code> characters to <code>buf</code>.</li>\n<li>So when there are less than 4 characters that we want to read, we will use an internal buffer <strong>only once</strong> and read exactly <code>remainingChars</code> from that buffer into <code>buf</code>.</li>\n<li>Finally, <code>buf</code> will either contain <strong>exactly</strong> <code>n</code> characters, or there were less than <code>n</code> characters in the file and we read all of the characters. So we will return the minimum value of <code>n</code> and <code>copiedChars</code> since this represents exactly how many characters were stored in <code>buf</code>.</li>\n</ol>\n<p><strong>Implementation</strong></p>\n<pre><code>class Solution {\n    public int read(char[] buf, int n) {\n        int copiedChars = 0;\n        int readChars = 4;\n        int remainingChars = n;\n\n        // While there are at least 4 characters remaining to be read and the\n        // last call to read4 returned 4 characters, write directly to buf.\n        while (remainingChars &gt;= 4 &amp;&amp; readChars == 4) {\n            char[] temp = new char[4];\n            readChars = read4(temp);\n            for (int i = 0; i &lt; readChars; i++) {\n                buf[copiedChars + i] = temp[i];\n            }\n            copiedChars += readChars;\n            remainingChars -= readChars;\n        }\n\n        // If there are between 1 and 3 characters that we still want to read\n        // and readChars was not 0 last time we called read4, then create a\n        // buffer for just this one call so we can ensure buf does not overflow.\n        if (remainingChars &gt; 0 &amp;&amp; readChars &gt; 0) {\n            char[] buf4 = new char[4];\n            readChars = read4(buf4);\n            for (int i = 0; i &lt; Math.min(remainingChars, readChars); i++) {\n                buf[copiedChars++] = buf4[i];\n            }\n        }\n\n        return Math.min(n, copiedChars);\n    }\n}</code></pre>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity: O(N) to copy N characters.</p>\n</li>\n<li>\n<p>Space complexity: O(1).</p>\n</li>\n</ul>"}